// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ble.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;

/// @nodoc
mixin _$BleDevice {
  /// [macAddress] is the MAC address of the BLE device.
  /// Be careful, on Apple ecosystem, the MAC address is not the real identifier, is a generated by the platform
  /// and is hidden from the developer.
  String get macAddress;

  /// [name] is the name of the BLE device.
  /// Can be null if the device does not have a name or is not broadcasted.
  String? get name;

  /// [rssi] is the signal strength of the BLE device.
  /// Can be null if the device does not have a signal strength due to a platform limitation.
  int? get rssi;

  /// [txPower] is the transmission power of the BLE device.
  /// Can be null if the device does not have a transmission power due to a platform limitation.
  int? get txPower;

  /// [manufacturerData] is the manufacturer data of the BLE device.
  List<BleManufacturerData> get manufacturerData;

  /// [serviceData] is the service data of the BLE device.
  List<BleServiceData> get serviceData;

  /// Create a copy of BleDevice
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BleDeviceCopyWith<BleDevice> get copyWith =>
      _$BleDeviceCopyWithImpl<BleDevice>(this as BleDevice, _$identity);

  /// Serializes this BleDevice to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BleDevice &&
            (identical(other.macAddress, macAddress) ||
                other.macAddress == macAddress) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.rssi, rssi) || other.rssi == rssi) &&
            (identical(other.txPower, txPower) || other.txPower == txPower) &&
            const DeepCollectionEquality()
                .equals(other.manufacturerData, manufacturerData) &&
            const DeepCollectionEquality()
                .equals(other.serviceData, serviceData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      macAddress,
      name,
      rssi,
      txPower,
      const DeepCollectionEquality().hash(manufacturerData),
      const DeepCollectionEquality().hash(serviceData));

  @override
  String toString() {
    return 'BleDevice(macAddress: $macAddress, name: $name, rssi: $rssi, txPower: $txPower, manufacturerData: $manufacturerData, serviceData: $serviceData)';
  }
}

/// @nodoc
abstract mixin class $BleDeviceCopyWith<$Res> {
  factory $BleDeviceCopyWith(BleDevice value, $Res Function(BleDevice) _then) =
      _$BleDeviceCopyWithImpl;
  @useResult
  $Res call(
      {String macAddress,
      String? name,
      int? rssi,
      int? txPower,
      List<BleManufacturerData> manufacturerData,
      List<BleServiceData> serviceData});
}

/// @nodoc
class _$BleDeviceCopyWithImpl<$Res> implements $BleDeviceCopyWith<$Res> {
  _$BleDeviceCopyWithImpl(this._self, this._then);

  final BleDevice _self;
  final $Res Function(BleDevice) _then;

  /// Create a copy of BleDevice
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? macAddress = null,
    Object? name = freezed,
    Object? rssi = freezed,
    Object? txPower = freezed,
    Object? manufacturerData = null,
    Object? serviceData = null,
  }) {
    return _then(_self.copyWith(
      macAddress: null == macAddress
          ? _self.macAddress
          : macAddress // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      rssi: freezed == rssi
          ? _self.rssi
          : rssi // ignore: cast_nullable_to_non_nullable
              as int?,
      txPower: freezed == txPower
          ? _self.txPower
          : txPower // ignore: cast_nullable_to_non_nullable
              as int?,
      manufacturerData: null == manufacturerData
          ? _self.manufacturerData
          : manufacturerData // ignore: cast_nullable_to_non_nullable
              as List<BleManufacturerData>,
      serviceData: null == serviceData
          ? _self.serviceData
          : serviceData // ignore: cast_nullable_to_non_nullable
              as List<BleServiceData>,
    ));
  }
}

/// Adds pattern-matching-related methods to [BleDevice].
extension BleDevicePatterns on BleDevice {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BleDevice value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleDevice() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BleDevice value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleDevice():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BleDevice value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleDevice() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String macAddress,
            String? name,
            int? rssi,
            int? txPower,
            List<BleManufacturerData> manufacturerData,
            List<BleServiceData> serviceData)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleDevice() when $default != null:
        return $default(_that.macAddress, _that.name, _that.rssi, _that.txPower,
            _that.manufacturerData, _that.serviceData);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String macAddress,
            String? name,
            int? rssi,
            int? txPower,
            List<BleManufacturerData> manufacturerData,
            List<BleServiceData> serviceData)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleDevice():
        return $default(_that.macAddress, _that.name, _that.rssi, _that.txPower,
            _that.manufacturerData, _that.serviceData);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String macAddress,
            String? name,
            int? rssi,
            int? txPower,
            List<BleManufacturerData> manufacturerData,
            List<BleServiceData> serviceData)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleDevice() when $default != null:
        return $default(_that.macAddress, _that.name, _that.rssi, _that.txPower,
            _that.manufacturerData, _that.serviceData);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BleDevice extends BleDevice {
  const _BleDevice(
      {required this.macAddress,
      this.name,
      this.rssi,
      this.txPower,
      final List<BleManufacturerData> manufacturerData = const [],
      final List<BleServiceData> serviceData = const []})
      : _manufacturerData = manufacturerData,
        _serviceData = serviceData,
        super._();
  factory _BleDevice.fromJson(Map<String, dynamic> json) =>
      _$BleDeviceFromJson(json);

  /// [macAddress] is the MAC address of the BLE device.
  /// Be careful, on Apple ecosystem, the MAC address is not the real identifier, is a generated by the platform
  /// and is hidden from the developer.
  @override
  final String macAddress;

  /// [name] is the name of the BLE device.
  /// Can be null if the device does not have a name or is not broadcasted.
  @override
  final String? name;

  /// [rssi] is the signal strength of the BLE device.
  /// Can be null if the device does not have a signal strength due to a platform limitation.
  @override
  final int? rssi;

  /// [txPower] is the transmission power of the BLE device.
  /// Can be null if the device does not have a transmission power due to a platform limitation.
  @override
  final int? txPower;

  /// [manufacturerData] is the manufacturer data of the BLE device.
  final List<BleManufacturerData> _manufacturerData;

  /// [manufacturerData] is the manufacturer data of the BLE device.
  @override
  @JsonKey()
  List<BleManufacturerData> get manufacturerData {
    if (_manufacturerData is EqualUnmodifiableListView)
      return _manufacturerData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_manufacturerData);
  }

  /// [serviceData] is the service data of the BLE device.
  final List<BleServiceData> _serviceData;

  /// [serviceData] is the service data of the BLE device.
  @override
  @JsonKey()
  List<BleServiceData> get serviceData {
    if (_serviceData is EqualUnmodifiableListView) return _serviceData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_serviceData);
  }

  /// Create a copy of BleDevice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BleDeviceCopyWith<_BleDevice> get copyWith =>
      __$BleDeviceCopyWithImpl<_BleDevice>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BleDeviceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BleDevice &&
            (identical(other.macAddress, macAddress) ||
                other.macAddress == macAddress) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.rssi, rssi) || other.rssi == rssi) &&
            (identical(other.txPower, txPower) || other.txPower == txPower) &&
            const DeepCollectionEquality()
                .equals(other._manufacturerData, _manufacturerData) &&
            const DeepCollectionEquality()
                .equals(other._serviceData, _serviceData));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      macAddress,
      name,
      rssi,
      txPower,
      const DeepCollectionEquality().hash(_manufacturerData),
      const DeepCollectionEquality().hash(_serviceData));

  @override
  String toString() {
    return 'BleDevice(macAddress: $macAddress, name: $name, rssi: $rssi, txPower: $txPower, manufacturerData: $manufacturerData, serviceData: $serviceData)';
  }
}

/// @nodoc
abstract mixin class _$BleDeviceCopyWith<$Res>
    implements $BleDeviceCopyWith<$Res> {
  factory _$BleDeviceCopyWith(
          _BleDevice value, $Res Function(_BleDevice) _then) =
      __$BleDeviceCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String macAddress,
      String? name,
      int? rssi,
      int? txPower,
      List<BleManufacturerData> manufacturerData,
      List<BleServiceData> serviceData});
}

/// @nodoc
class __$BleDeviceCopyWithImpl<$Res> implements _$BleDeviceCopyWith<$Res> {
  __$BleDeviceCopyWithImpl(this._self, this._then);

  final _BleDevice _self;
  final $Res Function(_BleDevice) _then;

  /// Create a copy of BleDevice
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? macAddress = null,
    Object? name = freezed,
    Object? rssi = freezed,
    Object? txPower = freezed,
    Object? manufacturerData = null,
    Object? serviceData = null,
  }) {
    return _then(_BleDevice(
      macAddress: null == macAddress
          ? _self.macAddress
          : macAddress // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _self.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      rssi: freezed == rssi
          ? _self.rssi
          : rssi // ignore: cast_nullable_to_non_nullable
              as int?,
      txPower: freezed == txPower
          ? _self.txPower
          : txPower // ignore: cast_nullable_to_non_nullable
              as int?,
      manufacturerData: null == manufacturerData
          ? _self._manufacturerData
          : manufacturerData // ignore: cast_nullable_to_non_nullable
              as List<BleManufacturerData>,
      serviceData: null == serviceData
          ? _self._serviceData
          : serviceData // ignore: cast_nullable_to_non_nullable
              as List<BleServiceData>,
    ));
  }
}

/// @nodoc
mixin _$BleService {
  /// [uuid] is the UUID of the BLE service.
  String get uuid;

  /// [characteristics] is the list of characteristics of the BLE service.
  List<BleCharacteristic>? get characteristics;

  /// Create a copy of BleService
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BleServiceCopyWith<BleService> get copyWith =>
      _$BleServiceCopyWithImpl<BleService>(this as BleService, _$identity);

  /// Serializes this BleService to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BleService &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            const DeepCollectionEquality()
                .equals(other.characteristics, characteristics));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, uuid, const DeepCollectionEquality().hash(characteristics));

  @override
  String toString() {
    return 'BleService(uuid: $uuid, characteristics: $characteristics)';
  }
}

/// @nodoc
abstract mixin class $BleServiceCopyWith<$Res> {
  factory $BleServiceCopyWith(
          BleService value, $Res Function(BleService) _then) =
      _$BleServiceCopyWithImpl;
  @useResult
  $Res call({String uuid, List<BleCharacteristic>? characteristics});
}

/// @nodoc
class _$BleServiceCopyWithImpl<$Res> implements $BleServiceCopyWith<$Res> {
  _$BleServiceCopyWithImpl(this._self, this._then);

  final BleService _self;
  final $Res Function(BleService) _then;

  /// Create a copy of BleService
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uuid = null,
    Object? characteristics = freezed,
  }) {
    return _then(_self.copyWith(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      characteristics: freezed == characteristics
          ? _self.characteristics
          : characteristics // ignore: cast_nullable_to_non_nullable
              as List<BleCharacteristic>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [BleService].
extension BleServicePatterns on BleService {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BleService value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleService() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BleService value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleService():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BleService value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleService() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(String uuid, List<BleCharacteristic>? characteristics)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleService() when $default != null:
        return $default(_that.uuid, _that.characteristics);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(String uuid, List<BleCharacteristic>? characteristics)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleService():
        return $default(_that.uuid, _that.characteristics);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(String uuid, List<BleCharacteristic>? characteristics)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleService() when $default != null:
        return $default(_that.uuid, _that.characteristics);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BleService extends BleService {
  const _BleService(
      {required this.uuid, final List<BleCharacteristic>? characteristics})
      : _characteristics = characteristics,
        super._();
  factory _BleService.fromJson(Map<String, dynamic> json) =>
      _$BleServiceFromJson(json);

  /// [uuid] is the UUID of the BLE service.
  @override
  final String uuid;

  /// [characteristics] is the list of characteristics of the BLE service.
  final List<BleCharacteristic>? _characteristics;

  /// [characteristics] is the list of characteristics of the BLE service.
  @override
  List<BleCharacteristic>? get characteristics {
    final value = _characteristics;
    if (value == null) return null;
    if (_characteristics is EqualUnmodifiableListView) return _characteristics;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of BleService
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BleServiceCopyWith<_BleService> get copyWith =>
      __$BleServiceCopyWithImpl<_BleService>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BleServiceToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BleService &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            const DeepCollectionEquality()
                .equals(other._characteristics, _characteristics));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, uuid, const DeepCollectionEquality().hash(_characteristics));

  @override
  String toString() {
    return 'BleService(uuid: $uuid, characteristics: $characteristics)';
  }
}

/// @nodoc
abstract mixin class _$BleServiceCopyWith<$Res>
    implements $BleServiceCopyWith<$Res> {
  factory _$BleServiceCopyWith(
          _BleService value, $Res Function(_BleService) _then) =
      __$BleServiceCopyWithImpl;
  @override
  @useResult
  $Res call({String uuid, List<BleCharacteristic>? characteristics});
}

/// @nodoc
class __$BleServiceCopyWithImpl<$Res> implements _$BleServiceCopyWith<$Res> {
  __$BleServiceCopyWithImpl(this._self, this._then);

  final _BleService _self;
  final $Res Function(_BleService) _then;

  /// Create a copy of BleService
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uuid = null,
    Object? characteristics = freezed,
  }) {
    return _then(_BleService(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      characteristics: freezed == characteristics
          ? _self._characteristics
          : characteristics // ignore: cast_nullable_to_non_nullable
              as List<BleCharacteristic>?,
    ));
  }
}

/// @nodoc
mixin _$BleServiceData {
  /// [uuid] is the UUID of the BLE service.
  int get uuid;

  /// [characteristics] is the list of characteristics of the BLE service.
  List<int>? get data;

  /// Create a copy of BleServiceData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BleServiceDataCopyWith<BleServiceData> get copyWith =>
      _$BleServiceDataCopyWithImpl<BleServiceData>(
          this as BleServiceData, _$identity);

  /// Serializes this BleServiceData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BleServiceData &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, uuid, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'BleServiceData(uuid: $uuid, data: $data)';
  }
}

/// @nodoc
abstract mixin class $BleServiceDataCopyWith<$Res> {
  factory $BleServiceDataCopyWith(
          BleServiceData value, $Res Function(BleServiceData) _then) =
      _$BleServiceDataCopyWithImpl;
  @useResult
  $Res call({int uuid, List<int>? data});
}

/// @nodoc
class _$BleServiceDataCopyWithImpl<$Res>
    implements $BleServiceDataCopyWith<$Res> {
  _$BleServiceDataCopyWithImpl(this._self, this._then);

  final BleServiceData _self;
  final $Res Function(BleServiceData) _then;

  /// Create a copy of BleServiceData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uuid = null,
    Object? data = freezed,
  }) {
    return _then(_self.copyWith(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as int,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [BleServiceData].
extension BleServiceDataPatterns on BleServiceData {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BleServiceData value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleServiceData() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BleServiceData value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleServiceData():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BleServiceData value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleServiceData() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int uuid, List<int>? data)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleServiceData() when $default != null:
        return $default(_that.uuid, _that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int uuid, List<int>? data) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleServiceData():
        return $default(_that.uuid, _that.data);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(int uuid, List<int>? data)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleServiceData() when $default != null:
        return $default(_that.uuid, _that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BleServiceData extends BleServiceData {
  const _BleServiceData({required this.uuid, final List<int>? data})
      : _data = data,
        super._();
  factory _BleServiceData.fromJson(Map<String, dynamic> json) =>
      _$BleServiceDataFromJson(json);

  /// [uuid] is the UUID of the BLE service.
  @override
  final int uuid;

  /// [characteristics] is the list of characteristics of the BLE service.
  final List<int>? _data;

  /// [characteristics] is the list of characteristics of the BLE service.
  @override
  List<int>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of BleServiceData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BleServiceDataCopyWith<_BleServiceData> get copyWith =>
      __$BleServiceDataCopyWithImpl<_BleServiceData>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BleServiceDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BleServiceData &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, uuid, const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'BleServiceData(uuid: $uuid, data: $data)';
  }
}

/// @nodoc
abstract mixin class _$BleServiceDataCopyWith<$Res>
    implements $BleServiceDataCopyWith<$Res> {
  factory _$BleServiceDataCopyWith(
          _BleServiceData value, $Res Function(_BleServiceData) _then) =
      __$BleServiceDataCopyWithImpl;
  @override
  @useResult
  $Res call({int uuid, List<int>? data});
}

/// @nodoc
class __$BleServiceDataCopyWithImpl<$Res>
    implements _$BleServiceDataCopyWith<$Res> {
  __$BleServiceDataCopyWithImpl(this._self, this._then);

  final _BleServiceData _self;
  final $Res Function(_BleServiceData) _then;

  /// Create a copy of BleServiceData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uuid = null,
    Object? data = freezed,
  }) {
    return _then(_BleServiceData(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as int,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// @nodoc
mixin _$BleCharacteristic {
  /// [uuid] is the UUID of the BLE characteristic.
  String get uuid;

  /// [properties] is the list of properties of the BLE characteristic.
  @JsonKey(unknownEnumValue: BleProperty.unknown)
  List<BleProperty> get properties;

  /// Create a copy of BleCharacteristic
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BleCharacteristicCopyWith<BleCharacteristic> get copyWith =>
      _$BleCharacteristicCopyWithImpl<BleCharacteristic>(
          this as BleCharacteristic, _$identity);

  /// Serializes this BleCharacteristic to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BleCharacteristic &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            const DeepCollectionEquality()
                .equals(other.properties, properties));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, uuid, const DeepCollectionEquality().hash(properties));

  @override
  String toString() {
    return 'BleCharacteristic(uuid: $uuid, properties: $properties)';
  }
}

/// @nodoc
abstract mixin class $BleCharacteristicCopyWith<$Res> {
  factory $BleCharacteristicCopyWith(
          BleCharacteristic value, $Res Function(BleCharacteristic) _then) =
      _$BleCharacteristicCopyWithImpl;
  @useResult
  $Res call(
      {String uuid,
      @JsonKey(unknownEnumValue: BleProperty.unknown)
      List<BleProperty> properties});
}

/// @nodoc
class _$BleCharacteristicCopyWithImpl<$Res>
    implements $BleCharacteristicCopyWith<$Res> {
  _$BleCharacteristicCopyWithImpl(this._self, this._then);

  final BleCharacteristic _self;
  final $Res Function(BleCharacteristic) _then;

  /// Create a copy of BleCharacteristic
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? uuid = null,
    Object? properties = null,
  }) {
    return _then(_self.copyWith(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      properties: null == properties
          ? _self.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as List<BleProperty>,
    ));
  }
}

/// Adds pattern-matching-related methods to [BleCharacteristic].
extension BleCharacteristicPatterns on BleCharacteristic {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BleCharacteristic value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleCharacteristic() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BleCharacteristic value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleCharacteristic():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BleCharacteristic value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleCharacteristic() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(
            String uuid,
            @JsonKey(unknownEnumValue: BleProperty.unknown)
            List<BleProperty> properties)?
        $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleCharacteristic() when $default != null:
        return $default(_that.uuid, _that.properties);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(
            String uuid,
            @JsonKey(unknownEnumValue: BleProperty.unknown)
            List<BleProperty> properties)
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleCharacteristic():
        return $default(_that.uuid, _that.properties);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(
            String uuid,
            @JsonKey(unknownEnumValue: BleProperty.unknown)
            List<BleProperty> properties)?
        $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleCharacteristic() when $default != null:
        return $default(_that.uuid, _that.properties);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BleCharacteristic extends BleCharacteristic {
  const _BleCharacteristic(
      {required this.uuid,
      @JsonKey(unknownEnumValue: BleProperty.unknown)
      final List<BleProperty> properties = const []})
      : _properties = properties,
        super._();
  factory _BleCharacteristic.fromJson(Map<String, dynamic> json) =>
      _$BleCharacteristicFromJson(json);

  /// [uuid] is the UUID of the BLE characteristic.
  @override
  final String uuid;

  /// [properties] is the list of properties of the BLE characteristic.
  final List<BleProperty> _properties;

  /// [properties] is the list of properties of the BLE characteristic.
  @override
  @JsonKey(unknownEnumValue: BleProperty.unknown)
  List<BleProperty> get properties {
    if (_properties is EqualUnmodifiableListView) return _properties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_properties);
  }

  /// Create a copy of BleCharacteristic
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BleCharacteristicCopyWith<_BleCharacteristic> get copyWith =>
      __$BleCharacteristicCopyWithImpl<_BleCharacteristic>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BleCharacteristicToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BleCharacteristic &&
            (identical(other.uuid, uuid) || other.uuid == uuid) &&
            const DeepCollectionEquality()
                .equals(other._properties, _properties));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, uuid, const DeepCollectionEquality().hash(_properties));

  @override
  String toString() {
    return 'BleCharacteristic(uuid: $uuid, properties: $properties)';
  }
}

/// @nodoc
abstract mixin class _$BleCharacteristicCopyWith<$Res>
    implements $BleCharacteristicCopyWith<$Res> {
  factory _$BleCharacteristicCopyWith(
          _BleCharacteristic value, $Res Function(_BleCharacteristic) _then) =
      __$BleCharacteristicCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String uuid,
      @JsonKey(unknownEnumValue: BleProperty.unknown)
      List<BleProperty> properties});
}

/// @nodoc
class __$BleCharacteristicCopyWithImpl<$Res>
    implements _$BleCharacteristicCopyWith<$Res> {
  __$BleCharacteristicCopyWithImpl(this._self, this._then);

  final _BleCharacteristic _self;
  final $Res Function(_BleCharacteristic) _then;

  /// Create a copy of BleCharacteristic
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? uuid = null,
    Object? properties = null,
  }) {
    return _then(_BleCharacteristic(
      uuid: null == uuid
          ? _self.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String,
      properties: null == properties
          ? _self._properties
          : properties // ignore: cast_nullable_to_non_nullable
              as List<BleProperty>,
    ));
  }
}

/// @nodoc
mixin _$BleManufacturerData {
  /// [companyId] is the company identifier of the manufacturer.
  int get companyId;

  /// [data] is the raw data of the manufacturer.
  List<int>? get data;

  /// Create a copy of BleManufacturerData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BleManufacturerDataCopyWith<BleManufacturerData> get copyWith =>
      _$BleManufacturerDataCopyWithImpl<BleManufacturerData>(
          this as BleManufacturerData, _$identity);

  /// Serializes this BleManufacturerData to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BleManufacturerData &&
            (identical(other.companyId, companyId) ||
                other.companyId == companyId) &&
            const DeepCollectionEquality().equals(other.data, data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, companyId, const DeepCollectionEquality().hash(data));

  @override
  String toString() {
    return 'BleManufacturerData(companyId: $companyId, data: $data)';
  }
}

/// @nodoc
abstract mixin class $BleManufacturerDataCopyWith<$Res> {
  factory $BleManufacturerDataCopyWith(
          BleManufacturerData value, $Res Function(BleManufacturerData) _then) =
      _$BleManufacturerDataCopyWithImpl;
  @useResult
  $Res call({int companyId, List<int>? data});
}

/// @nodoc
class _$BleManufacturerDataCopyWithImpl<$Res>
    implements $BleManufacturerDataCopyWith<$Res> {
  _$BleManufacturerDataCopyWithImpl(this._self, this._then);

  final BleManufacturerData _self;
  final $Res Function(BleManufacturerData) _then;

  /// Create a copy of BleManufacturerData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? companyId = null,
    Object? data = freezed,
  }) {
    return _then(_self.copyWith(
      companyId: null == companyId
          ? _self.companyId
          : companyId // ignore: cast_nullable_to_non_nullable
              as int,
      data: freezed == data
          ? _self.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// Adds pattern-matching-related methods to [BleManufacturerData].
extension BleManufacturerDataPatterns on BleManufacturerData {
  /// A variant of `map` that fallback to returning `orElse`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>(
    TResult Function(_BleManufacturerData value)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleManufacturerData() when $default != null:
        return $default(_that);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// Callbacks receives the raw object, upcasted.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case final Subclass2 value:
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult map<TResult extends Object?>(
    TResult Function(_BleManufacturerData value) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleManufacturerData():
        return $default(_that);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `map` that fallback to returning `null`.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case final Subclass value:
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>(
    TResult? Function(_BleManufacturerData value)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleManufacturerData() when $default != null:
        return $default(_that);
      case _:
        return null;
    }
  }

  /// A variant of `when` that fallback to an `orElse` callback.
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return orElse();
  /// }
  /// ```

  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function(int companyId, List<int>? data)? $default, {
    required TResult orElse(),
  }) {
    final _that = this;
    switch (_that) {
      case _BleManufacturerData() when $default != null:
        return $default(_that.companyId, _that.data);
      case _:
        return orElse();
    }
  }

  /// A `switch`-like method, using callbacks.
  ///
  /// As opposed to `map`, this offers destructuring.
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case Subclass2(:final field2):
  ///     return ...;
  /// }
  /// ```

  @optionalTypeArgs
  TResult when<TResult extends Object?>(
    TResult Function(int companyId, List<int>? data) $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleManufacturerData():
        return $default(_that.companyId, _that.data);
      case _:
        throw StateError('Unexpected subclass');
    }
  }

  /// A variant of `when` that fallback to returning `null`
  ///
  /// It is equivalent to doing:
  /// ```dart
  /// switch (sealedClass) {
  ///   case Subclass(:final field):
  ///     return ...;
  ///   case _:
  ///     return null;
  /// }
  /// ```

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function(int companyId, List<int>? data)? $default,
  ) {
    final _that = this;
    switch (_that) {
      case _BleManufacturerData() when $default != null:
        return $default(_that.companyId, _that.data);
      case _:
        return null;
    }
  }
}

/// @nodoc
@JsonSerializable()
class _BleManufacturerData extends BleManufacturerData {
  const _BleManufacturerData({this.companyId = 0x0000, final List<int>? data})
      : _data = data,
        super._();
  factory _BleManufacturerData.fromJson(Map<String, dynamic> json) =>
      _$BleManufacturerDataFromJson(json);

  /// [companyId] is the company identifier of the manufacturer.
  @override
  @JsonKey()
  final int companyId;

  /// [data] is the raw data of the manufacturer.
  final List<int>? _data;

  /// [data] is the raw data of the manufacturer.
  @override
  List<int>? get data {
    final value = _data;
    if (value == null) return null;
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Create a copy of BleManufacturerData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$BleManufacturerDataCopyWith<_BleManufacturerData> get copyWith =>
      __$BleManufacturerDataCopyWithImpl<_BleManufacturerData>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$BleManufacturerDataToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _BleManufacturerData &&
            (identical(other.companyId, companyId) ||
                other.companyId == companyId) &&
            const DeepCollectionEquality().equals(other._data, _data));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, companyId, const DeepCollectionEquality().hash(_data));

  @override
  String toString() {
    return 'BleManufacturerData(companyId: $companyId, data: $data)';
  }
}

/// @nodoc
abstract mixin class _$BleManufacturerDataCopyWith<$Res>
    implements $BleManufacturerDataCopyWith<$Res> {
  factory _$BleManufacturerDataCopyWith(_BleManufacturerData value,
          $Res Function(_BleManufacturerData) _then) =
      __$BleManufacturerDataCopyWithImpl;
  @override
  @useResult
  $Res call({int companyId, List<int>? data});
}

/// @nodoc
class __$BleManufacturerDataCopyWithImpl<$Res>
    implements _$BleManufacturerDataCopyWith<$Res> {
  __$BleManufacturerDataCopyWithImpl(this._self, this._then);

  final _BleManufacturerData _self;
  final $Res Function(_BleManufacturerData) _then;

  /// Create a copy of BleManufacturerData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? companyId = null,
    Object? data = freezed,
  }) {
    return _then(_BleManufacturerData(
      companyId: null == companyId
          ? _self.companyId
          : companyId // ignore: cast_nullable_to_non_nullable
              as int,
      data: freezed == data
          ? _self._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

// dart format on
