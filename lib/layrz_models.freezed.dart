// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'layrz_models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

AvailableLanguage _$AvailableLanguageFromJson(Map<String, dynamic> json) {
  return _AvailableLanguage.fromJson(json);
}

/// @nodoc
mixin _$AvailableLanguage {
  String? get id => throw _privateConstructorUsedError;
  String? get name => throw _privateConstructorUsedError;
  String? get code => throw _privateConstructorUsedError;
  String? get fallback => throw _privateConstructorUsedError;
  bool? get isVerified => throw _privateConstructorUsedError;
  Map<String, String>? get messages => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AvailableLanguageCopyWith<AvailableLanguage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AvailableLanguageCopyWith<$Res> {
  factory $AvailableLanguageCopyWith(
          AvailableLanguage value, $Res Function(AvailableLanguage) then) =
      _$AvailableLanguageCopyWithImpl<$Res, AvailableLanguage>;
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? code,
      String? fallback,
      bool? isVerified,
      Map<String, String>? messages});
}

/// @nodoc
class _$AvailableLanguageCopyWithImpl<$Res, $Val extends AvailableLanguage>
    implements $AvailableLanguageCopyWith<$Res> {
  _$AvailableLanguageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? code = freezed,
    Object? fallback = freezed,
    Object? isVerified = freezed,
    Object? messages = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      fallback: freezed == fallback
          ? _value.fallback
          : fallback // ignore: cast_nullable_to_non_nullable
              as String?,
      isVerified: freezed == isVerified
          ? _value.isVerified
          : isVerified // ignore: cast_nullable_to_non_nullable
              as bool?,
      messages: freezed == messages
          ? _value.messages
          : messages // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AvailableLanguageCopyWith<$Res>
    implements $AvailableLanguageCopyWith<$Res> {
  factory _$$_AvailableLanguageCopyWith(_$_AvailableLanguage value,
          $Res Function(_$_AvailableLanguage) then) =
      __$$_AvailableLanguageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? code,
      String? fallback,
      bool? isVerified,
      Map<String, String>? messages});
}

/// @nodoc
class __$$_AvailableLanguageCopyWithImpl<$Res>
    extends _$AvailableLanguageCopyWithImpl<$Res, _$_AvailableLanguage>
    implements _$$_AvailableLanguageCopyWith<$Res> {
  __$$_AvailableLanguageCopyWithImpl(
      _$_AvailableLanguage _value, $Res Function(_$_AvailableLanguage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? code = freezed,
    Object? fallback = freezed,
    Object? isVerified = freezed,
    Object? messages = freezed,
  }) {
    return _then(_$_AvailableLanguage(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      fallback: freezed == fallback
          ? _value.fallback
          : fallback // ignore: cast_nullable_to_non_nullable
              as String?,
      isVerified: freezed == isVerified
          ? _value.isVerified
          : isVerified // ignore: cast_nullable_to_non_nullable
              as bool?,
      messages: freezed == messages
          ? _value._messages
          : messages // ignore: cast_nullable_to_non_nullable
              as Map<String, String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AvailableLanguage extends _AvailableLanguage {
  _$_AvailableLanguage(
      {this.id,
      this.name,
      this.code,
      this.fallback,
      this.isVerified,
      final Map<String, String>? messages})
      : _messages = messages,
        super._();

  factory _$_AvailableLanguage.fromJson(Map<String, dynamic> json) =>
      _$$_AvailableLanguageFromJson(json);

  @override
  final String? id;
  @override
  final String? name;
  @override
  final String? code;
  @override
  final String? fallback;
  @override
  final bool? isVerified;
  final Map<String, String>? _messages;
  @override
  Map<String, String>? get messages {
    final value = _messages;
    if (value == null) return null;
    if (_messages is EqualUnmodifiableMapView) return _messages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'AvailableLanguage(id: $id, name: $name, code: $code, fallback: $fallback, isVerified: $isVerified, messages: $messages)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AvailableLanguage &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.fallback, fallback) ||
                other.fallback == fallback) &&
            (identical(other.isVerified, isVerified) ||
                other.isVerified == isVerified) &&
            const DeepCollectionEquality().equals(other._messages, _messages));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, code, fallback,
      isVerified, const DeepCollectionEquality().hash(_messages));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AvailableLanguageCopyWith<_$_AvailableLanguage> get copyWith =>
      __$$_AvailableLanguageCopyWithImpl<_$_AvailableLanguage>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AvailableLanguageToJson(
      this,
    );
  }
}

abstract class _AvailableLanguage extends AvailableLanguage {
  factory _AvailableLanguage(
      {final String? id,
      final String? name,
      final String? code,
      final String? fallback,
      final bool? isVerified,
      final Map<String, String>? messages}) = _$_AvailableLanguage;
  _AvailableLanguage._() : super._();

  factory _AvailableLanguage.fromJson(Map<String, dynamic> json) =
      _$_AvailableLanguage.fromJson;

  @override
  String? get id;
  @override
  String? get name;
  @override
  String? get code;
  @override
  String? get fallback;
  @override
  bool? get isVerified;
  @override
  Map<String, String>? get messages;
  @override
  @JsonKey(ignore: true)
  _$$_AvailableLanguageCopyWith<_$_AvailableLanguage> get copyWith =>
      throw _privateConstructorUsedError;
}

Category _$CategoryFromJson(Map<String, dynamic> json) {
  return _Category.fromJson(json);
}

/// @nodoc
mixin _$Category {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  @CategoryKindConverter()
  CategoryKind get kind => throw _privateConstructorUsedError;
  @AssetKindOrNullConverter()
  AssetKind? get assetKind => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CategoryCopyWith<Category> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CategoryCopyWith<$Res> {
  factory $CategoryCopyWith(Category value, $Res Function(Category) then) =
      _$CategoryCopyWithImpl<$Res, Category>;
  @useResult
  $Res call(
      {String id,
      String name,
      @CategoryKindConverter() CategoryKind kind,
      @AssetKindOrNullConverter() AssetKind? assetKind});
}

/// @nodoc
class _$CategoryCopyWithImpl<$Res, $Val extends Category>
    implements $CategoryCopyWith<$Res> {
  _$CategoryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? kind = null,
    Object? assetKind = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as CategoryKind,
      assetKind: freezed == assetKind
          ? _value.assetKind
          : assetKind // ignore: cast_nullable_to_non_nullable
              as AssetKind?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CategoryCopyWith<$Res> implements $CategoryCopyWith<$Res> {
  factory _$$_CategoryCopyWith(
          _$_Category value, $Res Function(_$_Category) then) =
      __$$_CategoryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @CategoryKindConverter() CategoryKind kind,
      @AssetKindOrNullConverter() AssetKind? assetKind});
}

/// @nodoc
class __$$_CategoryCopyWithImpl<$Res>
    extends _$CategoryCopyWithImpl<$Res, _$_Category>
    implements _$$_CategoryCopyWith<$Res> {
  __$$_CategoryCopyWithImpl(
      _$_Category _value, $Res Function(_$_Category) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? kind = null,
    Object? assetKind = freezed,
  }) {
    return _then(_$_Category(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as CategoryKind,
      assetKind: freezed == assetKind
          ? _value.assetKind
          : assetKind // ignore: cast_nullable_to_non_nullable
              as AssetKind?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Category implements _Category {
  const _$_Category(
      {required this.id,
      required this.name,
      @CategoryKindConverter() required this.kind,
      @AssetKindOrNullConverter() this.assetKind});

  factory _$_Category.fromJson(Map<String, dynamic> json) =>
      _$$_CategoryFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  @CategoryKindConverter()
  final CategoryKind kind;
  @override
  @AssetKindOrNullConverter()
  final AssetKind? assetKind;

  @override
  String toString() {
    return 'Category(id: $id, name: $name, kind: $kind, assetKind: $assetKind)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Category &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.kind, kind) || other.kind == kind) &&
            (identical(other.assetKind, assetKind) ||
                other.assetKind == assetKind));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, kind, assetKind);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CategoryCopyWith<_$_Category> get copyWith =>
      __$$_CategoryCopyWithImpl<_$_Category>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CategoryToJson(
      this,
    );
  }
}

abstract class _Category implements Category {
  const factory _Category(
      {required final String id,
      required final String name,
      @CategoryKindConverter() required final CategoryKind kind,
      @AssetKindOrNullConverter() final AssetKind? assetKind}) = _$_Category;

  factory _Category.fromJson(Map<String, dynamic> json) = _$_Category.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  @CategoryKindConverter()
  CategoryKind get kind;
  @override
  @AssetKindOrNullConverter()
  AssetKind? get assetKind;
  @override
  @JsonKey(ignore: true)
  _$$_CategoryCopyWith<_$_Category> get copyWith =>
      throw _privateConstructorUsedError;
}

Country _$CountryFromJson(Map<String, dynamic> json) {
  return _Country.fromJson(json);
}

/// @nodoc
mixin _$Country {
  String get id => throw _privateConstructorUsedError;
  String get commonName => throw _privateConstructorUsedError;
  String get flagEmoji => throw _privateConstructorUsedError;
  String? get phoneCode => throw _privateConstructorUsedError;
  String? get code => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CountryCopyWith<Country> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountryCopyWith<$Res> {
  factory $CountryCopyWith(Country value, $Res Function(Country) then) =
      _$CountryCopyWithImpl<$Res, Country>;
  @useResult
  $Res call(
      {String id,
      String commonName,
      String flagEmoji,
      String? phoneCode,
      String? code});
}

/// @nodoc
class _$CountryCopyWithImpl<$Res, $Val extends Country>
    implements $CountryCopyWith<$Res> {
  _$CountryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? commonName = null,
    Object? flagEmoji = null,
    Object? phoneCode = freezed,
    Object? code = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      commonName: null == commonName
          ? _value.commonName
          : commonName // ignore: cast_nullable_to_non_nullable
              as String,
      flagEmoji: null == flagEmoji
          ? _value.flagEmoji
          : flagEmoji // ignore: cast_nullable_to_non_nullable
              as String,
      phoneCode: freezed == phoneCode
          ? _value.phoneCode
          : phoneCode // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CountryCopyWith<$Res> implements $CountryCopyWith<$Res> {
  factory _$$_CountryCopyWith(
          _$_Country value, $Res Function(_$_Country) then) =
      __$$_CountryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String commonName,
      String flagEmoji,
      String? phoneCode,
      String? code});
}

/// @nodoc
class __$$_CountryCopyWithImpl<$Res>
    extends _$CountryCopyWithImpl<$Res, _$_Country>
    implements _$$_CountryCopyWith<$Res> {
  __$$_CountryCopyWithImpl(_$_Country _value, $Res Function(_$_Country) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? commonName = null,
    Object? flagEmoji = null,
    Object? phoneCode = freezed,
    Object? code = freezed,
  }) {
    return _then(_$_Country(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      commonName: null == commonName
          ? _value.commonName
          : commonName // ignore: cast_nullable_to_non_nullable
              as String,
      flagEmoji: null == flagEmoji
          ? _value.flagEmoji
          : flagEmoji // ignore: cast_nullable_to_non_nullable
              as String,
      phoneCode: freezed == phoneCode
          ? _value.phoneCode
          : phoneCode // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Country implements _Country {
  const _$_Country(
      {required this.id,
      required this.commonName,
      required this.flagEmoji,
      this.phoneCode,
      this.code});

  factory _$_Country.fromJson(Map<String, dynamic> json) =>
      _$$_CountryFromJson(json);

  @override
  final String id;
  @override
  final String commonName;
  @override
  final String flagEmoji;
  @override
  final String? phoneCode;
  @override
  final String? code;

  @override
  String toString() {
    return 'Country(id: $id, commonName: $commonName, flagEmoji: $flagEmoji, phoneCode: $phoneCode, code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Country &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.commonName, commonName) ||
                other.commonName == commonName) &&
            (identical(other.flagEmoji, flagEmoji) ||
                other.flagEmoji == flagEmoji) &&
            (identical(other.phoneCode, phoneCode) ||
                other.phoneCode == phoneCode) &&
            (identical(other.code, code) || other.code == code));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, commonName, flagEmoji, phoneCode, code);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CountryCopyWith<_$_Country> get copyWith =>
      __$$_CountryCopyWithImpl<_$_Country>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CountryToJson(
      this,
    );
  }
}

abstract class _Country implements Country {
  const factory _Country(
      {required final String id,
      required final String commonName,
      required final String flagEmoji,
      final String? phoneCode,
      final String? code}) = _$_Country;

  factory _Country.fromJson(Map<String, dynamic> json) = _$_Country.fromJson;

  @override
  String get id;
  @override
  String get commonName;
  @override
  String get flagEmoji;
  @override
  String? get phoneCode;
  @override
  String? get code;
  @override
  @JsonKey(ignore: true)
  _$$_CountryCopyWith<_$_Country> get copyWith =>
      throw _privateConstructorUsedError;
}

PhoneNumber _$PhoneNumberFromJson(Map<String, dynamic> json) {
  return _PhoneNumber.fromJson(json);
}

/// @nodoc
mixin _$PhoneNumber {
  /// Country code.
  String get countryCode => throw _privateConstructorUsedError;

  /// Phone number.
  String get phoneNumber => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PhoneNumberCopyWith<PhoneNumber> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhoneNumberCopyWith<$Res> {
  factory $PhoneNumberCopyWith(
          PhoneNumber value, $Res Function(PhoneNumber) then) =
      _$PhoneNumberCopyWithImpl<$Res, PhoneNumber>;
  @useResult
  $Res call({String countryCode, String phoneNumber});
}

/// @nodoc
class _$PhoneNumberCopyWithImpl<$Res, $Val extends PhoneNumber>
    implements $PhoneNumberCopyWith<$Res> {
  _$PhoneNumberCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? countryCode = null,
    Object? phoneNumber = null,
  }) {
    return _then(_value.copyWith(
      countryCode: null == countryCode
          ? _value.countryCode
          : countryCode // ignore: cast_nullable_to_non_nullable
              as String,
      phoneNumber: null == phoneNumber
          ? _value.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PhoneNumberCopyWith<$Res>
    implements $PhoneNumberCopyWith<$Res> {
  factory _$$_PhoneNumberCopyWith(
          _$_PhoneNumber value, $Res Function(_$_PhoneNumber) then) =
      __$$_PhoneNumberCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String countryCode, String phoneNumber});
}

/// @nodoc
class __$$_PhoneNumberCopyWithImpl<$Res>
    extends _$PhoneNumberCopyWithImpl<$Res, _$_PhoneNumber>
    implements _$$_PhoneNumberCopyWith<$Res> {
  __$$_PhoneNumberCopyWithImpl(
      _$_PhoneNumber _value, $Res Function(_$_PhoneNumber) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? countryCode = null,
    Object? phoneNumber = null,
  }) {
    return _then(_$_PhoneNumber(
      countryCode: null == countryCode
          ? _value.countryCode
          : countryCode // ignore: cast_nullable_to_non_nullable
              as String,
      phoneNumber: null == phoneNumber
          ? _value.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_PhoneNumber extends _PhoneNumber {
  const _$_PhoneNumber({required this.countryCode, required this.phoneNumber})
      : super._();

  factory _$_PhoneNumber.fromJson(Map<String, dynamic> json) =>
      _$$_PhoneNumberFromJson(json);

  /// Country code.
  @override
  final String countryCode;

  /// Phone number.
  @override
  final String phoneNumber;

  @override
  String toString() {
    return 'PhoneNumber(countryCode: $countryCode, phoneNumber: $phoneNumber)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_PhoneNumber &&
            (identical(other.countryCode, countryCode) ||
                other.countryCode == countryCode) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, countryCode, phoneNumber);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PhoneNumberCopyWith<_$_PhoneNumber> get copyWith =>
      __$$_PhoneNumberCopyWithImpl<_$_PhoneNumber>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PhoneNumberToJson(
      this,
    );
  }
}

abstract class _PhoneNumber extends PhoneNumber {
  const factory _PhoneNumber(
      {required final String countryCode,
      required final String phoneNumber}) = _$_PhoneNumber;
  const _PhoneNumber._() : super._();

  factory _PhoneNumber.fromJson(Map<String, dynamic> json) =
      _$_PhoneNumber.fromJson;

  @override

  /// Country code.
  String get countryCode;
  @override

  /// Phone number.
  String get phoneNumber;
  @override
  @JsonKey(ignore: true)
  _$$_PhoneNumberCopyWith<_$_PhoneNumber> get copyWith =>
      throw _privateConstructorUsedError;
}

NullablePhoneNumber _$NullablePhoneNumberFromJson(Map<String, dynamic> json) {
  return _NullablePhoneNumber.fromJson(json);
}

/// @nodoc
mixin _$NullablePhoneNumber {
  /// Country code.
  String? get countryCode => throw _privateConstructorUsedError;

  /// Phone number.
  String? get phoneNumber => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $NullablePhoneNumberCopyWith<NullablePhoneNumber> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NullablePhoneNumberCopyWith<$Res> {
  factory $NullablePhoneNumberCopyWith(
          NullablePhoneNumber value, $Res Function(NullablePhoneNumber) then) =
      _$NullablePhoneNumberCopyWithImpl<$Res, NullablePhoneNumber>;
  @useResult
  $Res call({String? countryCode, String? phoneNumber});
}

/// @nodoc
class _$NullablePhoneNumberCopyWithImpl<$Res, $Val extends NullablePhoneNumber>
    implements $NullablePhoneNumberCopyWith<$Res> {
  _$NullablePhoneNumberCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? countryCode = freezed,
    Object? phoneNumber = freezed,
  }) {
    return _then(_value.copyWith(
      countryCode: freezed == countryCode
          ? _value.countryCode
          : countryCode // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _value.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_NullablePhoneNumberCopyWith<$Res>
    implements $NullablePhoneNumberCopyWith<$Res> {
  factory _$$_NullablePhoneNumberCopyWith(_$_NullablePhoneNumber value,
          $Res Function(_$_NullablePhoneNumber) then) =
      __$$_NullablePhoneNumberCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? countryCode, String? phoneNumber});
}

/// @nodoc
class __$$_NullablePhoneNumberCopyWithImpl<$Res>
    extends _$NullablePhoneNumberCopyWithImpl<$Res, _$_NullablePhoneNumber>
    implements _$$_NullablePhoneNumberCopyWith<$Res> {
  __$$_NullablePhoneNumberCopyWithImpl(_$_NullablePhoneNumber _value,
      $Res Function(_$_NullablePhoneNumber) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? countryCode = freezed,
    Object? phoneNumber = freezed,
  }) {
    return _then(_$_NullablePhoneNumber(
      countryCode: freezed == countryCode
          ? _value.countryCode
          : countryCode // ignore: cast_nullable_to_non_nullable
              as String?,
      phoneNumber: freezed == phoneNumber
          ? _value.phoneNumber
          : phoneNumber // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_NullablePhoneNumber extends _NullablePhoneNumber {
  const _$_NullablePhoneNumber({this.countryCode, this.phoneNumber})
      : super._();

  factory _$_NullablePhoneNumber.fromJson(Map<String, dynamic> json) =>
      _$$_NullablePhoneNumberFromJson(json);

  /// Country code.
  @override
  final String? countryCode;

  /// Phone number.
  @override
  final String? phoneNumber;

  @override
  String toString() {
    return 'NullablePhoneNumber(countryCode: $countryCode, phoneNumber: $phoneNumber)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NullablePhoneNumber &&
            (identical(other.countryCode, countryCode) ||
                other.countryCode == countryCode) &&
            (identical(other.phoneNumber, phoneNumber) ||
                other.phoneNumber == phoneNumber));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, countryCode, phoneNumber);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NullablePhoneNumberCopyWith<_$_NullablePhoneNumber> get copyWith =>
      __$$_NullablePhoneNumberCopyWithImpl<_$_NullablePhoneNumber>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_NullablePhoneNumberToJson(
      this,
    );
  }
}

abstract class _NullablePhoneNumber extends NullablePhoneNumber {
  const factory _NullablePhoneNumber(
      {final String? countryCode,
      final String? phoneNumber}) = _$_NullablePhoneNumber;
  const _NullablePhoneNumber._() : super._();

  factory _NullablePhoneNumber.fromJson(Map<String, dynamic> json) =
      _$_NullablePhoneNumber.fromJson;

  @override

  /// Country code.
  String? get countryCode;
  @override

  /// Phone number.
  String? get phoneNumber;
  @override
  @JsonKey(ignore: true)
  _$$_NullablePhoneNumberCopyWith<_$_NullablePhoneNumber> get copyWith =>
      throw _privateConstructorUsedError;
}

City _$CityFromJson(Map<String, dynamic> json) {
  return _City.fromJson(json);
}

/// @nodoc
mixin _$City {
  /// [id] represents the unique identifier of the city
  String get id => throw _privateConstructorUsedError;

  /// [name] represents the name of the city
  @JsonKey(name: 'nativeName')
  String get name => throw _privateConstructorUsedError;

  /// [code] represents the code of the city
  String? get code => throw _privateConstructorUsedError;

  /// [countryStateId] represents the unique identifier of the country state
  String get countryStateId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CityCopyWith<City> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CityCopyWith<$Res> {
  factory $CityCopyWith(City value, $Res Function(City) then) =
      _$CityCopyWithImpl<$Res, City>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'nativeName') String name,
      String? code,
      String countryStateId});
}

/// @nodoc
class _$CityCopyWithImpl<$Res, $Val extends City>
    implements $CityCopyWith<$Res> {
  _$CityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = freezed,
    Object? countryStateId = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      countryStateId: null == countryStateId
          ? _value.countryStateId
          : countryStateId // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CityCopyWith<$Res> implements $CityCopyWith<$Res> {
  factory _$$_CityCopyWith(_$_City value, $Res Function(_$_City) then) =
      __$$_CityCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'nativeName') String name,
      String? code,
      String countryStateId});
}

/// @nodoc
class __$$_CityCopyWithImpl<$Res> extends _$CityCopyWithImpl<$Res, _$_City>
    implements _$$_CityCopyWith<$Res> {
  __$$_CityCopyWithImpl(_$_City _value, $Res Function(_$_City) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = freezed,
    Object? countryStateId = null,
  }) {
    return _then(_$_City(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      countryStateId: null == countryStateId
          ? _value.countryStateId
          : countryStateId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_City implements _City {
  const _$_City(
      {required this.id,
      @JsonKey(name: 'nativeName') required this.name,
      this.code,
      required this.countryStateId});

  factory _$_City.fromJson(Map<String, dynamic> json) => _$$_CityFromJson(json);

  /// [id] represents the unique identifier of the city
  @override
  final String id;

  /// [name] represents the name of the city
  @override
  @JsonKey(name: 'nativeName')
  final String name;

  /// [code] represents the code of the city
  @override
  final String? code;

  /// [countryStateId] represents the unique identifier of the country state
  @override
  final String countryStateId;

  @override
  String toString() {
    return 'City(id: $id, name: $name, code: $code, countryStateId: $countryStateId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_City &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.countryStateId, countryStateId) ||
                other.countryStateId == countryStateId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, code, countryStateId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CityCopyWith<_$_City> get copyWith =>
      __$$_CityCopyWithImpl<_$_City>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CityToJson(
      this,
    );
  }
}

abstract class _City implements City {
  const factory _City(
      {required final String id,
      @JsonKey(name: 'nativeName') required final String name,
      final String? code,
      required final String countryStateId}) = _$_City;

  factory _City.fromJson(Map<String, dynamic> json) = _$_City.fromJson;

  @override

  /// [id] represents the unique identifier of the city
  String get id;
  @override

  /// [name] represents the name of the city
  @JsonKey(name: 'nativeName')
  String get name;
  @override

  /// [code] represents the code of the city
  String? get code;
  @override

  /// [countryStateId] represents the unique identifier of the country state
  String get countryStateId;
  @override
  @JsonKey(ignore: true)
  _$$_CityCopyWith<_$_City> get copyWith => throw _privateConstructorUsedError;
}

CountryState _$CountryStateFromJson(Map<String, dynamic> json) {
  return _CountryState.fromJson(json);
}

/// @nodoc
mixin _$CountryState {
  /// [id] represents the unique identifier of the CountryState
  String get id => throw _privateConstructorUsedError;

  /// [name] represents the name of the CountryState
  @JsonKey(name: 'nativeName')
  String get name => throw _privateConstructorUsedError;

  /// [code] represents the code of the CountryState
  String get code => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CountryStateCopyWith<CountryState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CountryStateCopyWith<$Res> {
  factory $CountryStateCopyWith(
          CountryState value, $Res Function(CountryState) then) =
      _$CountryStateCopyWithImpl<$Res, CountryState>;
  @useResult
  $Res call({String id, @JsonKey(name: 'nativeName') String name, String code});
}

/// @nodoc
class _$CountryStateCopyWithImpl<$Res, $Val extends CountryState>
    implements $CountryStateCopyWith<$Res> {
  _$CountryStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CountryStateCopyWith<$Res>
    implements $CountryStateCopyWith<$Res> {
  factory _$$_CountryStateCopyWith(
          _$_CountryState value, $Res Function(_$_CountryState) then) =
      __$$_CountryStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, @JsonKey(name: 'nativeName') String name, String code});
}

/// @nodoc
class __$$_CountryStateCopyWithImpl<$Res>
    extends _$CountryStateCopyWithImpl<$Res, _$_CountryState>
    implements _$$_CountryStateCopyWith<$Res> {
  __$$_CountryStateCopyWithImpl(
      _$_CountryState _value, $Res Function(_$_CountryState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = null,
  }) {
    return _then(_$_CountryState(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CountryState implements _CountryState {
  const _$_CountryState(
      {required this.id,
      @JsonKey(name: 'nativeName') required this.name,
      required this.code});

  factory _$_CountryState.fromJson(Map<String, dynamic> json) =>
      _$$_CountryStateFromJson(json);

  /// [id] represents the unique identifier of the CountryState
  @override
  final String id;

  /// [name] represents the name of the CountryState
  @override
  @JsonKey(name: 'nativeName')
  final String name;

  /// [code] represents the code of the CountryState
  @override
  final String code;

  @override
  String toString() {
    return 'CountryState(id: $id, name: $name, code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CountryState &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.code, code) || other.code == code));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, code);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CountryStateCopyWith<_$_CountryState> get copyWith =>
      __$$_CountryStateCopyWithImpl<_$_CountryState>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CountryStateToJson(
      this,
    );
  }
}

abstract class _CountryState implements CountryState {
  const factory _CountryState(
      {required final String id,
      @JsonKey(name: 'nativeName') required final String name,
      required final String code}) = _$_CountryState;

  factory _CountryState.fromJson(Map<String, dynamic> json) =
      _$_CountryState.fromJson;

  @override

  /// [id] represents the unique identifier of the CountryState
  String get id;
  @override

  /// [name] represents the name of the CountryState
  @JsonKey(name: 'nativeName')
  String get name;
  @override

  /// [code] represents the code of the CountryState
  String get code;
  @override
  @JsonKey(ignore: true)
  _$$_CountryStateCopyWith<_$_CountryState> get copyWith =>
      throw _privateConstructorUsedError;
}

Profile _$ProfileFromJson(Map<String, dynamic> json) {
  return _Profile.fromJson(json);
}

/// @nodoc
mixin _$Profile {
  String? get companyName => throw _privateConstructorUsedError;
  String? get billingAddress => throw _privateConstructorUsedError;
  String? get fiscalId => throw _privateConstructorUsedError;
  String? get headquartersId => throw _privateConstructorUsedError;
  Country? get headquarters => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ProfileCopyWith<Profile> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProfileCopyWith<$Res> {
  factory $ProfileCopyWith(Profile value, $Res Function(Profile) then) =
      _$ProfileCopyWithImpl<$Res, Profile>;
  @useResult
  $Res call(
      {String? companyName,
      String? billingAddress,
      String? fiscalId,
      String? headquartersId,
      Country? headquarters});

  $CountryCopyWith<$Res>? get headquarters;
}

/// @nodoc
class _$ProfileCopyWithImpl<$Res, $Val extends Profile>
    implements $ProfileCopyWith<$Res> {
  _$ProfileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? companyName = freezed,
    Object? billingAddress = freezed,
    Object? fiscalId = freezed,
    Object? headquartersId = freezed,
    Object? headquarters = freezed,
  }) {
    return _then(_value.copyWith(
      companyName: freezed == companyName
          ? _value.companyName
          : companyName // ignore: cast_nullable_to_non_nullable
              as String?,
      billingAddress: freezed == billingAddress
          ? _value.billingAddress
          : billingAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      fiscalId: freezed == fiscalId
          ? _value.fiscalId
          : fiscalId // ignore: cast_nullable_to_non_nullable
              as String?,
      headquartersId: freezed == headquartersId
          ? _value.headquartersId
          : headquartersId // ignore: cast_nullable_to_non_nullable
              as String?,
      headquarters: freezed == headquarters
          ? _value.headquarters
          : headquarters // ignore: cast_nullable_to_non_nullable
              as Country?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CountryCopyWith<$Res>? get headquarters {
    if (_value.headquarters == null) {
      return null;
    }

    return $CountryCopyWith<$Res>(_value.headquarters!, (value) {
      return _then(_value.copyWith(headquarters: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ProfileCopyWith<$Res> implements $ProfileCopyWith<$Res> {
  factory _$$_ProfileCopyWith(
          _$_Profile value, $Res Function(_$_Profile) then) =
      __$$_ProfileCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? companyName,
      String? billingAddress,
      String? fiscalId,
      String? headquartersId,
      Country? headquarters});

  @override
  $CountryCopyWith<$Res>? get headquarters;
}

/// @nodoc
class __$$_ProfileCopyWithImpl<$Res>
    extends _$ProfileCopyWithImpl<$Res, _$_Profile>
    implements _$$_ProfileCopyWith<$Res> {
  __$$_ProfileCopyWithImpl(_$_Profile _value, $Res Function(_$_Profile) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? companyName = freezed,
    Object? billingAddress = freezed,
    Object? fiscalId = freezed,
    Object? headquartersId = freezed,
    Object? headquarters = freezed,
  }) {
    return _then(_$_Profile(
      companyName: freezed == companyName
          ? _value.companyName
          : companyName // ignore: cast_nullable_to_non_nullable
              as String?,
      billingAddress: freezed == billingAddress
          ? _value.billingAddress
          : billingAddress // ignore: cast_nullable_to_non_nullable
              as String?,
      fiscalId: freezed == fiscalId
          ? _value.fiscalId
          : fiscalId // ignore: cast_nullable_to_non_nullable
              as String?,
      headquartersId: freezed == headquartersId
          ? _value.headquartersId
          : headquartersId // ignore: cast_nullable_to_non_nullable
              as String?,
      headquarters: freezed == headquarters
          ? _value.headquarters
          : headquarters // ignore: cast_nullable_to_non_nullable
              as Country?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Profile implements _Profile {
  const _$_Profile(
      {this.companyName,
      this.billingAddress,
      this.fiscalId,
      this.headquartersId,
      this.headquarters});

  factory _$_Profile.fromJson(Map<String, dynamic> json) =>
      _$$_ProfileFromJson(json);

  @override
  final String? companyName;
  @override
  final String? billingAddress;
  @override
  final String? fiscalId;
  @override
  final String? headquartersId;
  @override
  final Country? headquarters;

  @override
  String toString() {
    return 'Profile(companyName: $companyName, billingAddress: $billingAddress, fiscalId: $fiscalId, headquartersId: $headquartersId, headquarters: $headquarters)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Profile &&
            (identical(other.companyName, companyName) ||
                other.companyName == companyName) &&
            (identical(other.billingAddress, billingAddress) ||
                other.billingAddress == billingAddress) &&
            (identical(other.fiscalId, fiscalId) ||
                other.fiscalId == fiscalId) &&
            (identical(other.headquartersId, headquartersId) ||
                other.headquartersId == headquartersId) &&
            (identical(other.headquarters, headquarters) ||
                other.headquarters == headquarters));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, companyName, billingAddress,
      fiscalId, headquartersId, headquarters);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ProfileCopyWith<_$_Profile> get copyWith =>
      __$$_ProfileCopyWithImpl<_$_Profile>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ProfileToJson(
      this,
    );
  }
}

abstract class _Profile implements Profile {
  const factory _Profile(
      {final String? companyName,
      final String? billingAddress,
      final String? fiscalId,
      final String? headquartersId,
      final Country? headquarters}) = _$_Profile;

  factory _Profile.fromJson(Map<String, dynamic> json) = _$_Profile.fromJson;

  @override
  String? get companyName;
  @override
  String? get billingAddress;
  @override
  String? get fiscalId;
  @override
  String? get headquartersId;
  @override
  Country? get headquarters;
  @override
  @JsonKey(ignore: true)
  _$$_ProfileCopyWith<_$_Profile> get copyWith =>
      throw _privateConstructorUsedError;
}

Reference _$ReferenceFromJson(Map<String, dynamic> json) {
  return _Reference.fromJson(json);
}

/// @nodoc
mixin _$Reference {
  /// Is the ID.
  String get id => throw _privateConstructorUsedError;

  /// Is the name.
  String get name => throw _privateConstructorUsedError;

  /// Is the category.
  @ReferenceCategoryOrNullConverter()
  ReferenceCategory? get category => throw _privateConstructorUsedError;

  /// Is a list of custom fields.
  List<CustomField>? get customFields => throw _privateConstructorUsedError;

  /// Is the QR code URI.
  String? get qrCode => throw _privateConstructorUsedError;

  /// Is the list of granted access
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ReferenceCopyWith<Reference> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReferenceCopyWith<$Res> {
  factory $ReferenceCopyWith(Reference value, $Res Function(Reference) then) =
      _$ReferenceCopyWithImpl<$Res, Reference>;
  @useResult
  $Res call(
      {String id,
      String name,
      @ReferenceCategoryOrNullConverter() ReferenceCategory? category,
      List<CustomField>? customFields,
      String? qrCode,
      List<Access>? access});
}

/// @nodoc
class _$ReferenceCopyWithImpl<$Res, $Val extends Reference>
    implements $ReferenceCopyWith<$Res> {
  _$ReferenceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? category = freezed,
    Object? customFields = freezed,
    Object? qrCode = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as ReferenceCategory?,
      customFields: freezed == customFields
          ? _value.customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ReferenceCopyWith<$Res> implements $ReferenceCopyWith<$Res> {
  factory _$$_ReferenceCopyWith(
          _$_Reference value, $Res Function(_$_Reference) then) =
      __$$_ReferenceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @ReferenceCategoryOrNullConverter() ReferenceCategory? category,
      List<CustomField>? customFields,
      String? qrCode,
      List<Access>? access});
}

/// @nodoc
class __$$_ReferenceCopyWithImpl<$Res>
    extends _$ReferenceCopyWithImpl<$Res, _$_Reference>
    implements _$$_ReferenceCopyWith<$Res> {
  __$$_ReferenceCopyWithImpl(
      _$_Reference _value, $Res Function(_$_Reference) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? category = freezed,
    Object? customFields = freezed,
    Object? qrCode = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_Reference(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as ReferenceCategory?,
      customFields: freezed == customFields
          ? _value._customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Reference implements _Reference {
  const _$_Reference(
      {required this.id,
      required this.name,
      @ReferenceCategoryOrNullConverter() this.category,
      final List<CustomField>? customFields,
      this.qrCode,
      final List<Access>? access})
      : _customFields = customFields,
        _access = access;

  factory _$_Reference.fromJson(Map<String, dynamic> json) =>
      _$$_ReferenceFromJson(json);

  /// Is the ID.
  @override
  final String id;

  /// Is the name.
  @override
  final String name;

  /// Is the category.
  @override
  @ReferenceCategoryOrNullConverter()
  final ReferenceCategory? category;

  /// Is a list of custom fields.
  final List<CustomField>? _customFields;

  /// Is a list of custom fields.
  @override
  List<CustomField>? get customFields {
    final value = _customFields;
    if (value == null) return null;
    if (_customFields is EqualUnmodifiableListView) return _customFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the QR code URI.
  @override
  final String? qrCode;

  /// Is the list of granted access
  final List<Access>? _access;

  /// Is the list of granted access
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Reference(id: $id, name: $name, category: $category, customFields: $customFields, qrCode: $qrCode, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Reference &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.category, category) ||
                other.category == category) &&
            const DeepCollectionEquality()
                .equals(other._customFields, _customFields) &&
            (identical(other.qrCode, qrCode) || other.qrCode == qrCode) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      category,
      const DeepCollectionEquality().hash(_customFields),
      qrCode,
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ReferenceCopyWith<_$_Reference> get copyWith =>
      __$$_ReferenceCopyWithImpl<_$_Reference>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ReferenceToJson(
      this,
    );
  }
}

abstract class _Reference implements Reference {
  const factory _Reference(
      {required final String id,
      required final String name,
      @ReferenceCategoryOrNullConverter() final ReferenceCategory? category,
      final List<CustomField>? customFields,
      final String? qrCode,
      final List<Access>? access}) = _$_Reference;

  factory _Reference.fromJson(Map<String, dynamic> json) =
      _$_Reference.fromJson;

  @override

  /// Is the ID.
  String get id;
  @override

  /// Is the name.
  String get name;
  @override

  /// Is the category.
  @ReferenceCategoryOrNullConverter()
  ReferenceCategory? get category;
  @override

  /// Is a list of custom fields.
  List<CustomField>? get customFields;
  @override

  /// Is the QR code URI.
  String? get qrCode;
  @override

  /// Is the list of granted access
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_ReferenceCopyWith<_$_Reference> get copyWith =>
      throw _privateConstructorUsedError;
}

Tag _$TagFromJson(Map<String, dynamic> json) {
  return _Tag.fromJson(json);
}

/// @nodoc
mixin _$Tag {
  /// Is the ID of the tag.
  String get id => throw _privateConstructorUsedError;

  /// Is the name of the tag.
  String get name => throw _privateConstructorUsedError;

  /// Is the color of the tag.
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;

  /// Is the icon of the tag.
  @Deprecated('Use `dynamicIcon` instead')
  @IconOrNullConverter()
  IconData? get icon => throw _privateConstructorUsedError;

  /// Dynamic icon
  Avatar? get dynamicIcon => throw _privateConstructorUsedError;

  /// Is a list of associated users to this module.
  List<User>? get users => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated users to this module.
  List<String>? get usersIds => throw _privateConstructorUsedError;

  /// Is a list of associated outbound services to this module.
  List<OutboundService>? get outboundServices =>
      throw _privateConstructorUsedError;

  /// Is a list of ID's of associated outbound services to this module.
  List<String>? get outboundServicesIds => throw _privateConstructorUsedError;

  /// Is a list of associated triggers to this module.
  List<Trigger>? get triggers => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated triggers to this module.
  List<String>? get triggersIds => throw _privateConstructorUsedError;

  /// Is a list of associated actions to this module.
  List<Action>? get actions => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated actions to this module.
  List<String>? get actionsIds => throw _privateConstructorUsedError;

  /// Is a list of associated operations to this module.
  List<Operation>? get operations => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated operations to this module.
  List<String>? get operationsIds => throw _privateConstructorUsedError;

  /// Is a list of associated assets to this module.
  List<Asset>? get assets => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated assets to this module.
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  /// Is a list of associated devices to this module.
  List<Device>? get devices => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated devices to this module.
  List<String>? get devicesIds => throw _privateConstructorUsedError;

  /// Is a list of associated geofences to this module.
  List<Geofence>? get geofences => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated geofences to this module.
  List<String>? get geofencesIds => throw _privateConstructorUsedError;

  /// Is a list of associated source accounts to this module.
  List<ExternalAccount>? get externalAccounts =>
      throw _privateConstructorUsedError;

  /// Is a list of ID's of associated source accounts to this module.
  List<String>? get externalAccountsIds => throw _privateConstructorUsedError;

  /// Is a list of associated presets to this module.
  List<Preset>? get presets => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated presets to this module.
  List<String>? get presetsIds => throw _privateConstructorUsedError;

  /// Is a list of associated references to this module.
  List<Reference>? get references => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated references to this module.
  List<String>? get referencesIds => throw _privateConstructorUsedError;

  /// Is a list of associated checkpoints to this module.
  List<Checkpoint>? get checkpoints => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated checkpoints to this module.
  List<String>? get checkpointsIds => throw _privateConstructorUsedError;

  /// Is a list of associated care protocols to this module.
  List<CareProtocol>? get careProtocols => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated care protocols to this module.
  List<String>? get careProtocolsIds => throw _privateConstructorUsedError;

  /// Is a list of associated inbound services to this module.
  List<InboundService>? get inboundServices =>
      throw _privateConstructorUsedError;

  /// Is a list of ID's of associated inbound services to this module.
  List<String>? get inboundServicesIds => throw _privateConstructorUsedError;

  /// Is a list of associated functions to this module.
  List<LayrzFunction>? get functions => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated functions to this module.
  List<String>? get functionsIds => throw _privateConstructorUsedError;

  /// Is a list of associated concierge forms to this module.
  List<ConciergeForm>? get conciergeForms => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated concierge forms to this module.
  List<String>? get conciergeFormsIds => throw _privateConstructorUsedError;

  /// Is a list of associated report templates to this module.
  List<ReportTemplate>? get reportTemplates =>
      throw _privateConstructorUsedError;

  /// Is a list of ID's of associated report templates to this module.
  List<String>? get reportTemplatesIds => throw _privateConstructorUsedError;

  /// Is a list of associated charts to this module.
  List<LayrzChart>? get charts => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated charts to this module.
  List<String>? get chartsIds => throw _privateConstructorUsedError;

  /// Is a list of associated workspaces to this module.
  List<Workspace>? get workspaces => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated workspaces to this module.
  List<String>? get workspacesIds => throw _privateConstructorUsedError;

  /// Is a list of associated vision profiles to this module.
  List<VisionProfile>? get visionProfiles => throw _privateConstructorUsedError;

  /// Is a list of ID's of associated vision profiles to this module.
  List<String>? get visionProfilesIds => throw _privateConstructorUsedError;

  /// Is a list of granted access to this entity.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TagCopyWith<Tag> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TagCopyWith<$Res> {
  factory $TagCopyWith(Tag value, $Res Function(Tag) then) =
      _$TagCopyWithImpl<$Res, Tag>;
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      @Deprecated('Use `dynamicIcon` instead')
      @IconOrNullConverter()
      IconData? icon,
      Avatar? dynamicIcon,
      List<User>? users,
      List<String>? usersIds,
      List<OutboundService>? outboundServices,
      List<String>? outboundServicesIds,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      List<Action>? actions,
      List<String>? actionsIds,
      List<Operation>? operations,
      List<String>? operationsIds,
      List<Asset>? assets,
      List<String>? assetsIds,
      List<Device>? devices,
      List<String>? devicesIds,
      List<Geofence>? geofences,
      List<String>? geofencesIds,
      List<ExternalAccount>? externalAccounts,
      List<String>? externalAccountsIds,
      List<Preset>? presets,
      List<String>? presetsIds,
      List<Reference>? references,
      List<String>? referencesIds,
      List<Checkpoint>? checkpoints,
      List<String>? checkpointsIds,
      List<CareProtocol>? careProtocols,
      List<String>? careProtocolsIds,
      List<InboundService>? inboundServices,
      List<String>? inboundServicesIds,
      List<LayrzFunction>? functions,
      List<String>? functionsIds,
      List<ConciergeForm>? conciergeForms,
      List<String>? conciergeFormsIds,
      List<ReportTemplate>? reportTemplates,
      List<String>? reportTemplatesIds,
      List<LayrzChart>? charts,
      List<String>? chartsIds,
      List<Workspace>? workspaces,
      List<String>? workspacesIds,
      List<VisionProfile>? visionProfiles,
      List<String>? visionProfilesIds,
      List<Access>? access});

  $AvatarCopyWith<$Res>? get dynamicIcon;
}

/// @nodoc
class _$TagCopyWithImpl<$Res, $Val extends Tag> implements $TagCopyWith<$Res> {
  _$TagCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? icon = freezed,
    Object? dynamicIcon = freezed,
    Object? users = freezed,
    Object? usersIds = freezed,
    Object? outboundServices = freezed,
    Object? outboundServicesIds = freezed,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? actions = freezed,
    Object? actionsIds = freezed,
    Object? operations = freezed,
    Object? operationsIds = freezed,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? devices = freezed,
    Object? devicesIds = freezed,
    Object? geofences = freezed,
    Object? geofencesIds = freezed,
    Object? externalAccounts = freezed,
    Object? externalAccountsIds = freezed,
    Object? presets = freezed,
    Object? presetsIds = freezed,
    Object? references = freezed,
    Object? referencesIds = freezed,
    Object? checkpoints = freezed,
    Object? checkpointsIds = freezed,
    Object? careProtocols = freezed,
    Object? careProtocolsIds = freezed,
    Object? inboundServices = freezed,
    Object? inboundServicesIds = freezed,
    Object? functions = freezed,
    Object? functionsIds = freezed,
    Object? conciergeForms = freezed,
    Object? conciergeFormsIds = freezed,
    Object? reportTemplates = freezed,
    Object? reportTemplatesIds = freezed,
    Object? charts = freezed,
    Object? chartsIds = freezed,
    Object? workspaces = freezed,
    Object? workspacesIds = freezed,
    Object? visionProfiles = freezed,
    Object? visionProfilesIds = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      dynamicIcon: freezed == dynamicIcon
          ? _value.dynamicIcon
          : dynamicIcon // ignore: cast_nullable_to_non_nullable
              as Avatar?,
      users: freezed == users
          ? _value.users
          : users // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      usersIds: freezed == usersIds
          ? _value.usersIds
          : usersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServices: freezed == outboundServices
          ? _value.outboundServices
          : outboundServices // ignore: cast_nullable_to_non_nullable
              as List<OutboundService>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value.outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      triggers: freezed == triggers
          ? _value.triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value.triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      actions: freezed == actions
          ? _value.actions
          : actions // ignore: cast_nullable_to_non_nullable
              as List<Action>?,
      actionsIds: freezed == actionsIds
          ? _value.actionsIds
          : actionsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      operations: freezed == operations
          ? _value.operations
          : operations // ignore: cast_nullable_to_non_nullable
              as List<Operation>?,
      operationsIds: freezed == operationsIds
          ? _value.operationsIds
          : operationsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assets: freezed == assets
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      devices: freezed == devices
          ? _value.devices
          : devices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
      devicesIds: freezed == devicesIds
          ? _value.devicesIds
          : devicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      geofences: freezed == geofences
          ? _value.geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      geofencesIds: freezed == geofencesIds
          ? _value.geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      externalAccounts: freezed == externalAccounts
          ? _value.externalAccounts
          : externalAccounts // ignore: cast_nullable_to_non_nullable
              as List<ExternalAccount>?,
      externalAccountsIds: freezed == externalAccountsIds
          ? _value.externalAccountsIds
          : externalAccountsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      presets: freezed == presets
          ? _value.presets
          : presets // ignore: cast_nullable_to_non_nullable
              as List<Preset>?,
      presetsIds: freezed == presetsIds
          ? _value.presetsIds
          : presetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      references: freezed == references
          ? _value.references
          : references // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      referencesIds: freezed == referencesIds
          ? _value.referencesIds
          : referencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      checkpoints: freezed == checkpoints
          ? _value.checkpoints
          : checkpoints // ignore: cast_nullable_to_non_nullable
              as List<Checkpoint>?,
      checkpointsIds: freezed == checkpointsIds
          ? _value.checkpointsIds
          : checkpointsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      careProtocols: freezed == careProtocols
          ? _value.careProtocols
          : careProtocols // ignore: cast_nullable_to_non_nullable
              as List<CareProtocol>?,
      careProtocolsIds: freezed == careProtocolsIds
          ? _value.careProtocolsIds
          : careProtocolsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      inboundServices: freezed == inboundServices
          ? _value.inboundServices
          : inboundServices // ignore: cast_nullable_to_non_nullable
              as List<InboundService>?,
      inboundServicesIds: freezed == inboundServicesIds
          ? _value.inboundServicesIds
          : inboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      functions: freezed == functions
          ? _value.functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<LayrzFunction>?,
      functionsIds: freezed == functionsIds
          ? _value.functionsIds
          : functionsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      conciergeForms: freezed == conciergeForms
          ? _value.conciergeForms
          : conciergeForms // ignore: cast_nullable_to_non_nullable
              as List<ConciergeForm>?,
      conciergeFormsIds: freezed == conciergeFormsIds
          ? _value.conciergeFormsIds
          : conciergeFormsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      reportTemplates: freezed == reportTemplates
          ? _value.reportTemplates
          : reportTemplates // ignore: cast_nullable_to_non_nullable
              as List<ReportTemplate>?,
      reportTemplatesIds: freezed == reportTemplatesIds
          ? _value.reportTemplatesIds
          : reportTemplatesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      charts: freezed == charts
          ? _value.charts
          : charts // ignore: cast_nullable_to_non_nullable
              as List<LayrzChart>?,
      chartsIds: freezed == chartsIds
          ? _value.chartsIds
          : chartsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      workspaces: freezed == workspaces
          ? _value.workspaces
          : workspaces // ignore: cast_nullable_to_non_nullable
              as List<Workspace>?,
      workspacesIds: freezed == workspacesIds
          ? _value.workspacesIds
          : workspacesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      visionProfiles: freezed == visionProfiles
          ? _value.visionProfiles
          : visionProfiles // ignore: cast_nullable_to_non_nullable
              as List<VisionProfile>?,
      visionProfilesIds: freezed == visionProfilesIds
          ? _value.visionProfilesIds
          : visionProfilesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AvatarCopyWith<$Res>? get dynamicIcon {
    if (_value.dynamicIcon == null) {
      return null;
    }

    return $AvatarCopyWith<$Res>(_value.dynamicIcon!, (value) {
      return _then(_value.copyWith(dynamicIcon: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TagCopyWith<$Res> implements $TagCopyWith<$Res> {
  factory _$$_TagCopyWith(_$_Tag value, $Res Function(_$_Tag) then) =
      __$$_TagCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      @Deprecated('Use `dynamicIcon` instead')
      @IconOrNullConverter()
      IconData? icon,
      Avatar? dynamicIcon,
      List<User>? users,
      List<String>? usersIds,
      List<OutboundService>? outboundServices,
      List<String>? outboundServicesIds,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      List<Action>? actions,
      List<String>? actionsIds,
      List<Operation>? operations,
      List<String>? operationsIds,
      List<Asset>? assets,
      List<String>? assetsIds,
      List<Device>? devices,
      List<String>? devicesIds,
      List<Geofence>? geofences,
      List<String>? geofencesIds,
      List<ExternalAccount>? externalAccounts,
      List<String>? externalAccountsIds,
      List<Preset>? presets,
      List<String>? presetsIds,
      List<Reference>? references,
      List<String>? referencesIds,
      List<Checkpoint>? checkpoints,
      List<String>? checkpointsIds,
      List<CareProtocol>? careProtocols,
      List<String>? careProtocolsIds,
      List<InboundService>? inboundServices,
      List<String>? inboundServicesIds,
      List<LayrzFunction>? functions,
      List<String>? functionsIds,
      List<ConciergeForm>? conciergeForms,
      List<String>? conciergeFormsIds,
      List<ReportTemplate>? reportTemplates,
      List<String>? reportTemplatesIds,
      List<LayrzChart>? charts,
      List<String>? chartsIds,
      List<Workspace>? workspaces,
      List<String>? workspacesIds,
      List<VisionProfile>? visionProfiles,
      List<String>? visionProfilesIds,
      List<Access>? access});

  @override
  $AvatarCopyWith<$Res>? get dynamicIcon;
}

/// @nodoc
class __$$_TagCopyWithImpl<$Res> extends _$TagCopyWithImpl<$Res, _$_Tag>
    implements _$$_TagCopyWith<$Res> {
  __$$_TagCopyWithImpl(_$_Tag _value, $Res Function(_$_Tag) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? icon = freezed,
    Object? dynamicIcon = freezed,
    Object? users = freezed,
    Object? usersIds = freezed,
    Object? outboundServices = freezed,
    Object? outboundServicesIds = freezed,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? actions = freezed,
    Object? actionsIds = freezed,
    Object? operations = freezed,
    Object? operationsIds = freezed,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? devices = freezed,
    Object? devicesIds = freezed,
    Object? geofences = freezed,
    Object? geofencesIds = freezed,
    Object? externalAccounts = freezed,
    Object? externalAccountsIds = freezed,
    Object? presets = freezed,
    Object? presetsIds = freezed,
    Object? references = freezed,
    Object? referencesIds = freezed,
    Object? checkpoints = freezed,
    Object? checkpointsIds = freezed,
    Object? careProtocols = freezed,
    Object? careProtocolsIds = freezed,
    Object? inboundServices = freezed,
    Object? inboundServicesIds = freezed,
    Object? functions = freezed,
    Object? functionsIds = freezed,
    Object? conciergeForms = freezed,
    Object? conciergeFormsIds = freezed,
    Object? reportTemplates = freezed,
    Object? reportTemplatesIds = freezed,
    Object? charts = freezed,
    Object? chartsIds = freezed,
    Object? workspaces = freezed,
    Object? workspacesIds = freezed,
    Object? visionProfiles = freezed,
    Object? visionProfilesIds = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_Tag(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      dynamicIcon: freezed == dynamicIcon
          ? _value.dynamicIcon
          : dynamicIcon // ignore: cast_nullable_to_non_nullable
              as Avatar?,
      users: freezed == users
          ? _value._users
          : users // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      usersIds: freezed == usersIds
          ? _value._usersIds
          : usersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServices: freezed == outboundServices
          ? _value._outboundServices
          : outboundServices // ignore: cast_nullable_to_non_nullable
              as List<OutboundService>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value._outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      triggers: freezed == triggers
          ? _value._triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value._triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      actions: freezed == actions
          ? _value._actions
          : actions // ignore: cast_nullable_to_non_nullable
              as List<Action>?,
      actionsIds: freezed == actionsIds
          ? _value._actionsIds
          : actionsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      operations: freezed == operations
          ? _value._operations
          : operations // ignore: cast_nullable_to_non_nullable
              as List<Operation>?,
      operationsIds: freezed == operationsIds
          ? _value._operationsIds
          : operationsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assets: freezed == assets
          ? _value._assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      devices: freezed == devices
          ? _value._devices
          : devices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
      devicesIds: freezed == devicesIds
          ? _value._devicesIds
          : devicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      geofences: freezed == geofences
          ? _value._geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      geofencesIds: freezed == geofencesIds
          ? _value._geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      externalAccounts: freezed == externalAccounts
          ? _value._externalAccounts
          : externalAccounts // ignore: cast_nullable_to_non_nullable
              as List<ExternalAccount>?,
      externalAccountsIds: freezed == externalAccountsIds
          ? _value._externalAccountsIds
          : externalAccountsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      presets: freezed == presets
          ? _value._presets
          : presets // ignore: cast_nullable_to_non_nullable
              as List<Preset>?,
      presetsIds: freezed == presetsIds
          ? _value._presetsIds
          : presetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      references: freezed == references
          ? _value._references
          : references // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      referencesIds: freezed == referencesIds
          ? _value._referencesIds
          : referencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      checkpoints: freezed == checkpoints
          ? _value._checkpoints
          : checkpoints // ignore: cast_nullable_to_non_nullable
              as List<Checkpoint>?,
      checkpointsIds: freezed == checkpointsIds
          ? _value._checkpointsIds
          : checkpointsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      careProtocols: freezed == careProtocols
          ? _value._careProtocols
          : careProtocols // ignore: cast_nullable_to_non_nullable
              as List<CareProtocol>?,
      careProtocolsIds: freezed == careProtocolsIds
          ? _value._careProtocolsIds
          : careProtocolsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      inboundServices: freezed == inboundServices
          ? _value._inboundServices
          : inboundServices // ignore: cast_nullable_to_non_nullable
              as List<InboundService>?,
      inboundServicesIds: freezed == inboundServicesIds
          ? _value._inboundServicesIds
          : inboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      functions: freezed == functions
          ? _value._functions
          : functions // ignore: cast_nullable_to_non_nullable
              as List<LayrzFunction>?,
      functionsIds: freezed == functionsIds
          ? _value._functionsIds
          : functionsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      conciergeForms: freezed == conciergeForms
          ? _value._conciergeForms
          : conciergeForms // ignore: cast_nullable_to_non_nullable
              as List<ConciergeForm>?,
      conciergeFormsIds: freezed == conciergeFormsIds
          ? _value._conciergeFormsIds
          : conciergeFormsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      reportTemplates: freezed == reportTemplates
          ? _value._reportTemplates
          : reportTemplates // ignore: cast_nullable_to_non_nullable
              as List<ReportTemplate>?,
      reportTemplatesIds: freezed == reportTemplatesIds
          ? _value._reportTemplatesIds
          : reportTemplatesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      charts: freezed == charts
          ? _value._charts
          : charts // ignore: cast_nullable_to_non_nullable
              as List<LayrzChart>?,
      chartsIds: freezed == chartsIds
          ? _value._chartsIds
          : chartsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      workspaces: freezed == workspaces
          ? _value._workspaces
          : workspaces // ignore: cast_nullable_to_non_nullable
              as List<Workspace>?,
      workspacesIds: freezed == workspacesIds
          ? _value._workspacesIds
          : workspacesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      visionProfiles: freezed == visionProfiles
          ? _value._visionProfiles
          : visionProfiles // ignore: cast_nullable_to_non_nullable
              as List<VisionProfile>?,
      visionProfilesIds: freezed == visionProfilesIds
          ? _value._visionProfilesIds
          : visionProfilesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Tag implements _Tag {
  const _$_Tag(
      {required this.id,
      required this.name,
      @ColorConverter() required this.color,
      @Deprecated('Use `dynamicIcon` instead') @IconOrNullConverter() this.icon,
      this.dynamicIcon,
      final List<User>? users,
      final List<String>? usersIds,
      final List<OutboundService>? outboundServices,
      final List<String>? outboundServicesIds,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      final List<Action>? actions,
      final List<String>? actionsIds,
      final List<Operation>? operations,
      final List<String>? operationsIds,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      final List<Device>? devices,
      final List<String>? devicesIds,
      final List<Geofence>? geofences,
      final List<String>? geofencesIds,
      final List<ExternalAccount>? externalAccounts,
      final List<String>? externalAccountsIds,
      final List<Preset>? presets,
      final List<String>? presetsIds,
      final List<Reference>? references,
      final List<String>? referencesIds,
      final List<Checkpoint>? checkpoints,
      final List<String>? checkpointsIds,
      final List<CareProtocol>? careProtocols,
      final List<String>? careProtocolsIds,
      final List<InboundService>? inboundServices,
      final List<String>? inboundServicesIds,
      final List<LayrzFunction>? functions,
      final List<String>? functionsIds,
      final List<ConciergeForm>? conciergeForms,
      final List<String>? conciergeFormsIds,
      final List<ReportTemplate>? reportTemplates,
      final List<String>? reportTemplatesIds,
      final List<LayrzChart>? charts,
      final List<String>? chartsIds,
      final List<Workspace>? workspaces,
      final List<String>? workspacesIds,
      final List<VisionProfile>? visionProfiles,
      final List<String>? visionProfilesIds,
      final List<Access>? access})
      : _users = users,
        _usersIds = usersIds,
        _outboundServices = outboundServices,
        _outboundServicesIds = outboundServicesIds,
        _triggers = triggers,
        _triggersIds = triggersIds,
        _actions = actions,
        _actionsIds = actionsIds,
        _operations = operations,
        _operationsIds = operationsIds,
        _assets = assets,
        _assetsIds = assetsIds,
        _devices = devices,
        _devicesIds = devicesIds,
        _geofences = geofences,
        _geofencesIds = geofencesIds,
        _externalAccounts = externalAccounts,
        _externalAccountsIds = externalAccountsIds,
        _presets = presets,
        _presetsIds = presetsIds,
        _references = references,
        _referencesIds = referencesIds,
        _checkpoints = checkpoints,
        _checkpointsIds = checkpointsIds,
        _careProtocols = careProtocols,
        _careProtocolsIds = careProtocolsIds,
        _inboundServices = inboundServices,
        _inboundServicesIds = inboundServicesIds,
        _functions = functions,
        _functionsIds = functionsIds,
        _conciergeForms = conciergeForms,
        _conciergeFormsIds = conciergeFormsIds,
        _reportTemplates = reportTemplates,
        _reportTemplatesIds = reportTemplatesIds,
        _charts = charts,
        _chartsIds = chartsIds,
        _workspaces = workspaces,
        _workspacesIds = workspacesIds,
        _visionProfiles = visionProfiles,
        _visionProfilesIds = visionProfilesIds,
        _access = access;

  factory _$_Tag.fromJson(Map<String, dynamic> json) => _$$_TagFromJson(json);

  /// Is the ID of the tag.
  @override
  final String id;

  /// Is the name of the tag.
  @override
  final String name;

  /// Is the color of the tag.
  @override
  @ColorConverter()
  final Color color;

  /// Is the icon of the tag.
  @override
  @Deprecated('Use `dynamicIcon` instead')
  @IconOrNullConverter()
  final IconData? icon;

  /// Dynamic icon
  @override
  final Avatar? dynamicIcon;

  /// Is a list of associated users to this module.
  final List<User>? _users;

  /// Is a list of associated users to this module.
  @override
  List<User>? get users {
    final value = _users;
    if (value == null) return null;
    if (_users is EqualUnmodifiableListView) return _users;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated users to this module.
  final List<String>? _usersIds;

  /// Is a list of ID's of associated users to this module.
  @override
  List<String>? get usersIds {
    final value = _usersIds;
    if (value == null) return null;
    if (_usersIds is EqualUnmodifiableListView) return _usersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated outbound services to this module.
  final List<OutboundService>? _outboundServices;

  /// Is a list of associated outbound services to this module.
  @override
  List<OutboundService>? get outboundServices {
    final value = _outboundServices;
    if (value == null) return null;
    if (_outboundServices is EqualUnmodifiableListView)
      return _outboundServices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated outbound services to this module.
  final List<String>? _outboundServicesIds;

  /// Is a list of ID's of associated outbound services to this module.
  @override
  List<String>? get outboundServicesIds {
    final value = _outboundServicesIds;
    if (value == null) return null;
    if (_outboundServicesIds is EqualUnmodifiableListView)
      return _outboundServicesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated triggers to this module.
  final List<Trigger>? _triggers;

  /// Is a list of associated triggers to this module.
  @override
  List<Trigger>? get triggers {
    final value = _triggers;
    if (value == null) return null;
    if (_triggers is EqualUnmodifiableListView) return _triggers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated triggers to this module.
  final List<String>? _triggersIds;

  /// Is a list of ID's of associated triggers to this module.
  @override
  List<String>? get triggersIds {
    final value = _triggersIds;
    if (value == null) return null;
    if (_triggersIds is EqualUnmodifiableListView) return _triggersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated actions to this module.
  final List<Action>? _actions;

  /// Is a list of associated actions to this module.
  @override
  List<Action>? get actions {
    final value = _actions;
    if (value == null) return null;
    if (_actions is EqualUnmodifiableListView) return _actions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated actions to this module.
  final List<String>? _actionsIds;

  /// Is a list of ID's of associated actions to this module.
  @override
  List<String>? get actionsIds {
    final value = _actionsIds;
    if (value == null) return null;
    if (_actionsIds is EqualUnmodifiableListView) return _actionsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated operations to this module.
  final List<Operation>? _operations;

  /// Is a list of associated operations to this module.
  @override
  List<Operation>? get operations {
    final value = _operations;
    if (value == null) return null;
    if (_operations is EqualUnmodifiableListView) return _operations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated operations to this module.
  final List<String>? _operationsIds;

  /// Is a list of ID's of associated operations to this module.
  @override
  List<String>? get operationsIds {
    final value = _operationsIds;
    if (value == null) return null;
    if (_operationsIds is EqualUnmodifiableListView) return _operationsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated assets to this module.
  final List<Asset>? _assets;

  /// Is a list of associated assets to this module.
  @override
  List<Asset>? get assets {
    final value = _assets;
    if (value == null) return null;
    if (_assets is EqualUnmodifiableListView) return _assets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated assets to this module.
  final List<String>? _assetsIds;

  /// Is a list of ID's of associated assets to this module.
  @override
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated devices to this module.
  final List<Device>? _devices;

  /// Is a list of associated devices to this module.
  @override
  List<Device>? get devices {
    final value = _devices;
    if (value == null) return null;
    if (_devices is EqualUnmodifiableListView) return _devices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated devices to this module.
  final List<String>? _devicesIds;

  /// Is a list of ID's of associated devices to this module.
  @override
  List<String>? get devicesIds {
    final value = _devicesIds;
    if (value == null) return null;
    if (_devicesIds is EqualUnmodifiableListView) return _devicesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated geofences to this module.
  final List<Geofence>? _geofences;

  /// Is a list of associated geofences to this module.
  @override
  List<Geofence>? get geofences {
    final value = _geofences;
    if (value == null) return null;
    if (_geofences is EqualUnmodifiableListView) return _geofences;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated geofences to this module.
  final List<String>? _geofencesIds;

  /// Is a list of ID's of associated geofences to this module.
  @override
  List<String>? get geofencesIds {
    final value = _geofencesIds;
    if (value == null) return null;
    if (_geofencesIds is EqualUnmodifiableListView) return _geofencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated source accounts to this module.
  final List<ExternalAccount>? _externalAccounts;

  /// Is a list of associated source accounts to this module.
  @override
  List<ExternalAccount>? get externalAccounts {
    final value = _externalAccounts;
    if (value == null) return null;
    if (_externalAccounts is EqualUnmodifiableListView)
      return _externalAccounts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated source accounts to this module.
  final List<String>? _externalAccountsIds;

  /// Is a list of ID's of associated source accounts to this module.
  @override
  List<String>? get externalAccountsIds {
    final value = _externalAccountsIds;
    if (value == null) return null;
    if (_externalAccountsIds is EqualUnmodifiableListView)
      return _externalAccountsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated presets to this module.
  final List<Preset>? _presets;

  /// Is a list of associated presets to this module.
  @override
  List<Preset>? get presets {
    final value = _presets;
    if (value == null) return null;
    if (_presets is EqualUnmodifiableListView) return _presets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated presets to this module.
  final List<String>? _presetsIds;

  /// Is a list of ID's of associated presets to this module.
  @override
  List<String>? get presetsIds {
    final value = _presetsIds;
    if (value == null) return null;
    if (_presetsIds is EqualUnmodifiableListView) return _presetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated references to this module.
  final List<Reference>? _references;

  /// Is a list of associated references to this module.
  @override
  List<Reference>? get references {
    final value = _references;
    if (value == null) return null;
    if (_references is EqualUnmodifiableListView) return _references;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated references to this module.
  final List<String>? _referencesIds;

  /// Is a list of ID's of associated references to this module.
  @override
  List<String>? get referencesIds {
    final value = _referencesIds;
    if (value == null) return null;
    if (_referencesIds is EqualUnmodifiableListView) return _referencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated checkpoints to this module.
  final List<Checkpoint>? _checkpoints;

  /// Is a list of associated checkpoints to this module.
  @override
  List<Checkpoint>? get checkpoints {
    final value = _checkpoints;
    if (value == null) return null;
    if (_checkpoints is EqualUnmodifiableListView) return _checkpoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated checkpoints to this module.
  final List<String>? _checkpointsIds;

  /// Is a list of ID's of associated checkpoints to this module.
  @override
  List<String>? get checkpointsIds {
    final value = _checkpointsIds;
    if (value == null) return null;
    if (_checkpointsIds is EqualUnmodifiableListView) return _checkpointsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated care protocols to this module.
  final List<CareProtocol>? _careProtocols;

  /// Is a list of associated care protocols to this module.
  @override
  List<CareProtocol>? get careProtocols {
    final value = _careProtocols;
    if (value == null) return null;
    if (_careProtocols is EqualUnmodifiableListView) return _careProtocols;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated care protocols to this module.
  final List<String>? _careProtocolsIds;

  /// Is a list of ID's of associated care protocols to this module.
  @override
  List<String>? get careProtocolsIds {
    final value = _careProtocolsIds;
    if (value == null) return null;
    if (_careProtocolsIds is EqualUnmodifiableListView)
      return _careProtocolsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated inbound services to this module.
  final List<InboundService>? _inboundServices;

  /// Is a list of associated inbound services to this module.
  @override
  List<InboundService>? get inboundServices {
    final value = _inboundServices;
    if (value == null) return null;
    if (_inboundServices is EqualUnmodifiableListView) return _inboundServices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated inbound services to this module.
  final List<String>? _inboundServicesIds;

  /// Is a list of ID's of associated inbound services to this module.
  @override
  List<String>? get inboundServicesIds {
    final value = _inboundServicesIds;
    if (value == null) return null;
    if (_inboundServicesIds is EqualUnmodifiableListView)
      return _inboundServicesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated functions to this module.
  final List<LayrzFunction>? _functions;

  /// Is a list of associated functions to this module.
  @override
  List<LayrzFunction>? get functions {
    final value = _functions;
    if (value == null) return null;
    if (_functions is EqualUnmodifiableListView) return _functions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated functions to this module.
  final List<String>? _functionsIds;

  /// Is a list of ID's of associated functions to this module.
  @override
  List<String>? get functionsIds {
    final value = _functionsIds;
    if (value == null) return null;
    if (_functionsIds is EqualUnmodifiableListView) return _functionsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated concierge forms to this module.
  final List<ConciergeForm>? _conciergeForms;

  /// Is a list of associated concierge forms to this module.
  @override
  List<ConciergeForm>? get conciergeForms {
    final value = _conciergeForms;
    if (value == null) return null;
    if (_conciergeForms is EqualUnmodifiableListView) return _conciergeForms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated concierge forms to this module.
  final List<String>? _conciergeFormsIds;

  /// Is a list of ID's of associated concierge forms to this module.
  @override
  List<String>? get conciergeFormsIds {
    final value = _conciergeFormsIds;
    if (value == null) return null;
    if (_conciergeFormsIds is EqualUnmodifiableListView)
      return _conciergeFormsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated report templates to this module.
  final List<ReportTemplate>? _reportTemplates;

  /// Is a list of associated report templates to this module.
  @override
  List<ReportTemplate>? get reportTemplates {
    final value = _reportTemplates;
    if (value == null) return null;
    if (_reportTemplates is EqualUnmodifiableListView) return _reportTemplates;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated report templates to this module.
  final List<String>? _reportTemplatesIds;

  /// Is a list of ID's of associated report templates to this module.
  @override
  List<String>? get reportTemplatesIds {
    final value = _reportTemplatesIds;
    if (value == null) return null;
    if (_reportTemplatesIds is EqualUnmodifiableListView)
      return _reportTemplatesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated charts to this module.
  final List<LayrzChart>? _charts;

  /// Is a list of associated charts to this module.
  @override
  List<LayrzChart>? get charts {
    final value = _charts;
    if (value == null) return null;
    if (_charts is EqualUnmodifiableListView) return _charts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated charts to this module.
  final List<String>? _chartsIds;

  /// Is a list of ID's of associated charts to this module.
  @override
  List<String>? get chartsIds {
    final value = _chartsIds;
    if (value == null) return null;
    if (_chartsIds is EqualUnmodifiableListView) return _chartsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated workspaces to this module.
  final List<Workspace>? _workspaces;

  /// Is a list of associated workspaces to this module.
  @override
  List<Workspace>? get workspaces {
    final value = _workspaces;
    if (value == null) return null;
    if (_workspaces is EqualUnmodifiableListView) return _workspaces;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated workspaces to this module.
  final List<String>? _workspacesIds;

  /// Is a list of ID's of associated workspaces to this module.
  @override
  List<String>? get workspacesIds {
    final value = _workspacesIds;
    if (value == null) return null;
    if (_workspacesIds is EqualUnmodifiableListView) return _workspacesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of associated vision profiles to this module.
  final List<VisionProfile>? _visionProfiles;

  /// Is a list of associated vision profiles to this module.
  @override
  List<VisionProfile>? get visionProfiles {
    final value = _visionProfiles;
    if (value == null) return null;
    if (_visionProfiles is EqualUnmodifiableListView) return _visionProfiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of ID's of associated vision profiles to this module.
  final List<String>? _visionProfilesIds;

  /// Is a list of ID's of associated vision profiles to this module.
  @override
  List<String>? get visionProfilesIds {
    final value = _visionProfilesIds;
    if (value == null) return null;
    if (_visionProfilesIds is EqualUnmodifiableListView)
      return _visionProfilesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of granted access to this entity.
  final List<Access>? _access;

  /// Is a list of granted access to this entity.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Tag(id: $id, name: $name, color: $color, icon: $icon, dynamicIcon: $dynamicIcon, users: $users, usersIds: $usersIds, outboundServices: $outboundServices, outboundServicesIds: $outboundServicesIds, triggers: $triggers, triggersIds: $triggersIds, actions: $actions, actionsIds: $actionsIds, operations: $operations, operationsIds: $operationsIds, assets: $assets, assetsIds: $assetsIds, devices: $devices, devicesIds: $devicesIds, geofences: $geofences, geofencesIds: $geofencesIds, externalAccounts: $externalAccounts, externalAccountsIds: $externalAccountsIds, presets: $presets, presetsIds: $presetsIds, references: $references, referencesIds: $referencesIds, checkpoints: $checkpoints, checkpointsIds: $checkpointsIds, careProtocols: $careProtocols, careProtocolsIds: $careProtocolsIds, inboundServices: $inboundServices, inboundServicesIds: $inboundServicesIds, functions: $functions, functionsIds: $functionsIds, conciergeForms: $conciergeForms, conciergeFormsIds: $conciergeFormsIds, reportTemplates: $reportTemplates, reportTemplatesIds: $reportTemplatesIds, charts: $charts, chartsIds: $chartsIds, workspaces: $workspaces, workspacesIds: $workspacesIds, visionProfiles: $visionProfiles, visionProfilesIds: $visionProfilesIds, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Tag &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.icon, icon) || other.icon == icon) &&
            (identical(other.dynamicIcon, dynamicIcon) ||
                other.dynamicIcon == dynamicIcon) &&
            const DeepCollectionEquality().equals(other._users, _users) &&
            const DeepCollectionEquality().equals(other._usersIds, _usersIds) &&
            const DeepCollectionEquality()
                .equals(other._outboundServices, _outboundServices) &&
            const DeepCollectionEquality()
                .equals(other._outboundServicesIds, _outboundServicesIds) &&
            const DeepCollectionEquality().equals(other._triggers, _triggers) &&
            const DeepCollectionEquality()
                .equals(other._triggersIds, _triggersIds) &&
            const DeepCollectionEquality().equals(other._actions, _actions) &&
            const DeepCollectionEquality()
                .equals(other._actionsIds, _actionsIds) &&
            const DeepCollectionEquality()
                .equals(other._operations, _operations) &&
            const DeepCollectionEquality()
                .equals(other._operationsIds, _operationsIds) &&
            const DeepCollectionEquality().equals(other._assets, _assets) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds) &&
            const DeepCollectionEquality().equals(other._devices, _devices) &&
            const DeepCollectionEquality()
                .equals(other._devicesIds, _devicesIds) &&
            const DeepCollectionEquality()
                .equals(other._geofences, _geofences) &&
            const DeepCollectionEquality()
                .equals(other._geofencesIds, _geofencesIds) &&
            const DeepCollectionEquality()
                .equals(other._externalAccounts, _externalAccounts) &&
            const DeepCollectionEquality()
                .equals(other._externalAccountsIds, _externalAccountsIds) &&
            const DeepCollectionEquality().equals(other._presets, _presets) &&
            const DeepCollectionEquality()
                .equals(other._presetsIds, _presetsIds) &&
            const DeepCollectionEquality()
                .equals(other._references, _references) &&
            const DeepCollectionEquality()
                .equals(other._referencesIds, _referencesIds) &&
            const DeepCollectionEquality()
                .equals(other._checkpoints, _checkpoints) &&
            const DeepCollectionEquality()
                .equals(other._checkpointsIds, _checkpointsIds) &&
            const DeepCollectionEquality()
                .equals(other._careProtocols, _careProtocols) &&
            const DeepCollectionEquality()
                .equals(other._careProtocolsIds, _careProtocolsIds) &&
            const DeepCollectionEquality()
                .equals(other._inboundServices, _inboundServices) &&
            const DeepCollectionEquality()
                .equals(other._inboundServicesIds, _inboundServicesIds) &&
            const DeepCollectionEquality()
                .equals(other._functions, _functions) &&
            const DeepCollectionEquality()
                .equals(other._functionsIds, _functionsIds) &&
            const DeepCollectionEquality()
                .equals(other._conciergeForms, _conciergeForms) &&
            const DeepCollectionEquality()
                .equals(other._conciergeFormsIds, _conciergeFormsIds) &&
            const DeepCollectionEquality()
                .equals(other._reportTemplates, _reportTemplates) &&
            const DeepCollectionEquality()
                .equals(other._reportTemplatesIds, _reportTemplatesIds) &&
            const DeepCollectionEquality().equals(other._charts, _charts) &&
            const DeepCollectionEquality()
                .equals(other._chartsIds, _chartsIds) &&
            const DeepCollectionEquality()
                .equals(other._workspaces, _workspaces) &&
            const DeepCollectionEquality()
                .equals(other._workspacesIds, _workspacesIds) &&
            const DeepCollectionEquality()
                .equals(other._visionProfiles, _visionProfiles) &&
            const DeepCollectionEquality()
                .equals(other._visionProfilesIds, _visionProfilesIds) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        color,
        icon,
        dynamicIcon,
        const DeepCollectionEquality().hash(_users),
        const DeepCollectionEquality().hash(_usersIds),
        const DeepCollectionEquality().hash(_outboundServices),
        const DeepCollectionEquality().hash(_outboundServicesIds),
        const DeepCollectionEquality().hash(_triggers),
        const DeepCollectionEquality().hash(_triggersIds),
        const DeepCollectionEquality().hash(_actions),
        const DeepCollectionEquality().hash(_actionsIds),
        const DeepCollectionEquality().hash(_operations),
        const DeepCollectionEquality().hash(_operationsIds),
        const DeepCollectionEquality().hash(_assets),
        const DeepCollectionEquality().hash(_assetsIds),
        const DeepCollectionEquality().hash(_devices),
        const DeepCollectionEquality().hash(_devicesIds),
        const DeepCollectionEquality().hash(_geofences),
        const DeepCollectionEquality().hash(_geofencesIds),
        const DeepCollectionEquality().hash(_externalAccounts),
        const DeepCollectionEquality().hash(_externalAccountsIds),
        const DeepCollectionEquality().hash(_presets),
        const DeepCollectionEquality().hash(_presetsIds),
        const DeepCollectionEquality().hash(_references),
        const DeepCollectionEquality().hash(_referencesIds),
        const DeepCollectionEquality().hash(_checkpoints),
        const DeepCollectionEquality().hash(_checkpointsIds),
        const DeepCollectionEquality().hash(_careProtocols),
        const DeepCollectionEquality().hash(_careProtocolsIds),
        const DeepCollectionEquality().hash(_inboundServices),
        const DeepCollectionEquality().hash(_inboundServicesIds),
        const DeepCollectionEquality().hash(_functions),
        const DeepCollectionEquality().hash(_functionsIds),
        const DeepCollectionEquality().hash(_conciergeForms),
        const DeepCollectionEquality().hash(_conciergeFormsIds),
        const DeepCollectionEquality().hash(_reportTemplates),
        const DeepCollectionEquality().hash(_reportTemplatesIds),
        const DeepCollectionEquality().hash(_charts),
        const DeepCollectionEquality().hash(_chartsIds),
        const DeepCollectionEquality().hash(_workspaces),
        const DeepCollectionEquality().hash(_workspacesIds),
        const DeepCollectionEquality().hash(_visionProfiles),
        const DeepCollectionEquality().hash(_visionProfilesIds),
        const DeepCollectionEquality().hash(_access)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TagCopyWith<_$_Tag> get copyWith =>
      __$$_TagCopyWithImpl<_$_Tag>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TagToJson(
      this,
    );
  }
}

abstract class _Tag implements Tag {
  const factory _Tag(
      {required final String id,
      required final String name,
      @ColorConverter() required final Color color,
      @Deprecated('Use `dynamicIcon` instead')
      @IconOrNullConverter()
      final IconData? icon,
      final Avatar? dynamicIcon,
      final List<User>? users,
      final List<String>? usersIds,
      final List<OutboundService>? outboundServices,
      final List<String>? outboundServicesIds,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      final List<Action>? actions,
      final List<String>? actionsIds,
      final List<Operation>? operations,
      final List<String>? operationsIds,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      final List<Device>? devices,
      final List<String>? devicesIds,
      final List<Geofence>? geofences,
      final List<String>? geofencesIds,
      final List<ExternalAccount>? externalAccounts,
      final List<String>? externalAccountsIds,
      final List<Preset>? presets,
      final List<String>? presetsIds,
      final List<Reference>? references,
      final List<String>? referencesIds,
      final List<Checkpoint>? checkpoints,
      final List<String>? checkpointsIds,
      final List<CareProtocol>? careProtocols,
      final List<String>? careProtocolsIds,
      final List<InboundService>? inboundServices,
      final List<String>? inboundServicesIds,
      final List<LayrzFunction>? functions,
      final List<String>? functionsIds,
      final List<ConciergeForm>? conciergeForms,
      final List<String>? conciergeFormsIds,
      final List<ReportTemplate>? reportTemplates,
      final List<String>? reportTemplatesIds,
      final List<LayrzChart>? charts,
      final List<String>? chartsIds,
      final List<Workspace>? workspaces,
      final List<String>? workspacesIds,
      final List<VisionProfile>? visionProfiles,
      final List<String>? visionProfilesIds,
      final List<Access>? access}) = _$_Tag;

  factory _Tag.fromJson(Map<String, dynamic> json) = _$_Tag.fromJson;

  @override

  /// Is the ID of the tag.
  String get id;
  @override

  /// Is the name of the tag.
  String get name;
  @override

  /// Is the color of the tag.
  @ColorConverter()
  Color get color;
  @override

  /// Is the icon of the tag.
  @Deprecated('Use `dynamicIcon` instead')
  @IconOrNullConverter()
  IconData? get icon;
  @override

  /// Dynamic icon
  Avatar? get dynamicIcon;
  @override

  /// Is a list of associated users to this module.
  List<User>? get users;
  @override

  /// Is a list of ID's of associated users to this module.
  List<String>? get usersIds;
  @override

  /// Is a list of associated outbound services to this module.
  List<OutboundService>? get outboundServices;
  @override

  /// Is a list of ID's of associated outbound services to this module.
  List<String>? get outboundServicesIds;
  @override

  /// Is a list of associated triggers to this module.
  List<Trigger>? get triggers;
  @override

  /// Is a list of ID's of associated triggers to this module.
  List<String>? get triggersIds;
  @override

  /// Is a list of associated actions to this module.
  List<Action>? get actions;
  @override

  /// Is a list of ID's of associated actions to this module.
  List<String>? get actionsIds;
  @override

  /// Is a list of associated operations to this module.
  List<Operation>? get operations;
  @override

  /// Is a list of ID's of associated operations to this module.
  List<String>? get operationsIds;
  @override

  /// Is a list of associated assets to this module.
  List<Asset>? get assets;
  @override

  /// Is a list of ID's of associated assets to this module.
  List<String>? get assetsIds;
  @override

  /// Is a list of associated devices to this module.
  List<Device>? get devices;
  @override

  /// Is a list of ID's of associated devices to this module.
  List<String>? get devicesIds;
  @override

  /// Is a list of associated geofences to this module.
  List<Geofence>? get geofences;
  @override

  /// Is a list of ID's of associated geofences to this module.
  List<String>? get geofencesIds;
  @override

  /// Is a list of associated source accounts to this module.
  List<ExternalAccount>? get externalAccounts;
  @override

  /// Is a list of ID's of associated source accounts to this module.
  List<String>? get externalAccountsIds;
  @override

  /// Is a list of associated presets to this module.
  List<Preset>? get presets;
  @override

  /// Is a list of ID's of associated presets to this module.
  List<String>? get presetsIds;
  @override

  /// Is a list of associated references to this module.
  List<Reference>? get references;
  @override

  /// Is a list of ID's of associated references to this module.
  List<String>? get referencesIds;
  @override

  /// Is a list of associated checkpoints to this module.
  List<Checkpoint>? get checkpoints;
  @override

  /// Is a list of ID's of associated checkpoints to this module.
  List<String>? get checkpointsIds;
  @override

  /// Is a list of associated care protocols to this module.
  List<CareProtocol>? get careProtocols;
  @override

  /// Is a list of ID's of associated care protocols to this module.
  List<String>? get careProtocolsIds;
  @override

  /// Is a list of associated inbound services to this module.
  List<InboundService>? get inboundServices;
  @override

  /// Is a list of ID's of associated inbound services to this module.
  List<String>? get inboundServicesIds;
  @override

  /// Is a list of associated functions to this module.
  List<LayrzFunction>? get functions;
  @override

  /// Is a list of ID's of associated functions to this module.
  List<String>? get functionsIds;
  @override

  /// Is a list of associated concierge forms to this module.
  List<ConciergeForm>? get conciergeForms;
  @override

  /// Is a list of ID's of associated concierge forms to this module.
  List<String>? get conciergeFormsIds;
  @override

  /// Is a list of associated report templates to this module.
  List<ReportTemplate>? get reportTemplates;
  @override

  /// Is a list of ID's of associated report templates to this module.
  List<String>? get reportTemplatesIds;
  @override

  /// Is a list of associated charts to this module.
  List<LayrzChart>? get charts;
  @override

  /// Is a list of ID's of associated charts to this module.
  List<String>? get chartsIds;
  @override

  /// Is a list of associated workspaces to this module.
  List<Workspace>? get workspaces;
  @override

  /// Is a list of ID's of associated workspaces to this module.
  List<String>? get workspacesIds;
  @override

  /// Is a list of associated vision profiles to this module.
  List<VisionProfile>? get visionProfiles;
  @override

  /// Is a list of ID's of associated vision profiles to this module.
  List<String>? get visionProfilesIds;
  @override

  /// Is a list of granted access to this entity.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_TagCopyWith<_$_Tag> get copyWith => throw _privateConstructorUsedError;
}

User _$UserFromJson(Map<String, dynamic> json) {
  return _User.fromJson(json);
}

/// @nodoc
mixin _$User {
  /// [id] represents the user ID.
  String get id => throw _privateConstructorUsedError;

  /// [name] represents the user name.
  String get name => throw _privateConstructorUsedError;

  /// [token] represents the user token.
  Token? get token => throw _privateConstructorUsedError;

  /// [parentId] represents the parent ID.
  String? get parentId => throw _privateConstructorUsedError;

  /// [email] represents the user email.
  String? get email => throw _privateConstructorUsedError;

  /// [username] represents the username.
  String? get username => throw _privateConstructorUsedError;

  /// [dynamicAvatar] represents the user avatar.
  Avatar? get dynamicAvatar => throw _privateConstructorUsedError;

  /// [referencesIds] represents the list of references IDs.
  List<String>? get referencesIds => throw _privateConstructorUsedError;

  /// [references] represents the list of references.
  List<Reference>? get references => throw _privateConstructorUsedError;

  /// [category] represents the user category.
  Category? get category => throw _privateConstructorUsedError;

  /// [categoryId] represents the user category ID.
  String? get categoryId => throw _privateConstructorUsedError;

  /// [mqttToken] represents the MQTT token.
  String? get mqttToken => throw _privateConstructorUsedError;

  /// [access] represents the list of granted access.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// [customFields] represents the list of custom fields.
  List<CustomField>? get customFields => throw _privateConstructorUsedError;

  /// [platformAuth] represents the platform auth.
  String get platformAuth => throw _privateConstructorUsedError;

  /// [profile] represents the user profile.
  Profile? get profile => throw _privateConstructorUsedError;

  /// [childs] represents the list of childs.
  List<User> get childs => throw _privateConstructorUsedError;

  /// [tagsIds] represents the list of tags IDs.
  List<String>? get tagsIds => throw _privateConstructorUsedError;

  /// [tags] represents the list of tags.
  List<Tag>? get tags => throw _privateConstructorUsedError;

  /// [planId] represents the plan ID.
  String? get planId => throw _privateConstructorUsedError;

  /// [configuration] represents the configuration.
  @EnvironmentOrNullConverter()
  Environment? get configuration => throw _privateConstructorUsedError;

  /// [allowedApps] represents the list of allowed apps.
  List<RegisteredApp>? get allowedApps => throw _privateConstructorUsedError;

  /// [mappitAssetsIds] represents the list of assets IDs.
  /// This field is only for `Mappit` use.
  List<String>? get mappitAssetsIds => throw _privateConstructorUsedError;

  /// [mappitAssets] represents the list of assets.
  /// This field is only for `Mappit` use.
  List<Asset>? get mappitAssets => throw _privateConstructorUsedError;

  /// [historicalDaysAllowed] represents the number of days allowed to access historical data.
  /// This field is only for `Mappit` use.
  int? get historicalDaysAllowed => throw _privateConstructorUsedError;

  /// [mappitExternalAccountId] represents the Mappit external account ID.
  /// This field is only for `Mappit` use.
  String? get mappitExternalAccountId => throw _privateConstructorUsedError;

  /// [mappitExternalAccount] represents the Mappit external account.
  /// This field is only for `Mappit` use.
  ExternalAccount? get mappitExternalAccount =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $UserCopyWith<User> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserCopyWith<$Res> {
  factory $UserCopyWith(User value, $Res Function(User) then) =
      _$UserCopyWithImpl<$Res, User>;
  @useResult
  $Res call(
      {String id,
      String name,
      Token? token,
      String? parentId,
      String? email,
      String? username,
      Avatar? dynamicAvatar,
      List<String>? referencesIds,
      List<Reference>? references,
      Category? category,
      String? categoryId,
      String? mqttToken,
      List<Access>? access,
      List<CustomField>? customFields,
      String platformAuth,
      Profile? profile,
      List<User> childs,
      List<String>? tagsIds,
      List<Tag>? tags,
      String? planId,
      @EnvironmentOrNullConverter() Environment? configuration,
      List<RegisteredApp>? allowedApps,
      List<String>? mappitAssetsIds,
      List<Asset>? mappitAssets,
      int? historicalDaysAllowed,
      String? mappitExternalAccountId,
      ExternalAccount? mappitExternalAccount});

  $TokenCopyWith<$Res>? get token;
  $AvatarCopyWith<$Res>? get dynamicAvatar;
  $CategoryCopyWith<$Res>? get category;
  $ProfileCopyWith<$Res>? get profile;
  $ExternalAccountCopyWith<$Res>? get mappitExternalAccount;
}

/// @nodoc
class _$UserCopyWithImpl<$Res, $Val extends User>
    implements $UserCopyWith<$Res> {
  _$UserCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? token = freezed,
    Object? parentId = freezed,
    Object? email = freezed,
    Object? username = freezed,
    Object? dynamicAvatar = freezed,
    Object? referencesIds = freezed,
    Object? references = freezed,
    Object? category = freezed,
    Object? categoryId = freezed,
    Object? mqttToken = freezed,
    Object? access = freezed,
    Object? customFields = freezed,
    Object? platformAuth = null,
    Object? profile = freezed,
    Object? childs = null,
    Object? tagsIds = freezed,
    Object? tags = freezed,
    Object? planId = freezed,
    Object? configuration = freezed,
    Object? allowedApps = freezed,
    Object? mappitAssetsIds = freezed,
    Object? mappitAssets = freezed,
    Object? historicalDaysAllowed = freezed,
    Object? mappitExternalAccountId = freezed,
    Object? mappitExternalAccount = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as Token?,
      parentId: freezed == parentId
          ? _value.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicAvatar: freezed == dynamicAvatar
          ? _value.dynamicAvatar
          : dynamicAvatar // ignore: cast_nullable_to_non_nullable
              as Avatar?,
      referencesIds: freezed == referencesIds
          ? _value.referencesIds
          : referencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      references: freezed == references
          ? _value.references
          : references // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as Category?,
      categoryId: freezed == categoryId
          ? _value.categoryId
          : categoryId // ignore: cast_nullable_to_non_nullable
              as String?,
      mqttToken: freezed == mqttToken
          ? _value.mqttToken
          : mqttToken // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      customFields: freezed == customFields
          ? _value.customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
      platformAuth: null == platformAuth
          ? _value.platformAuth
          : platformAuth // ignore: cast_nullable_to_non_nullable
              as String,
      profile: freezed == profile
          ? _value.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as Profile?,
      childs: null == childs
          ? _value.childs
          : childs // ignore: cast_nullable_to_non_nullable
              as List<User>,
      tagsIds: freezed == tagsIds
          ? _value.tagsIds
          : tagsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      planId: freezed == planId
          ? _value.planId
          : planId // ignore: cast_nullable_to_non_nullable
              as String?,
      configuration: freezed == configuration
          ? _value.configuration
          : configuration // ignore: cast_nullable_to_non_nullable
              as Environment?,
      allowedApps: freezed == allowedApps
          ? _value.allowedApps
          : allowedApps // ignore: cast_nullable_to_non_nullable
              as List<RegisteredApp>?,
      mappitAssetsIds: freezed == mappitAssetsIds
          ? _value.mappitAssetsIds
          : mappitAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      mappitAssets: freezed == mappitAssets
          ? _value.mappitAssets
          : mappitAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      historicalDaysAllowed: freezed == historicalDaysAllowed
          ? _value.historicalDaysAllowed
          : historicalDaysAllowed // ignore: cast_nullable_to_non_nullable
              as int?,
      mappitExternalAccountId: freezed == mappitExternalAccountId
          ? _value.mappitExternalAccountId
          : mappitExternalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      mappitExternalAccount: freezed == mappitExternalAccount
          ? _value.mappitExternalAccount
          : mappitExternalAccount // ignore: cast_nullable_to_non_nullable
              as ExternalAccount?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TokenCopyWith<$Res>? get token {
    if (_value.token == null) {
      return null;
    }

    return $TokenCopyWith<$Res>(_value.token!, (value) {
      return _then(_value.copyWith(token: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AvatarCopyWith<$Res>? get dynamicAvatar {
    if (_value.dynamicAvatar == null) {
      return null;
    }

    return $AvatarCopyWith<$Res>(_value.dynamicAvatar!, (value) {
      return _then(_value.copyWith(dynamicAvatar: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CategoryCopyWith<$Res>? get category {
    if (_value.category == null) {
      return null;
    }

    return $CategoryCopyWith<$Res>(_value.category!, (value) {
      return _then(_value.copyWith(category: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ProfileCopyWith<$Res>? get profile {
    if (_value.profile == null) {
      return null;
    }

    return $ProfileCopyWith<$Res>(_value.profile!, (value) {
      return _then(_value.copyWith(profile: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExternalAccountCopyWith<$Res>? get mappitExternalAccount {
    if (_value.mappitExternalAccount == null) {
      return null;
    }

    return $ExternalAccountCopyWith<$Res>(_value.mappitExternalAccount!,
        (value) {
      return _then(_value.copyWith(mappitExternalAccount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_UserCopyWith<$Res> implements $UserCopyWith<$Res> {
  factory _$$_UserCopyWith(_$_User value, $Res Function(_$_User) then) =
      __$$_UserCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      Token? token,
      String? parentId,
      String? email,
      String? username,
      Avatar? dynamicAvatar,
      List<String>? referencesIds,
      List<Reference>? references,
      Category? category,
      String? categoryId,
      String? mqttToken,
      List<Access>? access,
      List<CustomField>? customFields,
      String platformAuth,
      Profile? profile,
      List<User> childs,
      List<String>? tagsIds,
      List<Tag>? tags,
      String? planId,
      @EnvironmentOrNullConverter() Environment? configuration,
      List<RegisteredApp>? allowedApps,
      List<String>? mappitAssetsIds,
      List<Asset>? mappitAssets,
      int? historicalDaysAllowed,
      String? mappitExternalAccountId,
      ExternalAccount? mappitExternalAccount});

  @override
  $TokenCopyWith<$Res>? get token;
  @override
  $AvatarCopyWith<$Res>? get dynamicAvatar;
  @override
  $CategoryCopyWith<$Res>? get category;
  @override
  $ProfileCopyWith<$Res>? get profile;
  @override
  $ExternalAccountCopyWith<$Res>? get mappitExternalAccount;
}

/// @nodoc
class __$$_UserCopyWithImpl<$Res> extends _$UserCopyWithImpl<$Res, _$_User>
    implements _$$_UserCopyWith<$Res> {
  __$$_UserCopyWithImpl(_$_User _value, $Res Function(_$_User) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? token = freezed,
    Object? parentId = freezed,
    Object? email = freezed,
    Object? username = freezed,
    Object? dynamicAvatar = freezed,
    Object? referencesIds = freezed,
    Object? references = freezed,
    Object? category = freezed,
    Object? categoryId = freezed,
    Object? mqttToken = freezed,
    Object? access = freezed,
    Object? customFields = freezed,
    Object? platformAuth = null,
    Object? profile = freezed,
    Object? childs = null,
    Object? tagsIds = freezed,
    Object? tags = freezed,
    Object? planId = freezed,
    Object? configuration = freezed,
    Object? allowedApps = freezed,
    Object? mappitAssetsIds = freezed,
    Object? mappitAssets = freezed,
    Object? historicalDaysAllowed = freezed,
    Object? mappitExternalAccountId = freezed,
    Object? mappitExternalAccount = freezed,
  }) {
    return _then(_$_User(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as Token?,
      parentId: freezed == parentId
          ? _value.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicAvatar: freezed == dynamicAvatar
          ? _value.dynamicAvatar
          : dynamicAvatar // ignore: cast_nullable_to_non_nullable
              as Avatar?,
      referencesIds: freezed == referencesIds
          ? _value._referencesIds
          : referencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      references: freezed == references
          ? _value._references
          : references // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as Category?,
      categoryId: freezed == categoryId
          ? _value.categoryId
          : categoryId // ignore: cast_nullable_to_non_nullable
              as String?,
      mqttToken: freezed == mqttToken
          ? _value.mqttToken
          : mqttToken // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      customFields: freezed == customFields
          ? _value._customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
      platformAuth: null == platformAuth
          ? _value.platformAuth
          : platformAuth // ignore: cast_nullable_to_non_nullable
              as String,
      profile: freezed == profile
          ? _value.profile
          : profile // ignore: cast_nullable_to_non_nullable
              as Profile?,
      childs: null == childs
          ? _value._childs
          : childs // ignore: cast_nullable_to_non_nullable
              as List<User>,
      tagsIds: freezed == tagsIds
          ? _value._tagsIds
          : tagsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      planId: freezed == planId
          ? _value.planId
          : planId // ignore: cast_nullable_to_non_nullable
              as String?,
      configuration: freezed == configuration
          ? _value.configuration
          : configuration // ignore: cast_nullable_to_non_nullable
              as Environment?,
      allowedApps: freezed == allowedApps
          ? _value._allowedApps
          : allowedApps // ignore: cast_nullable_to_non_nullable
              as List<RegisteredApp>?,
      mappitAssetsIds: freezed == mappitAssetsIds
          ? _value._mappitAssetsIds
          : mappitAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      mappitAssets: freezed == mappitAssets
          ? _value._mappitAssets
          : mappitAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      historicalDaysAllowed: freezed == historicalDaysAllowed
          ? _value.historicalDaysAllowed
          : historicalDaysAllowed // ignore: cast_nullable_to_non_nullable
              as int?,
      mappitExternalAccountId: freezed == mappitExternalAccountId
          ? _value.mappitExternalAccountId
          : mappitExternalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      mappitExternalAccount: freezed == mappitExternalAccount
          ? _value.mappitExternalAccount
          : mappitExternalAccount // ignore: cast_nullable_to_non_nullable
              as ExternalAccount?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_User implements _User {
  const _$_User(
      {required this.id,
      required this.name,
      this.token,
      this.parentId,
      this.email,
      this.username,
      this.dynamicAvatar,
      final List<String>? referencesIds,
      final List<Reference>? references,
      this.category,
      this.categoryId,
      this.mqttToken,
      final List<Access>? access,
      final List<CustomField>? customFields,
      this.platformAuth = "",
      this.profile,
      final List<User> childs = const [],
      final List<String>? tagsIds,
      final List<Tag>? tags,
      this.planId,
      @EnvironmentOrNullConverter() this.configuration,
      final List<RegisteredApp>? allowedApps,
      final List<String>? mappitAssetsIds,
      final List<Asset>? mappitAssets,
      this.historicalDaysAllowed,
      this.mappitExternalAccountId,
      this.mappitExternalAccount})
      : _referencesIds = referencesIds,
        _references = references,
        _access = access,
        _customFields = customFields,
        _childs = childs,
        _tagsIds = tagsIds,
        _tags = tags,
        _allowedApps = allowedApps,
        _mappitAssetsIds = mappitAssetsIds,
        _mappitAssets = mappitAssets;

  factory _$_User.fromJson(Map<String, dynamic> json) => _$$_UserFromJson(json);

  /// [id] represents the user ID.
  @override
  final String id;

  /// [name] represents the user name.
  @override
  final String name;

  /// [token] represents the user token.
  @override
  final Token? token;

  /// [parentId] represents the parent ID.
  @override
  final String? parentId;

  /// [email] represents the user email.
  @override
  final String? email;

  /// [username] represents the username.
  @override
  final String? username;

  /// [dynamicAvatar] represents the user avatar.
  @override
  final Avatar? dynamicAvatar;

  /// [referencesIds] represents the list of references IDs.
  final List<String>? _referencesIds;

  /// [referencesIds] represents the list of references IDs.
  @override
  List<String>? get referencesIds {
    final value = _referencesIds;
    if (value == null) return null;
    if (_referencesIds is EqualUnmodifiableListView) return _referencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [references] represents the list of references.
  final List<Reference>? _references;

  /// [references] represents the list of references.
  @override
  List<Reference>? get references {
    final value = _references;
    if (value == null) return null;
    if (_references is EqualUnmodifiableListView) return _references;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [category] represents the user category.
  @override
  final Category? category;

  /// [categoryId] represents the user category ID.
  @override
  final String? categoryId;

  /// [mqttToken] represents the MQTT token.
  @override
  final String? mqttToken;

  /// [access] represents the list of granted access.
  final List<Access>? _access;

  /// [access] represents the list of granted access.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [customFields] represents the list of custom fields.
  final List<CustomField>? _customFields;

  /// [customFields] represents the list of custom fields.
  @override
  List<CustomField>? get customFields {
    final value = _customFields;
    if (value == null) return null;
    if (_customFields is EqualUnmodifiableListView) return _customFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [platformAuth] represents the platform auth.
  @override
  @JsonKey()
  final String platformAuth;

  /// [profile] represents the user profile.
  @override
  final Profile? profile;

  /// [childs] represents the list of childs.
  final List<User> _childs;

  /// [childs] represents the list of childs.
  @override
  @JsonKey()
  List<User> get childs {
    if (_childs is EqualUnmodifiableListView) return _childs;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_childs);
  }

  /// [tagsIds] represents the list of tags IDs.
  final List<String>? _tagsIds;

  /// [tagsIds] represents the list of tags IDs.
  @override
  List<String>? get tagsIds {
    final value = _tagsIds;
    if (value == null) return null;
    if (_tagsIds is EqualUnmodifiableListView) return _tagsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [tags] represents the list of tags.
  final List<Tag>? _tags;

  /// [tags] represents the list of tags.
  @override
  List<Tag>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [planId] represents the plan ID.
  @override
  final String? planId;

  /// [configuration] represents the configuration.
  @override
  @EnvironmentOrNullConverter()
  final Environment? configuration;

  /// [allowedApps] represents the list of allowed apps.
  final List<RegisteredApp>? _allowedApps;

  /// [allowedApps] represents the list of allowed apps.
  @override
  List<RegisteredApp>? get allowedApps {
    final value = _allowedApps;
    if (value == null) return null;
    if (_allowedApps is EqualUnmodifiableListView) return _allowedApps;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [mappitAssetsIds] represents the list of assets IDs.
  /// This field is only for `Mappit` use.
  final List<String>? _mappitAssetsIds;

  /// [mappitAssetsIds] represents the list of assets IDs.
  /// This field is only for `Mappit` use.
  @override
  List<String>? get mappitAssetsIds {
    final value = _mappitAssetsIds;
    if (value == null) return null;
    if (_mappitAssetsIds is EqualUnmodifiableListView) return _mappitAssetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [mappitAssets] represents the list of assets.
  /// This field is only for `Mappit` use.
  final List<Asset>? _mappitAssets;

  /// [mappitAssets] represents the list of assets.
  /// This field is only for `Mappit` use.
  @override
  List<Asset>? get mappitAssets {
    final value = _mappitAssets;
    if (value == null) return null;
    if (_mappitAssets is EqualUnmodifiableListView) return _mappitAssets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [historicalDaysAllowed] represents the number of days allowed to access historical data.
  /// This field is only for `Mappit` use.
  @override
  final int? historicalDaysAllowed;

  /// [mappitExternalAccountId] represents the Mappit external account ID.
  /// This field is only for `Mappit` use.
  @override
  final String? mappitExternalAccountId;

  /// [mappitExternalAccount] represents the Mappit external account.
  /// This field is only for `Mappit` use.
  @override
  final ExternalAccount? mappitExternalAccount;

  @override
  String toString() {
    return 'User(id: $id, name: $name, token: $token, parentId: $parentId, email: $email, username: $username, dynamicAvatar: $dynamicAvatar, referencesIds: $referencesIds, references: $references, category: $category, categoryId: $categoryId, mqttToken: $mqttToken, access: $access, customFields: $customFields, platformAuth: $platformAuth, profile: $profile, childs: $childs, tagsIds: $tagsIds, tags: $tags, planId: $planId, configuration: $configuration, allowedApps: $allowedApps, mappitAssetsIds: $mappitAssetsIds, mappitAssets: $mappitAssets, historicalDaysAllowed: $historicalDaysAllowed, mappitExternalAccountId: $mappitExternalAccountId, mappitExternalAccount: $mappitExternalAccount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_User &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.dynamicAvatar, dynamicAvatar) ||
                other.dynamicAvatar == dynamicAvatar) &&
            const DeepCollectionEquality()
                .equals(other._referencesIds, _referencesIds) &&
            const DeepCollectionEquality()
                .equals(other._references, _references) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.categoryId, categoryId) ||
                other.categoryId == categoryId) &&
            (identical(other.mqttToken, mqttToken) ||
                other.mqttToken == mqttToken) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            const DeepCollectionEquality()
                .equals(other._customFields, _customFields) &&
            (identical(other.platformAuth, platformAuth) ||
                other.platformAuth == platformAuth) &&
            (identical(other.profile, profile) || other.profile == profile) &&
            const DeepCollectionEquality().equals(other._childs, _childs) &&
            const DeepCollectionEquality().equals(other._tagsIds, _tagsIds) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.planId, planId) || other.planId == planId) &&
            (identical(other.configuration, configuration) ||
                other.configuration == configuration) &&
            const DeepCollectionEquality()
                .equals(other._allowedApps, _allowedApps) &&
            const DeepCollectionEquality()
                .equals(other._mappitAssetsIds, _mappitAssetsIds) &&
            const DeepCollectionEquality()
                .equals(other._mappitAssets, _mappitAssets) &&
            (identical(other.historicalDaysAllowed, historicalDaysAllowed) ||
                other.historicalDaysAllowed == historicalDaysAllowed) &&
            (identical(
                    other.mappitExternalAccountId, mappitExternalAccountId) ||
                other.mappitExternalAccountId == mappitExternalAccountId) &&
            (identical(other.mappitExternalAccount, mappitExternalAccount) ||
                other.mappitExternalAccount == mappitExternalAccount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        token,
        parentId,
        email,
        username,
        dynamicAvatar,
        const DeepCollectionEquality().hash(_referencesIds),
        const DeepCollectionEquality().hash(_references),
        category,
        categoryId,
        mqttToken,
        const DeepCollectionEquality().hash(_access),
        const DeepCollectionEquality().hash(_customFields),
        platformAuth,
        profile,
        const DeepCollectionEquality().hash(_childs),
        const DeepCollectionEquality().hash(_tagsIds),
        const DeepCollectionEquality().hash(_tags),
        planId,
        configuration,
        const DeepCollectionEquality().hash(_allowedApps),
        const DeepCollectionEquality().hash(_mappitAssetsIds),
        const DeepCollectionEquality().hash(_mappitAssets),
        historicalDaysAllowed,
        mappitExternalAccountId,
        mappitExternalAccount
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserCopyWith<_$_User> get copyWith =>
      __$$_UserCopyWithImpl<_$_User>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_UserToJson(
      this,
    );
  }
}

abstract class _User implements User {
  const factory _User(
      {required final String id,
      required final String name,
      final Token? token,
      final String? parentId,
      final String? email,
      final String? username,
      final Avatar? dynamicAvatar,
      final List<String>? referencesIds,
      final List<Reference>? references,
      final Category? category,
      final String? categoryId,
      final String? mqttToken,
      final List<Access>? access,
      final List<CustomField>? customFields,
      final String platformAuth,
      final Profile? profile,
      final List<User> childs,
      final List<String>? tagsIds,
      final List<Tag>? tags,
      final String? planId,
      @EnvironmentOrNullConverter() final Environment? configuration,
      final List<RegisteredApp>? allowedApps,
      final List<String>? mappitAssetsIds,
      final List<Asset>? mappitAssets,
      final int? historicalDaysAllowed,
      final String? mappitExternalAccountId,
      final ExternalAccount? mappitExternalAccount}) = _$_User;

  factory _User.fromJson(Map<String, dynamic> json) = _$_User.fromJson;

  @override

  /// [id] represents the user ID.
  String get id;
  @override

  /// [name] represents the user name.
  String get name;
  @override

  /// [token] represents the user token.
  Token? get token;
  @override

  /// [parentId] represents the parent ID.
  String? get parentId;
  @override

  /// [email] represents the user email.
  String? get email;
  @override

  /// [username] represents the username.
  String? get username;
  @override

  /// [dynamicAvatar] represents the user avatar.
  Avatar? get dynamicAvatar;
  @override

  /// [referencesIds] represents the list of references IDs.
  List<String>? get referencesIds;
  @override

  /// [references] represents the list of references.
  List<Reference>? get references;
  @override

  /// [category] represents the user category.
  Category? get category;
  @override

  /// [categoryId] represents the user category ID.
  String? get categoryId;
  @override

  /// [mqttToken] represents the MQTT token.
  String? get mqttToken;
  @override

  /// [access] represents the list of granted access.
  List<Access>? get access;
  @override

  /// [customFields] represents the list of custom fields.
  List<CustomField>? get customFields;
  @override

  /// [platformAuth] represents the platform auth.
  String get platformAuth;
  @override

  /// [profile] represents the user profile.
  Profile? get profile;
  @override

  /// [childs] represents the list of childs.
  List<User> get childs;
  @override

  /// [tagsIds] represents the list of tags IDs.
  List<String>? get tagsIds;
  @override

  /// [tags] represents the list of tags.
  List<Tag>? get tags;
  @override

  /// [planId] represents the plan ID.
  String? get planId;
  @override

  /// [configuration] represents the configuration.
  @EnvironmentOrNullConverter()
  Environment? get configuration;
  @override

  /// [allowedApps] represents the list of allowed apps.
  List<RegisteredApp>? get allowedApps;
  @override

  /// [mappitAssetsIds] represents the list of assets IDs.
  /// This field is only for `Mappit` use.
  List<String>? get mappitAssetsIds;
  @override

  /// [mappitAssets] represents the list of assets.
  /// This field is only for `Mappit` use.
  List<Asset>? get mappitAssets;
  @override

  /// [historicalDaysAllowed] represents the number of days allowed to access historical data.
  /// This field is only for `Mappit` use.
  int? get historicalDaysAllowed;
  @override

  /// [mappitExternalAccountId] represents the Mappit external account ID.
  /// This field is only for `Mappit` use.
  String? get mappitExternalAccountId;
  @override

  /// [mappitExternalAccount] represents the Mappit external account.
  /// This field is only for `Mappit` use.
  ExternalAccount? get mappitExternalAccount;
  @override
  @JsonKey(ignore: true)
  _$$_UserCopyWith<_$_User> get copyWith => throw _privateConstructorUsedError;
}

Token _$TokenFromJson(Map<String, dynamic> json) {
  return _Token.fromJson(json);
}

/// @nodoc
mixin _$Token {
  String get token => throw _privateConstructorUsedError;
  @TimestampConverter()
  DateTime get validBefore => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TokenCopyWith<Token> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TokenCopyWith<$Res> {
  factory $TokenCopyWith(Token value, $Res Function(Token) then) =
      _$TokenCopyWithImpl<$Res, Token>;
  @useResult
  $Res call({String token, @TimestampConverter() DateTime validBefore});
}

/// @nodoc
class _$TokenCopyWithImpl<$Res, $Val extends Token>
    implements $TokenCopyWith<$Res> {
  _$TokenCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? validBefore = null,
  }) {
    return _then(_value.copyWith(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      validBefore: null == validBefore
          ? _value.validBefore
          : validBefore // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TokenCopyWith<$Res> implements $TokenCopyWith<$Res> {
  factory _$$_TokenCopyWith(_$_Token value, $Res Function(_$_Token) then) =
      __$$_TokenCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String token, @TimestampConverter() DateTime validBefore});
}

/// @nodoc
class __$$_TokenCopyWithImpl<$Res> extends _$TokenCopyWithImpl<$Res, _$_Token>
    implements _$$_TokenCopyWith<$Res> {
  __$$_TokenCopyWithImpl(_$_Token _value, $Res Function(_$_Token) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? token = null,
    Object? validBefore = null,
  }) {
    return _then(_$_Token(
      token: null == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String,
      validBefore: null == validBefore
          ? _value.validBefore
          : validBefore // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Token implements _Token {
  const _$_Token(
      {required this.token, @TimestampConverter() required this.validBefore});

  factory _$_Token.fromJson(Map<String, dynamic> json) =>
      _$$_TokenFromJson(json);

  @override
  final String token;
  @override
  @TimestampConverter()
  final DateTime validBefore;

  @override
  String toString() {
    return 'Token(token: $token, validBefore: $validBefore)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Token &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.validBefore, validBefore) ||
                other.validBefore == validBefore));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, token, validBefore);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TokenCopyWith<_$_Token> get copyWith =>
      __$$_TokenCopyWithImpl<_$_Token>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TokenToJson(
      this,
    );
  }
}

abstract class _Token implements Token {
  const factory _Token(
      {required final String token,
      @TimestampConverter() required final DateTime validBefore}) = _$_Token;

  factory _Token.fromJson(Map<String, dynamic> json) = _$_Token.fromJson;

  @override
  String get token;
  @override
  @TimestampConverter()
  DateTime get validBefore;
  @override
  @JsonKey(ignore: true)
  _$$_TokenCopyWith<_$_Token> get copyWith =>
      throw _privateConstructorUsedError;
}

Access _$AccessFromJson(Map<String, dynamic> json) {
  return _Access.fromJson(json);
}

/// @nodoc
mixin _$Access {
  String get id => throw _privateConstructorUsedError;
  String? get label => throw _privateConstructorUsedError;
  bool? get read => throw _privateConstructorUsedError;
  bool? get write => throw _privateConstructorUsedError;
  bool? get manage => throw _privateConstructorUsedError;
  String? get objectId => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  User? get user => throw _privateConstructorUsedError;
  @AccessModuleConverter()
  AccessModule get module => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccessCopyWith<Access> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccessCopyWith<$Res> {
  factory $AccessCopyWith(Access value, $Res Function(Access) then) =
      _$AccessCopyWithImpl<$Res, Access>;
  @useResult
  $Res call(
      {String id,
      String? label,
      bool? read,
      bool? write,
      bool? manage,
      String? objectId,
      String userId,
      User? user,
      @AccessModuleConverter() AccessModule module});

  $UserCopyWith<$Res>? get user;
}

/// @nodoc
class _$AccessCopyWithImpl<$Res, $Val extends Access>
    implements $AccessCopyWith<$Res> {
  _$AccessCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? label = freezed,
    Object? read = freezed,
    Object? write = freezed,
    Object? manage = freezed,
    Object? objectId = freezed,
    Object? userId = null,
    Object? user = freezed,
    Object? module = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      read: freezed == read
          ? _value.read
          : read // ignore: cast_nullable_to_non_nullable
              as bool?,
      write: freezed == write
          ? _value.write
          : write // ignore: cast_nullable_to_non_nullable
              as bool?,
      manage: freezed == manage
          ? _value.manage
          : manage // ignore: cast_nullable_to_non_nullable
              as bool?,
      objectId: freezed == objectId
          ? _value.objectId
          : objectId // ignore: cast_nullable_to_non_nullable
              as String?,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      module: null == module
          ? _value.module
          : module // ignore: cast_nullable_to_non_nullable
              as AccessModule,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get user {
    if (_value.user == null) {
      return null;
    }

    return $UserCopyWith<$Res>(_value.user!, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AccessCopyWith<$Res> implements $AccessCopyWith<$Res> {
  factory _$$_AccessCopyWith(_$_Access value, $Res Function(_$_Access) then) =
      __$$_AccessCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String? label,
      bool? read,
      bool? write,
      bool? manage,
      String? objectId,
      String userId,
      User? user,
      @AccessModuleConverter() AccessModule module});

  @override
  $UserCopyWith<$Res>? get user;
}

/// @nodoc
class __$$_AccessCopyWithImpl<$Res>
    extends _$AccessCopyWithImpl<$Res, _$_Access>
    implements _$$_AccessCopyWith<$Res> {
  __$$_AccessCopyWithImpl(_$_Access _value, $Res Function(_$_Access) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? label = freezed,
    Object? read = freezed,
    Object? write = freezed,
    Object? manage = freezed,
    Object? objectId = freezed,
    Object? userId = null,
    Object? user = freezed,
    Object? module = null,
  }) {
    return _then(_$_Access(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      label: freezed == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String?,
      read: freezed == read
          ? _value.read
          : read // ignore: cast_nullable_to_non_nullable
              as bool?,
      write: freezed == write
          ? _value.write
          : write // ignore: cast_nullable_to_non_nullable
              as bool?,
      manage: freezed == manage
          ? _value.manage
          : manage // ignore: cast_nullable_to_non_nullable
              as bool?,
      objectId: freezed == objectId
          ? _value.objectId
          : objectId // ignore: cast_nullable_to_non_nullable
              as String?,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      module: null == module
          ? _value.module
          : module // ignore: cast_nullable_to_non_nullable
              as AccessModule,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Access implements _Access {
  const _$_Access(
      {required this.id,
      this.label,
      this.read,
      this.write,
      this.manage,
      this.objectId,
      required this.userId,
      this.user,
      @AccessModuleConverter() required this.module});

  factory _$_Access.fromJson(Map<String, dynamic> json) =>
      _$$_AccessFromJson(json);

  @override
  final String id;
  @override
  final String? label;
  @override
  final bool? read;
  @override
  final bool? write;
  @override
  final bool? manage;
  @override
  final String? objectId;
  @override
  final String userId;
  @override
  final User? user;
  @override
  @AccessModuleConverter()
  final AccessModule module;

  @override
  String toString() {
    return 'Access(id: $id, label: $label, read: $read, write: $write, manage: $manage, objectId: $objectId, userId: $userId, user: $user, module: $module)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Access &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.label, label) || other.label == label) &&
            (identical(other.read, read) || other.read == read) &&
            (identical(other.write, write) || other.write == write) &&
            (identical(other.manage, manage) || other.manage == manage) &&
            (identical(other.objectId, objectId) ||
                other.objectId == objectId) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.module, module) || other.module == module));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, label, read, write, manage,
      objectId, userId, user, module);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AccessCopyWith<_$_Access> get copyWith =>
      __$$_AccessCopyWithImpl<_$_Access>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AccessToJson(
      this,
    );
  }
}

abstract class _Access implements Access {
  const factory _Access(
      {required final String id,
      final String? label,
      final bool? read,
      final bool? write,
      final bool? manage,
      final String? objectId,
      required final String userId,
      final User? user,
      @AccessModuleConverter() required final AccessModule module}) = _$_Access;

  factory _Access.fromJson(Map<String, dynamic> json) = _$_Access.fromJson;

  @override
  String get id;
  @override
  String? get label;
  @override
  bool? get read;
  @override
  bool? get write;
  @override
  bool? get manage;
  @override
  String? get objectId;
  @override
  String get userId;
  @override
  User? get user;
  @override
  @AccessModuleConverter()
  AccessModule get module;
  @override
  @JsonKey(ignore: true)
  _$$_AccessCopyWith<_$_Access> get copyWith =>
      throw _privateConstructorUsedError;
}

DbPartition _$DbPartitionFromJson(Map<String, dynamic> json) {
  return _DbPartition.fromJson(json);
}

/// @nodoc
mixin _$DbPartition {
  String get id => throw _privateConstructorUsedError;
  String get parentTable => throw _privateConstructorUsedError;
  String get tableName => throw _privateConstructorUsedError;
  bool get isCompleted => throw _privateConstructorUsedError;
  bool get isDefault => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get startAt => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get endAt => throw _privateConstructorUsedError;
  int? get numOfRecords => throw _privateConstructorUsedError;
  double? get totalSize => throw _privateConstructorUsedError;
  double? get sizePerRecord => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DbPartitionCopyWith<DbPartition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DbPartitionCopyWith<$Res> {
  factory $DbPartitionCopyWith(
          DbPartition value, $Res Function(DbPartition) then) =
      _$DbPartitionCopyWithImpl<$Res, DbPartition>;
  @useResult
  $Res call(
      {String id,
      String parentTable,
      String tableName,
      bool isCompleted,
      bool isDefault,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      int? numOfRecords,
      double? totalSize,
      double? sizePerRecord});
}

/// @nodoc
class _$DbPartitionCopyWithImpl<$Res, $Val extends DbPartition>
    implements $DbPartitionCopyWith<$Res> {
  _$DbPartitionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? parentTable = null,
    Object? tableName = null,
    Object? isCompleted = null,
    Object? isDefault = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? numOfRecords = freezed,
    Object? totalSize = freezed,
    Object? sizePerRecord = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      parentTable: null == parentTable
          ? _value.parentTable
          : parentTable // ignore: cast_nullable_to_non_nullable
              as String,
      tableName: null == tableName
          ? _value.tableName
          : tableName // ignore: cast_nullable_to_non_nullable
              as String,
      isCompleted: null == isCompleted
          ? _value.isCompleted
          : isCompleted // ignore: cast_nullable_to_non_nullable
              as bool,
      isDefault: null == isDefault
          ? _value.isDefault
          : isDefault // ignore: cast_nullable_to_non_nullable
              as bool,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      numOfRecords: freezed == numOfRecords
          ? _value.numOfRecords
          : numOfRecords // ignore: cast_nullable_to_non_nullable
              as int?,
      totalSize: freezed == totalSize
          ? _value.totalSize
          : totalSize // ignore: cast_nullable_to_non_nullable
              as double?,
      sizePerRecord: freezed == sizePerRecord
          ? _value.sizePerRecord
          : sizePerRecord // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DbPartitionCopyWith<$Res>
    implements $DbPartitionCopyWith<$Res> {
  factory _$$_DbPartitionCopyWith(
          _$_DbPartition value, $Res Function(_$_DbPartition) then) =
      __$$_DbPartitionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String parentTable,
      String tableName,
      bool isCompleted,
      bool isDefault,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      int? numOfRecords,
      double? totalSize,
      double? sizePerRecord});
}

/// @nodoc
class __$$_DbPartitionCopyWithImpl<$Res>
    extends _$DbPartitionCopyWithImpl<$Res, _$_DbPartition>
    implements _$$_DbPartitionCopyWith<$Res> {
  __$$_DbPartitionCopyWithImpl(
      _$_DbPartition _value, $Res Function(_$_DbPartition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? parentTable = null,
    Object? tableName = null,
    Object? isCompleted = null,
    Object? isDefault = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? numOfRecords = freezed,
    Object? totalSize = freezed,
    Object? sizePerRecord = freezed,
  }) {
    return _then(_$_DbPartition(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      parentTable: null == parentTable
          ? _value.parentTable
          : parentTable // ignore: cast_nullable_to_non_nullable
              as String,
      tableName: null == tableName
          ? _value.tableName
          : tableName // ignore: cast_nullable_to_non_nullable
              as String,
      isCompleted: null == isCompleted
          ? _value.isCompleted
          : isCompleted // ignore: cast_nullable_to_non_nullable
              as bool,
      isDefault: null == isDefault
          ? _value.isDefault
          : isDefault // ignore: cast_nullable_to_non_nullable
              as bool,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      numOfRecords: freezed == numOfRecords
          ? _value.numOfRecords
          : numOfRecords // ignore: cast_nullable_to_non_nullable
              as int?,
      totalSize: freezed == totalSize
          ? _value.totalSize
          : totalSize // ignore: cast_nullable_to_non_nullable
              as double?,
      sizePerRecord: freezed == sizePerRecord
          ? _value.sizePerRecord
          : sizePerRecord // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DbPartition implements _DbPartition {
  const _$_DbPartition(
      {required this.id,
      required this.parentTable,
      required this.tableName,
      this.isCompleted = false,
      this.isDefault = false,
      @TimestampOrNullConverter() this.startAt,
      @TimestampOrNullConverter() this.endAt,
      this.numOfRecords,
      this.totalSize,
      this.sizePerRecord});

  factory _$_DbPartition.fromJson(Map<String, dynamic> json) =>
      _$$_DbPartitionFromJson(json);

  @override
  final String id;
  @override
  final String parentTable;
  @override
  final String tableName;
  @override
  @JsonKey()
  final bool isCompleted;
  @override
  @JsonKey()
  final bool isDefault;
  @override
  @TimestampOrNullConverter()
  final DateTime? startAt;
  @override
  @TimestampOrNullConverter()
  final DateTime? endAt;
  @override
  final int? numOfRecords;
  @override
  final double? totalSize;
  @override
  final double? sizePerRecord;

  @override
  String toString() {
    return 'DbPartition(id: $id, parentTable: $parentTable, tableName: $tableName, isCompleted: $isCompleted, isDefault: $isDefault, startAt: $startAt, endAt: $endAt, numOfRecords: $numOfRecords, totalSize: $totalSize, sizePerRecord: $sizePerRecord)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DbPartition &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.parentTable, parentTable) ||
                other.parentTable == parentTable) &&
            (identical(other.tableName, tableName) ||
                other.tableName == tableName) &&
            (identical(other.isCompleted, isCompleted) ||
                other.isCompleted == isCompleted) &&
            (identical(other.isDefault, isDefault) ||
                other.isDefault == isDefault) &&
            (identical(other.startAt, startAt) || other.startAt == startAt) &&
            (identical(other.endAt, endAt) || other.endAt == endAt) &&
            (identical(other.numOfRecords, numOfRecords) ||
                other.numOfRecords == numOfRecords) &&
            (identical(other.totalSize, totalSize) ||
                other.totalSize == totalSize) &&
            (identical(other.sizePerRecord, sizePerRecord) ||
                other.sizePerRecord == sizePerRecord));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      parentTable,
      tableName,
      isCompleted,
      isDefault,
      startAt,
      endAt,
      numOfRecords,
      totalSize,
      sizePerRecord);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DbPartitionCopyWith<_$_DbPartition> get copyWith =>
      __$$_DbPartitionCopyWithImpl<_$_DbPartition>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DbPartitionToJson(
      this,
    );
  }
}

abstract class _DbPartition implements DbPartition {
  const factory _DbPartition(
      {required final String id,
      required final String parentTable,
      required final String tableName,
      final bool isCompleted,
      final bool isDefault,
      @TimestampOrNullConverter() final DateTime? startAt,
      @TimestampOrNullConverter() final DateTime? endAt,
      final int? numOfRecords,
      final double? totalSize,
      final double? sizePerRecord}) = _$_DbPartition;

  factory _DbPartition.fromJson(Map<String, dynamic> json) =
      _$_DbPartition.fromJson;

  @override
  String get id;
  @override
  String get parentTable;
  @override
  String get tableName;
  @override
  bool get isCompleted;
  @override
  bool get isDefault;
  @override
  @TimestampOrNullConverter()
  DateTime? get startAt;
  @override
  @TimestampOrNullConverter()
  DateTime? get endAt;
  @override
  int? get numOfRecords;
  @override
  double? get totalSize;
  @override
  double? get sizePerRecord;
  @override
  @JsonKey(ignore: true)
  _$$_DbPartitionCopyWith<_$_DbPartition> get copyWith =>
      throw _privateConstructorUsedError;
}

GenericPermissionItem _$GenericPermissionItemFromJson(
    Map<String, dynamic> json) {
  return _GenericPermissionItem.fromJson(json);
}

/// @nodoc
mixin _$GenericPermissionItem {
  bool get read => throw _privateConstructorUsedError;
  bool get write => throw _privateConstructorUsedError;
  bool get create => throw _privateConstructorUsedError;
  bool get delete => throw _privateConstructorUsedError;
  bool get plan => throw _privateConstructorUsedError;
  bool get loginas => throw _privateConstructorUsedError;
  bool get suspend => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GenericPermissionItemCopyWith<GenericPermissionItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenericPermissionItemCopyWith<$Res> {
  factory $GenericPermissionItemCopyWith(GenericPermissionItem value,
          $Res Function(GenericPermissionItem) then) =
      _$GenericPermissionItemCopyWithImpl<$Res, GenericPermissionItem>;
  @useResult
  $Res call(
      {bool read,
      bool write,
      bool create,
      bool delete,
      bool plan,
      bool loginas,
      bool suspend});
}

/// @nodoc
class _$GenericPermissionItemCopyWithImpl<$Res,
        $Val extends GenericPermissionItem>
    implements $GenericPermissionItemCopyWith<$Res> {
  _$GenericPermissionItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? read = null,
    Object? write = null,
    Object? create = null,
    Object? delete = null,
    Object? plan = null,
    Object? loginas = null,
    Object? suspend = null,
  }) {
    return _then(_value.copyWith(
      read: null == read
          ? _value.read
          : read // ignore: cast_nullable_to_non_nullable
              as bool,
      write: null == write
          ? _value.write
          : write // ignore: cast_nullable_to_non_nullable
              as bool,
      create: null == create
          ? _value.create
          : create // ignore: cast_nullable_to_non_nullable
              as bool,
      delete: null == delete
          ? _value.delete
          : delete // ignore: cast_nullable_to_non_nullable
              as bool,
      plan: null == plan
          ? _value.plan
          : plan // ignore: cast_nullable_to_non_nullable
              as bool,
      loginas: null == loginas
          ? _value.loginas
          : loginas // ignore: cast_nullable_to_non_nullable
              as bool,
      suspend: null == suspend
          ? _value.suspend
          : suspend // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GenericPermissionItemCopyWith<$Res>
    implements $GenericPermissionItemCopyWith<$Res> {
  factory _$$_GenericPermissionItemCopyWith(_$_GenericPermissionItem value,
          $Res Function(_$_GenericPermissionItem) then) =
      __$$_GenericPermissionItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool read,
      bool write,
      bool create,
      bool delete,
      bool plan,
      bool loginas,
      bool suspend});
}

/// @nodoc
class __$$_GenericPermissionItemCopyWithImpl<$Res>
    extends _$GenericPermissionItemCopyWithImpl<$Res, _$_GenericPermissionItem>
    implements _$$_GenericPermissionItemCopyWith<$Res> {
  __$$_GenericPermissionItemCopyWithImpl(_$_GenericPermissionItem _value,
      $Res Function(_$_GenericPermissionItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? read = null,
    Object? write = null,
    Object? create = null,
    Object? delete = null,
    Object? plan = null,
    Object? loginas = null,
    Object? suspend = null,
  }) {
    return _then(_$_GenericPermissionItem(
      read: null == read
          ? _value.read
          : read // ignore: cast_nullable_to_non_nullable
              as bool,
      write: null == write
          ? _value.write
          : write // ignore: cast_nullable_to_non_nullable
              as bool,
      create: null == create
          ? _value.create
          : create // ignore: cast_nullable_to_non_nullable
              as bool,
      delete: null == delete
          ? _value.delete
          : delete // ignore: cast_nullable_to_non_nullable
              as bool,
      plan: null == plan
          ? _value.plan
          : plan // ignore: cast_nullable_to_non_nullable
              as bool,
      loginas: null == loginas
          ? _value.loginas
          : loginas // ignore: cast_nullable_to_non_nullable
              as bool,
      suspend: null == suspend
          ? _value.suspend
          : suspend // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GenericPermissionItem implements _GenericPermissionItem {
  const _$_GenericPermissionItem(
      {this.read = false,
      this.write = false,
      this.create = false,
      this.delete = false,
      this.plan = false,
      this.loginas = false,
      this.suspend = false});

  factory _$_GenericPermissionItem.fromJson(Map<String, dynamic> json) =>
      _$$_GenericPermissionItemFromJson(json);

  @override
  @JsonKey()
  final bool read;
  @override
  @JsonKey()
  final bool write;
  @override
  @JsonKey()
  final bool create;
  @override
  @JsonKey()
  final bool delete;
  @override
  @JsonKey()
  final bool plan;
  @override
  @JsonKey()
  final bool loginas;
  @override
  @JsonKey()
  final bool suspend;

  @override
  String toString() {
    return 'GenericPermissionItem(read: $read, write: $write, create: $create, delete: $delete, plan: $plan, loginas: $loginas, suspend: $suspend)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GenericPermissionItem &&
            (identical(other.read, read) || other.read == read) &&
            (identical(other.write, write) || other.write == write) &&
            (identical(other.create, create) || other.create == create) &&
            (identical(other.delete, delete) || other.delete == delete) &&
            (identical(other.plan, plan) || other.plan == plan) &&
            (identical(other.loginas, loginas) || other.loginas == loginas) &&
            (identical(other.suspend, suspend) || other.suspend == suspend));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, read, write, create, delete, plan, loginas, suspend);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GenericPermissionItemCopyWith<_$_GenericPermissionItem> get copyWith =>
      __$$_GenericPermissionItemCopyWithImpl<_$_GenericPermissionItem>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GenericPermissionItemToJson(
      this,
    );
  }
}

abstract class _GenericPermissionItem implements GenericPermissionItem {
  const factory _GenericPermissionItem(
      {final bool read,
      final bool write,
      final bool create,
      final bool delete,
      final bool plan,
      final bool loginas,
      final bool suspend}) = _$_GenericPermissionItem;

  factory _GenericPermissionItem.fromJson(Map<String, dynamic> json) =
      _$_GenericPermissionItem.fromJson;

  @override
  bool get read;
  @override
  bool get write;
  @override
  bool get create;
  @override
  bool get delete;
  @override
  bool get plan;
  @override
  bool get loginas;
  @override
  bool get suspend;
  @override
  @JsonKey(ignore: true)
  _$$_GenericPermissionItemCopyWith<_$_GenericPermissionItem> get copyWith =>
      throw _privateConstructorUsedError;
}

GenericPermission _$GenericPermissionFromJson(Map<String, dynamic> json) {
  return _GenericPermission.fromJson(json);
}

/// @nodoc
mixin _$GenericPermission {
  GenericPermissionItem? get apps => throw _privateConstructorUsedError;
  GenericPermissionItem? get users => throw _privateConstructorUsedError;
  GenericPermissionItem? get firmwares => throw _privateConstructorUsedError;
  GenericPermissionItem? get employees => throw _privateConstructorUsedError;
  GenericPermissionItem? get languages => throw _privateConstructorUsedError;
  GenericPermissionItem? get categories => throw _privateConstructorUsedError;
  GenericPermissionItem? get departments => throw _privateConstructorUsedError;
  GenericPermissionItem? get protocols => throw _privateConstructorUsedError;
  GenericPermissionItem? get billing => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GenericPermissionCopyWith<GenericPermission> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenericPermissionCopyWith<$Res> {
  factory $GenericPermissionCopyWith(
          GenericPermission value, $Res Function(GenericPermission) then) =
      _$GenericPermissionCopyWithImpl<$Res, GenericPermission>;
  @useResult
  $Res call(
      {GenericPermissionItem? apps,
      GenericPermissionItem? users,
      GenericPermissionItem? firmwares,
      GenericPermissionItem? employees,
      GenericPermissionItem? languages,
      GenericPermissionItem? categories,
      GenericPermissionItem? departments,
      GenericPermissionItem? protocols,
      GenericPermissionItem? billing});

  $GenericPermissionItemCopyWith<$Res>? get apps;
  $GenericPermissionItemCopyWith<$Res>? get users;
  $GenericPermissionItemCopyWith<$Res>? get firmwares;
  $GenericPermissionItemCopyWith<$Res>? get employees;
  $GenericPermissionItemCopyWith<$Res>? get languages;
  $GenericPermissionItemCopyWith<$Res>? get categories;
  $GenericPermissionItemCopyWith<$Res>? get departments;
  $GenericPermissionItemCopyWith<$Res>? get protocols;
  $GenericPermissionItemCopyWith<$Res>? get billing;
}

/// @nodoc
class _$GenericPermissionCopyWithImpl<$Res, $Val extends GenericPermission>
    implements $GenericPermissionCopyWith<$Res> {
  _$GenericPermissionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? apps = freezed,
    Object? users = freezed,
    Object? firmwares = freezed,
    Object? employees = freezed,
    Object? languages = freezed,
    Object? categories = freezed,
    Object? departments = freezed,
    Object? protocols = freezed,
    Object? billing = freezed,
  }) {
    return _then(_value.copyWith(
      apps: freezed == apps
          ? _value.apps
          : apps // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      users: freezed == users
          ? _value.users
          : users // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      firmwares: freezed == firmwares
          ? _value.firmwares
          : firmwares // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      employees: freezed == employees
          ? _value.employees
          : employees // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      languages: freezed == languages
          ? _value.languages
          : languages // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      categories: freezed == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      departments: freezed == departments
          ? _value.departments
          : departments // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      protocols: freezed == protocols
          ? _value.protocols
          : protocols // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      billing: freezed == billing
          ? _value.billing
          : billing // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get apps {
    if (_value.apps == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.apps!, (value) {
      return _then(_value.copyWith(apps: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get users {
    if (_value.users == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.users!, (value) {
      return _then(_value.copyWith(users: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get firmwares {
    if (_value.firmwares == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.firmwares!, (value) {
      return _then(_value.copyWith(firmwares: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get employees {
    if (_value.employees == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.employees!, (value) {
      return _then(_value.copyWith(employees: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get languages {
    if (_value.languages == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.languages!, (value) {
      return _then(_value.copyWith(languages: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get categories {
    if (_value.categories == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.categories!, (value) {
      return _then(_value.copyWith(categories: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get departments {
    if (_value.departments == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.departments!, (value) {
      return _then(_value.copyWith(departments: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get protocols {
    if (_value.protocols == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.protocols!, (value) {
      return _then(_value.copyWith(protocols: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionItemCopyWith<$Res>? get billing {
    if (_value.billing == null) {
      return null;
    }

    return $GenericPermissionItemCopyWith<$Res>(_value.billing!, (value) {
      return _then(_value.copyWith(billing: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_GenericPermissionCopyWith<$Res>
    implements $GenericPermissionCopyWith<$Res> {
  factory _$$_GenericPermissionCopyWith(_$_GenericPermission value,
          $Res Function(_$_GenericPermission) then) =
      __$$_GenericPermissionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {GenericPermissionItem? apps,
      GenericPermissionItem? users,
      GenericPermissionItem? firmwares,
      GenericPermissionItem? employees,
      GenericPermissionItem? languages,
      GenericPermissionItem? categories,
      GenericPermissionItem? departments,
      GenericPermissionItem? protocols,
      GenericPermissionItem? billing});

  @override
  $GenericPermissionItemCopyWith<$Res>? get apps;
  @override
  $GenericPermissionItemCopyWith<$Res>? get users;
  @override
  $GenericPermissionItemCopyWith<$Res>? get firmwares;
  @override
  $GenericPermissionItemCopyWith<$Res>? get employees;
  @override
  $GenericPermissionItemCopyWith<$Res>? get languages;
  @override
  $GenericPermissionItemCopyWith<$Res>? get categories;
  @override
  $GenericPermissionItemCopyWith<$Res>? get departments;
  @override
  $GenericPermissionItemCopyWith<$Res>? get protocols;
  @override
  $GenericPermissionItemCopyWith<$Res>? get billing;
}

/// @nodoc
class __$$_GenericPermissionCopyWithImpl<$Res>
    extends _$GenericPermissionCopyWithImpl<$Res, _$_GenericPermission>
    implements _$$_GenericPermissionCopyWith<$Res> {
  __$$_GenericPermissionCopyWithImpl(
      _$_GenericPermission _value, $Res Function(_$_GenericPermission) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? apps = freezed,
    Object? users = freezed,
    Object? firmwares = freezed,
    Object? employees = freezed,
    Object? languages = freezed,
    Object? categories = freezed,
    Object? departments = freezed,
    Object? protocols = freezed,
    Object? billing = freezed,
  }) {
    return _then(_$_GenericPermission(
      apps: freezed == apps
          ? _value.apps
          : apps // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      users: freezed == users
          ? _value.users
          : users // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      firmwares: freezed == firmwares
          ? _value.firmwares
          : firmwares // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      employees: freezed == employees
          ? _value.employees
          : employees // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      languages: freezed == languages
          ? _value.languages
          : languages // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      categories: freezed == categories
          ? _value.categories
          : categories // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      departments: freezed == departments
          ? _value.departments
          : departments // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      protocols: freezed == protocols
          ? _value.protocols
          : protocols // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
      billing: freezed == billing
          ? _value.billing
          : billing // ignore: cast_nullable_to_non_nullable
              as GenericPermissionItem?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GenericPermission implements _GenericPermission {
  const _$_GenericPermission(
      {this.apps,
      this.users,
      this.firmwares,
      this.employees,
      this.languages,
      this.categories,
      this.departments,
      this.protocols,
      this.billing});

  factory _$_GenericPermission.fromJson(Map<String, dynamic> json) =>
      _$$_GenericPermissionFromJson(json);

  @override
  final GenericPermissionItem? apps;
  @override
  final GenericPermissionItem? users;
  @override
  final GenericPermissionItem? firmwares;
  @override
  final GenericPermissionItem? employees;
  @override
  final GenericPermissionItem? languages;
  @override
  final GenericPermissionItem? categories;
  @override
  final GenericPermissionItem? departments;
  @override
  final GenericPermissionItem? protocols;
  @override
  final GenericPermissionItem? billing;

  @override
  String toString() {
    return 'GenericPermission(apps: $apps, users: $users, firmwares: $firmwares, employees: $employees, languages: $languages, categories: $categories, departments: $departments, protocols: $protocols, billing: $billing)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GenericPermission &&
            (identical(other.apps, apps) || other.apps == apps) &&
            (identical(other.users, users) || other.users == users) &&
            (identical(other.firmwares, firmwares) ||
                other.firmwares == firmwares) &&
            (identical(other.employees, employees) ||
                other.employees == employees) &&
            (identical(other.languages, languages) ||
                other.languages == languages) &&
            (identical(other.categories, categories) ||
                other.categories == categories) &&
            (identical(other.departments, departments) ||
                other.departments == departments) &&
            (identical(other.protocols, protocols) ||
                other.protocols == protocols) &&
            (identical(other.billing, billing) || other.billing == billing));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, apps, users, firmwares,
      employees, languages, categories, departments, protocols, billing);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GenericPermissionCopyWith<_$_GenericPermission> get copyWith =>
      __$$_GenericPermissionCopyWithImpl<_$_GenericPermission>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GenericPermissionToJson(
      this,
    );
  }
}

abstract class _GenericPermission implements GenericPermission {
  const factory _GenericPermission(
      {final GenericPermissionItem? apps,
      final GenericPermissionItem? users,
      final GenericPermissionItem? firmwares,
      final GenericPermissionItem? employees,
      final GenericPermissionItem? languages,
      final GenericPermissionItem? categories,
      final GenericPermissionItem? departments,
      final GenericPermissionItem? protocols,
      final GenericPermissionItem? billing}) = _$_GenericPermission;

  factory _GenericPermission.fromJson(Map<String, dynamic> json) =
      _$_GenericPermission.fromJson;

  @override
  GenericPermissionItem? get apps;
  @override
  GenericPermissionItem? get users;
  @override
  GenericPermissionItem? get firmwares;
  @override
  GenericPermissionItem? get employees;
  @override
  GenericPermissionItem? get languages;
  @override
  GenericPermissionItem? get categories;
  @override
  GenericPermissionItem? get departments;
  @override
  GenericPermissionItem? get protocols;
  @override
  GenericPermissionItem? get billing;
  @override
  @JsonKey(ignore: true)
  _$$_GenericPermissionCopyWith<_$_GenericPermission> get copyWith =>
      throw _privateConstructorUsedError;
}

Department _$DepartmentFromJson(Map<String, dynamic> json) {
  return _Department.fromJson(json);
}

/// @nodoc
mixin _$Department {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  GenericPermission? get permissions => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DepartmentCopyWith<Department> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DepartmentCopyWith<$Res> {
  factory $DepartmentCopyWith(
          Department value, $Res Function(Department) then) =
      _$DepartmentCopyWithImpl<$Res, Department>;
  @useResult
  $Res call({String id, String name, GenericPermission? permissions});

  $GenericPermissionCopyWith<$Res>? get permissions;
}

/// @nodoc
class _$DepartmentCopyWithImpl<$Res, $Val extends Department>
    implements $DepartmentCopyWith<$Res> {
  _$DepartmentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? permissions = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      permissions: freezed == permissions
          ? _value.permissions
          : permissions // ignore: cast_nullable_to_non_nullable
              as GenericPermission?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionCopyWith<$Res>? get permissions {
    if (_value.permissions == null) {
      return null;
    }

    return $GenericPermissionCopyWith<$Res>(_value.permissions!, (value) {
      return _then(_value.copyWith(permissions: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_DepartmentCopyWith<$Res>
    implements $DepartmentCopyWith<$Res> {
  factory _$$_DepartmentCopyWith(
          _$_Department value, $Res Function(_$_Department) then) =
      __$$_DepartmentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name, GenericPermission? permissions});

  @override
  $GenericPermissionCopyWith<$Res>? get permissions;
}

/// @nodoc
class __$$_DepartmentCopyWithImpl<$Res>
    extends _$DepartmentCopyWithImpl<$Res, _$_Department>
    implements _$$_DepartmentCopyWith<$Res> {
  __$$_DepartmentCopyWithImpl(
      _$_Department _value, $Res Function(_$_Department) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? permissions = freezed,
  }) {
    return _then(_$_Department(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      permissions: freezed == permissions
          ? _value.permissions
          : permissions // ignore: cast_nullable_to_non_nullable
              as GenericPermission?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Department implements _Department {
  const _$_Department({required this.id, required this.name, this.permissions});

  factory _$_Department.fromJson(Map<String, dynamic> json) =>
      _$$_DepartmentFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final GenericPermission? permissions;

  @override
  String toString() {
    return 'Department(id: $id, name: $name, permissions: $permissions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Department &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.permissions, permissions) ||
                other.permissions == permissions));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, permissions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DepartmentCopyWith<_$_Department> get copyWith =>
      __$$_DepartmentCopyWithImpl<_$_Department>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DepartmentToJson(
      this,
    );
  }
}

abstract class _Department implements Department {
  const factory _Department(
      {required final String id,
      required final String name,
      final GenericPermission? permissions}) = _$_Department;

  factory _Department.fromJson(Map<String, dynamic> json) =
      _$_Department.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  GenericPermission? get permissions;
  @override
  @JsonKey(ignore: true)
  _$$_DepartmentCopyWith<_$_Department> get copyWith =>
      throw _privateConstructorUsedError;
}

Employee _$EmployeeFromJson(Map<String, dynamic> json) {
  return _Employee.fromJson(json);
}

/// @nodoc
mixin _$Employee {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String? get email => throw _privateConstructorUsedError;
  String? get username => throw _privateConstructorUsedError;
  Department? get department => throw _privateConstructorUsedError;
  String? get departmentId => throw _privateConstructorUsedError;
  String? get avatar => throw _privateConstructorUsedError;
  Token? get token => throw _privateConstructorUsedError;
  GenericPermission? get permissions => throw _privateConstructorUsedError;
  GenericPermission? get customPermissions =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmployeeCopyWith<Employee> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmployeeCopyWith<$Res> {
  factory $EmployeeCopyWith(Employee value, $Res Function(Employee) then) =
      _$EmployeeCopyWithImpl<$Res, Employee>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? email,
      String? username,
      Department? department,
      String? departmentId,
      String? avatar,
      Token? token,
      GenericPermission? permissions,
      GenericPermission? customPermissions});

  $DepartmentCopyWith<$Res>? get department;
  $TokenCopyWith<$Res>? get token;
  $GenericPermissionCopyWith<$Res>? get permissions;
  $GenericPermissionCopyWith<$Res>? get customPermissions;
}

/// @nodoc
class _$EmployeeCopyWithImpl<$Res, $Val extends Employee>
    implements $EmployeeCopyWith<$Res> {
  _$EmployeeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? email = freezed,
    Object? username = freezed,
    Object? department = freezed,
    Object? departmentId = freezed,
    Object? avatar = freezed,
    Object? token = freezed,
    Object? permissions = freezed,
    Object? customPermissions = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      department: freezed == department
          ? _value.department
          : department // ignore: cast_nullable_to_non_nullable
              as Department?,
      departmentId: freezed == departmentId
          ? _value.departmentId
          : departmentId // ignore: cast_nullable_to_non_nullable
              as String?,
      avatar: freezed == avatar
          ? _value.avatar
          : avatar // ignore: cast_nullable_to_non_nullable
              as String?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as Token?,
      permissions: freezed == permissions
          ? _value.permissions
          : permissions // ignore: cast_nullable_to_non_nullable
              as GenericPermission?,
      customPermissions: freezed == customPermissions
          ? _value.customPermissions
          : customPermissions // ignore: cast_nullable_to_non_nullable
              as GenericPermission?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $DepartmentCopyWith<$Res>? get department {
    if (_value.department == null) {
      return null;
    }

    return $DepartmentCopyWith<$Res>(_value.department!, (value) {
      return _then(_value.copyWith(department: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TokenCopyWith<$Res>? get token {
    if (_value.token == null) {
      return null;
    }

    return $TokenCopyWith<$Res>(_value.token!, (value) {
      return _then(_value.copyWith(token: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionCopyWith<$Res>? get permissions {
    if (_value.permissions == null) {
      return null;
    }

    return $GenericPermissionCopyWith<$Res>(_value.permissions!, (value) {
      return _then(_value.copyWith(permissions: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $GenericPermissionCopyWith<$Res>? get customPermissions {
    if (_value.customPermissions == null) {
      return null;
    }

    return $GenericPermissionCopyWith<$Res>(_value.customPermissions!, (value) {
      return _then(_value.copyWith(customPermissions: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_EmployeeCopyWith<$Res> implements $EmployeeCopyWith<$Res> {
  factory _$$_EmployeeCopyWith(
          _$_Employee value, $Res Function(_$_Employee) then) =
      __$$_EmployeeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? email,
      String? username,
      Department? department,
      String? departmentId,
      String? avatar,
      Token? token,
      GenericPermission? permissions,
      GenericPermission? customPermissions});

  @override
  $DepartmentCopyWith<$Res>? get department;
  @override
  $TokenCopyWith<$Res>? get token;
  @override
  $GenericPermissionCopyWith<$Res>? get permissions;
  @override
  $GenericPermissionCopyWith<$Res>? get customPermissions;
}

/// @nodoc
class __$$_EmployeeCopyWithImpl<$Res>
    extends _$EmployeeCopyWithImpl<$Res, _$_Employee>
    implements _$$_EmployeeCopyWith<$Res> {
  __$$_EmployeeCopyWithImpl(
      _$_Employee _value, $Res Function(_$_Employee) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? email = freezed,
    Object? username = freezed,
    Object? department = freezed,
    Object? departmentId = freezed,
    Object? avatar = freezed,
    Object? token = freezed,
    Object? permissions = freezed,
    Object? customPermissions = freezed,
  }) {
    return _then(_$_Employee(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      department: freezed == department
          ? _value.department
          : department // ignore: cast_nullable_to_non_nullable
              as Department?,
      departmentId: freezed == departmentId
          ? _value.departmentId
          : departmentId // ignore: cast_nullable_to_non_nullable
              as String?,
      avatar: freezed == avatar
          ? _value.avatar
          : avatar // ignore: cast_nullable_to_non_nullable
              as String?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as Token?,
      permissions: freezed == permissions
          ? _value.permissions
          : permissions // ignore: cast_nullable_to_non_nullable
              as GenericPermission?,
      customPermissions: freezed == customPermissions
          ? _value.customPermissions
          : customPermissions // ignore: cast_nullable_to_non_nullable
              as GenericPermission?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Employee implements _Employee {
  const _$_Employee(
      {required this.id,
      required this.name,
      this.email,
      this.username,
      this.department,
      this.departmentId,
      this.avatar,
      this.token,
      this.permissions,
      this.customPermissions});

  factory _$_Employee.fromJson(Map<String, dynamic> json) =>
      _$$_EmployeeFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String? email;
  @override
  final String? username;
  @override
  final Department? department;
  @override
  final String? departmentId;
  @override
  final String? avatar;
  @override
  final Token? token;
  @override
  final GenericPermission? permissions;
  @override
  final GenericPermission? customPermissions;

  @override
  String toString() {
    return 'Employee(id: $id, name: $name, email: $email, username: $username, department: $department, departmentId: $departmentId, avatar: $avatar, token: $token, permissions: $permissions, customPermissions: $customPermissions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Employee &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.department, department) ||
                other.department == department) &&
            (identical(other.departmentId, departmentId) ||
                other.departmentId == departmentId) &&
            (identical(other.avatar, avatar) || other.avatar == avatar) &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.permissions, permissions) ||
                other.permissions == permissions) &&
            (identical(other.customPermissions, customPermissions) ||
                other.customPermissions == customPermissions));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, email, username,
      department, departmentId, avatar, token, permissions, customPermissions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EmployeeCopyWith<_$_Employee> get copyWith =>
      __$$_EmployeeCopyWithImpl<_$_Employee>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_EmployeeToJson(
      this,
    );
  }
}

abstract class _Employee implements Employee {
  const factory _Employee(
      {required final String id,
      required final String name,
      final String? email,
      final String? username,
      final Department? department,
      final String? departmentId,
      final String? avatar,
      final Token? token,
      final GenericPermission? permissions,
      final GenericPermission? customPermissions}) = _$_Employee;

  factory _Employee.fromJson(Map<String, dynamic> json) = _$_Employee.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String? get email;
  @override
  String? get username;
  @override
  Department? get department;
  @override
  String? get departmentId;
  @override
  String? get avatar;
  @override
  Token? get token;
  @override
  GenericPermission? get permissions;
  @override
  GenericPermission? get customPermissions;
  @override
  @JsonKey(ignore: true)
  _$$_EmployeeCopyWith<_$_Employee> get copyWith =>
      throw _privateConstructorUsedError;
}

Algorithm _$AlgorithmFromJson(Map<String, dynamic> json) {
  return _Algorithm.fromJson(json);
}

/// @nodoc
mixin _$Algorithm {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;
  @IconOrNullConverter()
  IconData? get icon => throw _privateConstructorUsedError;
  bool get isEnabled => throw _privateConstructorUsedError;
  List<String> get categoriesIds => throw _privateConstructorUsedError;
  bool get canBeInSensors => throw _privateConstructorUsedError;
  bool get hasHttp => throw _privateConstructorUsedError;
  bool get hasFtp => throw _privateConstructorUsedError;
  List<CredentialField> get requiredFields =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AlgorithmCopyWith<Algorithm> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AlgorithmCopyWith<$Res> {
  factory $AlgorithmCopyWith(Algorithm value, $Res Function(Algorithm) then) =
      _$AlgorithmCopyWithImpl<$Res, Algorithm>;
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      @IconOrNullConverter() IconData? icon,
      bool isEnabled,
      List<String> categoriesIds,
      bool canBeInSensors,
      bool hasHttp,
      bool hasFtp,
      List<CredentialField> requiredFields});
}

/// @nodoc
class _$AlgorithmCopyWithImpl<$Res, $Val extends Algorithm>
    implements $AlgorithmCopyWith<$Res> {
  _$AlgorithmCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? icon = freezed,
    Object? isEnabled = null,
    Object? categoriesIds = null,
    Object? canBeInSensors = null,
    Object? hasHttp = null,
    Object? hasFtp = null,
    Object? requiredFields = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      categoriesIds: null == categoriesIds
          ? _value.categoriesIds
          : categoriesIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      canBeInSensors: null == canBeInSensors
          ? _value.canBeInSensors
          : canBeInSensors // ignore: cast_nullable_to_non_nullable
              as bool,
      hasHttp: null == hasHttp
          ? _value.hasHttp
          : hasHttp // ignore: cast_nullable_to_non_nullable
              as bool,
      hasFtp: null == hasFtp
          ? _value.hasFtp
          : hasFtp // ignore: cast_nullable_to_non_nullable
              as bool,
      requiredFields: null == requiredFields
          ? _value.requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AlgorithmCopyWith<$Res> implements $AlgorithmCopyWith<$Res> {
  factory _$$_AlgorithmCopyWith(
          _$_Algorithm value, $Res Function(_$_Algorithm) then) =
      __$$_AlgorithmCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      @IconOrNullConverter() IconData? icon,
      bool isEnabled,
      List<String> categoriesIds,
      bool canBeInSensors,
      bool hasHttp,
      bool hasFtp,
      List<CredentialField> requiredFields});
}

/// @nodoc
class __$$_AlgorithmCopyWithImpl<$Res>
    extends _$AlgorithmCopyWithImpl<$Res, _$_Algorithm>
    implements _$$_AlgorithmCopyWith<$Res> {
  __$$_AlgorithmCopyWithImpl(
      _$_Algorithm _value, $Res Function(_$_Algorithm) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? icon = freezed,
    Object? isEnabled = null,
    Object? categoriesIds = null,
    Object? canBeInSensors = null,
    Object? hasHttp = null,
    Object? hasFtp = null,
    Object? requiredFields = null,
  }) {
    return _then(_$_Algorithm(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      categoriesIds: null == categoriesIds
          ? _value._categoriesIds
          : categoriesIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      canBeInSensors: null == canBeInSensors
          ? _value.canBeInSensors
          : canBeInSensors // ignore: cast_nullable_to_non_nullable
              as bool,
      hasHttp: null == hasHttp
          ? _value.hasHttp
          : hasHttp // ignore: cast_nullable_to_non_nullable
              as bool,
      hasFtp: null == hasFtp
          ? _value.hasFtp
          : hasFtp // ignore: cast_nullable_to_non_nullable
              as bool,
      requiredFields: null == requiredFields
          ? _value._requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Algorithm implements _Algorithm {
  const _$_Algorithm(
      {required this.id,
      required this.name,
      @ColorConverter() required this.color,
      @IconOrNullConverter() this.icon,
      required this.isEnabled,
      final List<String> categoriesIds = const [],
      this.canBeInSensors = false,
      this.hasHttp = false,
      this.hasFtp = false,
      final List<CredentialField> requiredFields = const []})
      : _categoriesIds = categoriesIds,
        _requiredFields = requiredFields;

  factory _$_Algorithm.fromJson(Map<String, dynamic> json) =>
      _$$_AlgorithmFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  @ColorConverter()
  final Color color;
  @override
  @IconOrNullConverter()
  final IconData? icon;
  @override
  final bool isEnabled;
  final List<String> _categoriesIds;
  @override
  @JsonKey()
  List<String> get categoriesIds {
    if (_categoriesIds is EqualUnmodifiableListView) return _categoriesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categoriesIds);
  }

  @override
  @JsonKey()
  final bool canBeInSensors;
  @override
  @JsonKey()
  final bool hasHttp;
  @override
  @JsonKey()
  final bool hasFtp;
  final List<CredentialField> _requiredFields;
  @override
  @JsonKey()
  List<CredentialField> get requiredFields {
    if (_requiredFields is EqualUnmodifiableListView) return _requiredFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requiredFields);
  }

  @override
  String toString() {
    return 'Algorithm(id: $id, name: $name, color: $color, icon: $icon, isEnabled: $isEnabled, categoriesIds: $categoriesIds, canBeInSensors: $canBeInSensors, hasHttp: $hasHttp, hasFtp: $hasFtp, requiredFields: $requiredFields)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Algorithm &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.icon, icon) || other.icon == icon) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            const DeepCollectionEquality()
                .equals(other._categoriesIds, _categoriesIds) &&
            (identical(other.canBeInSensors, canBeInSensors) ||
                other.canBeInSensors == canBeInSensors) &&
            (identical(other.hasHttp, hasHttp) || other.hasHttp == hasHttp) &&
            (identical(other.hasFtp, hasFtp) || other.hasFtp == hasFtp) &&
            const DeepCollectionEquality()
                .equals(other._requiredFields, _requiredFields));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      color,
      icon,
      isEnabled,
      const DeepCollectionEquality().hash(_categoriesIds),
      canBeInSensors,
      hasHttp,
      hasFtp,
      const DeepCollectionEquality().hash(_requiredFields));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AlgorithmCopyWith<_$_Algorithm> get copyWith =>
      __$$_AlgorithmCopyWithImpl<_$_Algorithm>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AlgorithmToJson(
      this,
    );
  }
}

abstract class _Algorithm implements Algorithm {
  const factory _Algorithm(
      {required final String id,
      required final String name,
      @ColorConverter() required final Color color,
      @IconOrNullConverter() final IconData? icon,
      required final bool isEnabled,
      final List<String> categoriesIds,
      final bool canBeInSensors,
      final bool hasHttp,
      final bool hasFtp,
      final List<CredentialField> requiredFields}) = _$_Algorithm;

  factory _Algorithm.fromJson(Map<String, dynamic> json) =
      _$_Algorithm.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  @ColorConverter()
  Color get color;
  @override
  @IconOrNullConverter()
  IconData? get icon;
  @override
  bool get isEnabled;
  @override
  List<String> get categoriesIds;
  @override
  bool get canBeInSensors;
  @override
  bool get hasHttp;
  @override
  bool get hasFtp;
  @override
  List<CredentialField> get requiredFields;
  @override
  @JsonKey(ignore: true)
  _$$_AlgorithmCopyWith<_$_Algorithm> get copyWith =>
      throw _privateConstructorUsedError;
}

RealtimeEndpoint _$RealtimeEndpointFromJson(Map<String, dynamic> json) {
  return _RealtimeEndpoint.fromJson(json);
}

/// @nodoc
mixin _$RealtimeEndpoint {
  String? get host => throw _privateConstructorUsedError;
  int? get port => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RealtimeEndpointCopyWith<RealtimeEndpoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RealtimeEndpointCopyWith<$Res> {
  factory $RealtimeEndpointCopyWith(
          RealtimeEndpoint value, $Res Function(RealtimeEndpoint) then) =
      _$RealtimeEndpointCopyWithImpl<$Res, RealtimeEndpoint>;
  @useResult
  $Res call({String? host, int? port});
}

/// @nodoc
class _$RealtimeEndpointCopyWithImpl<$Res, $Val extends RealtimeEndpoint>
    implements $RealtimeEndpointCopyWith<$Res> {
  _$RealtimeEndpointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? host = freezed,
    Object? port = freezed,
  }) {
    return _then(_value.copyWith(
      host: freezed == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String?,
      port: freezed == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_RealtimeEndpointCopyWith<$Res>
    implements $RealtimeEndpointCopyWith<$Res> {
  factory _$$_RealtimeEndpointCopyWith(
          _$_RealtimeEndpoint value, $Res Function(_$_RealtimeEndpoint) then) =
      __$$_RealtimeEndpointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? host, int? port});
}

/// @nodoc
class __$$_RealtimeEndpointCopyWithImpl<$Res>
    extends _$RealtimeEndpointCopyWithImpl<$Res, _$_RealtimeEndpoint>
    implements _$$_RealtimeEndpointCopyWith<$Res> {
  __$$_RealtimeEndpointCopyWithImpl(
      _$_RealtimeEndpoint _value, $Res Function(_$_RealtimeEndpoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? host = freezed,
    Object? port = freezed,
  }) {
    return _then(_$_RealtimeEndpoint(
      host: freezed == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String?,
      port: freezed == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RealtimeEndpoint implements _RealtimeEndpoint {
  const _$_RealtimeEndpoint({this.host, this.port});

  factory _$_RealtimeEndpoint.fromJson(Map<String, dynamic> json) =>
      _$$_RealtimeEndpointFromJson(json);

  @override
  final String? host;
  @override
  final int? port;

  @override
  String toString() {
    return 'RealtimeEndpoint(host: $host, port: $port)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RealtimeEndpoint &&
            (identical(other.host, host) || other.host == host) &&
            (identical(other.port, port) || other.port == port));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, host, port);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RealtimeEndpointCopyWith<_$_RealtimeEndpoint> get copyWith =>
      __$$_RealtimeEndpointCopyWithImpl<_$_RealtimeEndpoint>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RealtimeEndpointToJson(
      this,
    );
  }
}

abstract class _RealtimeEndpoint implements RealtimeEndpoint {
  const factory _RealtimeEndpoint({final String? host, final int? port}) =
      _$_RealtimeEndpoint;

  factory _RealtimeEndpoint.fromJson(Map<String, dynamic> json) =
      _$_RealtimeEndpoint.fromJson;

  @override
  String? get host;
  @override
  int? get port;
  @override
  @JsonKey(ignore: true)
  _$$_RealtimeEndpointCopyWith<_$_RealtimeEndpoint> get copyWith =>
      throw _privateConstructorUsedError;
}

RealtimeVariantEndpoint _$RealtimeVariantEndpointFromJson(
    Map<String, dynamic> json) {
  return _RealtimeVariantEndpoint.fromJson(json);
}

/// @nodoc
mixin _$RealtimeVariantEndpoint {
  String? get dataTopic => throw _privateConstructorUsedError;
  String? get eventsTopic => throw _privateConstructorUsedError;
  String? get realtimeTopic => throw _privateConstructorUsedError;
  String? get commandTopic => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RealtimeVariantEndpointCopyWith<RealtimeVariantEndpoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RealtimeVariantEndpointCopyWith<$Res> {
  factory $RealtimeVariantEndpointCopyWith(RealtimeVariantEndpoint value,
          $Res Function(RealtimeVariantEndpoint) then) =
      _$RealtimeVariantEndpointCopyWithImpl<$Res, RealtimeVariantEndpoint>;
  @useResult
  $Res call(
      {String? dataTopic,
      String? eventsTopic,
      String? realtimeTopic,
      String? commandTopic});
}

/// @nodoc
class _$RealtimeVariantEndpointCopyWithImpl<$Res,
        $Val extends RealtimeVariantEndpoint>
    implements $RealtimeVariantEndpointCopyWith<$Res> {
  _$RealtimeVariantEndpointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dataTopic = freezed,
    Object? eventsTopic = freezed,
    Object? realtimeTopic = freezed,
    Object? commandTopic = freezed,
  }) {
    return _then(_value.copyWith(
      dataTopic: freezed == dataTopic
          ? _value.dataTopic
          : dataTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      eventsTopic: freezed == eventsTopic
          ? _value.eventsTopic
          : eventsTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      realtimeTopic: freezed == realtimeTopic
          ? _value.realtimeTopic
          : realtimeTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      commandTopic: freezed == commandTopic
          ? _value.commandTopic
          : commandTopic // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_RealtimeVariantEndpointCopyWith<$Res>
    implements $RealtimeVariantEndpointCopyWith<$Res> {
  factory _$$_RealtimeVariantEndpointCopyWith(_$_RealtimeVariantEndpoint value,
          $Res Function(_$_RealtimeVariantEndpoint) then) =
      __$$_RealtimeVariantEndpointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? dataTopic,
      String? eventsTopic,
      String? realtimeTopic,
      String? commandTopic});
}

/// @nodoc
class __$$_RealtimeVariantEndpointCopyWithImpl<$Res>
    extends _$RealtimeVariantEndpointCopyWithImpl<$Res,
        _$_RealtimeVariantEndpoint>
    implements _$$_RealtimeVariantEndpointCopyWith<$Res> {
  __$$_RealtimeVariantEndpointCopyWithImpl(_$_RealtimeVariantEndpoint _value,
      $Res Function(_$_RealtimeVariantEndpoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dataTopic = freezed,
    Object? eventsTopic = freezed,
    Object? realtimeTopic = freezed,
    Object? commandTopic = freezed,
  }) {
    return _then(_$_RealtimeVariantEndpoint(
      dataTopic: freezed == dataTopic
          ? _value.dataTopic
          : dataTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      eventsTopic: freezed == eventsTopic
          ? _value.eventsTopic
          : eventsTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      realtimeTopic: freezed == realtimeTopic
          ? _value.realtimeTopic
          : realtimeTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      commandTopic: freezed == commandTopic
          ? _value.commandTopic
          : commandTopic // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RealtimeVariantEndpoint implements _RealtimeVariantEndpoint {
  const _$_RealtimeVariantEndpoint(
      {this.dataTopic,
      this.eventsTopic,
      this.realtimeTopic,
      this.commandTopic});

  factory _$_RealtimeVariantEndpoint.fromJson(Map<String, dynamic> json) =>
      _$$_RealtimeVariantEndpointFromJson(json);

  @override
  final String? dataTopic;
  @override
  final String? eventsTopic;
  @override
  final String? realtimeTopic;
  @override
  final String? commandTopic;

  @override
  String toString() {
    return 'RealtimeVariantEndpoint(dataTopic: $dataTopic, eventsTopic: $eventsTopic, realtimeTopic: $realtimeTopic, commandTopic: $commandTopic)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RealtimeVariantEndpoint &&
            (identical(other.dataTopic, dataTopic) ||
                other.dataTopic == dataTopic) &&
            (identical(other.eventsTopic, eventsTopic) ||
                other.eventsTopic == eventsTopic) &&
            (identical(other.realtimeTopic, realtimeTopic) ||
                other.realtimeTopic == realtimeTopic) &&
            (identical(other.commandTopic, commandTopic) ||
                other.commandTopic == commandTopic));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, dataTopic, eventsTopic, realtimeTopic, commandTopic);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RealtimeVariantEndpointCopyWith<_$_RealtimeVariantEndpoint>
      get copyWith =>
          __$$_RealtimeVariantEndpointCopyWithImpl<_$_RealtimeVariantEndpoint>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RealtimeVariantEndpointToJson(
      this,
    );
  }
}

abstract class _RealtimeVariantEndpoint implements RealtimeVariantEndpoint {
  const factory _RealtimeVariantEndpoint(
      {final String? dataTopic,
      final String? eventsTopic,
      final String? realtimeTopic,
      final String? commandTopic}) = _$_RealtimeVariantEndpoint;

  factory _RealtimeVariantEndpoint.fromJson(Map<String, dynamic> json) =
      _$_RealtimeVariantEndpoint.fromJson;

  @override
  String? get dataTopic;
  @override
  String? get eventsTopic;
  @override
  String? get realtimeTopic;
  @override
  String? get commandTopic;
  @override
  @JsonKey(ignore: true)
  _$$_RealtimeVariantEndpointCopyWith<_$_RealtimeVariantEndpoint>
      get copyWith => throw _privateConstructorUsedError;
}

InboundProtocol _$InboundProtocolFromJson(Map<String, dynamic> json) {
  return _InboundProtocol.fromJson(json);
}

/// @nodoc
mixin _$InboundProtocol {
  /// The protocol ID
  String get id => throw _privateConstructorUsedError;

  /// The name of the protocol
  String get name => throw _privateConstructorUsedError;

  /// Indicates the color assigned to the protocol
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;

  /// Indicates if the protocol is enabled and available for use, or disabled and not available for use.
  bool get isEnabled => throw _privateConstructorUsedError;

  /// Indicates the operation mode of the protocol.
  @OperationModeConverter()
  OperationMode get operationMode => throw _privateConstructorUsedError;

  /// Indicates the [host] and [port] server. Only when [operationMode] is [OperationMode.realtime]
  RealtimeEndpoint? get realtimeEndpoint => throw _privateConstructorUsedError;

  /// Indicates the [dataTopic], [eventsTopic], [realtimeTopic] and [commandTopic] server.
  /// Only when [operationMode] is [OperationMode.realtime]
  RealtimeVariantEndpoint? get realtimeVariantEndpoint =>
      throw _privateConstructorUsedError;

  /// Indicates if the protocol has support for commands, depending on the field, means:
  /// for [hasNativeCommands] = true, the protocol has support for commands through the protocol itself
  /// for [hasSmsCommands] = true, the protocol has support for commands through a SMS gateway
  /// !Important: [hasNativeCommands] and [hasSmsCommands] can be true at the same time
  bool? get hasNativeCommands => throw _privateConstructorUsedError;
  bool? get hasSmsCommands => throw _privateConstructorUsedError;

  /// Indicates if the protocol has support for command ACK, only valid for [hasNativeCommands] = true
  bool? get hasCommandsResult => throw _privateConstructorUsedError;

  /// [isFlespi], [channelId], [maxPerReceptor] and [flespiId] are the fields for Flespi protocols.
  /// Indicates if the protocol is from Flespi or not
  bool? get isFlespi => throw _privateConstructorUsedError;

  /// Indicates the Flespi Channel ID.
  int? get channelId => throw _privateConstructorUsedError;

  /// Indicates the maximum amount of devices supported/handled by each receptor.
  int? get maxPerReceptor => throw _privateConstructorUsedError;

  /// Indicates the ID of the protocol in Flespi.
  String? get flespiId => throw _privateConstructorUsedError;

  /// Indicates the structure or required fields for the protocol use.
  List<CredentialField>? get requiredFields =>
      throw _privateConstructorUsedError;

  /// Indicates if the devices only can be created through import
  bool? get isImported => throw _privateConstructorUsedError;

  /// Indicates the list of categories assigned to the protocol
  List<String>? get categoriesIds => throw _privateConstructorUsedError;

  /// Indicates if the protocol has support for Firmware Over The Air (FOTA)
  bool? get canFota => throw _privateConstructorUsedError;

  /// Indicates the list of models linked to the protocol
  List<Model>? get models => throw _privateConstructorUsedError;

  /// Indicates if the protocol has support for ACK through the protocol itself.
  /// [hasAck] is the [bool] value that indicates if the protocol has support for ACK.
  /// and [ackTopicFormat] is the [String] value that indicates the format of the topic to send the ACK.
  /// Currently only works for Layrz Link protocol.
  bool? get hasAck => throw _privateConstructorUsedError;
  String? get ackTopicFormat => throw _privateConstructorUsedError;

  /// [dynamicIcon] is the icon of the inbound protocol.
  /// This is the new schema of the icon
  Avatar? get dynamicIcon => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InboundProtocolCopyWith<InboundProtocol> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InboundProtocolCopyWith<$Res> {
  factory $InboundProtocolCopyWith(
          InboundProtocol value, $Res Function(InboundProtocol) then) =
      _$InboundProtocolCopyWithImpl<$Res, InboundProtocol>;
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      bool isEnabled,
      @OperationModeConverter() OperationMode operationMode,
      RealtimeEndpoint? realtimeEndpoint,
      RealtimeVariantEndpoint? realtimeVariantEndpoint,
      bool? hasNativeCommands,
      bool? hasSmsCommands,
      bool? hasCommandsResult,
      bool? isFlespi,
      int? channelId,
      int? maxPerReceptor,
      String? flespiId,
      List<CredentialField>? requiredFields,
      bool? isImported,
      List<String>? categoriesIds,
      bool? canFota,
      List<Model>? models,
      bool? hasAck,
      String? ackTopicFormat,
      Avatar? dynamicIcon});

  $RealtimeEndpointCopyWith<$Res>? get realtimeEndpoint;
  $RealtimeVariantEndpointCopyWith<$Res>? get realtimeVariantEndpoint;
  $AvatarCopyWith<$Res>? get dynamicIcon;
}

/// @nodoc
class _$InboundProtocolCopyWithImpl<$Res, $Val extends InboundProtocol>
    implements $InboundProtocolCopyWith<$Res> {
  _$InboundProtocolCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? isEnabled = null,
    Object? operationMode = null,
    Object? realtimeEndpoint = freezed,
    Object? realtimeVariantEndpoint = freezed,
    Object? hasNativeCommands = freezed,
    Object? hasSmsCommands = freezed,
    Object? hasCommandsResult = freezed,
    Object? isFlespi = freezed,
    Object? channelId = freezed,
    Object? maxPerReceptor = freezed,
    Object? flespiId = freezed,
    Object? requiredFields = freezed,
    Object? isImported = freezed,
    Object? categoriesIds = freezed,
    Object? canFota = freezed,
    Object? models = freezed,
    Object? hasAck = freezed,
    Object? ackTopicFormat = freezed,
    Object? dynamicIcon = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      operationMode: null == operationMode
          ? _value.operationMode
          : operationMode // ignore: cast_nullable_to_non_nullable
              as OperationMode,
      realtimeEndpoint: freezed == realtimeEndpoint
          ? _value.realtimeEndpoint
          : realtimeEndpoint // ignore: cast_nullable_to_non_nullable
              as RealtimeEndpoint?,
      realtimeVariantEndpoint: freezed == realtimeVariantEndpoint
          ? _value.realtimeVariantEndpoint
          : realtimeVariantEndpoint // ignore: cast_nullable_to_non_nullable
              as RealtimeVariantEndpoint?,
      hasNativeCommands: freezed == hasNativeCommands
          ? _value.hasNativeCommands
          : hasNativeCommands // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasSmsCommands: freezed == hasSmsCommands
          ? _value.hasSmsCommands
          : hasSmsCommands // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasCommandsResult: freezed == hasCommandsResult
          ? _value.hasCommandsResult
          : hasCommandsResult // ignore: cast_nullable_to_non_nullable
              as bool?,
      isFlespi: freezed == isFlespi
          ? _value.isFlespi
          : isFlespi // ignore: cast_nullable_to_non_nullable
              as bool?,
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as int?,
      maxPerReceptor: freezed == maxPerReceptor
          ? _value.maxPerReceptor
          : maxPerReceptor // ignore: cast_nullable_to_non_nullable
              as int?,
      flespiId: freezed == flespiId
          ? _value.flespiId
          : flespiId // ignore: cast_nullable_to_non_nullable
              as String?,
      requiredFields: freezed == requiredFields
          ? _value.requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>?,
      isImported: freezed == isImported
          ? _value.isImported
          : isImported // ignore: cast_nullable_to_non_nullable
              as bool?,
      categoriesIds: freezed == categoriesIds
          ? _value.categoriesIds
          : categoriesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      canFota: freezed == canFota
          ? _value.canFota
          : canFota // ignore: cast_nullable_to_non_nullable
              as bool?,
      models: freezed == models
          ? _value.models
          : models // ignore: cast_nullable_to_non_nullable
              as List<Model>?,
      hasAck: freezed == hasAck
          ? _value.hasAck
          : hasAck // ignore: cast_nullable_to_non_nullable
              as bool?,
      ackTopicFormat: freezed == ackTopicFormat
          ? _value.ackTopicFormat
          : ackTopicFormat // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicIcon: freezed == dynamicIcon
          ? _value.dynamicIcon
          : dynamicIcon // ignore: cast_nullable_to_non_nullable
              as Avatar?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $RealtimeEndpointCopyWith<$Res>? get realtimeEndpoint {
    if (_value.realtimeEndpoint == null) {
      return null;
    }

    return $RealtimeEndpointCopyWith<$Res>(_value.realtimeEndpoint!, (value) {
      return _then(_value.copyWith(realtimeEndpoint: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RealtimeVariantEndpointCopyWith<$Res>? get realtimeVariantEndpoint {
    if (_value.realtimeVariantEndpoint == null) {
      return null;
    }

    return $RealtimeVariantEndpointCopyWith<$Res>(
        _value.realtimeVariantEndpoint!, (value) {
      return _then(_value.copyWith(realtimeVariantEndpoint: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AvatarCopyWith<$Res>? get dynamicIcon {
    if (_value.dynamicIcon == null) {
      return null;
    }

    return $AvatarCopyWith<$Res>(_value.dynamicIcon!, (value) {
      return _then(_value.copyWith(dynamicIcon: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_InboundProtocolCopyWith<$Res>
    implements $InboundProtocolCopyWith<$Res> {
  factory _$$_InboundProtocolCopyWith(
          _$_InboundProtocol value, $Res Function(_$_InboundProtocol) then) =
      __$$_InboundProtocolCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      bool isEnabled,
      @OperationModeConverter() OperationMode operationMode,
      RealtimeEndpoint? realtimeEndpoint,
      RealtimeVariantEndpoint? realtimeVariantEndpoint,
      bool? hasNativeCommands,
      bool? hasSmsCommands,
      bool? hasCommandsResult,
      bool? isFlespi,
      int? channelId,
      int? maxPerReceptor,
      String? flespiId,
      List<CredentialField>? requiredFields,
      bool? isImported,
      List<String>? categoriesIds,
      bool? canFota,
      List<Model>? models,
      bool? hasAck,
      String? ackTopicFormat,
      Avatar? dynamicIcon});

  @override
  $RealtimeEndpointCopyWith<$Res>? get realtimeEndpoint;
  @override
  $RealtimeVariantEndpointCopyWith<$Res>? get realtimeVariantEndpoint;
  @override
  $AvatarCopyWith<$Res>? get dynamicIcon;
}

/// @nodoc
class __$$_InboundProtocolCopyWithImpl<$Res>
    extends _$InboundProtocolCopyWithImpl<$Res, _$_InboundProtocol>
    implements _$$_InboundProtocolCopyWith<$Res> {
  __$$_InboundProtocolCopyWithImpl(
      _$_InboundProtocol _value, $Res Function(_$_InboundProtocol) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? isEnabled = null,
    Object? operationMode = null,
    Object? realtimeEndpoint = freezed,
    Object? realtimeVariantEndpoint = freezed,
    Object? hasNativeCommands = freezed,
    Object? hasSmsCommands = freezed,
    Object? hasCommandsResult = freezed,
    Object? isFlespi = freezed,
    Object? channelId = freezed,
    Object? maxPerReceptor = freezed,
    Object? flespiId = freezed,
    Object? requiredFields = freezed,
    Object? isImported = freezed,
    Object? categoriesIds = freezed,
    Object? canFota = freezed,
    Object? models = freezed,
    Object? hasAck = freezed,
    Object? ackTopicFormat = freezed,
    Object? dynamicIcon = freezed,
  }) {
    return _then(_$_InboundProtocol(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      operationMode: null == operationMode
          ? _value.operationMode
          : operationMode // ignore: cast_nullable_to_non_nullable
              as OperationMode,
      realtimeEndpoint: freezed == realtimeEndpoint
          ? _value.realtimeEndpoint
          : realtimeEndpoint // ignore: cast_nullable_to_non_nullable
              as RealtimeEndpoint?,
      realtimeVariantEndpoint: freezed == realtimeVariantEndpoint
          ? _value.realtimeVariantEndpoint
          : realtimeVariantEndpoint // ignore: cast_nullable_to_non_nullable
              as RealtimeVariantEndpoint?,
      hasNativeCommands: freezed == hasNativeCommands
          ? _value.hasNativeCommands
          : hasNativeCommands // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasSmsCommands: freezed == hasSmsCommands
          ? _value.hasSmsCommands
          : hasSmsCommands // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasCommandsResult: freezed == hasCommandsResult
          ? _value.hasCommandsResult
          : hasCommandsResult // ignore: cast_nullable_to_non_nullable
              as bool?,
      isFlespi: freezed == isFlespi
          ? _value.isFlespi
          : isFlespi // ignore: cast_nullable_to_non_nullable
              as bool?,
      channelId: freezed == channelId
          ? _value.channelId
          : channelId // ignore: cast_nullable_to_non_nullable
              as int?,
      maxPerReceptor: freezed == maxPerReceptor
          ? _value.maxPerReceptor
          : maxPerReceptor // ignore: cast_nullable_to_non_nullable
              as int?,
      flespiId: freezed == flespiId
          ? _value.flespiId
          : flespiId // ignore: cast_nullable_to_non_nullable
              as String?,
      requiredFields: freezed == requiredFields
          ? _value._requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>?,
      isImported: freezed == isImported
          ? _value.isImported
          : isImported // ignore: cast_nullable_to_non_nullable
              as bool?,
      categoriesIds: freezed == categoriesIds
          ? _value._categoriesIds
          : categoriesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      canFota: freezed == canFota
          ? _value.canFota
          : canFota // ignore: cast_nullable_to_non_nullable
              as bool?,
      models: freezed == models
          ? _value._models
          : models // ignore: cast_nullable_to_non_nullable
              as List<Model>?,
      hasAck: freezed == hasAck
          ? _value.hasAck
          : hasAck // ignore: cast_nullable_to_non_nullable
              as bool?,
      ackTopicFormat: freezed == ackTopicFormat
          ? _value.ackTopicFormat
          : ackTopicFormat // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicIcon: freezed == dynamicIcon
          ? _value.dynamicIcon
          : dynamicIcon // ignore: cast_nullable_to_non_nullable
              as Avatar?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_InboundProtocol implements _InboundProtocol {
  const _$_InboundProtocol(
      {required this.id,
      required this.name,
      @ColorConverter() required this.color,
      required this.isEnabled,
      @OperationModeConverter() required this.operationMode,
      this.realtimeEndpoint,
      this.realtimeVariantEndpoint,
      this.hasNativeCommands,
      this.hasSmsCommands,
      this.hasCommandsResult,
      this.isFlespi,
      this.channelId,
      this.maxPerReceptor,
      this.flespiId,
      final List<CredentialField>? requiredFields,
      this.isImported,
      final List<String>? categoriesIds,
      this.canFota,
      final List<Model>? models,
      this.hasAck,
      this.ackTopicFormat,
      this.dynamicIcon})
      : _requiredFields = requiredFields,
        _categoriesIds = categoriesIds,
        _models = models;

  factory _$_InboundProtocol.fromJson(Map<String, dynamic> json) =>
      _$$_InboundProtocolFromJson(json);

  /// The protocol ID
  @override
  final String id;

  /// The name of the protocol
  @override
  final String name;

  /// Indicates the color assigned to the protocol
  @override
  @ColorConverter()
  final Color color;

  /// Indicates if the protocol is enabled and available for use, or disabled and not available for use.
  @override
  final bool isEnabled;

  /// Indicates the operation mode of the protocol.
  @override
  @OperationModeConverter()
  final OperationMode operationMode;

  /// Indicates the [host] and [port] server. Only when [operationMode] is [OperationMode.realtime]
  @override
  final RealtimeEndpoint? realtimeEndpoint;

  /// Indicates the [dataTopic], [eventsTopic], [realtimeTopic] and [commandTopic] server.
  /// Only when [operationMode] is [OperationMode.realtime]
  @override
  final RealtimeVariantEndpoint? realtimeVariantEndpoint;

  /// Indicates if the protocol has support for commands, depending on the field, means:
  /// for [hasNativeCommands] = true, the protocol has support for commands through the protocol itself
  /// for [hasSmsCommands] = true, the protocol has support for commands through a SMS gateway
  /// !Important: [hasNativeCommands] and [hasSmsCommands] can be true at the same time
  @override
  final bool? hasNativeCommands;
  @override
  final bool? hasSmsCommands;

  /// Indicates if the protocol has support for command ACK, only valid for [hasNativeCommands] = true
  @override
  final bool? hasCommandsResult;

  /// [isFlespi], [channelId], [maxPerReceptor] and [flespiId] are the fields for Flespi protocols.
  /// Indicates if the protocol is from Flespi or not
  @override
  final bool? isFlespi;

  /// Indicates the Flespi Channel ID.
  @override
  final int? channelId;

  /// Indicates the maximum amount of devices supported/handled by each receptor.
  @override
  final int? maxPerReceptor;

  /// Indicates the ID of the protocol in Flespi.
  @override
  final String? flespiId;

  /// Indicates the structure or required fields for the protocol use.
  final List<CredentialField>? _requiredFields;

  /// Indicates the structure or required fields for the protocol use.
  @override
  List<CredentialField>? get requiredFields {
    final value = _requiredFields;
    if (value == null) return null;
    if (_requiredFields is EqualUnmodifiableListView) return _requiredFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Indicates if the devices only can be created through import
  @override
  final bool? isImported;

  /// Indicates the list of categories assigned to the protocol
  final List<String>? _categoriesIds;

  /// Indicates the list of categories assigned to the protocol
  @override
  List<String>? get categoriesIds {
    final value = _categoriesIds;
    if (value == null) return null;
    if (_categoriesIds is EqualUnmodifiableListView) return _categoriesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Indicates if the protocol has support for Firmware Over The Air (FOTA)
  @override
  final bool? canFota;

  /// Indicates the list of models linked to the protocol
  final List<Model>? _models;

  /// Indicates the list of models linked to the protocol
  @override
  List<Model>? get models {
    final value = _models;
    if (value == null) return null;
    if (_models is EqualUnmodifiableListView) return _models;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Indicates if the protocol has support for ACK through the protocol itself.
  /// [hasAck] is the [bool] value that indicates if the protocol has support for ACK.
  /// and [ackTopicFormat] is the [String] value that indicates the format of the topic to send the ACK.
  /// Currently only works for Layrz Link protocol.
  @override
  final bool? hasAck;
  @override
  final String? ackTopicFormat;

  /// [dynamicIcon] is the icon of the inbound protocol.
  /// This is the new schema of the icon
  @override
  final Avatar? dynamicIcon;

  @override
  String toString() {
    return 'InboundProtocol(id: $id, name: $name, color: $color, isEnabled: $isEnabled, operationMode: $operationMode, realtimeEndpoint: $realtimeEndpoint, realtimeVariantEndpoint: $realtimeVariantEndpoint, hasNativeCommands: $hasNativeCommands, hasSmsCommands: $hasSmsCommands, hasCommandsResult: $hasCommandsResult, isFlespi: $isFlespi, channelId: $channelId, maxPerReceptor: $maxPerReceptor, flespiId: $flespiId, requiredFields: $requiredFields, isImported: $isImported, categoriesIds: $categoriesIds, canFota: $canFota, models: $models, hasAck: $hasAck, ackTopicFormat: $ackTopicFormat, dynamicIcon: $dynamicIcon)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InboundProtocol &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            (identical(other.operationMode, operationMode) ||
                other.operationMode == operationMode) &&
            (identical(other.realtimeEndpoint, realtimeEndpoint) ||
                other.realtimeEndpoint == realtimeEndpoint) &&
            (identical(
                    other.realtimeVariantEndpoint, realtimeVariantEndpoint) ||
                other.realtimeVariantEndpoint == realtimeVariantEndpoint) &&
            (identical(other.hasNativeCommands, hasNativeCommands) ||
                other.hasNativeCommands == hasNativeCommands) &&
            (identical(other.hasSmsCommands, hasSmsCommands) ||
                other.hasSmsCommands == hasSmsCommands) &&
            (identical(other.hasCommandsResult, hasCommandsResult) ||
                other.hasCommandsResult == hasCommandsResult) &&
            (identical(other.isFlespi, isFlespi) ||
                other.isFlespi == isFlespi) &&
            (identical(other.channelId, channelId) ||
                other.channelId == channelId) &&
            (identical(other.maxPerReceptor, maxPerReceptor) ||
                other.maxPerReceptor == maxPerReceptor) &&
            (identical(other.flespiId, flespiId) ||
                other.flespiId == flespiId) &&
            const DeepCollectionEquality()
                .equals(other._requiredFields, _requiredFields) &&
            (identical(other.isImported, isImported) ||
                other.isImported == isImported) &&
            const DeepCollectionEquality()
                .equals(other._categoriesIds, _categoriesIds) &&
            (identical(other.canFota, canFota) || other.canFota == canFota) &&
            const DeepCollectionEquality().equals(other._models, _models) &&
            (identical(other.hasAck, hasAck) || other.hasAck == hasAck) &&
            (identical(other.ackTopicFormat, ackTopicFormat) ||
                other.ackTopicFormat == ackTopicFormat) &&
            (identical(other.dynamicIcon, dynamicIcon) ||
                other.dynamicIcon == dynamicIcon));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        color,
        isEnabled,
        operationMode,
        realtimeEndpoint,
        realtimeVariantEndpoint,
        hasNativeCommands,
        hasSmsCommands,
        hasCommandsResult,
        isFlespi,
        channelId,
        maxPerReceptor,
        flespiId,
        const DeepCollectionEquality().hash(_requiredFields),
        isImported,
        const DeepCollectionEquality().hash(_categoriesIds),
        canFota,
        const DeepCollectionEquality().hash(_models),
        hasAck,
        ackTopicFormat,
        dynamicIcon
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InboundProtocolCopyWith<_$_InboundProtocol> get copyWith =>
      __$$_InboundProtocolCopyWithImpl<_$_InboundProtocol>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InboundProtocolToJson(
      this,
    );
  }
}

abstract class _InboundProtocol implements InboundProtocol {
  const factory _InboundProtocol(
      {required final String id,
      required final String name,
      @ColorConverter() required final Color color,
      required final bool isEnabled,
      @OperationModeConverter() required final OperationMode operationMode,
      final RealtimeEndpoint? realtimeEndpoint,
      final RealtimeVariantEndpoint? realtimeVariantEndpoint,
      final bool? hasNativeCommands,
      final bool? hasSmsCommands,
      final bool? hasCommandsResult,
      final bool? isFlespi,
      final int? channelId,
      final int? maxPerReceptor,
      final String? flespiId,
      final List<CredentialField>? requiredFields,
      final bool? isImported,
      final List<String>? categoriesIds,
      final bool? canFota,
      final List<Model>? models,
      final bool? hasAck,
      final String? ackTopicFormat,
      final Avatar? dynamicIcon}) = _$_InboundProtocol;

  factory _InboundProtocol.fromJson(Map<String, dynamic> json) =
      _$_InboundProtocol.fromJson;

  @override

  /// The protocol ID
  String get id;
  @override

  /// The name of the protocol
  String get name;
  @override

  /// Indicates the color assigned to the protocol
  @ColorConverter()
  Color get color;
  @override

  /// Indicates if the protocol is enabled and available for use, or disabled and not available for use.
  bool get isEnabled;
  @override

  /// Indicates the operation mode of the protocol.
  @OperationModeConverter()
  OperationMode get operationMode;
  @override

  /// Indicates the [host] and [port] server. Only when [operationMode] is [OperationMode.realtime]
  RealtimeEndpoint? get realtimeEndpoint;
  @override

  /// Indicates the [dataTopic], [eventsTopic], [realtimeTopic] and [commandTopic] server.
  /// Only when [operationMode] is [OperationMode.realtime]
  RealtimeVariantEndpoint? get realtimeVariantEndpoint;
  @override

  /// Indicates if the protocol has support for commands, depending on the field, means:
  /// for [hasNativeCommands] = true, the protocol has support for commands through the protocol itself
  /// for [hasSmsCommands] = true, the protocol has support for commands through a SMS gateway
  /// !Important: [hasNativeCommands] and [hasSmsCommands] can be true at the same time
  bool? get hasNativeCommands;
  @override
  bool? get hasSmsCommands;
  @override

  /// Indicates if the protocol has support for command ACK, only valid for [hasNativeCommands] = true
  bool? get hasCommandsResult;
  @override

  /// [isFlespi], [channelId], [maxPerReceptor] and [flespiId] are the fields for Flespi protocols.
  /// Indicates if the protocol is from Flespi or not
  bool? get isFlespi;
  @override

  /// Indicates the Flespi Channel ID.
  int? get channelId;
  @override

  /// Indicates the maximum amount of devices supported/handled by each receptor.
  int? get maxPerReceptor;
  @override

  /// Indicates the ID of the protocol in Flespi.
  String? get flespiId;
  @override

  /// Indicates the structure or required fields for the protocol use.
  List<CredentialField>? get requiredFields;
  @override

  /// Indicates if the devices only can be created through import
  bool? get isImported;
  @override

  /// Indicates the list of categories assigned to the protocol
  List<String>? get categoriesIds;
  @override

  /// Indicates if the protocol has support for Firmware Over The Air (FOTA)
  bool? get canFota;
  @override

  /// Indicates the list of models linked to the protocol
  List<Model>? get models;
  @override

  /// Indicates if the protocol has support for ACK through the protocol itself.
  /// [hasAck] is the [bool] value that indicates if the protocol has support for ACK.
  /// and [ackTopicFormat] is the [String] value that indicates the format of the topic to send the ACK.
  /// Currently only works for Layrz Link protocol.
  bool? get hasAck;
  @override
  String? get ackTopicFormat;
  @override

  /// [dynamicIcon] is the icon of the inbound protocol.
  /// This is the new schema of the icon
  Avatar? get dynamicIcon;
  @override
  @JsonKey(ignore: true)
  _$$_InboundProtocolCopyWith<_$_InboundProtocol> get copyWith =>
      throw _privateConstructorUsedError;
}

OutboundProtocol _$OutboundProtocolFromJson(Map<String, dynamic> json) {
  return _OutboundProtocol.fromJson(json);
}

/// @nodoc
mixin _$OutboundProtocol {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;
  bool get isEnabled => throw _privateConstructorUsedError;
  List<String> get categoriesIds => throw _privateConstructorUsedError;
  bool? get hasFtp => throw _privateConstructorUsedError;
  bool? get isConsumpted => throw _privateConstructorUsedError;
  String? get mqttTopic => throw _privateConstructorUsedError;
  bool? get isAsync => throw _privateConstructorUsedError;
  List<CredentialField> get requiredFields =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OutboundProtocolCopyWith<OutboundProtocol> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OutboundProtocolCopyWith<$Res> {
  factory $OutboundProtocolCopyWith(
          OutboundProtocol value, $Res Function(OutboundProtocol) then) =
      _$OutboundProtocolCopyWithImpl<$Res, OutboundProtocol>;
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      bool isEnabled,
      List<String> categoriesIds,
      bool? hasFtp,
      bool? isConsumpted,
      String? mqttTopic,
      bool? isAsync,
      List<CredentialField> requiredFields});
}

/// @nodoc
class _$OutboundProtocolCopyWithImpl<$Res, $Val extends OutboundProtocol>
    implements $OutboundProtocolCopyWith<$Res> {
  _$OutboundProtocolCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? isEnabled = null,
    Object? categoriesIds = null,
    Object? hasFtp = freezed,
    Object? isConsumpted = freezed,
    Object? mqttTopic = freezed,
    Object? isAsync = freezed,
    Object? requiredFields = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      categoriesIds: null == categoriesIds
          ? _value.categoriesIds
          : categoriesIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      hasFtp: freezed == hasFtp
          ? _value.hasFtp
          : hasFtp // ignore: cast_nullable_to_non_nullable
              as bool?,
      isConsumpted: freezed == isConsumpted
          ? _value.isConsumpted
          : isConsumpted // ignore: cast_nullable_to_non_nullable
              as bool?,
      mqttTopic: freezed == mqttTopic
          ? _value.mqttTopic
          : mqttTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      isAsync: freezed == isAsync
          ? _value.isAsync
          : isAsync // ignore: cast_nullable_to_non_nullable
              as bool?,
      requiredFields: null == requiredFields
          ? _value.requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_OutboundProtocolCopyWith<$Res>
    implements $OutboundProtocolCopyWith<$Res> {
  factory _$$_OutboundProtocolCopyWith(
          _$_OutboundProtocol value, $Res Function(_$_OutboundProtocol) then) =
      __$$_OutboundProtocolCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      bool isEnabled,
      List<String> categoriesIds,
      bool? hasFtp,
      bool? isConsumpted,
      String? mqttTopic,
      bool? isAsync,
      List<CredentialField> requiredFields});
}

/// @nodoc
class __$$_OutboundProtocolCopyWithImpl<$Res>
    extends _$OutboundProtocolCopyWithImpl<$Res, _$_OutboundProtocol>
    implements _$$_OutboundProtocolCopyWith<$Res> {
  __$$_OutboundProtocolCopyWithImpl(
      _$_OutboundProtocol _value, $Res Function(_$_OutboundProtocol) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? isEnabled = null,
    Object? categoriesIds = null,
    Object? hasFtp = freezed,
    Object? isConsumpted = freezed,
    Object? mqttTopic = freezed,
    Object? isAsync = freezed,
    Object? requiredFields = null,
  }) {
    return _then(_$_OutboundProtocol(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      categoriesIds: null == categoriesIds
          ? _value._categoriesIds
          : categoriesIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      hasFtp: freezed == hasFtp
          ? _value.hasFtp
          : hasFtp // ignore: cast_nullable_to_non_nullable
              as bool?,
      isConsumpted: freezed == isConsumpted
          ? _value.isConsumpted
          : isConsumpted // ignore: cast_nullable_to_non_nullable
              as bool?,
      mqttTopic: freezed == mqttTopic
          ? _value.mqttTopic
          : mqttTopic // ignore: cast_nullable_to_non_nullable
              as String?,
      isAsync: freezed == isAsync
          ? _value.isAsync
          : isAsync // ignore: cast_nullable_to_non_nullable
              as bool?,
      requiredFields: null == requiredFields
          ? _value._requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OutboundProtocol implements _OutboundProtocol {
  const _$_OutboundProtocol(
      {required this.id,
      required this.name,
      @ColorConverter() required this.color,
      required this.isEnabled,
      final List<String> categoriesIds = const [],
      this.hasFtp,
      this.isConsumpted,
      this.mqttTopic,
      this.isAsync,
      final List<CredentialField> requiredFields = const []})
      : _categoriesIds = categoriesIds,
        _requiredFields = requiredFields;

  factory _$_OutboundProtocol.fromJson(Map<String, dynamic> json) =>
      _$$_OutboundProtocolFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  @ColorConverter()
  final Color color;
  @override
  final bool isEnabled;
  final List<String> _categoriesIds;
  @override
  @JsonKey()
  List<String> get categoriesIds {
    if (_categoriesIds is EqualUnmodifiableListView) return _categoriesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_categoriesIds);
  }

  @override
  final bool? hasFtp;
  @override
  final bool? isConsumpted;
  @override
  final String? mqttTopic;
  @override
  final bool? isAsync;
  final List<CredentialField> _requiredFields;
  @override
  @JsonKey()
  List<CredentialField> get requiredFields {
    if (_requiredFields is EqualUnmodifiableListView) return _requiredFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requiredFields);
  }

  @override
  String toString() {
    return 'OutboundProtocol(id: $id, name: $name, color: $color, isEnabled: $isEnabled, categoriesIds: $categoriesIds, hasFtp: $hasFtp, isConsumpted: $isConsumpted, mqttTopic: $mqttTopic, isAsync: $isAsync, requiredFields: $requiredFields)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OutboundProtocol &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            const DeepCollectionEquality()
                .equals(other._categoriesIds, _categoriesIds) &&
            (identical(other.hasFtp, hasFtp) || other.hasFtp == hasFtp) &&
            (identical(other.isConsumpted, isConsumpted) ||
                other.isConsumpted == isConsumpted) &&
            (identical(other.mqttTopic, mqttTopic) ||
                other.mqttTopic == mqttTopic) &&
            (identical(other.isAsync, isAsync) || other.isAsync == isAsync) &&
            const DeepCollectionEquality()
                .equals(other._requiredFields, _requiredFields));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      color,
      isEnabled,
      const DeepCollectionEquality().hash(_categoriesIds),
      hasFtp,
      isConsumpted,
      mqttTopic,
      isAsync,
      const DeepCollectionEquality().hash(_requiredFields));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OutboundProtocolCopyWith<_$_OutboundProtocol> get copyWith =>
      __$$_OutboundProtocolCopyWithImpl<_$_OutboundProtocol>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OutboundProtocolToJson(
      this,
    );
  }
}

abstract class _OutboundProtocol implements OutboundProtocol {
  const factory _OutboundProtocol(
      {required final String id,
      required final String name,
      @ColorConverter() required final Color color,
      required final bool isEnabled,
      final List<String> categoriesIds,
      final bool? hasFtp,
      final bool? isConsumpted,
      final String? mqttTopic,
      final bool? isAsync,
      final List<CredentialField> requiredFields}) = _$_OutboundProtocol;

  factory _OutboundProtocol.fromJson(Map<String, dynamic> json) =
      _$_OutboundProtocol.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  @ColorConverter()
  Color get color;
  @override
  bool get isEnabled;
  @override
  List<String> get categoriesIds;
  @override
  bool? get hasFtp;
  @override
  bool? get isConsumpted;
  @override
  String? get mqttTopic;
  @override
  bool? get isAsync;
  @override
  List<CredentialField> get requiredFields;
  @override
  @JsonKey(ignore: true)
  _$$_OutboundProtocolCopyWith<_$_OutboundProtocol> get copyWith =>
      throw _privateConstructorUsedError;
}

Language _$LanguageFromJson(Map<String, dynamic> json) {
  return _Language.fromJson(json);
}

/// @nodoc
mixin _$Language {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get code => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LanguageCopyWith<Language> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LanguageCopyWith<$Res> {
  factory $LanguageCopyWith(Language value, $Res Function(Language) then) =
      _$LanguageCopyWithImpl<$Res, Language>;
  @useResult
  $Res call({String id, String name, String code});
}

/// @nodoc
class _$LanguageCopyWithImpl<$Res, $Val extends Language>
    implements $LanguageCopyWith<$Res> {
  _$LanguageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LanguageCopyWith<$Res> implements $LanguageCopyWith<$Res> {
  factory _$$_LanguageCopyWith(
          _$_Language value, $Res Function(_$_Language) then) =
      __$$_LanguageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name, String code});
}

/// @nodoc
class __$$_LanguageCopyWithImpl<$Res>
    extends _$LanguageCopyWithImpl<$Res, _$_Language>
    implements _$$_LanguageCopyWith<$Res> {
  __$$_LanguageCopyWithImpl(
      _$_Language _value, $Res Function(_$_Language) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = null,
  }) {
    return _then(_$_Language(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Language implements _Language {
  const _$_Language({required this.id, required this.name, required this.code});

  factory _$_Language.fromJson(Map<String, dynamic> json) =>
      _$$_LanguageFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String code;

  @override
  String toString() {
    return 'Language(id: $id, name: $name, code: $code)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Language &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.code, code) || other.code == code));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, code);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LanguageCopyWith<_$_Language> get copyWith =>
      __$$_LanguageCopyWithImpl<_$_Language>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LanguageToJson(
      this,
    );
  }
}

abstract class _Language implements Language {
  const factory _Language(
      {required final String id,
      required final String name,
      required final String code}) = _$_Language;

  factory _Language.fromJson(Map<String, dynamic> json) = _$_Language.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get code;
  @override
  @JsonKey(ignore: true)
  _$$_LanguageCopyWith<_$_Language> get copyWith =>
      throw _privateConstructorUsedError;
}

CredentialField _$CredentialFieldFromJson(Map<String, dynamic> json) {
  return _CredentialField.fromJson(json);
}

/// @nodoc
mixin _$CredentialField {
  /// [field] is the name of the field, is a translation key.
  String get field => throw _privateConstructorUsedError;

  /// [type] is the type of the field.
  @CredentialFieldTypeConverter()
  CredentialFieldType get type => throw _privateConstructorUsedError;

  /// [maxLength] is the maximum length of the field, only used in [type] = [CredentialFieldType.string].
  int? get maxLength => throw _privateConstructorUsedError;

  /// [minLength] is the minimum length of the field, only used in [type] = [CredentialFieldType.string].
  int? get minLength => throw _privateConstructorUsedError;

  /// [maxValue] is the maximum value of the field, only used in [type] = [CredentialFieldType.integer]
  /// or [CredentialFieldType.float].
  int? get maxValue => throw _privateConstructorUsedError;

  /// [minValue] is the minimum value of the field, only used in [type] = [CredentialFieldType.integer]
  /// or [CredentialFieldType.float].
  int? get minValue => throw _privateConstructorUsedError;

  /// [choices] is the list of possible choices for the field, only used in [type] = [CredentialFieldType.choices].
  List<String>? get choices => throw _privateConstructorUsedError;

  /// [onlyField] is the name of the field that must be present in the object,
  /// only used in [type] = [CredentialFieldType.choices].
  String? get onlyField => throw _privateConstructorUsedError;

  /// [onlyChoices] is the list of possible choices for the field, only used in
  /// [type] = [CredentialFieldType.choices].
  List<String>? get onlyChoices => throw _privateConstructorUsedError;

  /// [action] defines the action to show in the field (as suffix icon).
  @CredentialFieldActionConverter()
  CredentialFieldAction? get action => throw _privateConstructorUsedError;

  /// [requiredFields] represents the nested fields.
  /// Only used when [type] = [CredentialFieldType.nestedField].
  List<CredentialField>? get requiredFields =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CredentialFieldCopyWith<CredentialField> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CredentialFieldCopyWith<$Res> {
  factory $CredentialFieldCopyWith(
          CredentialField value, $Res Function(CredentialField) then) =
      _$CredentialFieldCopyWithImpl<$Res, CredentialField>;
  @useResult
  $Res call(
      {String field,
      @CredentialFieldTypeConverter() CredentialFieldType type,
      int? maxLength,
      int? minLength,
      int? maxValue,
      int? minValue,
      List<String>? choices,
      String? onlyField,
      List<String>? onlyChoices,
      @CredentialFieldActionConverter() CredentialFieldAction? action,
      List<CredentialField>? requiredFields});
}

/// @nodoc
class _$CredentialFieldCopyWithImpl<$Res, $Val extends CredentialField>
    implements $CredentialFieldCopyWith<$Res> {
  _$CredentialFieldCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? type = null,
    Object? maxLength = freezed,
    Object? minLength = freezed,
    Object? maxValue = freezed,
    Object? minValue = freezed,
    Object? choices = freezed,
    Object? onlyField = freezed,
    Object? onlyChoices = freezed,
    Object? action = freezed,
    Object? requiredFields = freezed,
  }) {
    return _then(_value.copyWith(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CredentialFieldType,
      maxLength: freezed == maxLength
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int?,
      minLength: freezed == minLength
          ? _value.minLength
          : minLength // ignore: cast_nullable_to_non_nullable
              as int?,
      maxValue: freezed == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as int?,
      minValue: freezed == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as int?,
      choices: freezed == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      onlyField: freezed == onlyField
          ? _value.onlyField
          : onlyField // ignore: cast_nullable_to_non_nullable
              as String?,
      onlyChoices: freezed == onlyChoices
          ? _value.onlyChoices
          : onlyChoices // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      action: freezed == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as CredentialFieldAction?,
      requiredFields: freezed == requiredFields
          ? _value.requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CredentialFieldCopyWith<$Res>
    implements $CredentialFieldCopyWith<$Res> {
  factory _$$_CredentialFieldCopyWith(
          _$_CredentialField value, $Res Function(_$_CredentialField) then) =
      __$$_CredentialFieldCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String field,
      @CredentialFieldTypeConverter() CredentialFieldType type,
      int? maxLength,
      int? minLength,
      int? maxValue,
      int? minValue,
      List<String>? choices,
      String? onlyField,
      List<String>? onlyChoices,
      @CredentialFieldActionConverter() CredentialFieldAction? action,
      List<CredentialField>? requiredFields});
}

/// @nodoc
class __$$_CredentialFieldCopyWithImpl<$Res>
    extends _$CredentialFieldCopyWithImpl<$Res, _$_CredentialField>
    implements _$$_CredentialFieldCopyWith<$Res> {
  __$$_CredentialFieldCopyWithImpl(
      _$_CredentialField _value, $Res Function(_$_CredentialField) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? type = null,
    Object? maxLength = freezed,
    Object? minLength = freezed,
    Object? maxValue = freezed,
    Object? minValue = freezed,
    Object? choices = freezed,
    Object? onlyField = freezed,
    Object? onlyChoices = freezed,
    Object? action = freezed,
    Object? requiredFields = freezed,
  }) {
    return _then(_$_CredentialField(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CredentialFieldType,
      maxLength: freezed == maxLength
          ? _value.maxLength
          : maxLength // ignore: cast_nullable_to_non_nullable
              as int?,
      minLength: freezed == minLength
          ? _value.minLength
          : minLength // ignore: cast_nullable_to_non_nullable
              as int?,
      maxValue: freezed == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as int?,
      minValue: freezed == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as int?,
      choices: freezed == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      onlyField: freezed == onlyField
          ? _value.onlyField
          : onlyField // ignore: cast_nullable_to_non_nullable
              as String?,
      onlyChoices: freezed == onlyChoices
          ? _value._onlyChoices
          : onlyChoices // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      action: freezed == action
          ? _value.action
          : action // ignore: cast_nullable_to_non_nullable
              as CredentialFieldAction?,
      requiredFields: freezed == requiredFields
          ? _value._requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CredentialField implements _CredentialField {
  const _$_CredentialField(
      {required this.field,
      @CredentialFieldTypeConverter() required this.type,
      this.maxLength,
      this.minLength,
      this.maxValue,
      this.minValue,
      final List<String>? choices,
      this.onlyField,
      final List<String>? onlyChoices,
      @CredentialFieldActionConverter() this.action,
      final List<CredentialField>? requiredFields})
      : _choices = choices,
        _onlyChoices = onlyChoices,
        _requiredFields = requiredFields;

  factory _$_CredentialField.fromJson(Map<String, dynamic> json) =>
      _$$_CredentialFieldFromJson(json);

  /// [field] is the name of the field, is a translation key.
  @override
  final String field;

  /// [type] is the type of the field.
  @override
  @CredentialFieldTypeConverter()
  final CredentialFieldType type;

  /// [maxLength] is the maximum length of the field, only used in [type] = [CredentialFieldType.string].
  @override
  final int? maxLength;

  /// [minLength] is the minimum length of the field, only used in [type] = [CredentialFieldType.string].
  @override
  final int? minLength;

  /// [maxValue] is the maximum value of the field, only used in [type] = [CredentialFieldType.integer]
  /// or [CredentialFieldType.float].
  @override
  final int? maxValue;

  /// [minValue] is the minimum value of the field, only used in [type] = [CredentialFieldType.integer]
  /// or [CredentialFieldType.float].
  @override
  final int? minValue;

  /// [choices] is the list of possible choices for the field, only used in [type] = [CredentialFieldType.choices].
  final List<String>? _choices;

  /// [choices] is the list of possible choices for the field, only used in [type] = [CredentialFieldType.choices].
  @override
  List<String>? get choices {
    final value = _choices;
    if (value == null) return null;
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [onlyField] is the name of the field that must be present in the object,
  /// only used in [type] = [CredentialFieldType.choices].
  @override
  final String? onlyField;

  /// [onlyChoices] is the list of possible choices for the field, only used in
  /// [type] = [CredentialFieldType.choices].
  final List<String>? _onlyChoices;

  /// [onlyChoices] is the list of possible choices for the field, only used in
  /// [type] = [CredentialFieldType.choices].
  @override
  List<String>? get onlyChoices {
    final value = _onlyChoices;
    if (value == null) return null;
    if (_onlyChoices is EqualUnmodifiableListView) return _onlyChoices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [action] defines the action to show in the field (as suffix icon).
  @override
  @CredentialFieldActionConverter()
  final CredentialFieldAction? action;

  /// [requiredFields] represents the nested fields.
  /// Only used when [type] = [CredentialFieldType.nestedField].
  final List<CredentialField>? _requiredFields;

  /// [requiredFields] represents the nested fields.
  /// Only used when [type] = [CredentialFieldType.nestedField].
  @override
  List<CredentialField>? get requiredFields {
    final value = _requiredFields;
    if (value == null) return null;
    if (_requiredFields is EqualUnmodifiableListView) return _requiredFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CredentialField(field: $field, type: $type, maxLength: $maxLength, minLength: $minLength, maxValue: $maxValue, minValue: $minValue, choices: $choices, onlyField: $onlyField, onlyChoices: $onlyChoices, action: $action, requiredFields: $requiredFields)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CredentialField &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.maxLength, maxLength) ||
                other.maxLength == maxLength) &&
            (identical(other.minLength, minLength) ||
                other.minLength == minLength) &&
            (identical(other.maxValue, maxValue) ||
                other.maxValue == maxValue) &&
            (identical(other.minValue, minValue) ||
                other.minValue == minValue) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.onlyField, onlyField) ||
                other.onlyField == onlyField) &&
            const DeepCollectionEquality()
                .equals(other._onlyChoices, _onlyChoices) &&
            (identical(other.action, action) || other.action == action) &&
            const DeepCollectionEquality()
                .equals(other._requiredFields, _requiredFields));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      field,
      type,
      maxLength,
      minLength,
      maxValue,
      minValue,
      const DeepCollectionEquality().hash(_choices),
      onlyField,
      const DeepCollectionEquality().hash(_onlyChoices),
      action,
      const DeepCollectionEquality().hash(_requiredFields));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CredentialFieldCopyWith<_$_CredentialField> get copyWith =>
      __$$_CredentialFieldCopyWithImpl<_$_CredentialField>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CredentialFieldToJson(
      this,
    );
  }
}

abstract class _CredentialField implements CredentialField {
  const factory _CredentialField(
      {required final String field,
      @CredentialFieldTypeConverter() required final CredentialFieldType type,
      final int? maxLength,
      final int? minLength,
      final int? maxValue,
      final int? minValue,
      final List<String>? choices,
      final String? onlyField,
      final List<String>? onlyChoices,
      @CredentialFieldActionConverter() final CredentialFieldAction? action,
      final List<CredentialField>? requiredFields}) = _$_CredentialField;

  factory _CredentialField.fromJson(Map<String, dynamic> json) =
      _$_CredentialField.fromJson;

  @override

  /// [field] is the name of the field, is a translation key.
  String get field;
  @override

  /// [type] is the type of the field.
  @CredentialFieldTypeConverter()
  CredentialFieldType get type;
  @override

  /// [maxLength] is the maximum length of the field, only used in [type] = [CredentialFieldType.string].
  int? get maxLength;
  @override

  /// [minLength] is the minimum length of the field, only used in [type] = [CredentialFieldType.string].
  int? get minLength;
  @override

  /// [maxValue] is the maximum value of the field, only used in [type] = [CredentialFieldType.integer]
  /// or [CredentialFieldType.float].
  int? get maxValue;
  @override

  /// [minValue] is the minimum value of the field, only used in [type] = [CredentialFieldType.integer]
  /// or [CredentialFieldType.float].
  int? get minValue;
  @override

  /// [choices] is the list of possible choices for the field, only used in [type] = [CredentialFieldType.choices].
  List<String>? get choices;
  @override

  /// [onlyField] is the name of the field that must be present in the object,
  /// only used in [type] = [CredentialFieldType.choices].
  String? get onlyField;
  @override

  /// [onlyChoices] is the list of possible choices for the field, only used in
  /// [type] = [CredentialFieldType.choices].
  List<String>? get onlyChoices;
  @override

  /// [action] defines the action to show in the field (as suffix icon).
  @CredentialFieldActionConverter()
  CredentialFieldAction? get action;
  @override

  /// [requiredFields] represents the nested fields.
  /// Only used when [type] = [CredentialFieldType.nestedField].
  List<CredentialField>? get requiredFields;
  @override
  @JsonKey(ignore: true)
  _$$_CredentialFieldCopyWith<_$_CredentialField> get copyWith =>
      throw _privateConstructorUsedError;
}

SuspendedService _$SuspendedServiceFromJson(Map<String, dynamic> json) {
  return _SuspendedService.fromJson(json);
}

/// @nodoc
mixin _$SuspendedService {
  String get incidentId => throw _privateConstructorUsedError;
  String get serviceId => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  User get user => throw _privateConstructorUsedError;
  OutboundProtocol get protocol => throw _privateConstructorUsedError;
  @TimestampConverter()
  DateTime get suspendedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SuspendedServiceCopyWith<SuspendedService> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SuspendedServiceCopyWith<$Res> {
  factory $SuspendedServiceCopyWith(
          SuspendedService value, $Res Function(SuspendedService) then) =
      _$SuspendedServiceCopyWithImpl<$Res, SuspendedService>;
  @useResult
  $Res call(
      {String incidentId,
      String serviceId,
      String name,
      User user,
      OutboundProtocol protocol,
      @TimestampConverter() DateTime suspendedAt});

  $UserCopyWith<$Res> get user;
  $OutboundProtocolCopyWith<$Res> get protocol;
}

/// @nodoc
class _$SuspendedServiceCopyWithImpl<$Res, $Val extends SuspendedService>
    implements $SuspendedServiceCopyWith<$Res> {
  _$SuspendedServiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? incidentId = null,
    Object? serviceId = null,
    Object? name = null,
    Object? user = null,
    Object? protocol = null,
    Object? suspendedAt = null,
  }) {
    return _then(_value.copyWith(
      incidentId: null == incidentId
          ? _value.incidentId
          : incidentId // ignore: cast_nullable_to_non_nullable
              as String,
      serviceId: null == serviceId
          ? _value.serviceId
          : serviceId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      protocol: null == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as OutboundProtocol,
      suspendedAt: null == suspendedAt
          ? _value.suspendedAt
          : suspendedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res> get user {
    return $UserCopyWith<$Res>(_value.user, (value) {
      return _then(_value.copyWith(user: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $OutboundProtocolCopyWith<$Res> get protocol {
    return $OutboundProtocolCopyWith<$Res>(_value.protocol, (value) {
      return _then(_value.copyWith(protocol: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SuspendedServiceCopyWith<$Res>
    implements $SuspendedServiceCopyWith<$Res> {
  factory _$$_SuspendedServiceCopyWith(
          _$_SuspendedService value, $Res Function(_$_SuspendedService) then) =
      __$$_SuspendedServiceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String incidentId,
      String serviceId,
      String name,
      User user,
      OutboundProtocol protocol,
      @TimestampConverter() DateTime suspendedAt});

  @override
  $UserCopyWith<$Res> get user;
  @override
  $OutboundProtocolCopyWith<$Res> get protocol;
}

/// @nodoc
class __$$_SuspendedServiceCopyWithImpl<$Res>
    extends _$SuspendedServiceCopyWithImpl<$Res, _$_SuspendedService>
    implements _$$_SuspendedServiceCopyWith<$Res> {
  __$$_SuspendedServiceCopyWithImpl(
      _$_SuspendedService _value, $Res Function(_$_SuspendedService) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? incidentId = null,
    Object? serviceId = null,
    Object? name = null,
    Object? user = null,
    Object? protocol = null,
    Object? suspendedAt = null,
  }) {
    return _then(_$_SuspendedService(
      incidentId: null == incidentId
          ? _value.incidentId
          : incidentId // ignore: cast_nullable_to_non_nullable
              as String,
      serviceId: null == serviceId
          ? _value.serviceId
          : serviceId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      user: null == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User,
      protocol: null == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as OutboundProtocol,
      suspendedAt: null == suspendedAt
          ? _value.suspendedAt
          : suspendedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SuspendedService implements _SuspendedService {
  const _$_SuspendedService(
      {required this.incidentId,
      required this.serviceId,
      required this.name,
      required this.user,
      required this.protocol,
      @TimestampConverter() required this.suspendedAt});

  factory _$_SuspendedService.fromJson(Map<String, dynamic> json) =>
      _$$_SuspendedServiceFromJson(json);

  @override
  final String incidentId;
  @override
  final String serviceId;
  @override
  final String name;
  @override
  final User user;
  @override
  final OutboundProtocol protocol;
  @override
  @TimestampConverter()
  final DateTime suspendedAt;

  @override
  String toString() {
    return 'SuspendedService(incidentId: $incidentId, serviceId: $serviceId, name: $name, user: $user, protocol: $protocol, suspendedAt: $suspendedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SuspendedService &&
            (identical(other.incidentId, incidentId) ||
                other.incidentId == incidentId) &&
            (identical(other.serviceId, serviceId) ||
                other.serviceId == serviceId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            (identical(other.suspendedAt, suspendedAt) ||
                other.suspendedAt == suspendedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, incidentId, serviceId, name, user, protocol, suspendedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SuspendedServiceCopyWith<_$_SuspendedService> get copyWith =>
      __$$_SuspendedServiceCopyWithImpl<_$_SuspendedService>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SuspendedServiceToJson(
      this,
    );
  }
}

abstract class _SuspendedService implements SuspendedService {
  const factory _SuspendedService(
          {required final String incidentId,
          required final String serviceId,
          required final String name,
          required final User user,
          required final OutboundProtocol protocol,
          @TimestampConverter() required final DateTime suspendedAt}) =
      _$_SuspendedService;

  factory _SuspendedService.fromJson(Map<String, dynamic> json) =
      _$_SuspendedService.fromJson;

  @override
  String get incidentId;
  @override
  String get serviceId;
  @override
  String get name;
  @override
  User get user;
  @override
  OutboundProtocol get protocol;
  @override
  @TimestampConverter()
  DateTime get suspendedAt;
  @override
  @JsonKey(ignore: true)
  _$$_SuspendedServiceCopyWith<_$_SuspendedService> get copyWith =>
      throw _privateConstructorUsedError;
}

BillingPlan _$BillingPlanFromJson(Map<String, dynamic> json) {
  return _BillingPlan.fromJson(json);
}

/// @nodoc
mixin _$BillingPlan {
  String get id => throw _privateConstructorUsedError;
  double get reconnectionPercent => throw _privateConstructorUsedError;
  int get reconnectionMaximum => throw _privateConstructorUsedError;
  int get reconnectionIncidents => throw _privateConstructorUsedError;
  int get maxAssets => throw _privateConstructorUsedError;
  int get maxDevices => throw _privateConstructorUsedError;
  int get maxUsers => throw _privateConstructorUsedError;
  int get maxOutboundServices => throw _privateConstructorUsedError;
  int get maxFunctions => throw _privateConstructorUsedError;
  int get maxApps => throw _privateConstructorUsedError;
  List<String> get allowedAppsIds => throw _privateConstructorUsedError;
  List<String> get allowedAlgorithmsIds => throw _privateConstructorUsedError;
  List<String> get allowedInboundProtocolsIds =>
      throw _privateConstructorUsedError;
  List<String> get allowedOutboundProtocolsIds =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BillingPlanCopyWith<BillingPlan> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BillingPlanCopyWith<$Res> {
  factory $BillingPlanCopyWith(
          BillingPlan value, $Res Function(BillingPlan) then) =
      _$BillingPlanCopyWithImpl<$Res, BillingPlan>;
  @useResult
  $Res call(
      {String id,
      double reconnectionPercent,
      int reconnectionMaximum,
      int reconnectionIncidents,
      int maxAssets,
      int maxDevices,
      int maxUsers,
      int maxOutboundServices,
      int maxFunctions,
      int maxApps,
      List<String> allowedAppsIds,
      List<String> allowedAlgorithmsIds,
      List<String> allowedInboundProtocolsIds,
      List<String> allowedOutboundProtocolsIds});
}

/// @nodoc
class _$BillingPlanCopyWithImpl<$Res, $Val extends BillingPlan>
    implements $BillingPlanCopyWith<$Res> {
  _$BillingPlanCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? reconnectionPercent = null,
    Object? reconnectionMaximum = null,
    Object? reconnectionIncidents = null,
    Object? maxAssets = null,
    Object? maxDevices = null,
    Object? maxUsers = null,
    Object? maxOutboundServices = null,
    Object? maxFunctions = null,
    Object? maxApps = null,
    Object? allowedAppsIds = null,
    Object? allowedAlgorithmsIds = null,
    Object? allowedInboundProtocolsIds = null,
    Object? allowedOutboundProtocolsIds = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      reconnectionPercent: null == reconnectionPercent
          ? _value.reconnectionPercent
          : reconnectionPercent // ignore: cast_nullable_to_non_nullable
              as double,
      reconnectionMaximum: null == reconnectionMaximum
          ? _value.reconnectionMaximum
          : reconnectionMaximum // ignore: cast_nullable_to_non_nullable
              as int,
      reconnectionIncidents: null == reconnectionIncidents
          ? _value.reconnectionIncidents
          : reconnectionIncidents // ignore: cast_nullable_to_non_nullable
              as int,
      maxAssets: null == maxAssets
          ? _value.maxAssets
          : maxAssets // ignore: cast_nullable_to_non_nullable
              as int,
      maxDevices: null == maxDevices
          ? _value.maxDevices
          : maxDevices // ignore: cast_nullable_to_non_nullable
              as int,
      maxUsers: null == maxUsers
          ? _value.maxUsers
          : maxUsers // ignore: cast_nullable_to_non_nullable
              as int,
      maxOutboundServices: null == maxOutboundServices
          ? _value.maxOutboundServices
          : maxOutboundServices // ignore: cast_nullable_to_non_nullable
              as int,
      maxFunctions: null == maxFunctions
          ? _value.maxFunctions
          : maxFunctions // ignore: cast_nullable_to_non_nullable
              as int,
      maxApps: null == maxApps
          ? _value.maxApps
          : maxApps // ignore: cast_nullable_to_non_nullable
              as int,
      allowedAppsIds: null == allowedAppsIds
          ? _value.allowedAppsIds
          : allowedAppsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowedAlgorithmsIds: null == allowedAlgorithmsIds
          ? _value.allowedAlgorithmsIds
          : allowedAlgorithmsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowedInboundProtocolsIds: null == allowedInboundProtocolsIds
          ? _value.allowedInboundProtocolsIds
          : allowedInboundProtocolsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowedOutboundProtocolsIds: null == allowedOutboundProtocolsIds
          ? _value.allowedOutboundProtocolsIds
          : allowedOutboundProtocolsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BillingPlanCopyWith<$Res>
    implements $BillingPlanCopyWith<$Res> {
  factory _$$_BillingPlanCopyWith(
          _$_BillingPlan value, $Res Function(_$_BillingPlan) then) =
      __$$_BillingPlanCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      double reconnectionPercent,
      int reconnectionMaximum,
      int reconnectionIncidents,
      int maxAssets,
      int maxDevices,
      int maxUsers,
      int maxOutboundServices,
      int maxFunctions,
      int maxApps,
      List<String> allowedAppsIds,
      List<String> allowedAlgorithmsIds,
      List<String> allowedInboundProtocolsIds,
      List<String> allowedOutboundProtocolsIds});
}

/// @nodoc
class __$$_BillingPlanCopyWithImpl<$Res>
    extends _$BillingPlanCopyWithImpl<$Res, _$_BillingPlan>
    implements _$$_BillingPlanCopyWith<$Res> {
  __$$_BillingPlanCopyWithImpl(
      _$_BillingPlan _value, $Res Function(_$_BillingPlan) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? reconnectionPercent = null,
    Object? reconnectionMaximum = null,
    Object? reconnectionIncidents = null,
    Object? maxAssets = null,
    Object? maxDevices = null,
    Object? maxUsers = null,
    Object? maxOutboundServices = null,
    Object? maxFunctions = null,
    Object? maxApps = null,
    Object? allowedAppsIds = null,
    Object? allowedAlgorithmsIds = null,
    Object? allowedInboundProtocolsIds = null,
    Object? allowedOutboundProtocolsIds = null,
  }) {
    return _then(_$_BillingPlan(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      reconnectionPercent: null == reconnectionPercent
          ? _value.reconnectionPercent
          : reconnectionPercent // ignore: cast_nullable_to_non_nullable
              as double,
      reconnectionMaximum: null == reconnectionMaximum
          ? _value.reconnectionMaximum
          : reconnectionMaximum // ignore: cast_nullable_to_non_nullable
              as int,
      reconnectionIncidents: null == reconnectionIncidents
          ? _value.reconnectionIncidents
          : reconnectionIncidents // ignore: cast_nullable_to_non_nullable
              as int,
      maxAssets: null == maxAssets
          ? _value.maxAssets
          : maxAssets // ignore: cast_nullable_to_non_nullable
              as int,
      maxDevices: null == maxDevices
          ? _value.maxDevices
          : maxDevices // ignore: cast_nullable_to_non_nullable
              as int,
      maxUsers: null == maxUsers
          ? _value.maxUsers
          : maxUsers // ignore: cast_nullable_to_non_nullable
              as int,
      maxOutboundServices: null == maxOutboundServices
          ? _value.maxOutboundServices
          : maxOutboundServices // ignore: cast_nullable_to_non_nullable
              as int,
      maxFunctions: null == maxFunctions
          ? _value.maxFunctions
          : maxFunctions // ignore: cast_nullable_to_non_nullable
              as int,
      maxApps: null == maxApps
          ? _value.maxApps
          : maxApps // ignore: cast_nullable_to_non_nullable
              as int,
      allowedAppsIds: null == allowedAppsIds
          ? _value._allowedAppsIds
          : allowedAppsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowedAlgorithmsIds: null == allowedAlgorithmsIds
          ? _value._allowedAlgorithmsIds
          : allowedAlgorithmsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowedInboundProtocolsIds: null == allowedInboundProtocolsIds
          ? _value._allowedInboundProtocolsIds
          : allowedInboundProtocolsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      allowedOutboundProtocolsIds: null == allowedOutboundProtocolsIds
          ? _value._allowedOutboundProtocolsIds
          : allowedOutboundProtocolsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BillingPlan implements _BillingPlan {
  const _$_BillingPlan(
      {required this.id,
      required this.reconnectionPercent,
      required this.reconnectionMaximum,
      required this.reconnectionIncidents,
      required this.maxAssets,
      required this.maxDevices,
      required this.maxUsers,
      required this.maxOutboundServices,
      required this.maxFunctions,
      required this.maxApps,
      required final List<String> allowedAppsIds,
      required final List<String> allowedAlgorithmsIds,
      required final List<String> allowedInboundProtocolsIds,
      required final List<String> allowedOutboundProtocolsIds})
      : _allowedAppsIds = allowedAppsIds,
        _allowedAlgorithmsIds = allowedAlgorithmsIds,
        _allowedInboundProtocolsIds = allowedInboundProtocolsIds,
        _allowedOutboundProtocolsIds = allowedOutboundProtocolsIds;

  factory _$_BillingPlan.fromJson(Map<String, dynamic> json) =>
      _$$_BillingPlanFromJson(json);

  @override
  final String id;
  @override
  final double reconnectionPercent;
  @override
  final int reconnectionMaximum;
  @override
  final int reconnectionIncidents;
  @override
  final int maxAssets;
  @override
  final int maxDevices;
  @override
  final int maxUsers;
  @override
  final int maxOutboundServices;
  @override
  final int maxFunctions;
  @override
  final int maxApps;
  final List<String> _allowedAppsIds;
  @override
  List<String> get allowedAppsIds {
    if (_allowedAppsIds is EqualUnmodifiableListView) return _allowedAppsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allowedAppsIds);
  }

  final List<String> _allowedAlgorithmsIds;
  @override
  List<String> get allowedAlgorithmsIds {
    if (_allowedAlgorithmsIds is EqualUnmodifiableListView)
      return _allowedAlgorithmsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allowedAlgorithmsIds);
  }

  final List<String> _allowedInboundProtocolsIds;
  @override
  List<String> get allowedInboundProtocolsIds {
    if (_allowedInboundProtocolsIds is EqualUnmodifiableListView)
      return _allowedInboundProtocolsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allowedInboundProtocolsIds);
  }

  final List<String> _allowedOutboundProtocolsIds;
  @override
  List<String> get allowedOutboundProtocolsIds {
    if (_allowedOutboundProtocolsIds is EqualUnmodifiableListView)
      return _allowedOutboundProtocolsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_allowedOutboundProtocolsIds);
  }

  @override
  String toString() {
    return 'BillingPlan(id: $id, reconnectionPercent: $reconnectionPercent, reconnectionMaximum: $reconnectionMaximum, reconnectionIncidents: $reconnectionIncidents, maxAssets: $maxAssets, maxDevices: $maxDevices, maxUsers: $maxUsers, maxOutboundServices: $maxOutboundServices, maxFunctions: $maxFunctions, maxApps: $maxApps, allowedAppsIds: $allowedAppsIds, allowedAlgorithmsIds: $allowedAlgorithmsIds, allowedInboundProtocolsIds: $allowedInboundProtocolsIds, allowedOutboundProtocolsIds: $allowedOutboundProtocolsIds)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BillingPlan &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.reconnectionPercent, reconnectionPercent) ||
                other.reconnectionPercent == reconnectionPercent) &&
            (identical(other.reconnectionMaximum, reconnectionMaximum) ||
                other.reconnectionMaximum == reconnectionMaximum) &&
            (identical(other.reconnectionIncidents, reconnectionIncidents) ||
                other.reconnectionIncidents == reconnectionIncidents) &&
            (identical(other.maxAssets, maxAssets) ||
                other.maxAssets == maxAssets) &&
            (identical(other.maxDevices, maxDevices) ||
                other.maxDevices == maxDevices) &&
            (identical(other.maxUsers, maxUsers) ||
                other.maxUsers == maxUsers) &&
            (identical(other.maxOutboundServices, maxOutboundServices) ||
                other.maxOutboundServices == maxOutboundServices) &&
            (identical(other.maxFunctions, maxFunctions) ||
                other.maxFunctions == maxFunctions) &&
            (identical(other.maxApps, maxApps) || other.maxApps == maxApps) &&
            const DeepCollectionEquality()
                .equals(other._allowedAppsIds, _allowedAppsIds) &&
            const DeepCollectionEquality()
                .equals(other._allowedAlgorithmsIds, _allowedAlgorithmsIds) &&
            const DeepCollectionEquality().equals(
                other._allowedInboundProtocolsIds,
                _allowedInboundProtocolsIds) &&
            const DeepCollectionEquality().equals(
                other._allowedOutboundProtocolsIds,
                _allowedOutboundProtocolsIds));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      reconnectionPercent,
      reconnectionMaximum,
      reconnectionIncidents,
      maxAssets,
      maxDevices,
      maxUsers,
      maxOutboundServices,
      maxFunctions,
      maxApps,
      const DeepCollectionEquality().hash(_allowedAppsIds),
      const DeepCollectionEquality().hash(_allowedAlgorithmsIds),
      const DeepCollectionEquality().hash(_allowedInboundProtocolsIds),
      const DeepCollectionEquality().hash(_allowedOutboundProtocolsIds));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BillingPlanCopyWith<_$_BillingPlan> get copyWith =>
      __$$_BillingPlanCopyWithImpl<_$_BillingPlan>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BillingPlanToJson(
      this,
    );
  }
}

abstract class _BillingPlan implements BillingPlan {
  const factory _BillingPlan(
          {required final String id,
          required final double reconnectionPercent,
          required final int reconnectionMaximum,
          required final int reconnectionIncidents,
          required final int maxAssets,
          required final int maxDevices,
          required final int maxUsers,
          required final int maxOutboundServices,
          required final int maxFunctions,
          required final int maxApps,
          required final List<String> allowedAppsIds,
          required final List<String> allowedAlgorithmsIds,
          required final List<String> allowedInboundProtocolsIds,
          required final List<String> allowedOutboundProtocolsIds}) =
      _$_BillingPlan;

  factory _BillingPlan.fromJson(Map<String, dynamic> json) =
      _$_BillingPlan.fromJson;

  @override
  String get id;
  @override
  double get reconnectionPercent;
  @override
  int get reconnectionMaximum;
  @override
  int get reconnectionIncidents;
  @override
  int get maxAssets;
  @override
  int get maxDevices;
  @override
  int get maxUsers;
  @override
  int get maxOutboundServices;
  @override
  int get maxFunctions;
  @override
  int get maxApps;
  @override
  List<String> get allowedAppsIds;
  @override
  List<String> get allowedAlgorithmsIds;
  @override
  List<String> get allowedInboundProtocolsIds;
  @override
  List<String> get allowedOutboundProtocolsIds;
  @override
  @JsonKey(ignore: true)
  _$$_BillingPlanCopyWith<_$_BillingPlan> get copyWith =>
      throw _privateConstructorUsedError;
}

GeofencePoint _$GeofencePointFromJson(Map<String, dynamic> json) {
  return _GeofencePoint.fromJson(json);
}

/// @nodoc
mixin _$GeofencePoint {
  double get latitude => throw _privateConstructorUsedError;
  double get longitude => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GeofencePointCopyWith<GeofencePoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeofencePointCopyWith<$Res> {
  factory $GeofencePointCopyWith(
          GeofencePoint value, $Res Function(GeofencePoint) then) =
      _$GeofencePointCopyWithImpl<$Res, GeofencePoint>;
  @useResult
  $Res call({double latitude, double longitude});
}

/// @nodoc
class _$GeofencePointCopyWithImpl<$Res, $Val extends GeofencePoint>
    implements $GeofencePointCopyWith<$Res> {
  _$GeofencePointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = null,
    Object? longitude = null,
  }) {
    return _then(_value.copyWith(
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GeofencePointCopyWith<$Res>
    implements $GeofencePointCopyWith<$Res> {
  factory _$$_GeofencePointCopyWith(
          _$_GeofencePoint value, $Res Function(_$_GeofencePoint) then) =
      __$$_GeofencePointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double latitude, double longitude});
}

/// @nodoc
class __$$_GeofencePointCopyWithImpl<$Res>
    extends _$GeofencePointCopyWithImpl<$Res, _$_GeofencePoint>
    implements _$$_GeofencePointCopyWith<$Res> {
  __$$_GeofencePointCopyWithImpl(
      _$_GeofencePoint _value, $Res Function(_$_GeofencePoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = null,
    Object? longitude = null,
  }) {
    return _then(_$_GeofencePoint(
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GeofencePoint implements _GeofencePoint {
  const _$_GeofencePoint({required this.latitude, required this.longitude});

  factory _$_GeofencePoint.fromJson(Map<String, dynamic> json) =>
      _$$_GeofencePointFromJson(json);

  @override
  final double latitude;
  @override
  final double longitude;

  @override
  String toString() {
    return 'GeofencePoint(latitude: $latitude, longitude: $longitude)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GeofencePoint &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, latitude, longitude);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GeofencePointCopyWith<_$_GeofencePoint> get copyWith =>
      __$$_GeofencePointCopyWithImpl<_$_GeofencePoint>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GeofencePointToJson(
      this,
    );
  }
}

abstract class _GeofencePoint implements GeofencePoint {
  const factory _GeofencePoint(
      {required final double latitude,
      required final double longitude}) = _$_GeofencePoint;

  factory _GeofencePoint.fromJson(Map<String, dynamic> json) =
      _$_GeofencePoint.fromJson;

  @override
  double get latitude;
  @override
  double get longitude;
  @override
  @JsonKey(ignore: true)
  _$$_GeofencePointCopyWith<_$_GeofencePoint> get copyWith =>
      throw _privateConstructorUsedError;
}

Geofence _$GeofenceFromJson(Map<String, dynamic> json) {
  return _Geofence.fromJson(json);
}

/// @nodoc
mixin _$Geofence {
  /// ID of the geofence entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// Name of the geofence.
  String get name => throw _privateConstructorUsedError;

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @GeofenceModeConverter()
  GeofenceMode get mode => throw _privateConstructorUsedError;

  /// Description of the geofence.
  String? get description => throw _privateConstructorUsedError;

  /// Color of the geofence in hexadecimal code.
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  List<GeofencePoint>? get path => throw _privateConstructorUsedError;

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  double? get radius => throw _privateConstructorUsedError;

  /// External resource ID, only for external geofences.
  String? get resourceId => throw _privateConstructorUsedError;

  /// List of assets inside the geofence.
  List<Asset>? get assetsInside => throw _privateConstructorUsedError;

  /// [category] refers to the type of geofence, by default is [GeofenceCategory.none] when is requested
  /// from the API.
  @GeofenceCategoryConverter()
  GeofenceCategory get category => throw _privateConstructorUsedError;

  /// [childrenIds] refers to the list of children geofences.
  List<String>? get childrenIds => throw _privateConstructorUsedError;

  /// [children] refers to the list of children geofences.
  List<Geofence>? get children => throw _privateConstructorUsedError;

  /// List of custom access permissions.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// List of [customFields] linked to the geofence. Please read the documentation for [CustomField]
  /// for more details about the fields.
  List<CustomField>? get customFields => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GeofenceCopyWith<Geofence> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeofenceCopyWith<$Res> {
  factory $GeofenceCopyWith(Geofence value, $Res Function(Geofence) then) =
      _$GeofenceCopyWithImpl<$Res, Geofence>;
  @useResult
  $Res call(
      {String id,
      String name,
      @GeofenceModeConverter() GeofenceMode mode,
      String? description,
      @ColorOrNullConverter() Color? color,
      List<GeofencePoint>? path,
      double? radius,
      String? resourceId,
      List<Asset>? assetsInside,
      @GeofenceCategoryConverter() GeofenceCategory category,
      List<String>? childrenIds,
      List<Geofence>? children,
      List<Access>? access,
      List<CustomField>? customFields});
}

/// @nodoc
class _$GeofenceCopyWithImpl<$Res, $Val extends Geofence>
    implements $GeofenceCopyWith<$Res> {
  _$GeofenceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? mode = null,
    Object? description = freezed,
    Object? color = freezed,
    Object? path = freezed,
    Object? radius = freezed,
    Object? resourceId = freezed,
    Object? assetsInside = freezed,
    Object? category = null,
    Object? childrenIds = freezed,
    Object? children = freezed,
    Object? access = freezed,
    Object? customFields = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      radius: freezed == radius
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as double?,
      resourceId: freezed == resourceId
          ? _value.resourceId
          : resourceId // ignore: cast_nullable_to_non_nullable
              as String?,
      assetsInside: freezed == assetsInside
          ? _value.assetsInside
          : assetsInside // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as GeofenceCategory,
      childrenIds: freezed == childrenIds
          ? _value.childrenIds
          : childrenIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      children: freezed == children
          ? _value.children
          : children // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      customFields: freezed == customFields
          ? _value.customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GeofenceCopyWith<$Res> implements $GeofenceCopyWith<$Res> {
  factory _$$_GeofenceCopyWith(
          _$_Geofence value, $Res Function(_$_Geofence) then) =
      __$$_GeofenceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @GeofenceModeConverter() GeofenceMode mode,
      String? description,
      @ColorOrNullConverter() Color? color,
      List<GeofencePoint>? path,
      double? radius,
      String? resourceId,
      List<Asset>? assetsInside,
      @GeofenceCategoryConverter() GeofenceCategory category,
      List<String>? childrenIds,
      List<Geofence>? children,
      List<Access>? access,
      List<CustomField>? customFields});
}

/// @nodoc
class __$$_GeofenceCopyWithImpl<$Res>
    extends _$GeofenceCopyWithImpl<$Res, _$_Geofence>
    implements _$$_GeofenceCopyWith<$Res> {
  __$$_GeofenceCopyWithImpl(
      _$_Geofence _value, $Res Function(_$_Geofence) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? mode = null,
    Object? description = freezed,
    Object? color = freezed,
    Object? path = freezed,
    Object? radius = freezed,
    Object? resourceId = freezed,
    Object? assetsInside = freezed,
    Object? category = null,
    Object? childrenIds = freezed,
    Object? children = freezed,
    Object? access = freezed,
    Object? customFields = freezed,
  }) {
    return _then(_$_Geofence(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      path: freezed == path
          ? _value._path
          : path // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      radius: freezed == radius
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as double?,
      resourceId: freezed == resourceId
          ? _value.resourceId
          : resourceId // ignore: cast_nullable_to_non_nullable
              as String?,
      assetsInside: freezed == assetsInside
          ? _value._assetsInside
          : assetsInside // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      category: null == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as GeofenceCategory,
      childrenIds: freezed == childrenIds
          ? _value._childrenIds
          : childrenIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      children: freezed == children
          ? _value._children
          : children // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      customFields: freezed == customFields
          ? _value._customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Geofence implements _Geofence {
  const _$_Geofence(
      {required this.id,
      required this.name,
      @GeofenceModeConverter() required this.mode,
      this.description,
      @ColorOrNullConverter() this.color,
      final List<GeofencePoint>? path,
      this.radius,
      this.resourceId,
      final List<Asset>? assetsInside,
      @GeofenceCategoryConverter() this.category = GeofenceCategory.none,
      final List<String>? childrenIds,
      final List<Geofence>? children,
      final List<Access>? access,
      final List<CustomField>? customFields})
      : _path = path,
        _assetsInside = assetsInside,
        _childrenIds = childrenIds,
        _children = children,
        _access = access,
        _customFields = customFields;

  factory _$_Geofence.fromJson(Map<String, dynamic> json) =>
      _$$_GeofenceFromJson(json);

  /// ID of the geofence entity. This ID is unique.
  @override
  final String id;

  /// Name of the geofence.
  @override
  final String name;

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @override
  @GeofenceModeConverter()
  final GeofenceMode mode;

  /// Description of the geofence.
  @override
  final String? description;

  /// Color of the geofence in hexadecimal code.
  @override
  @ColorOrNullConverter()
  final Color? color;

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  final List<GeofencePoint>? _path;

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  @override
  List<GeofencePoint>? get path {
    final value = _path;
    if (value == null) return null;
    if (_path is EqualUnmodifiableListView) return _path;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  @override
  final double? radius;

  /// External resource ID, only for external geofences.
  @override
  final String? resourceId;

  /// List of assets inside the geofence.
  final List<Asset>? _assetsInside;

  /// List of assets inside the geofence.
  @override
  List<Asset>? get assetsInside {
    final value = _assetsInside;
    if (value == null) return null;
    if (_assetsInside is EqualUnmodifiableListView) return _assetsInside;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [category] refers to the type of geofence, by default is [GeofenceCategory.none] when is requested
  /// from the API.
  @override
  @JsonKey()
  @GeofenceCategoryConverter()
  final GeofenceCategory category;

  /// [childrenIds] refers to the list of children geofences.
  final List<String>? _childrenIds;

  /// [childrenIds] refers to the list of children geofences.
  @override
  List<String>? get childrenIds {
    final value = _childrenIds;
    if (value == null) return null;
    if (_childrenIds is EqualUnmodifiableListView) return _childrenIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [children] refers to the list of children geofences.
  final List<Geofence>? _children;

  /// [children] refers to the list of children geofences.
  @override
  List<Geofence>? get children {
    final value = _children;
    if (value == null) return null;
    if (_children is EqualUnmodifiableListView) return _children;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of custom access permissions.
  final List<Access>? _access;

  /// List of custom access permissions.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of [customFields] linked to the geofence. Please read the documentation for [CustomField]
  /// for more details about the fields.
  final List<CustomField>? _customFields;

  /// List of [customFields] linked to the geofence. Please read the documentation for [CustomField]
  /// for more details about the fields.
  @override
  List<CustomField>? get customFields {
    final value = _customFields;
    if (value == null) return null;
    if (_customFields is EqualUnmodifiableListView) return _customFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Geofence(id: $id, name: $name, mode: $mode, description: $description, color: $color, path: $path, radius: $radius, resourceId: $resourceId, assetsInside: $assetsInside, category: $category, childrenIds: $childrenIds, children: $children, access: $access, customFields: $customFields)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Geofence &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.color, color) || other.color == color) &&
            const DeepCollectionEquality().equals(other._path, _path) &&
            (identical(other.radius, radius) || other.radius == radius) &&
            (identical(other.resourceId, resourceId) ||
                other.resourceId == resourceId) &&
            const DeepCollectionEquality()
                .equals(other._assetsInside, _assetsInside) &&
            (identical(other.category, category) ||
                other.category == category) &&
            const DeepCollectionEquality()
                .equals(other._childrenIds, _childrenIds) &&
            const DeepCollectionEquality().equals(other._children, _children) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            const DeepCollectionEquality()
                .equals(other._customFields, _customFields));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      mode,
      description,
      color,
      const DeepCollectionEquality().hash(_path),
      radius,
      resourceId,
      const DeepCollectionEquality().hash(_assetsInside),
      category,
      const DeepCollectionEquality().hash(_childrenIds),
      const DeepCollectionEquality().hash(_children),
      const DeepCollectionEquality().hash(_access),
      const DeepCollectionEquality().hash(_customFields));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GeofenceCopyWith<_$_Geofence> get copyWith =>
      __$$_GeofenceCopyWithImpl<_$_Geofence>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GeofenceToJson(
      this,
    );
  }
}

abstract class _Geofence implements Geofence {
  const factory _Geofence(
      {required final String id,
      required final String name,
      @GeofenceModeConverter() required final GeofenceMode mode,
      final String? description,
      @ColorOrNullConverter() final Color? color,
      final List<GeofencePoint>? path,
      final double? radius,
      final String? resourceId,
      final List<Asset>? assetsInside,
      @GeofenceCategoryConverter() final GeofenceCategory category,
      final List<String>? childrenIds,
      final List<Geofence>? children,
      final List<Access>? access,
      final List<CustomField>? customFields}) = _$_Geofence;

  factory _Geofence.fromJson(Map<String, dynamic> json) = _$_Geofence.fromJson;

  @override

  /// ID of the geofence entity. This ID is unique.
  String get id;
  @override

  /// Name of the geofence.
  String get name;
  @override

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @GeofenceModeConverter()
  GeofenceMode get mode;
  @override

  /// Description of the geofence.
  String? get description;
  @override

  /// Color of the geofence in hexadecimal code.
  @ColorOrNullConverter()
  Color? get color;
  @override

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  List<GeofencePoint>? get path;
  @override

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  double? get radius;
  @override

  /// External resource ID, only for external geofences.
  String? get resourceId;
  @override

  /// List of assets inside the geofence.
  List<Asset>? get assetsInside;
  @override

  /// [category] refers to the type of geofence, by default is [GeofenceCategory.none] when is requested
  /// from the API.
  @GeofenceCategoryConverter()
  GeofenceCategory get category;
  @override

  /// [childrenIds] refers to the list of children geofences.
  List<String>? get childrenIds;
  @override

  /// [children] refers to the list of children geofences.
  List<Geofence>? get children;
  @override

  /// List of custom access permissions.
  List<Access>? get access;
  @override

  /// List of [customFields] linked to the geofence. Please read the documentation for [CustomField]
  /// for more details about the fields.
  List<CustomField>? get customFields;
  @override
  @JsonKey(ignore: true)
  _$$_GeofenceCopyWith<_$_Geofence> get copyWith =>
      throw _privateConstructorUsedError;
}

GeofenceInput _$GeofenceInputFromJson(Map<String, dynamic> json) {
  return _GeofenceInput.fromJson(json);
}

/// @nodoc
mixin _$GeofenceInput {
  /// ID of the geofence entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the geofence entity. This ID is unique.
  set id(String? value) => throw _privateConstructorUsedError;

  /// Color of the geofence in hexadecimal code.
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  /// Color of the geofence in hexadecimal code.
  @ColorOrNullConverter()
  set color(Color? value) => throw _privateConstructorUsedError;

  /// Description of the geofence.
  String? get description => throw _privateConstructorUsedError;

  /// Description of the geofence.
  set description(String? value) => throw _privateConstructorUsedError;

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @GeofenceModeConverter()
  GeofenceMode? get mode => throw _privateConstructorUsedError;

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @GeofenceModeConverter()
  set mode(GeofenceMode? value) => throw _privateConstructorUsedError;

  /// Name of the geofence.
  String? get name => throw _privateConstructorUsedError;

  /// Name of the geofence.
  set name(String? value) => throw _privateConstructorUsedError;

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  List<GeofencePoint>? get path => throw _privateConstructorUsedError;

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  set path(List<GeofencePoint>? value) => throw _privateConstructorUsedError;

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  double? get radius => throw _privateConstructorUsedError;

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  set radius(double? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GeofenceInputCopyWith<GeofenceInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeofenceInputCopyWith<$Res> {
  factory $GeofenceInputCopyWith(
          GeofenceInput value, $Res Function(GeofenceInput) then) =
      _$GeofenceInputCopyWithImpl<$Res, GeofenceInput>;
  @useResult
  $Res call(
      {String? id,
      @ColorOrNullConverter() Color? color,
      String? description,
      @GeofenceModeConverter() GeofenceMode? mode,
      String? name,
      List<GeofencePoint>? path,
      double? radius});
}

/// @nodoc
class _$GeofenceInputCopyWithImpl<$Res, $Val extends GeofenceInput>
    implements $GeofenceInputCopyWith<$Res> {
  _$GeofenceInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? color = freezed,
    Object? description = freezed,
    Object? mode = freezed,
    Object? name = freezed,
    Object? path = freezed,
    Object? radius = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      radius: freezed == radius
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GeofenceInputCopyWith<$Res>
    implements $GeofenceInputCopyWith<$Res> {
  factory _$$_GeofenceInputCopyWith(
          _$_GeofenceInput value, $Res Function(_$_GeofenceInput) then) =
      __$$_GeofenceInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @ColorOrNullConverter() Color? color,
      String? description,
      @GeofenceModeConverter() GeofenceMode? mode,
      String? name,
      List<GeofencePoint>? path,
      double? radius});
}

/// @nodoc
class __$$_GeofenceInputCopyWithImpl<$Res>
    extends _$GeofenceInputCopyWithImpl<$Res, _$_GeofenceInput>
    implements _$$_GeofenceInputCopyWith<$Res> {
  __$$_GeofenceInputCopyWithImpl(
      _$_GeofenceInput _value, $Res Function(_$_GeofenceInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? color = freezed,
    Object? description = freezed,
    Object? mode = freezed,
    Object? name = freezed,
    Object? path = freezed,
    Object? radius = freezed,
  }) {
    return _then(_$_GeofenceInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      radius: freezed == radius
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GeofenceInput implements _GeofenceInput {
  _$_GeofenceInput(
      {this.id,
      @ColorOrNullConverter() this.color,
      this.description,
      @GeofenceModeConverter() this.mode,
      this.name,
      this.path,
      this.radius});

  factory _$_GeofenceInput.fromJson(Map<String, dynamic> json) =>
      _$$_GeofenceInputFromJson(json);

  /// ID of the geofence entity. This ID is unique.
  @override
  String? id;

  /// Color of the geofence in hexadecimal code.
  @override
  @ColorOrNullConverter()
  Color? color;

  /// Description of the geofence.
  @override
  String? description;

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @override
  @GeofenceModeConverter()
  GeofenceMode? mode;

  /// Name of the geofence.
  @override
  String? name;

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  @override
  List<GeofencePoint>? path;

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  @override
  double? radius;

  @override
  String toString() {
    return 'GeofenceInput(id: $id, color: $color, description: $description, mode: $mode, name: $name, path: $path, radius: $radius)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GeofenceInputCopyWith<_$_GeofenceInput> get copyWith =>
      __$$_GeofenceInputCopyWithImpl<_$_GeofenceInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GeofenceInputToJson(
      this,
    );
  }
}

abstract class _GeofenceInput implements GeofenceInput {
  factory _GeofenceInput(
      {String? id,
      @ColorOrNullConverter() Color? color,
      String? description,
      @GeofenceModeConverter() GeofenceMode? mode,
      String? name,
      List<GeofencePoint>? path,
      double? radius}) = _$_GeofenceInput;

  factory _GeofenceInput.fromJson(Map<String, dynamic> json) =
      _$_GeofenceInput.fromJson;

  @override

  /// ID of the geofence entity. This ID is unique.
  String? get id;

  /// ID of the geofence entity. This ID is unique.
  set id(String? value);
  @override

  /// Color of the geofence in hexadecimal code.
  @ColorOrNullConverter()
  Color? get color;

  /// Color of the geofence in hexadecimal code.
  @ColorOrNullConverter()
  set color(Color? value);
  @override

  /// Description of the geofence.
  String? get description;

  /// Description of the geofence.
  set description(String? value);
  @override

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @GeofenceModeConverter()
  GeofenceMode? get mode;

  /// Mode of geofence, check the documentation of GeofenceMode for more information.
  @GeofenceModeConverter()
  set mode(GeofenceMode? value);
  @override

  /// Name of the geofence.
  String? get name;

  /// Name of the geofence.
  set name(String? value);
  @override

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  List<GeofencePoint>? get path;

  /// Depending of the Geofence mode, this field may return one or N points. Please check the GeofenceMode definition
  set path(List<GeofencePoint>? value);
  @override

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  double? get radius;

  /// Radius of the geofence in meters. If mode is GeofenceMode.LINEAR, this field will be the weight of the geofence. For GeofenceMode.POLYGON, this field will be ignored.
  set radius(double? value);
  @override
  @JsonKey(ignore: true)
  _$$_GeofenceInputCopyWith<_$_GeofenceInput> get copyWith =>
      throw _privateConstructorUsedError;
}

GeoPoint _$GeoPointFromJson(Map<String, dynamic> json) {
  return _GeoPoint.fromJson(json);
}

/// @nodoc
mixin _$GeoPoint {
  double? get latitude => throw _privateConstructorUsedError;
  double? get longitude => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GeoPointCopyWith<GeoPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GeoPointCopyWith<$Res> {
  factory $GeoPointCopyWith(GeoPoint value, $Res Function(GeoPoint) then) =
      _$GeoPointCopyWithImpl<$Res, GeoPoint>;
  @useResult
  $Res call({double? latitude, double? longitude});
}

/// @nodoc
class _$GeoPointCopyWithImpl<$Res, $Val extends GeoPoint>
    implements $GeoPointCopyWith<$Res> {
  _$GeoPointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
  }) {
    return _then(_value.copyWith(
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GeoPointCopyWith<$Res> implements $GeoPointCopyWith<$Res> {
  factory _$$_GeoPointCopyWith(
          _$_GeoPoint value, $Res Function(_$_GeoPoint) then) =
      __$$_GeoPointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double? latitude, double? longitude});
}

/// @nodoc
class __$$_GeoPointCopyWithImpl<$Res>
    extends _$GeoPointCopyWithImpl<$Res, _$_GeoPoint>
    implements _$$_GeoPointCopyWith<$Res> {
  __$$_GeoPointCopyWithImpl(
      _$_GeoPoint _value, $Res Function(_$_GeoPoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
  }) {
    return _then(_$_GeoPoint(
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GeoPoint implements _GeoPoint {
  const _$_GeoPoint({this.latitude, this.longitude});

  factory _$_GeoPoint.fromJson(Map<String, dynamic> json) =>
      _$$_GeoPointFromJson(json);

  @override
  final double? latitude;
  @override
  final double? longitude;

  @override
  String toString() {
    return 'GeoPoint(latitude: $latitude, longitude: $longitude)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GeoPoint &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, latitude, longitude);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GeoPointCopyWith<_$_GeoPoint> get copyWith =>
      __$$_GeoPointCopyWithImpl<_$_GeoPoint>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GeoPointToJson(
      this,
    );
  }
}

abstract class _GeoPoint implements GeoPoint {
  const factory _GeoPoint({final double? latitude, final double? longitude}) =
      _$_GeoPoint;

  factory _GeoPoint.fromJson(Map<String, dynamic> json) = _$_GeoPoint.fromJson;

  @override
  double? get latitude;
  @override
  double? get longitude;
  @override
  @JsonKey(ignore: true)
  _$$_GeoPointCopyWith<_$_GeoPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

ContactInfo _$ContactInfoFromJson(Map<String, dynamic> json) {
  return _ContactInfo.fromJson(json);
}

/// @nodoc
mixin _$ContactInfo {
  String get name => throw _privateConstructorUsedError;
  String get email => throw _privateConstructorUsedError;
  String get phone => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ContactInfoCopyWith<ContactInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContactInfoCopyWith<$Res> {
  factory $ContactInfoCopyWith(
          ContactInfo value, $Res Function(ContactInfo) then) =
      _$ContactInfoCopyWithImpl<$Res, ContactInfo>;
  @useResult
  $Res call({String name, String email, String phone});
}

/// @nodoc
class _$ContactInfoCopyWithImpl<$Res, $Val extends ContactInfo>
    implements $ContactInfoCopyWith<$Res> {
  _$ContactInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? email = null,
    Object? phone = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      phone: null == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ContactInfoCopyWith<$Res>
    implements $ContactInfoCopyWith<$Res> {
  factory _$$_ContactInfoCopyWith(
          _$_ContactInfo value, $Res Function(_$_ContactInfo) then) =
      __$$_ContactInfoCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String email, String phone});
}

/// @nodoc
class __$$_ContactInfoCopyWithImpl<$Res>
    extends _$ContactInfoCopyWithImpl<$Res, _$_ContactInfo>
    implements _$$_ContactInfoCopyWith<$Res> {
  __$$_ContactInfoCopyWithImpl(
      _$_ContactInfo _value, $Res Function(_$_ContactInfo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? email = null,
    Object? phone = null,
  }) {
    return _then(_$_ContactInfo(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      email: null == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      phone: null == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ContactInfo implements _ContactInfo {
  const _$_ContactInfo({this.name = '', this.email = '', this.phone = ''});

  factory _$_ContactInfo.fromJson(Map<String, dynamic> json) =>
      _$$_ContactInfoFromJson(json);

  @override
  @JsonKey()
  final String name;
  @override
  @JsonKey()
  final String email;
  @override
  @JsonKey()
  final String phone;

  @override
  String toString() {
    return 'ContactInfo(name: $name, email: $email, phone: $phone)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ContactInfo &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.phone, phone) || other.phone == phone));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, email, phone);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ContactInfoCopyWith<_$_ContactInfo> get copyWith =>
      __$$_ContactInfoCopyWithImpl<_$_ContactInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ContactInfoToJson(
      this,
    );
  }
}

abstract class _ContactInfo implements ContactInfo {
  const factory _ContactInfo(
      {final String name,
      final String email,
      final String phone}) = _$_ContactInfo;

  factory _ContactInfo.fromJson(Map<String, dynamic> json) =
      _$_ContactInfo.fromJson;

  @override
  String get name;
  @override
  String get email;
  @override
  String get phone;
  @override
  @JsonKey(ignore: true)
  _$$_ContactInfoCopyWith<_$_ContactInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

AssetLoginInfo _$AssetLoginInfoFromJson(Map<String, dynamic> json) {
  return _AssetLoginInfo.fromJson(json);
}

/// @nodoc
mixin _$AssetLoginInfo {
  /// [enabled] is the login status of the asset.
  bool get enabled => throw _privateConstructorUsedError;

  /// [email] is the login email of the asset.
  String? get email => throw _privateConstructorUsedError;

  /// [username] is the login username of the asset.
  String? get username => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetLoginInfoCopyWith<AssetLoginInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetLoginInfoCopyWith<$Res> {
  factory $AssetLoginInfoCopyWith(
          AssetLoginInfo value, $Res Function(AssetLoginInfo) then) =
      _$AssetLoginInfoCopyWithImpl<$Res, AssetLoginInfo>;
  @useResult
  $Res call({bool enabled, String? email, String? username});
}

/// @nodoc
class _$AssetLoginInfoCopyWithImpl<$Res, $Val extends AssetLoginInfo>
    implements $AssetLoginInfoCopyWith<$Res> {
  _$AssetLoginInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? email = freezed,
    Object? username = freezed,
  }) {
    return _then(_value.copyWith(
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AssetLoginInfoCopyWith<$Res>
    implements $AssetLoginInfoCopyWith<$Res> {
  factory _$$_AssetLoginInfoCopyWith(
          _$_AssetLoginInfo value, $Res Function(_$_AssetLoginInfo) then) =
      __$$_AssetLoginInfoCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool enabled, String? email, String? username});
}

/// @nodoc
class __$$_AssetLoginInfoCopyWithImpl<$Res>
    extends _$AssetLoginInfoCopyWithImpl<$Res, _$_AssetLoginInfo>
    implements _$$_AssetLoginInfoCopyWith<$Res> {
  __$$_AssetLoginInfoCopyWithImpl(
      _$_AssetLoginInfo _value, $Res Function(_$_AssetLoginInfo) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? email = freezed,
    Object? username = freezed,
  }) {
    return _then(_$_AssetLoginInfo(
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AssetLoginInfo implements _AssetLoginInfo {
  const _$_AssetLoginInfo({required this.enabled, this.email, this.username});

  factory _$_AssetLoginInfo.fromJson(Map<String, dynamic> json) =>
      _$$_AssetLoginInfoFromJson(json);

  /// [enabled] is the login status of the asset.
  @override
  final bool enabled;

  /// [email] is the login email of the asset.
  @override
  final String? email;

  /// [username] is the login username of the asset.
  @override
  final String? username;

  @override
  String toString() {
    return 'AssetLoginInfo(enabled: $enabled, email: $email, username: $username)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AssetLoginInfo &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.username, username) ||
                other.username == username));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, enabled, email, username);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AssetLoginInfoCopyWith<_$_AssetLoginInfo> get copyWith =>
      __$$_AssetLoginInfoCopyWithImpl<_$_AssetLoginInfo>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetLoginInfoToJson(
      this,
    );
  }
}

abstract class _AssetLoginInfo implements AssetLoginInfo {
  const factory _AssetLoginInfo(
      {required final bool enabled,
      final String? email,
      final String? username}) = _$_AssetLoginInfo;

  factory _AssetLoginInfo.fromJson(Map<String, dynamic> json) =
      _$_AssetLoginInfo.fromJson;

  @override

  /// [enabled] is the login status of the asset.
  bool get enabled;
  @override

  /// [email] is the login email of the asset.
  String? get email;
  @override

  /// [username] is the login username of the asset.
  String? get username;
  @override
  @JsonKey(ignore: true)
  _$$_AssetLoginInfoCopyWith<_$_AssetLoginInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

Asset _$AssetFromJson(Map<String, dynamic> json) {
  return _Asset.fromJson(json);
}

/// @nodoc
mixin _$Asset {
  /// [id] of the asset entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// [name] of the asset.
  String get name => throw _privateConstructorUsedError;

  /// [plate] of the asset (If apply).
  String? get plate => throw _privateConstructorUsedError;

  /// [vin] or Vehicle serial number of the asset (If apply).
  String? get vin => throw _privateConstructorUsedError;

  /// [dynamicIcon] is the icon of the asset.
  /// This is the new schema of the icon
  Avatar? get dynamicIcon => throw _privateConstructorUsedError;

  /// Operation [mode] of the asset
  @AssetModeOrNullConverter()
  AssetMode? get mode => throw _privateConstructorUsedError;

  /// Children [assets] ids, only for clusters, limited to 1 level.
  List<String>? get childrenIds => throw _privateConstructorUsedError;

  /// Children [assets], only for clusters, limited to 1 level.
  List<Asset>? get children => throw _privateConstructorUsedError;

  /// Is the list of device [commands] available for this asset.
  List<DeviceCommand>? get commands => throw _privateConstructorUsedError;

  /// Is the list of available [parameters] for this asset.
  List<String?>? get parameters => throw _privateConstructorUsedError;

  /// Is the list of [references] ids associated to the asset
  List<String>? get referencesIds => throw _privateConstructorUsedError;

  /// Is the list of [references] associated to the asset
  List<Reference>? get references => throw _privateConstructorUsedError;

  /// Is the list of [authenticatedAssetsIds] to the asset
  List<String>? get authenticatedAssetsIds =>
      throw _privateConstructorUsedError;

  /// Is the list of [authenticatedAssets] to the asset
  List<Asset>? get authenticatedAssets => throw _privateConstructorUsedError;

  /// Is the list of [authenticatedUsersIds] to the asset
  List<String>? get authenticatedUsersIds => throw _privateConstructorUsedError;

  /// Is the list of [authenticatedUsers] to the asset
  List<User>? get authenticatedUsers => throw _privateConstructorUsedError;

  /// [kindId] is the id of the asset kind.
  String? get kindId => throw _privateConstructorUsedError;

  /// [kind] is the asset kind.
  Category? get kind => throw _privateConstructorUsedError;

  /// List of [customFields] linked to the asset. Please read the documentation for [CustomField]
  /// for more details about the fields.
  List<CustomField>? get customFields => throw _privateConstructorUsedError;

  /// List of [sensors] linked to the asset. Please read the documentation for Sensor for more
  /// details about the fields.
  List<Sensor>? get sensors => throw _privateConstructorUsedError;

  /// [primaryId] is the primary device id.
  String? get primaryId => throw _privateConstructorUsedError;

  /// [primary] is the primary device.
  Device? get primary => throw _privateConstructorUsedError;

  /// [secondaryId] is the secondary device id.
  String? get secondaryId => throw _privateConstructorUsedError;

  /// [secondary] is the secondary device.
  Device? get secondary => throw _privateConstructorUsedError;

  /// [devicesIds] is the list of devices ids associated to the asset.
  List<String>? get devicesIds => throw _privateConstructorUsedError;

  /// [devices] is the list of devices associated to the asset.
  List<Device>? get devices => throw _privateConstructorUsedError;

  /// [qrCode] is the QR code of the asset.
  String? get qrCode => throw _privateConstructorUsedError;

  /// [externalIdentifiers] is the list of external identifiers of the asset.
  List<String>? get externalIdentifiers => throw _privateConstructorUsedError;

  /// [connection] is the connection status of the asset.
  Connection? get connection => throw _privateConstructorUsedError;

  /// [telemetry] is the telemetry of the asset.
  AssetTelemetry? get telemetry => throw _privateConstructorUsedError;

  /// List of [tags] assigned to the asset
  List<Tag>? get tags => throw _privateConstructorUsedError;

  /// List of custom [access] permissions.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// List of [lastExits] of the asset.
  /// Only used for AllTank Systems project.
  List<AtsExit>? get lastExits => throw _privateConstructorUsedError;

  /// [activeTime] is the active time of the asset.
  /// Only used for AllTank Systems project.
  String? get activeTime => throw _privateConstructorUsedError;

  /// [contacts] is the list of contacts associated to the asset.
  List<ContactInfo>? get contacts => throw _privateConstructorUsedError;

  /// [laborHours] represents the list of labor hours configured to this asset.
  /// This field is only for `Mappit` use.
  List<MappitLaborHour>? get mappitLaborHours =>
      throw _privateConstructorUsedError;

  /// [ownerId] is the ID of the user owner of this asset
  String? get ownerId => throw _privateConstructorUsedError;

  /// [loginInfo] refers to the login information of the asset.
  AssetLoginInfo? get loginInfo => throw _privateConstructorUsedError;

  /// [authenticationCard] refers to the authentication card of the asset.
  /// Only used in ATS apps.
  AtsAuthenticationCard? get authenticationCard =>
      throw _privateConstructorUsedError;

  /// [authenticationCardId] refers to the authentication card ID of the asset.
  /// Only used in ATS apps.
  String? get authenticationCardId => throw _privateConstructorUsedError;

  /// [nfcIdentifier] refers to the NFC identifier of the asset.
  /// Only used in ATS apps.
  String? get nfcIdentifier => throw _privateConstructorUsedError;

  /// [linkedSupplyPointAssets] refers to the list of supply points assets linked to this asset.
  /// Only used in ATS apps.
  List<Asset>? get linkedSupplyPointAssets =>
      throw _privateConstructorUsedError;

  /// [linkedSupplyPointAssetsIds] refers to the list of supply points assets IDs linked to this asset.
  /// Only used in ATS apps.
  List<String>? get linkedSupplyPointAssetsIds =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetCopyWith<Asset> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetCopyWith<$Res> {
  factory $AssetCopyWith(Asset value, $Res Function(Asset) then) =
      _$AssetCopyWithImpl<$Res, Asset>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? plate,
      String? vin,
      Avatar? dynamicIcon,
      @AssetModeOrNullConverter() AssetMode? mode,
      List<String>? childrenIds,
      List<Asset>? children,
      List<DeviceCommand>? commands,
      List<String?>? parameters,
      List<String>? referencesIds,
      List<Reference>? references,
      List<String>? authenticatedAssetsIds,
      List<Asset>? authenticatedAssets,
      List<String>? authenticatedUsersIds,
      List<User>? authenticatedUsers,
      String? kindId,
      Category? kind,
      List<CustomField>? customFields,
      List<Sensor>? sensors,
      String? primaryId,
      Device? primary,
      String? secondaryId,
      Device? secondary,
      List<String>? devicesIds,
      List<Device>? devices,
      String? qrCode,
      List<String>? externalIdentifiers,
      Connection? connection,
      AssetTelemetry? telemetry,
      List<Tag>? tags,
      List<Access>? access,
      List<AtsExit>? lastExits,
      String? activeTime,
      List<ContactInfo>? contacts,
      List<MappitLaborHour>? mappitLaborHours,
      String? ownerId,
      AssetLoginInfo? loginInfo,
      AtsAuthenticationCard? authenticationCard,
      String? authenticationCardId,
      String? nfcIdentifier,
      List<Asset>? linkedSupplyPointAssets,
      List<String>? linkedSupplyPointAssetsIds});

  $AvatarCopyWith<$Res>? get dynamicIcon;
  $CategoryCopyWith<$Res>? get kind;
  $DeviceCopyWith<$Res>? get primary;
  $DeviceCopyWith<$Res>? get secondary;
  $ConnectionCopyWith<$Res>? get connection;
  $AssetTelemetryCopyWith<$Res>? get telemetry;
  $AssetLoginInfoCopyWith<$Res>? get loginInfo;
  $AtsAuthenticationCardCopyWith<$Res>? get authenticationCard;
}

/// @nodoc
class _$AssetCopyWithImpl<$Res, $Val extends Asset>
    implements $AssetCopyWith<$Res> {
  _$AssetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? plate = freezed,
    Object? vin = freezed,
    Object? dynamicIcon = freezed,
    Object? mode = freezed,
    Object? childrenIds = freezed,
    Object? children = freezed,
    Object? commands = freezed,
    Object? parameters = freezed,
    Object? referencesIds = freezed,
    Object? references = freezed,
    Object? authenticatedAssetsIds = freezed,
    Object? authenticatedAssets = freezed,
    Object? authenticatedUsersIds = freezed,
    Object? authenticatedUsers = freezed,
    Object? kindId = freezed,
    Object? kind = freezed,
    Object? customFields = freezed,
    Object? sensors = freezed,
    Object? primaryId = freezed,
    Object? primary = freezed,
    Object? secondaryId = freezed,
    Object? secondary = freezed,
    Object? devicesIds = freezed,
    Object? devices = freezed,
    Object? qrCode = freezed,
    Object? externalIdentifiers = freezed,
    Object? connection = freezed,
    Object? telemetry = freezed,
    Object? tags = freezed,
    Object? access = freezed,
    Object? lastExits = freezed,
    Object? activeTime = freezed,
    Object? contacts = freezed,
    Object? mappitLaborHours = freezed,
    Object? ownerId = freezed,
    Object? loginInfo = freezed,
    Object? authenticationCard = freezed,
    Object? authenticationCardId = freezed,
    Object? nfcIdentifier = freezed,
    Object? linkedSupplyPointAssets = freezed,
    Object? linkedSupplyPointAssetsIds = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      plate: freezed == plate
          ? _value.plate
          : plate // ignore: cast_nullable_to_non_nullable
              as String?,
      vin: freezed == vin
          ? _value.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicIcon: freezed == dynamicIcon
          ? _value.dynamicIcon
          : dynamicIcon // ignore: cast_nullable_to_non_nullable
              as Avatar?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as AssetMode?,
      childrenIds: freezed == childrenIds
          ? _value.childrenIds
          : childrenIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      children: freezed == children
          ? _value.children
          : children // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      commands: freezed == commands
          ? _value.commands
          : commands // ignore: cast_nullable_to_non_nullable
              as List<DeviceCommand>?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<String?>?,
      referencesIds: freezed == referencesIds
          ? _value.referencesIds
          : referencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      references: freezed == references
          ? _value.references
          : references // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      authenticatedAssetsIds: freezed == authenticatedAssetsIds
          ? _value.authenticatedAssetsIds
          : authenticatedAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authenticatedAssets: freezed == authenticatedAssets
          ? _value.authenticatedAssets
          : authenticatedAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      authenticatedUsersIds: freezed == authenticatedUsersIds
          ? _value.authenticatedUsersIds
          : authenticatedUsersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authenticatedUsers: freezed == authenticatedUsers
          ? _value.authenticatedUsers
          : authenticatedUsers // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      kindId: freezed == kindId
          ? _value.kindId
          : kindId // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as Category?,
      customFields: freezed == customFields
          ? _value.customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
      sensors: freezed == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<Sensor>?,
      primaryId: freezed == primaryId
          ? _value.primaryId
          : primaryId // ignore: cast_nullable_to_non_nullable
              as String?,
      primary: freezed == primary
          ? _value.primary
          : primary // ignore: cast_nullable_to_non_nullable
              as Device?,
      secondaryId: freezed == secondaryId
          ? _value.secondaryId
          : secondaryId // ignore: cast_nullable_to_non_nullable
              as String?,
      secondary: freezed == secondary
          ? _value.secondary
          : secondary // ignore: cast_nullable_to_non_nullable
              as Device?,
      devicesIds: freezed == devicesIds
          ? _value.devicesIds
          : devicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      devices: freezed == devices
          ? _value.devices
          : devices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
      externalIdentifiers: freezed == externalIdentifiers
          ? _value.externalIdentifiers
          : externalIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      connection: freezed == connection
          ? _value.connection
          : connection // ignore: cast_nullable_to_non_nullable
              as Connection?,
      telemetry: freezed == telemetry
          ? _value.telemetry
          : telemetry // ignore: cast_nullable_to_non_nullable
              as AssetTelemetry?,
      tags: freezed == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      lastExits: freezed == lastExits
          ? _value.lastExits
          : lastExits // ignore: cast_nullable_to_non_nullable
              as List<AtsExit>?,
      activeTime: freezed == activeTime
          ? _value.activeTime
          : activeTime // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _value.contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<ContactInfo>?,
      mappitLaborHours: freezed == mappitLaborHours
          ? _value.mappitLaborHours
          : mappitLaborHours // ignore: cast_nullable_to_non_nullable
              as List<MappitLaborHour>?,
      ownerId: freezed == ownerId
          ? _value.ownerId
          : ownerId // ignore: cast_nullable_to_non_nullable
              as String?,
      loginInfo: freezed == loginInfo
          ? _value.loginInfo
          : loginInfo // ignore: cast_nullable_to_non_nullable
              as AssetLoginInfo?,
      authenticationCard: freezed == authenticationCard
          ? _value.authenticationCard
          : authenticationCard // ignore: cast_nullable_to_non_nullable
              as AtsAuthenticationCard?,
      authenticationCardId: freezed == authenticationCardId
          ? _value.authenticationCardId
          : authenticationCardId // ignore: cast_nullable_to_non_nullable
              as String?,
      nfcIdentifier: freezed == nfcIdentifier
          ? _value.nfcIdentifier
          : nfcIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      linkedSupplyPointAssets: freezed == linkedSupplyPointAssets
          ? _value.linkedSupplyPointAssets
          : linkedSupplyPointAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      linkedSupplyPointAssetsIds: freezed == linkedSupplyPointAssetsIds
          ? _value.linkedSupplyPointAssetsIds
          : linkedSupplyPointAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AvatarCopyWith<$Res>? get dynamicIcon {
    if (_value.dynamicIcon == null) {
      return null;
    }

    return $AvatarCopyWith<$Res>(_value.dynamicIcon!, (value) {
      return _then(_value.copyWith(dynamicIcon: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CategoryCopyWith<$Res>? get kind {
    if (_value.kind == null) {
      return null;
    }

    return $CategoryCopyWith<$Res>(_value.kind!, (value) {
      return _then(_value.copyWith(kind: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DeviceCopyWith<$Res>? get primary {
    if (_value.primary == null) {
      return null;
    }

    return $DeviceCopyWith<$Res>(_value.primary!, (value) {
      return _then(_value.copyWith(primary: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DeviceCopyWith<$Res>? get secondary {
    if (_value.secondary == null) {
      return null;
    }

    return $DeviceCopyWith<$Res>(_value.secondary!, (value) {
      return _then(_value.copyWith(secondary: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ConnectionCopyWith<$Res>? get connection {
    if (_value.connection == null) {
      return null;
    }

    return $ConnectionCopyWith<$Res>(_value.connection!, (value) {
      return _then(_value.copyWith(connection: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetTelemetryCopyWith<$Res>? get telemetry {
    if (_value.telemetry == null) {
      return null;
    }

    return $AssetTelemetryCopyWith<$Res>(_value.telemetry!, (value) {
      return _then(_value.copyWith(telemetry: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetLoginInfoCopyWith<$Res>? get loginInfo {
    if (_value.loginInfo == null) {
      return null;
    }

    return $AssetLoginInfoCopyWith<$Res>(_value.loginInfo!, (value) {
      return _then(_value.copyWith(loginInfo: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsAuthenticationCardCopyWith<$Res>? get authenticationCard {
    if (_value.authenticationCard == null) {
      return null;
    }

    return $AtsAuthenticationCardCopyWith<$Res>(_value.authenticationCard!,
        (value) {
      return _then(_value.copyWith(authenticationCard: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AssetCopyWith<$Res> implements $AssetCopyWith<$Res> {
  factory _$$_AssetCopyWith(_$_Asset value, $Res Function(_$_Asset) then) =
      __$$_AssetCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? plate,
      String? vin,
      Avatar? dynamicIcon,
      @AssetModeOrNullConverter() AssetMode? mode,
      List<String>? childrenIds,
      List<Asset>? children,
      List<DeviceCommand>? commands,
      List<String?>? parameters,
      List<String>? referencesIds,
      List<Reference>? references,
      List<String>? authenticatedAssetsIds,
      List<Asset>? authenticatedAssets,
      List<String>? authenticatedUsersIds,
      List<User>? authenticatedUsers,
      String? kindId,
      Category? kind,
      List<CustomField>? customFields,
      List<Sensor>? sensors,
      String? primaryId,
      Device? primary,
      String? secondaryId,
      Device? secondary,
      List<String>? devicesIds,
      List<Device>? devices,
      String? qrCode,
      List<String>? externalIdentifiers,
      Connection? connection,
      AssetTelemetry? telemetry,
      List<Tag>? tags,
      List<Access>? access,
      List<AtsExit>? lastExits,
      String? activeTime,
      List<ContactInfo>? contacts,
      List<MappitLaborHour>? mappitLaborHours,
      String? ownerId,
      AssetLoginInfo? loginInfo,
      AtsAuthenticationCard? authenticationCard,
      String? authenticationCardId,
      String? nfcIdentifier,
      List<Asset>? linkedSupplyPointAssets,
      List<String>? linkedSupplyPointAssetsIds});

  @override
  $AvatarCopyWith<$Res>? get dynamicIcon;
  @override
  $CategoryCopyWith<$Res>? get kind;
  @override
  $DeviceCopyWith<$Res>? get primary;
  @override
  $DeviceCopyWith<$Res>? get secondary;
  @override
  $ConnectionCopyWith<$Res>? get connection;
  @override
  $AssetTelemetryCopyWith<$Res>? get telemetry;
  @override
  $AssetLoginInfoCopyWith<$Res>? get loginInfo;
  @override
  $AtsAuthenticationCardCopyWith<$Res>? get authenticationCard;
}

/// @nodoc
class __$$_AssetCopyWithImpl<$Res> extends _$AssetCopyWithImpl<$Res, _$_Asset>
    implements _$$_AssetCopyWith<$Res> {
  __$$_AssetCopyWithImpl(_$_Asset _value, $Res Function(_$_Asset) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? plate = freezed,
    Object? vin = freezed,
    Object? dynamicIcon = freezed,
    Object? mode = freezed,
    Object? childrenIds = freezed,
    Object? children = freezed,
    Object? commands = freezed,
    Object? parameters = freezed,
    Object? referencesIds = freezed,
    Object? references = freezed,
    Object? authenticatedAssetsIds = freezed,
    Object? authenticatedAssets = freezed,
    Object? authenticatedUsersIds = freezed,
    Object? authenticatedUsers = freezed,
    Object? kindId = freezed,
    Object? kind = freezed,
    Object? customFields = freezed,
    Object? sensors = freezed,
    Object? primaryId = freezed,
    Object? primary = freezed,
    Object? secondaryId = freezed,
    Object? secondary = freezed,
    Object? devicesIds = freezed,
    Object? devices = freezed,
    Object? qrCode = freezed,
    Object? externalIdentifiers = freezed,
    Object? connection = freezed,
    Object? telemetry = freezed,
    Object? tags = freezed,
    Object? access = freezed,
    Object? lastExits = freezed,
    Object? activeTime = freezed,
    Object? contacts = freezed,
    Object? mappitLaborHours = freezed,
    Object? ownerId = freezed,
    Object? loginInfo = freezed,
    Object? authenticationCard = freezed,
    Object? authenticationCardId = freezed,
    Object? nfcIdentifier = freezed,
    Object? linkedSupplyPointAssets = freezed,
    Object? linkedSupplyPointAssetsIds = freezed,
  }) {
    return _then(_$_Asset(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      plate: freezed == plate
          ? _value.plate
          : plate // ignore: cast_nullable_to_non_nullable
              as String?,
      vin: freezed == vin
          ? _value.vin
          : vin // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicIcon: freezed == dynamicIcon
          ? _value.dynamicIcon
          : dynamicIcon // ignore: cast_nullable_to_non_nullable
              as Avatar?,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as AssetMode?,
      childrenIds: freezed == childrenIds
          ? _value._childrenIds
          : childrenIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      children: freezed == children
          ? _value._children
          : children // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      commands: freezed == commands
          ? _value._commands
          : commands // ignore: cast_nullable_to_non_nullable
              as List<DeviceCommand>?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<String?>?,
      referencesIds: freezed == referencesIds
          ? _value._referencesIds
          : referencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      references: freezed == references
          ? _value._references
          : references // ignore: cast_nullable_to_non_nullable
              as List<Reference>?,
      authenticatedAssetsIds: freezed == authenticatedAssetsIds
          ? _value._authenticatedAssetsIds
          : authenticatedAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authenticatedAssets: freezed == authenticatedAssets
          ? _value._authenticatedAssets
          : authenticatedAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      authenticatedUsersIds: freezed == authenticatedUsersIds
          ? _value._authenticatedUsersIds
          : authenticatedUsersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authenticatedUsers: freezed == authenticatedUsers
          ? _value._authenticatedUsers
          : authenticatedUsers // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      kindId: freezed == kindId
          ? _value.kindId
          : kindId // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as Category?,
      customFields: freezed == customFields
          ? _value._customFields
          : customFields // ignore: cast_nullable_to_non_nullable
              as List<CustomField>?,
      sensors: freezed == sensors
          ? _value._sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<Sensor>?,
      primaryId: freezed == primaryId
          ? _value.primaryId
          : primaryId // ignore: cast_nullable_to_non_nullable
              as String?,
      primary: freezed == primary
          ? _value.primary
          : primary // ignore: cast_nullable_to_non_nullable
              as Device?,
      secondaryId: freezed == secondaryId
          ? _value.secondaryId
          : secondaryId // ignore: cast_nullable_to_non_nullable
              as String?,
      secondary: freezed == secondary
          ? _value.secondary
          : secondary // ignore: cast_nullable_to_non_nullable
              as Device?,
      devicesIds: freezed == devicesIds
          ? _value._devicesIds
          : devicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      devices: freezed == devices
          ? _value._devices
          : devices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
      externalIdentifiers: freezed == externalIdentifiers
          ? _value._externalIdentifiers
          : externalIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      connection: freezed == connection
          ? _value.connection
          : connection // ignore: cast_nullable_to_non_nullable
              as Connection?,
      telemetry: freezed == telemetry
          ? _value.telemetry
          : telemetry // ignore: cast_nullable_to_non_nullable
              as AssetTelemetry?,
      tags: freezed == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      lastExits: freezed == lastExits
          ? _value._lastExits
          : lastExits // ignore: cast_nullable_to_non_nullable
              as List<AtsExit>?,
      activeTime: freezed == activeTime
          ? _value.activeTime
          : activeTime // ignore: cast_nullable_to_non_nullable
              as String?,
      contacts: freezed == contacts
          ? _value._contacts
          : contacts // ignore: cast_nullable_to_non_nullable
              as List<ContactInfo>?,
      mappitLaborHours: freezed == mappitLaborHours
          ? _value._mappitLaborHours
          : mappitLaborHours // ignore: cast_nullable_to_non_nullable
              as List<MappitLaborHour>?,
      ownerId: freezed == ownerId
          ? _value.ownerId
          : ownerId // ignore: cast_nullable_to_non_nullable
              as String?,
      loginInfo: freezed == loginInfo
          ? _value.loginInfo
          : loginInfo // ignore: cast_nullable_to_non_nullable
              as AssetLoginInfo?,
      authenticationCard: freezed == authenticationCard
          ? _value.authenticationCard
          : authenticationCard // ignore: cast_nullable_to_non_nullable
              as AtsAuthenticationCard?,
      authenticationCardId: freezed == authenticationCardId
          ? _value.authenticationCardId
          : authenticationCardId // ignore: cast_nullable_to_non_nullable
              as String?,
      nfcIdentifier: freezed == nfcIdentifier
          ? _value.nfcIdentifier
          : nfcIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      linkedSupplyPointAssets: freezed == linkedSupplyPointAssets
          ? _value._linkedSupplyPointAssets
          : linkedSupplyPointAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      linkedSupplyPointAssetsIds: freezed == linkedSupplyPointAssetsIds
          ? _value._linkedSupplyPointAssetsIds
          : linkedSupplyPointAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Asset implements _Asset {
  const _$_Asset(
      {required this.id,
      required this.name,
      this.plate,
      this.vin,
      this.dynamicIcon,
      @AssetModeOrNullConverter() this.mode,
      final List<String>? childrenIds,
      final List<Asset>? children,
      final List<DeviceCommand>? commands,
      final List<String?>? parameters,
      final List<String>? referencesIds,
      final List<Reference>? references,
      final List<String>? authenticatedAssetsIds,
      final List<Asset>? authenticatedAssets,
      final List<String>? authenticatedUsersIds,
      final List<User>? authenticatedUsers,
      this.kindId,
      this.kind,
      final List<CustomField>? customFields,
      final List<Sensor>? sensors,
      this.primaryId,
      this.primary,
      this.secondaryId,
      this.secondary,
      final List<String>? devicesIds,
      final List<Device>? devices,
      this.qrCode,
      final List<String>? externalIdentifiers,
      this.connection,
      this.telemetry,
      final List<Tag>? tags,
      final List<Access>? access,
      final List<AtsExit>? lastExits,
      this.activeTime,
      final List<ContactInfo>? contacts,
      final List<MappitLaborHour>? mappitLaborHours,
      this.ownerId,
      this.loginInfo,
      this.authenticationCard,
      this.authenticationCardId,
      this.nfcIdentifier,
      final List<Asset>? linkedSupplyPointAssets,
      final List<String>? linkedSupplyPointAssetsIds})
      : _childrenIds = childrenIds,
        _children = children,
        _commands = commands,
        _parameters = parameters,
        _referencesIds = referencesIds,
        _references = references,
        _authenticatedAssetsIds = authenticatedAssetsIds,
        _authenticatedAssets = authenticatedAssets,
        _authenticatedUsersIds = authenticatedUsersIds,
        _authenticatedUsers = authenticatedUsers,
        _customFields = customFields,
        _sensors = sensors,
        _devicesIds = devicesIds,
        _devices = devices,
        _externalIdentifiers = externalIdentifiers,
        _tags = tags,
        _access = access,
        _lastExits = lastExits,
        _contacts = contacts,
        _mappitLaborHours = mappitLaborHours,
        _linkedSupplyPointAssets = linkedSupplyPointAssets,
        _linkedSupplyPointAssetsIds = linkedSupplyPointAssetsIds;

  factory _$_Asset.fromJson(Map<String, dynamic> json) =>
      _$$_AssetFromJson(json);

  /// [id] of the asset entity. This ID is unique.
  @override
  final String id;

  /// [name] of the asset.
  @override
  final String name;

  /// [plate] of the asset (If apply).
  @override
  final String? plate;

  /// [vin] or Vehicle serial number of the asset (If apply).
  @override
  final String? vin;

  /// [dynamicIcon] is the icon of the asset.
  /// This is the new schema of the icon
  @override
  final Avatar? dynamicIcon;

  /// Operation [mode] of the asset
  @override
  @AssetModeOrNullConverter()
  final AssetMode? mode;

  /// Children [assets] ids, only for clusters, limited to 1 level.
  final List<String>? _childrenIds;

  /// Children [assets] ids, only for clusters, limited to 1 level.
  @override
  List<String>? get childrenIds {
    final value = _childrenIds;
    if (value == null) return null;
    if (_childrenIds is EqualUnmodifiableListView) return _childrenIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Children [assets], only for clusters, limited to 1 level.
  final List<Asset>? _children;

  /// Children [assets], only for clusters, limited to 1 level.
  @override
  List<Asset>? get children {
    final value = _children;
    if (value == null) return null;
    if (_children is EqualUnmodifiableListView) return _children;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of device [commands] available for this asset.
  final List<DeviceCommand>? _commands;

  /// Is the list of device [commands] available for this asset.
  @override
  List<DeviceCommand>? get commands {
    final value = _commands;
    if (value == null) return null;
    if (_commands is EqualUnmodifiableListView) return _commands;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of available [parameters] for this asset.
  final List<String?>? _parameters;

  /// Is the list of available [parameters] for this asset.
  @override
  List<String?>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [references] ids associated to the asset
  final List<String>? _referencesIds;

  /// Is the list of [references] ids associated to the asset
  @override
  List<String>? get referencesIds {
    final value = _referencesIds;
    if (value == null) return null;
    if (_referencesIds is EqualUnmodifiableListView) return _referencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [references] associated to the asset
  final List<Reference>? _references;

  /// Is the list of [references] associated to the asset
  @override
  List<Reference>? get references {
    final value = _references;
    if (value == null) return null;
    if (_references is EqualUnmodifiableListView) return _references;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [authenticatedAssetsIds] to the asset
  final List<String>? _authenticatedAssetsIds;

  /// Is the list of [authenticatedAssetsIds] to the asset
  @override
  List<String>? get authenticatedAssetsIds {
    final value = _authenticatedAssetsIds;
    if (value == null) return null;
    if (_authenticatedAssetsIds is EqualUnmodifiableListView)
      return _authenticatedAssetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [authenticatedAssets] to the asset
  final List<Asset>? _authenticatedAssets;

  /// Is the list of [authenticatedAssets] to the asset
  @override
  List<Asset>? get authenticatedAssets {
    final value = _authenticatedAssets;
    if (value == null) return null;
    if (_authenticatedAssets is EqualUnmodifiableListView)
      return _authenticatedAssets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [authenticatedUsersIds] to the asset
  final List<String>? _authenticatedUsersIds;

  /// Is the list of [authenticatedUsersIds] to the asset
  @override
  List<String>? get authenticatedUsersIds {
    final value = _authenticatedUsersIds;
    if (value == null) return null;
    if (_authenticatedUsersIds is EqualUnmodifiableListView)
      return _authenticatedUsersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [authenticatedUsers] to the asset
  final List<User>? _authenticatedUsers;

  /// Is the list of [authenticatedUsers] to the asset
  @override
  List<User>? get authenticatedUsers {
    final value = _authenticatedUsers;
    if (value == null) return null;
    if (_authenticatedUsers is EqualUnmodifiableListView)
      return _authenticatedUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [kindId] is the id of the asset kind.
  @override
  final String? kindId;

  /// [kind] is the asset kind.
  @override
  final Category? kind;

  /// List of [customFields] linked to the asset. Please read the documentation for [CustomField]
  /// for more details about the fields.
  final List<CustomField>? _customFields;

  /// List of [customFields] linked to the asset. Please read the documentation for [CustomField]
  /// for more details about the fields.
  @override
  List<CustomField>? get customFields {
    final value = _customFields;
    if (value == null) return null;
    if (_customFields is EqualUnmodifiableListView) return _customFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of [sensors] linked to the asset. Please read the documentation for Sensor for more
  /// details about the fields.
  final List<Sensor>? _sensors;

  /// List of [sensors] linked to the asset. Please read the documentation for Sensor for more
  /// details about the fields.
  @override
  List<Sensor>? get sensors {
    final value = _sensors;
    if (value == null) return null;
    if (_sensors is EqualUnmodifiableListView) return _sensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [primaryId] is the primary device id.
  @override
  final String? primaryId;

  /// [primary] is the primary device.
  @override
  final Device? primary;

  /// [secondaryId] is the secondary device id.
  @override
  final String? secondaryId;

  /// [secondary] is the secondary device.
  @override
  final Device? secondary;

  /// [devicesIds] is the list of devices ids associated to the asset.
  final List<String>? _devicesIds;

  /// [devicesIds] is the list of devices ids associated to the asset.
  @override
  List<String>? get devicesIds {
    final value = _devicesIds;
    if (value == null) return null;
    if (_devicesIds is EqualUnmodifiableListView) return _devicesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [devices] is the list of devices associated to the asset.
  final List<Device>? _devices;

  /// [devices] is the list of devices associated to the asset.
  @override
  List<Device>? get devices {
    final value = _devices;
    if (value == null) return null;
    if (_devices is EqualUnmodifiableListView) return _devices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [qrCode] is the QR code of the asset.
  @override
  final String? qrCode;

  /// [externalIdentifiers] is the list of external identifiers of the asset.
  final List<String>? _externalIdentifiers;

  /// [externalIdentifiers] is the list of external identifiers of the asset.
  @override
  List<String>? get externalIdentifiers {
    final value = _externalIdentifiers;
    if (value == null) return null;
    if (_externalIdentifiers is EqualUnmodifiableListView)
      return _externalIdentifiers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [connection] is the connection status of the asset.
  @override
  final Connection? connection;

  /// [telemetry] is the telemetry of the asset.
  @override
  final AssetTelemetry? telemetry;

  /// List of [tags] assigned to the asset
  final List<Tag>? _tags;

  /// List of [tags] assigned to the asset
  @override
  List<Tag>? get tags {
    final value = _tags;
    if (value == null) return null;
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of custom [access] permissions.
  final List<Access>? _access;

  /// List of custom [access] permissions.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of [lastExits] of the asset.
  /// Only used for AllTank Systems project.
  final List<AtsExit>? _lastExits;

  /// List of [lastExits] of the asset.
  /// Only used for AllTank Systems project.
  @override
  List<AtsExit>? get lastExits {
    final value = _lastExits;
    if (value == null) return null;
    if (_lastExits is EqualUnmodifiableListView) return _lastExits;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [activeTime] is the active time of the asset.
  /// Only used for AllTank Systems project.
  @override
  final String? activeTime;

  /// [contacts] is the list of contacts associated to the asset.
  final List<ContactInfo>? _contacts;

  /// [contacts] is the list of contacts associated to the asset.
  @override
  List<ContactInfo>? get contacts {
    final value = _contacts;
    if (value == null) return null;
    if (_contacts is EqualUnmodifiableListView) return _contacts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [laborHours] represents the list of labor hours configured to this asset.
  /// This field is only for `Mappit` use.
  final List<MappitLaborHour>? _mappitLaborHours;

  /// [laborHours] represents the list of labor hours configured to this asset.
  /// This field is only for `Mappit` use.
  @override
  List<MappitLaborHour>? get mappitLaborHours {
    final value = _mappitLaborHours;
    if (value == null) return null;
    if (_mappitLaborHours is EqualUnmodifiableListView)
      return _mappitLaborHours;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [ownerId] is the ID of the user owner of this asset
  @override
  final String? ownerId;

  /// [loginInfo] refers to the login information of the asset.
  @override
  final AssetLoginInfo? loginInfo;

  /// [authenticationCard] refers to the authentication card of the asset.
  /// Only used in ATS apps.
  @override
  final AtsAuthenticationCard? authenticationCard;

  /// [authenticationCardId] refers to the authentication card ID of the asset.
  /// Only used in ATS apps.
  @override
  final String? authenticationCardId;

  /// [nfcIdentifier] refers to the NFC identifier of the asset.
  /// Only used in ATS apps.
  @override
  final String? nfcIdentifier;

  /// [linkedSupplyPointAssets] refers to the list of supply points assets linked to this asset.
  /// Only used in ATS apps.
  final List<Asset>? _linkedSupplyPointAssets;

  /// [linkedSupplyPointAssets] refers to the list of supply points assets linked to this asset.
  /// Only used in ATS apps.
  @override
  List<Asset>? get linkedSupplyPointAssets {
    final value = _linkedSupplyPointAssets;
    if (value == null) return null;
    if (_linkedSupplyPointAssets is EqualUnmodifiableListView)
      return _linkedSupplyPointAssets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [linkedSupplyPointAssetsIds] refers to the list of supply points assets IDs linked to this asset.
  /// Only used in ATS apps.
  final List<String>? _linkedSupplyPointAssetsIds;

  /// [linkedSupplyPointAssetsIds] refers to the list of supply points assets IDs linked to this asset.
  /// Only used in ATS apps.
  @override
  List<String>? get linkedSupplyPointAssetsIds {
    final value = _linkedSupplyPointAssetsIds;
    if (value == null) return null;
    if (_linkedSupplyPointAssetsIds is EqualUnmodifiableListView)
      return _linkedSupplyPointAssetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Asset(id: $id, name: $name, plate: $plate, vin: $vin, dynamicIcon: $dynamicIcon, mode: $mode, childrenIds: $childrenIds, children: $children, commands: $commands, parameters: $parameters, referencesIds: $referencesIds, references: $references, authenticatedAssetsIds: $authenticatedAssetsIds, authenticatedAssets: $authenticatedAssets, authenticatedUsersIds: $authenticatedUsersIds, authenticatedUsers: $authenticatedUsers, kindId: $kindId, kind: $kind, customFields: $customFields, sensors: $sensors, primaryId: $primaryId, primary: $primary, secondaryId: $secondaryId, secondary: $secondary, devicesIds: $devicesIds, devices: $devices, qrCode: $qrCode, externalIdentifiers: $externalIdentifiers, connection: $connection, telemetry: $telemetry, tags: $tags, access: $access, lastExits: $lastExits, activeTime: $activeTime, contacts: $contacts, mappitLaborHours: $mappitLaborHours, ownerId: $ownerId, loginInfo: $loginInfo, authenticationCard: $authenticationCard, authenticationCardId: $authenticationCardId, nfcIdentifier: $nfcIdentifier, linkedSupplyPointAssets: $linkedSupplyPointAssets, linkedSupplyPointAssetsIds: $linkedSupplyPointAssetsIds)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Asset &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.plate, plate) || other.plate == plate) &&
            (identical(other.vin, vin) || other.vin == vin) &&
            (identical(other.dynamicIcon, dynamicIcon) ||
                other.dynamicIcon == dynamicIcon) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            const DeepCollectionEquality()
                .equals(other._childrenIds, _childrenIds) &&
            const DeepCollectionEquality().equals(other._children, _children) &&
            const DeepCollectionEquality().equals(other._commands, _commands) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            const DeepCollectionEquality()
                .equals(other._referencesIds, _referencesIds) &&
            const DeepCollectionEquality()
                .equals(other._references, _references) &&
            const DeepCollectionEquality().equals(
                other._authenticatedAssetsIds, _authenticatedAssetsIds) &&
            const DeepCollectionEquality()
                .equals(other._authenticatedAssets, _authenticatedAssets) &&
            const DeepCollectionEquality()
                .equals(other._authenticatedUsersIds, _authenticatedUsersIds) &&
            const DeepCollectionEquality()
                .equals(other._authenticatedUsers, _authenticatedUsers) &&
            (identical(other.kindId, kindId) || other.kindId == kindId) &&
            (identical(other.kind, kind) || other.kind == kind) &&
            const DeepCollectionEquality()
                .equals(other._customFields, _customFields) &&
            const DeepCollectionEquality().equals(other._sensors, _sensors) &&
            (identical(other.primaryId, primaryId) ||
                other.primaryId == primaryId) &&
            (identical(other.primary, primary) || other.primary == primary) &&
            (identical(other.secondaryId, secondaryId) ||
                other.secondaryId == secondaryId) &&
            (identical(other.secondary, secondary) ||
                other.secondary == secondary) &&
            const DeepCollectionEquality()
                .equals(other._devicesIds, _devicesIds) &&
            const DeepCollectionEquality().equals(other._devices, _devices) &&
            (identical(other.qrCode, qrCode) || other.qrCode == qrCode) &&
            const DeepCollectionEquality()
                .equals(other._externalIdentifiers, _externalIdentifiers) &&
            (identical(other.connection, connection) ||
                other.connection == connection) &&
            (identical(other.telemetry, telemetry) ||
                other.telemetry == telemetry) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            const DeepCollectionEquality()
                .equals(other._lastExits, _lastExits) &&
            (identical(other.activeTime, activeTime) ||
                other.activeTime == activeTime) &&
            const DeepCollectionEquality().equals(other._contacts, _contacts) &&
            const DeepCollectionEquality()
                .equals(other._mappitLaborHours, _mappitLaborHours) &&
            (identical(other.ownerId, ownerId) || other.ownerId == ownerId) &&
            (identical(other.loginInfo, loginInfo) ||
                other.loginInfo == loginInfo) &&
            (identical(other.authenticationCard, authenticationCard) ||
                other.authenticationCard == authenticationCard) &&
            (identical(other.authenticationCardId, authenticationCardId) ||
                other.authenticationCardId == authenticationCardId) &&
            (identical(other.nfcIdentifier, nfcIdentifier) ||
                other.nfcIdentifier == nfcIdentifier) &&
            const DeepCollectionEquality().equals(
                other._linkedSupplyPointAssets, _linkedSupplyPointAssets) &&
            const DeepCollectionEquality().equals(
                other._linkedSupplyPointAssetsIds,
                _linkedSupplyPointAssetsIds));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        plate,
        vin,
        dynamicIcon,
        mode,
        const DeepCollectionEquality().hash(_childrenIds),
        const DeepCollectionEquality().hash(_children),
        const DeepCollectionEquality().hash(_commands),
        const DeepCollectionEquality().hash(_parameters),
        const DeepCollectionEquality().hash(_referencesIds),
        const DeepCollectionEquality().hash(_references),
        const DeepCollectionEquality().hash(_authenticatedAssetsIds),
        const DeepCollectionEquality().hash(_authenticatedAssets),
        const DeepCollectionEquality().hash(_authenticatedUsersIds),
        const DeepCollectionEquality().hash(_authenticatedUsers),
        kindId,
        kind,
        const DeepCollectionEquality().hash(_customFields),
        const DeepCollectionEquality().hash(_sensors),
        primaryId,
        primary,
        secondaryId,
        secondary,
        const DeepCollectionEquality().hash(_devicesIds),
        const DeepCollectionEquality().hash(_devices),
        qrCode,
        const DeepCollectionEquality().hash(_externalIdentifiers),
        connection,
        telemetry,
        const DeepCollectionEquality().hash(_tags),
        const DeepCollectionEquality().hash(_access),
        const DeepCollectionEquality().hash(_lastExits),
        activeTime,
        const DeepCollectionEquality().hash(_contacts),
        const DeepCollectionEquality().hash(_mappitLaborHours),
        ownerId,
        loginInfo,
        authenticationCard,
        authenticationCardId,
        nfcIdentifier,
        const DeepCollectionEquality().hash(_linkedSupplyPointAssets),
        const DeepCollectionEquality().hash(_linkedSupplyPointAssetsIds)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AssetCopyWith<_$_Asset> get copyWith =>
      __$$_AssetCopyWithImpl<_$_Asset>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetToJson(
      this,
    );
  }
}

abstract class _Asset implements Asset {
  const factory _Asset(
      {required final String id,
      required final String name,
      final String? plate,
      final String? vin,
      final Avatar? dynamicIcon,
      @AssetModeOrNullConverter() final AssetMode? mode,
      final List<String>? childrenIds,
      final List<Asset>? children,
      final List<DeviceCommand>? commands,
      final List<String?>? parameters,
      final List<String>? referencesIds,
      final List<Reference>? references,
      final List<String>? authenticatedAssetsIds,
      final List<Asset>? authenticatedAssets,
      final List<String>? authenticatedUsersIds,
      final List<User>? authenticatedUsers,
      final String? kindId,
      final Category? kind,
      final List<CustomField>? customFields,
      final List<Sensor>? sensors,
      final String? primaryId,
      final Device? primary,
      final String? secondaryId,
      final Device? secondary,
      final List<String>? devicesIds,
      final List<Device>? devices,
      final String? qrCode,
      final List<String>? externalIdentifiers,
      final Connection? connection,
      final AssetTelemetry? telemetry,
      final List<Tag>? tags,
      final List<Access>? access,
      final List<AtsExit>? lastExits,
      final String? activeTime,
      final List<ContactInfo>? contacts,
      final List<MappitLaborHour>? mappitLaborHours,
      final String? ownerId,
      final AssetLoginInfo? loginInfo,
      final AtsAuthenticationCard? authenticationCard,
      final String? authenticationCardId,
      final String? nfcIdentifier,
      final List<Asset>? linkedSupplyPointAssets,
      final List<String>? linkedSupplyPointAssetsIds}) = _$_Asset;

  factory _Asset.fromJson(Map<String, dynamic> json) = _$_Asset.fromJson;

  @override

  /// [id] of the asset entity. This ID is unique.
  String get id;
  @override

  /// [name] of the asset.
  String get name;
  @override

  /// [plate] of the asset (If apply).
  String? get plate;
  @override

  /// [vin] or Vehicle serial number of the asset (If apply).
  String? get vin;
  @override

  /// [dynamicIcon] is the icon of the asset.
  /// This is the new schema of the icon
  Avatar? get dynamicIcon;
  @override

  /// Operation [mode] of the asset
  @AssetModeOrNullConverter()
  AssetMode? get mode;
  @override

  /// Children [assets] ids, only for clusters, limited to 1 level.
  List<String>? get childrenIds;
  @override

  /// Children [assets], only for clusters, limited to 1 level.
  List<Asset>? get children;
  @override

  /// Is the list of device [commands] available for this asset.
  List<DeviceCommand>? get commands;
  @override

  /// Is the list of available [parameters] for this asset.
  List<String?>? get parameters;
  @override

  /// Is the list of [references] ids associated to the asset
  List<String>? get referencesIds;
  @override

  /// Is the list of [references] associated to the asset
  List<Reference>? get references;
  @override

  /// Is the list of [authenticatedAssetsIds] to the asset
  List<String>? get authenticatedAssetsIds;
  @override

  /// Is the list of [authenticatedAssets] to the asset
  List<Asset>? get authenticatedAssets;
  @override

  /// Is the list of [authenticatedUsersIds] to the asset
  List<String>? get authenticatedUsersIds;
  @override

  /// Is the list of [authenticatedUsers] to the asset
  List<User>? get authenticatedUsers;
  @override

  /// [kindId] is the id of the asset kind.
  String? get kindId;
  @override

  /// [kind] is the asset kind.
  Category? get kind;
  @override

  /// List of [customFields] linked to the asset. Please read the documentation for [CustomField]
  /// for more details about the fields.
  List<CustomField>? get customFields;
  @override

  /// List of [sensors] linked to the asset. Please read the documentation for Sensor for more
  /// details about the fields.
  List<Sensor>? get sensors;
  @override

  /// [primaryId] is the primary device id.
  String? get primaryId;
  @override

  /// [primary] is the primary device.
  Device? get primary;
  @override

  /// [secondaryId] is the secondary device id.
  String? get secondaryId;
  @override

  /// [secondary] is the secondary device.
  Device? get secondary;
  @override

  /// [devicesIds] is the list of devices ids associated to the asset.
  List<String>? get devicesIds;
  @override

  /// [devices] is the list of devices associated to the asset.
  List<Device>? get devices;
  @override

  /// [qrCode] is the QR code of the asset.
  String? get qrCode;
  @override

  /// [externalIdentifiers] is the list of external identifiers of the asset.
  List<String>? get externalIdentifiers;
  @override

  /// [connection] is the connection status of the asset.
  Connection? get connection;
  @override

  /// [telemetry] is the telemetry of the asset.
  AssetTelemetry? get telemetry;
  @override

  /// List of [tags] assigned to the asset
  List<Tag>? get tags;
  @override

  /// List of custom [access] permissions.
  List<Access>? get access;
  @override

  /// List of [lastExits] of the asset.
  /// Only used for AllTank Systems project.
  List<AtsExit>? get lastExits;
  @override

  /// [activeTime] is the active time of the asset.
  /// Only used for AllTank Systems project.
  String? get activeTime;
  @override

  /// [contacts] is the list of contacts associated to the asset.
  List<ContactInfo>? get contacts;
  @override

  /// [laborHours] represents the list of labor hours configured to this asset.
  /// This field is only for `Mappit` use.
  List<MappitLaborHour>? get mappitLaborHours;
  @override

  /// [ownerId] is the ID of the user owner of this asset
  String? get ownerId;
  @override

  /// [loginInfo] refers to the login information of the asset.
  AssetLoginInfo? get loginInfo;
  @override

  /// [authenticationCard] refers to the authentication card of the asset.
  /// Only used in ATS apps.
  AtsAuthenticationCard? get authenticationCard;
  @override

  /// [authenticationCardId] refers to the authentication card ID of the asset.
  /// Only used in ATS apps.
  String? get authenticationCardId;
  @override

  /// [nfcIdentifier] refers to the NFC identifier of the asset.
  /// Only used in ATS apps.
  String? get nfcIdentifier;
  @override

  /// [linkedSupplyPointAssets] refers to the list of supply points assets linked to this asset.
  /// Only used in ATS apps.
  List<Asset>? get linkedSupplyPointAssets;
  @override

  /// [linkedSupplyPointAssetsIds] refers to the list of supply points assets IDs linked to this asset.
  /// Only used in ATS apps.
  List<String>? get linkedSupplyPointAssetsIds;
  @override
  @JsonKey(ignore: true)
  _$$_AssetCopyWith<_$_Asset> get copyWith =>
      throw _privateConstructorUsedError;
}

Device _$DeviceFromJson(Map<String, dynamic> json) {
  return _Device.fromJson(json);
}

/// @nodoc
mixin _$Device {
  String get id => throw _privateConstructorUsedError;

  /// The [name] of the device.
  String get name => throw _privateConstructorUsedError;

  /// The [ident] of the device. Generally, for GPS devices means the IMEI, for other devices means the MAC address or randomly string.
  String get ident => throw _privateConstructorUsedError;

  /// The [mqttToken] of the device, only for Xirgo MQTT devices.
  String? get mqttToken => throw _privateConstructorUsedError;

  /// The [modelId] of the device.
  String? get modelId => throw _privateConstructorUsedError;

  /// The [model] of the device.
  Model? get model => throw _privateConstructorUsedError;

  /// The [protocolId] of the device. Only the ID
  String? get protocolId => throw _privateConstructorUsedError;

  /// The [protocol] of the device.
  InboundProtocol? get protocol => throw _privateConstructorUsedError;

  /// The [additionalFields] of the device, only will return something when is imported from compatible source.
  Map<String, dynamic>? get additionalFields =>
      throw _privateConstructorUsedError;

  /// The [qrCode] of the device.
  String? get qrCode => throw _privateConstructorUsedError;

  /// The [linkQr] of the device, means the QR code generated for auto-config of the Layrz Link app device.
  String? get linkQr => throw _privateConstructorUsedError;

  /// The [commands] of the device.
  List<DeviceCommand>? get commands => throw _privateConstructorUsedError;

  /// The [access] of the device.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// Device last message, read the documentation of LastLocation for more information.
  DeviceTelemetry? get telemetry => throw _privateConstructorUsedError;

  /// The [visionProfileId] of the device. Only the ID
  String? get visionProfileId => throw _privateConstructorUsedError;

  /// The [visionProfile] of the device.
  VisionProfile? get visionProfile => throw _privateConstructorUsedError;

  /// Is the phone number information linked to this device, can be null.
  PhoneNumber? get phone => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeviceCopyWith<Device> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceCopyWith<$Res> {
  factory $DeviceCopyWith(Device value, $Res Function(Device) then) =
      _$DeviceCopyWithImpl<$Res, Device>;
  @useResult
  $Res call(
      {String id,
      String name,
      String ident,
      String? mqttToken,
      String? modelId,
      Model? model,
      String? protocolId,
      InboundProtocol? protocol,
      Map<String, dynamic>? additionalFields,
      String? qrCode,
      String? linkQr,
      List<DeviceCommand>? commands,
      List<Access>? access,
      DeviceTelemetry? telemetry,
      String? visionProfileId,
      VisionProfile? visionProfile,
      PhoneNumber? phone});

  $ModelCopyWith<$Res>? get model;
  $InboundProtocolCopyWith<$Res>? get protocol;
  $DeviceTelemetryCopyWith<$Res>? get telemetry;
  $VisionProfileCopyWith<$Res>? get visionProfile;
  $PhoneNumberCopyWith<$Res>? get phone;
}

/// @nodoc
class _$DeviceCopyWithImpl<$Res, $Val extends Device>
    implements $DeviceCopyWith<$Res> {
  _$DeviceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? ident = null,
    Object? mqttToken = freezed,
    Object? modelId = freezed,
    Object? model = freezed,
    Object? protocolId = freezed,
    Object? protocol = freezed,
    Object? additionalFields = freezed,
    Object? qrCode = freezed,
    Object? linkQr = freezed,
    Object? commands = freezed,
    Object? access = freezed,
    Object? telemetry = freezed,
    Object? visionProfileId = freezed,
    Object? visionProfile = freezed,
    Object? phone = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      ident: null == ident
          ? _value.ident
          : ident // ignore: cast_nullable_to_non_nullable
              as String,
      mqttToken: freezed == mqttToken
          ? _value.mqttToken
          : mqttToken // ignore: cast_nullable_to_non_nullable
              as String?,
      modelId: freezed == modelId
          ? _value.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as Model?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      additionalFields: freezed == additionalFields
          ? _value.additionalFields
          : additionalFields // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
      linkQr: freezed == linkQr
          ? _value.linkQr
          : linkQr // ignore: cast_nullable_to_non_nullable
              as String?,
      commands: freezed == commands
          ? _value.commands
          : commands // ignore: cast_nullable_to_non_nullable
              as List<DeviceCommand>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      telemetry: freezed == telemetry
          ? _value.telemetry
          : telemetry // ignore: cast_nullable_to_non_nullable
              as DeviceTelemetry?,
      visionProfileId: freezed == visionProfileId
          ? _value.visionProfileId
          : visionProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      visionProfile: freezed == visionProfile
          ? _value.visionProfile
          : visionProfile // ignore: cast_nullable_to_non_nullable
              as VisionProfile?,
      phone: freezed == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as PhoneNumber?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $ModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $InboundProtocolCopyWith<$Res>? get protocol {
    if (_value.protocol == null) {
      return null;
    }

    return $InboundProtocolCopyWith<$Res>(_value.protocol!, (value) {
      return _then(_value.copyWith(protocol: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $DeviceTelemetryCopyWith<$Res>? get telemetry {
    if (_value.telemetry == null) {
      return null;
    }

    return $DeviceTelemetryCopyWith<$Res>(_value.telemetry!, (value) {
      return _then(_value.copyWith(telemetry: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $VisionProfileCopyWith<$Res>? get visionProfile {
    if (_value.visionProfile == null) {
      return null;
    }

    return $VisionProfileCopyWith<$Res>(_value.visionProfile!, (value) {
      return _then(_value.copyWith(visionProfile: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PhoneNumberCopyWith<$Res>? get phone {
    if (_value.phone == null) {
      return null;
    }

    return $PhoneNumberCopyWith<$Res>(_value.phone!, (value) {
      return _then(_value.copyWith(phone: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_DeviceCopyWith<$Res> implements $DeviceCopyWith<$Res> {
  factory _$$_DeviceCopyWith(_$_Device value, $Res Function(_$_Device) then) =
      __$$_DeviceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String ident,
      String? mqttToken,
      String? modelId,
      Model? model,
      String? protocolId,
      InboundProtocol? protocol,
      Map<String, dynamic>? additionalFields,
      String? qrCode,
      String? linkQr,
      List<DeviceCommand>? commands,
      List<Access>? access,
      DeviceTelemetry? telemetry,
      String? visionProfileId,
      VisionProfile? visionProfile,
      PhoneNumber? phone});

  @override
  $ModelCopyWith<$Res>? get model;
  @override
  $InboundProtocolCopyWith<$Res>? get protocol;
  @override
  $DeviceTelemetryCopyWith<$Res>? get telemetry;
  @override
  $VisionProfileCopyWith<$Res>? get visionProfile;
  @override
  $PhoneNumberCopyWith<$Res>? get phone;
}

/// @nodoc
class __$$_DeviceCopyWithImpl<$Res>
    extends _$DeviceCopyWithImpl<$Res, _$_Device>
    implements _$$_DeviceCopyWith<$Res> {
  __$$_DeviceCopyWithImpl(_$_Device _value, $Res Function(_$_Device) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? ident = null,
    Object? mqttToken = freezed,
    Object? modelId = freezed,
    Object? model = freezed,
    Object? protocolId = freezed,
    Object? protocol = freezed,
    Object? additionalFields = freezed,
    Object? qrCode = freezed,
    Object? linkQr = freezed,
    Object? commands = freezed,
    Object? access = freezed,
    Object? telemetry = freezed,
    Object? visionProfileId = freezed,
    Object? visionProfile = freezed,
    Object? phone = freezed,
  }) {
    return _then(_$_Device(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      ident: null == ident
          ? _value.ident
          : ident // ignore: cast_nullable_to_non_nullable
              as String,
      mqttToken: freezed == mqttToken
          ? _value.mqttToken
          : mqttToken // ignore: cast_nullable_to_non_nullable
              as String?,
      modelId: freezed == modelId
          ? _value.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as Model?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      additionalFields: freezed == additionalFields
          ? _value._additionalFields
          : additionalFields // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
      linkQr: freezed == linkQr
          ? _value.linkQr
          : linkQr // ignore: cast_nullable_to_non_nullable
              as String?,
      commands: freezed == commands
          ? _value._commands
          : commands // ignore: cast_nullable_to_non_nullable
              as List<DeviceCommand>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      telemetry: freezed == telemetry
          ? _value.telemetry
          : telemetry // ignore: cast_nullable_to_non_nullable
              as DeviceTelemetry?,
      visionProfileId: freezed == visionProfileId
          ? _value.visionProfileId
          : visionProfileId // ignore: cast_nullable_to_non_nullable
              as String?,
      visionProfile: freezed == visionProfile
          ? _value.visionProfile
          : visionProfile // ignore: cast_nullable_to_non_nullable
              as VisionProfile?,
      phone: freezed == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as PhoneNumber?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Device implements _Device {
  const _$_Device(
      {required this.id,
      required this.name,
      required this.ident,
      this.mqttToken,
      this.modelId,
      this.model,
      this.protocolId,
      this.protocol,
      final Map<String, dynamic>? additionalFields,
      this.qrCode,
      this.linkQr,
      final List<DeviceCommand>? commands,
      final List<Access>? access,
      this.telemetry,
      this.visionProfileId,
      this.visionProfile,
      this.phone})
      : _additionalFields = additionalFields,
        _commands = commands,
        _access = access;

  factory _$_Device.fromJson(Map<String, dynamic> json) =>
      _$$_DeviceFromJson(json);

  @override
  final String id;

  /// The [name] of the device.
  @override
  final String name;

  /// The [ident] of the device. Generally, for GPS devices means the IMEI, for other devices means the MAC address or randomly string.
  @override
  final String ident;

  /// The [mqttToken] of the device, only for Xirgo MQTT devices.
  @override
  final String? mqttToken;

  /// The [modelId] of the device.
  @override
  final String? modelId;

  /// The [model] of the device.
  @override
  final Model? model;

  /// The [protocolId] of the device. Only the ID
  @override
  final String? protocolId;

  /// The [protocol] of the device.
  @override
  final InboundProtocol? protocol;

  /// The [additionalFields] of the device, only will return something when is imported from compatible source.
  final Map<String, dynamic>? _additionalFields;

  /// The [additionalFields] of the device, only will return something when is imported from compatible source.
  @override
  Map<String, dynamic>? get additionalFields {
    final value = _additionalFields;
    if (value == null) return null;
    if (_additionalFields is EqualUnmodifiableMapView) return _additionalFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// The [qrCode] of the device.
  @override
  final String? qrCode;

  /// The [linkQr] of the device, means the QR code generated for auto-config of the Layrz Link app device.
  @override
  final String? linkQr;

  /// The [commands] of the device.
  final List<DeviceCommand>? _commands;

  /// The [commands] of the device.
  @override
  List<DeviceCommand>? get commands {
    final value = _commands;
    if (value == null) return null;
    if (_commands is EqualUnmodifiableListView) return _commands;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The [access] of the device.
  final List<Access>? _access;

  /// The [access] of the device.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Device last message, read the documentation of LastLocation for more information.
  @override
  final DeviceTelemetry? telemetry;

  /// The [visionProfileId] of the device. Only the ID
  @override
  final String? visionProfileId;

  /// The [visionProfile] of the device.
  @override
  final VisionProfile? visionProfile;

  /// Is the phone number information linked to this device, can be null.
  @override
  final PhoneNumber? phone;

  @override
  String toString() {
    return 'Device(id: $id, name: $name, ident: $ident, mqttToken: $mqttToken, modelId: $modelId, model: $model, protocolId: $protocolId, protocol: $protocol, additionalFields: $additionalFields, qrCode: $qrCode, linkQr: $linkQr, commands: $commands, access: $access, telemetry: $telemetry, visionProfileId: $visionProfileId, visionProfile: $visionProfile, phone: $phone)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Device &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.ident, ident) || other.ident == ident) &&
            (identical(other.mqttToken, mqttToken) ||
                other.mqttToken == mqttToken) &&
            (identical(other.modelId, modelId) || other.modelId == modelId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.protocolId, protocolId) ||
                other.protocolId == protocolId) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            const DeepCollectionEquality()
                .equals(other._additionalFields, _additionalFields) &&
            (identical(other.qrCode, qrCode) || other.qrCode == qrCode) &&
            (identical(other.linkQr, linkQr) || other.linkQr == linkQr) &&
            const DeepCollectionEquality().equals(other._commands, _commands) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            (identical(other.telemetry, telemetry) ||
                other.telemetry == telemetry) &&
            (identical(other.visionProfileId, visionProfileId) ||
                other.visionProfileId == visionProfileId) &&
            (identical(other.visionProfile, visionProfile) ||
                other.visionProfile == visionProfile) &&
            (identical(other.phone, phone) || other.phone == phone));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      ident,
      mqttToken,
      modelId,
      model,
      protocolId,
      protocol,
      const DeepCollectionEquality().hash(_additionalFields),
      qrCode,
      linkQr,
      const DeepCollectionEquality().hash(_commands),
      const DeepCollectionEquality().hash(_access),
      telemetry,
      visionProfileId,
      visionProfile,
      phone);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DeviceCopyWith<_$_Device> get copyWith =>
      __$$_DeviceCopyWithImpl<_$_Device>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DeviceToJson(
      this,
    );
  }
}

abstract class _Device implements Device {
  const factory _Device(
      {required final String id,
      required final String name,
      required final String ident,
      final String? mqttToken,
      final String? modelId,
      final Model? model,
      final String? protocolId,
      final InboundProtocol? protocol,
      final Map<String, dynamic>? additionalFields,
      final String? qrCode,
      final String? linkQr,
      final List<DeviceCommand>? commands,
      final List<Access>? access,
      final DeviceTelemetry? telemetry,
      final String? visionProfileId,
      final VisionProfile? visionProfile,
      final PhoneNumber? phone}) = _$_Device;

  factory _Device.fromJson(Map<String, dynamic> json) = _$_Device.fromJson;

  @override
  String get id;
  @override

  /// The [name] of the device.
  String get name;
  @override

  /// The [ident] of the device. Generally, for GPS devices means the IMEI, for other devices means the MAC address or randomly string.
  String get ident;
  @override

  /// The [mqttToken] of the device, only for Xirgo MQTT devices.
  String? get mqttToken;
  @override

  /// The [modelId] of the device.
  String? get modelId;
  @override

  /// The [model] of the device.
  Model? get model;
  @override

  /// The [protocolId] of the device. Only the ID
  String? get protocolId;
  @override

  /// The [protocol] of the device.
  InboundProtocol? get protocol;
  @override

  /// The [additionalFields] of the device, only will return something when is imported from compatible source.
  Map<String, dynamic>? get additionalFields;
  @override

  /// The [qrCode] of the device.
  String? get qrCode;
  @override

  /// The [linkQr] of the device, means the QR code generated for auto-config of the Layrz Link app device.
  String? get linkQr;
  @override

  /// The [commands] of the device.
  List<DeviceCommand>? get commands;
  @override

  /// The [access] of the device.
  List<Access>? get access;
  @override

  /// Device last message, read the documentation of LastLocation for more information.
  DeviceTelemetry? get telemetry;
  @override

  /// The [visionProfileId] of the device. Only the ID
  String? get visionProfileId;
  @override

  /// The [visionProfile] of the device.
  VisionProfile? get visionProfile;
  @override

  /// Is the phone number information linked to this device, can be null.
  PhoneNumber? get phone;
  @override
  @JsonKey(ignore: true)
  _$$_DeviceCopyWith<_$_Device> get copyWith =>
      throw _privateConstructorUsedError;
}

CustomField _$CustomFieldFromJson(Map<String, dynamic> json) {
  return _CustomField.fromJson(json);
}

/// @nodoc
mixin _$CustomField {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get value => throw _privateConstructorUsedError;
  bool? get isFixed => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get updatedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CustomFieldCopyWith<CustomField> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomFieldCopyWith<$Res> {
  factory $CustomFieldCopyWith(
          CustomField value, $Res Function(CustomField) then) =
      _$CustomFieldCopyWithImpl<$Res, CustomField>;
  @useResult
  $Res call(
      {String id,
      String name,
      String value,
      bool? isFixed,
      @TimestampOrNullConverter() DateTime? updatedAt});
}

/// @nodoc
class _$CustomFieldCopyWithImpl<$Res, $Val extends CustomField>
    implements $CustomFieldCopyWith<$Res> {
  _$CustomFieldCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? value = null,
    Object? isFixed = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      isFixed: freezed == isFixed
          ? _value.isFixed
          : isFixed // ignore: cast_nullable_to_non_nullable
              as bool?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CustomFieldCopyWith<$Res>
    implements $CustomFieldCopyWith<$Res> {
  factory _$$_CustomFieldCopyWith(
          _$_CustomField value, $Res Function(_$_CustomField) then) =
      __$$_CustomFieldCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String value,
      bool? isFixed,
      @TimestampOrNullConverter() DateTime? updatedAt});
}

/// @nodoc
class __$$_CustomFieldCopyWithImpl<$Res>
    extends _$CustomFieldCopyWithImpl<$Res, _$_CustomField>
    implements _$$_CustomFieldCopyWith<$Res> {
  __$$_CustomFieldCopyWithImpl(
      _$_CustomField _value, $Res Function(_$_CustomField) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? value = null,
    Object? isFixed = freezed,
    Object? updatedAt = freezed,
  }) {
    return _then(_$_CustomField(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      isFixed: freezed == isFixed
          ? _value.isFixed
          : isFixed // ignore: cast_nullable_to_non_nullable
              as bool?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CustomField implements _CustomField {
  const _$_CustomField(
      {required this.id,
      required this.name,
      required this.value,
      this.isFixed,
      @TimestampOrNullConverter() this.updatedAt});

  factory _$_CustomField.fromJson(Map<String, dynamic> json) =>
      _$$_CustomFieldFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String value;
  @override
  final bool? isFixed;
  @override
  @TimestampOrNullConverter()
  final DateTime? updatedAt;

  @override
  String toString() {
    return 'CustomField(id: $id, name: $name, value: $value, isFixed: $isFixed, updatedAt: $updatedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CustomField &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.isFixed, isFixed) || other.isFixed == isFixed) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, name, value, isFixed, updatedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CustomFieldCopyWith<_$_CustomField> get copyWith =>
      __$$_CustomFieldCopyWithImpl<_$_CustomField>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CustomFieldToJson(
      this,
    );
  }
}

abstract class _CustomField implements CustomField {
  const factory _CustomField(
      {required final String id,
      required final String name,
      required final String value,
      final bool? isFixed,
      @TimestampOrNullConverter() final DateTime? updatedAt}) = _$_CustomField;

  factory _CustomField.fromJson(Map<String, dynamic> json) =
      _$_CustomField.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get value;
  @override
  bool? get isFixed;
  @override
  @TimestampOrNullConverter()
  DateTime? get updatedAt;
  @override
  @JsonKey(ignore: true)
  _$$_CustomFieldCopyWith<_$_CustomField> get copyWith =>
      throw _privateConstructorUsedError;
}

CustomFieldInput _$CustomFieldInputFromJson(Map<String, dynamic> json) {
  return _CustomFieldInput.fromJson(json);
}

/// @nodoc
mixin _$CustomFieldInput {
  String get name => throw _privateConstructorUsedError;
  String get value => throw _privateConstructorUsedError;
  bool get isFixed => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CustomFieldInputCopyWith<CustomFieldInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomFieldInputCopyWith<$Res> {
  factory $CustomFieldInputCopyWith(
          CustomFieldInput value, $Res Function(CustomFieldInput) then) =
      _$CustomFieldInputCopyWithImpl<$Res, CustomFieldInput>;
  @useResult
  $Res call({String name, String value, bool isFixed});
}

/// @nodoc
class _$CustomFieldInputCopyWithImpl<$Res, $Val extends CustomFieldInput>
    implements $CustomFieldInputCopyWith<$Res> {
  _$CustomFieldInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = null,
    Object? isFixed = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      isFixed: null == isFixed
          ? _value.isFixed
          : isFixed // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CustomFieldInputCopyWith<$Res>
    implements $CustomFieldInputCopyWith<$Res> {
  factory _$$_CustomFieldInputCopyWith(
          _$_CustomFieldInput value, $Res Function(_$_CustomFieldInput) then) =
      __$$_CustomFieldInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String value, bool isFixed});
}

/// @nodoc
class __$$_CustomFieldInputCopyWithImpl<$Res>
    extends _$CustomFieldInputCopyWithImpl<$Res, _$_CustomFieldInput>
    implements _$$_CustomFieldInputCopyWith<$Res> {
  __$$_CustomFieldInputCopyWithImpl(
      _$_CustomFieldInput _value, $Res Function(_$_CustomFieldInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = null,
    Object? isFixed = null,
  }) {
    return _then(_$_CustomFieldInput(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      isFixed: null == isFixed
          ? _value.isFixed
          : isFixed // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CustomFieldInput implements _CustomFieldInput {
  const _$_CustomFieldInput(
      {required this.name, required this.value, this.isFixed = false});

  factory _$_CustomFieldInput.fromJson(Map<String, dynamic> json) =>
      _$$_CustomFieldInputFromJson(json);

  @override
  final String name;
  @override
  final String value;
  @override
  @JsonKey()
  final bool isFixed;

  @override
  String toString() {
    return 'CustomFieldInput(name: $name, value: $value, isFixed: $isFixed)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CustomFieldInput &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.isFixed, isFixed) || other.isFixed == isFixed));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, value, isFixed);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CustomFieldInputCopyWith<_$_CustomFieldInput> get copyWith =>
      __$$_CustomFieldInputCopyWithImpl<_$_CustomFieldInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CustomFieldInputToJson(
      this,
    );
  }
}

abstract class _CustomFieldInput implements CustomFieldInput {
  const factory _CustomFieldInput(
      {required final String name,
      required final String value,
      final bool isFixed}) = _$_CustomFieldInput;

  factory _CustomFieldInput.fromJson(Map<String, dynamic> json) =
      _$_CustomFieldInput.fromJson;

  @override
  String get name;
  @override
  String get value;
  @override
  bool get isFixed;
  @override
  @JsonKey(ignore: true)
  _$$_CustomFieldInputCopyWith<_$_CustomFieldInput> get copyWith =>
      throw _privateConstructorUsedError;
}

Sensor _$SensorFromJson(Map<String, dynamic> json) {
  return _Sensor.fromJson(json);
}

/// @nodoc
mixin _$Sensor {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  /// [iterationCycle] of the sensor. Only will accept positive values
  int get iterationCycle => throw _privateConstructorUsedError;

  /// [slug] of the sensor. Must be unique along of all sensors of the asset.
  String get slug => throw _privateConstructorUsedError;

  /// [isInstant] is a boolean to indicate if the sensor is an instant sensor. Means what the sensor execution
  /// returns [null], if it's [true], the sensor is will "disappear" from the calculated sensors, otherwise it will be
  /// take the previous value of the sensor.
  bool get isInstant => throw _privateConstructorUsedError;

  /// [icon] of the sensor. To send it to API, will convert to javascript codename, but from Flutter execution
  /// will convert to IconData entity.
  @IconOrNullConverter()
  IconData? get icon => throw _privateConstructorUsedError;

  /// [measuringUnit] of the sensor. Can be an estandard unit or a custom one.
  String? get measuringUnit => throw _privateConstructorUsedError;

  /// [type] of the sensor.
  @SensorTypeOrNullConverter()
  SensorType? get type => throw _privateConstructorUsedError;

  /// [subType] of the sensor.
  @SensorSubTypeOrNullConverter()
  SensorSubType? get subtype => throw _privateConstructorUsedError;

  /// [parameter] of the sensor.
  String? get parameter => throw _privateConstructorUsedError;
  List<String>? get externalIdentifiers => throw _privateConstructorUsedError;
  String? get formula => throw _privateConstructorUsedError;
  String? get script => throw _privateConstructorUsedError;

  /// Only for [SensorType.unpack] and [SensorSubType.csv], [hasHeaders], [csvHeaders] and [csvSeparator] means the configuration
  /// to unpack a CSV data comming from message.
  /// [hasHeaders] is a boolean to indicate if the CSV has headers inside of the message.
  bool? get hasHeaders => throw _privateConstructorUsedError;

  /// [csvHeaders] is a list of strings to indicate the names of the columns of the CSV. Only when [hasHeaders] is true.
  List<String>? get csvHeaders => throw _privateConstructorUsedError;

  /// [csvSeparator] is a string to indicate the separator of the CSV.
  String? get csvSeparator => throw _privateConstructorUsedError;

  /// [ranges] of the sensor, only for [SensorType.interval] linear conversion.
  /// It's a list of [SensorPair] objects.
  List<SensorPair>? get ranges => throw _privateConstructorUsedError;

  /// [mask] of the sensor. Is basically a list of [MaskPoint] objects.
  List<MaskPoint>? get mask => throw _privateConstructorUsedError;

  /// [hasValidator] is a boolean to indicate if the sensor has a [double] validator. When true, [minValur] and [maxValue]
  /// will define the range, both values can be [null] if the minimum or maximum range is [double.infinity].
  bool? get hasValidator => throw _privateConstructorUsedError;

  /// [minValue] is a [double] to indicate the minimum value of the sensor. Only when [hasValidator] is true.
  /// Can return [null] if the minimum range is [double.infinity].
  double? get minValue => throw _privateConstructorUsedError;

  /// [maxValue] is a [double] to indicate the maximum value of the sensor. Only when [hasValidator] is true.
  /// [maxValue] must be greater than [minValue].
  /// If [maxValue] is [null], the minimum range is [double.infinity].
  double? get maxValue => throw _privateConstructorUsedError;

  /// [contentType] is a string to indicate the content type of the sensor, only used for [SensorType.image],
  /// [SensorType.video] and [SensorType.audio], but only when the [SensorSubType] is [SensorSubType.base64].
  String? get contentType => throw _privateConstructorUsedError;

  /// [parentId] is a string to indicate the id of the parent sensor.
  String? get parentId => throw _privateConstructorUsedError;

  /// [parent] is a [Sensor] to indicate the parent sensor.
  Sensor? get parent => throw _privateConstructorUsedError;

  /// [functionId] is a string to indicate the id of the [Function] of the sensor.
  String? get functionId => throw _privateConstructorUsedError;

  /// [lastExit] is the last [AtsExit] registered by this sensor.
  AtsExit? get lastExit => throw _privateConstructorUsedError;

  /// [qrCode] is a string to indicate the QR code URI of the sensor.
  String? get qrCode => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SensorCopyWith<Sensor> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SensorCopyWith<$Res> {
  factory $SensorCopyWith(Sensor value, $Res Function(Sensor) then) =
      _$SensorCopyWithImpl<$Res, Sensor>;
  @useResult
  $Res call(
      {String id,
      String name,
      int iterationCycle,
      String slug,
      bool isInstant,
      @IconOrNullConverter() IconData? icon,
      String? measuringUnit,
      @SensorTypeOrNullConverter() SensorType? type,
      @SensorSubTypeOrNullConverter() SensorSubType? subtype,
      String? parameter,
      List<String>? externalIdentifiers,
      String? formula,
      String? script,
      bool? hasHeaders,
      List<String>? csvHeaders,
      String? csvSeparator,
      List<SensorPair>? ranges,
      List<MaskPoint>? mask,
      bool? hasValidator,
      double? minValue,
      double? maxValue,
      String? contentType,
      String? parentId,
      Sensor? parent,
      String? functionId,
      AtsExit? lastExit,
      String? qrCode});

  $SensorCopyWith<$Res>? get parent;
  $AtsExitCopyWith<$Res>? get lastExit;
}

/// @nodoc
class _$SensorCopyWithImpl<$Res, $Val extends Sensor>
    implements $SensorCopyWith<$Res> {
  _$SensorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? iterationCycle = null,
    Object? slug = null,
    Object? isInstant = null,
    Object? icon = freezed,
    Object? measuringUnit = freezed,
    Object? type = freezed,
    Object? subtype = freezed,
    Object? parameter = freezed,
    Object? externalIdentifiers = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? hasHeaders = freezed,
    Object? csvHeaders = freezed,
    Object? csvSeparator = freezed,
    Object? ranges = freezed,
    Object? mask = freezed,
    Object? hasValidator = freezed,
    Object? minValue = freezed,
    Object? maxValue = freezed,
    Object? contentType = freezed,
    Object? parentId = freezed,
    Object? parent = freezed,
    Object? functionId = freezed,
    Object? lastExit = freezed,
    Object? qrCode = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      iterationCycle: null == iterationCycle
          ? _value.iterationCycle
          : iterationCycle // ignore: cast_nullable_to_non_nullable
              as int,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      isInstant: null == isInstant
          ? _value.isInstant
          : isInstant // ignore: cast_nullable_to_non_nullable
              as bool,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      measuringUnit: freezed == measuringUnit
          ? _value.measuringUnit
          : measuringUnit // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as SensorType?,
      subtype: freezed == subtype
          ? _value.subtype
          : subtype // ignore: cast_nullable_to_non_nullable
              as SensorSubType?,
      parameter: freezed == parameter
          ? _value.parameter
          : parameter // ignore: cast_nullable_to_non_nullable
              as String?,
      externalIdentifiers: freezed == externalIdentifiers
          ? _value.externalIdentifiers
          : externalIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      hasHeaders: freezed == hasHeaders
          ? _value.hasHeaders
          : hasHeaders // ignore: cast_nullable_to_non_nullable
              as bool?,
      csvHeaders: freezed == csvHeaders
          ? _value.csvHeaders
          : csvHeaders // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      csvSeparator: freezed == csvSeparator
          ? _value.csvSeparator
          : csvSeparator // ignore: cast_nullable_to_non_nullable
              as String?,
      ranges: freezed == ranges
          ? _value.ranges
          : ranges // ignore: cast_nullable_to_non_nullable
              as List<SensorPair>?,
      mask: freezed == mask
          ? _value.mask
          : mask // ignore: cast_nullable_to_non_nullable
              as List<MaskPoint>?,
      hasValidator: freezed == hasValidator
          ? _value.hasValidator
          : hasValidator // ignore: cast_nullable_to_non_nullable
              as bool?,
      minValue: freezed == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxValue: freezed == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      parentId: freezed == parentId
          ? _value.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      parent: freezed == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as Sensor?,
      functionId: freezed == functionId
          ? _value.functionId
          : functionId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastExit: freezed == lastExit
          ? _value.lastExit
          : lastExit // ignore: cast_nullable_to_non_nullable
              as AtsExit?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $SensorCopyWith<$Res>? get parent {
    if (_value.parent == null) {
      return null;
    }

    return $SensorCopyWith<$Res>(_value.parent!, (value) {
      return _then(_value.copyWith(parent: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsExitCopyWith<$Res>? get lastExit {
    if (_value.lastExit == null) {
      return null;
    }

    return $AtsExitCopyWith<$Res>(_value.lastExit!, (value) {
      return _then(_value.copyWith(lastExit: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SensorCopyWith<$Res> implements $SensorCopyWith<$Res> {
  factory _$$_SensorCopyWith(_$_Sensor value, $Res Function(_$_Sensor) then) =
      __$$_SensorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      int iterationCycle,
      String slug,
      bool isInstant,
      @IconOrNullConverter() IconData? icon,
      String? measuringUnit,
      @SensorTypeOrNullConverter() SensorType? type,
      @SensorSubTypeOrNullConverter() SensorSubType? subtype,
      String? parameter,
      List<String>? externalIdentifiers,
      String? formula,
      String? script,
      bool? hasHeaders,
      List<String>? csvHeaders,
      String? csvSeparator,
      List<SensorPair>? ranges,
      List<MaskPoint>? mask,
      bool? hasValidator,
      double? minValue,
      double? maxValue,
      String? contentType,
      String? parentId,
      Sensor? parent,
      String? functionId,
      AtsExit? lastExit,
      String? qrCode});

  @override
  $SensorCopyWith<$Res>? get parent;
  @override
  $AtsExitCopyWith<$Res>? get lastExit;
}

/// @nodoc
class __$$_SensorCopyWithImpl<$Res>
    extends _$SensorCopyWithImpl<$Res, _$_Sensor>
    implements _$$_SensorCopyWith<$Res> {
  __$$_SensorCopyWithImpl(_$_Sensor _value, $Res Function(_$_Sensor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? iterationCycle = null,
    Object? slug = null,
    Object? isInstant = null,
    Object? icon = freezed,
    Object? measuringUnit = freezed,
    Object? type = freezed,
    Object? subtype = freezed,
    Object? parameter = freezed,
    Object? externalIdentifiers = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? hasHeaders = freezed,
    Object? csvHeaders = freezed,
    Object? csvSeparator = freezed,
    Object? ranges = freezed,
    Object? mask = freezed,
    Object? hasValidator = freezed,
    Object? minValue = freezed,
    Object? maxValue = freezed,
    Object? contentType = freezed,
    Object? parentId = freezed,
    Object? parent = freezed,
    Object? functionId = freezed,
    Object? lastExit = freezed,
    Object? qrCode = freezed,
  }) {
    return _then(_$_Sensor(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      iterationCycle: null == iterationCycle
          ? _value.iterationCycle
          : iterationCycle // ignore: cast_nullable_to_non_nullable
              as int,
      slug: null == slug
          ? _value.slug
          : slug // ignore: cast_nullable_to_non_nullable
              as String,
      isInstant: null == isInstant
          ? _value.isInstant
          : isInstant // ignore: cast_nullable_to_non_nullable
              as bool,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      measuringUnit: freezed == measuringUnit
          ? _value.measuringUnit
          : measuringUnit // ignore: cast_nullable_to_non_nullable
              as String?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as SensorType?,
      subtype: freezed == subtype
          ? _value.subtype
          : subtype // ignore: cast_nullable_to_non_nullable
              as SensorSubType?,
      parameter: freezed == parameter
          ? _value.parameter
          : parameter // ignore: cast_nullable_to_non_nullable
              as String?,
      externalIdentifiers: freezed == externalIdentifiers
          ? _value._externalIdentifiers
          : externalIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      hasHeaders: freezed == hasHeaders
          ? _value.hasHeaders
          : hasHeaders // ignore: cast_nullable_to_non_nullable
              as bool?,
      csvHeaders: freezed == csvHeaders
          ? _value._csvHeaders
          : csvHeaders // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      csvSeparator: freezed == csvSeparator
          ? _value.csvSeparator
          : csvSeparator // ignore: cast_nullable_to_non_nullable
              as String?,
      ranges: freezed == ranges
          ? _value._ranges
          : ranges // ignore: cast_nullable_to_non_nullable
              as List<SensorPair>?,
      mask: freezed == mask
          ? _value._mask
          : mask // ignore: cast_nullable_to_non_nullable
              as List<MaskPoint>?,
      hasValidator: freezed == hasValidator
          ? _value.hasValidator
          : hasValidator // ignore: cast_nullable_to_non_nullable
              as bool?,
      minValue: freezed == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxValue: freezed == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      parentId: freezed == parentId
          ? _value.parentId
          : parentId // ignore: cast_nullable_to_non_nullable
              as String?,
      parent: freezed == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as Sensor?,
      functionId: freezed == functionId
          ? _value.functionId
          : functionId // ignore: cast_nullable_to_non_nullable
              as String?,
      lastExit: freezed == lastExit
          ? _value.lastExit
          : lastExit // ignore: cast_nullable_to_non_nullable
              as AtsExit?,
      qrCode: freezed == qrCode
          ? _value.qrCode
          : qrCode // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Sensor implements _Sensor {
  const _$_Sensor(
      {required this.id,
      required this.name,
      required this.iterationCycle,
      required this.slug,
      required this.isInstant,
      @IconOrNullConverter() this.icon,
      this.measuringUnit,
      @SensorTypeOrNullConverter() this.type,
      @SensorSubTypeOrNullConverter() this.subtype,
      this.parameter,
      final List<String>? externalIdentifiers,
      this.formula,
      this.script,
      this.hasHeaders,
      final List<String>? csvHeaders,
      this.csvSeparator,
      final List<SensorPair>? ranges,
      final List<MaskPoint>? mask,
      this.hasValidator,
      this.minValue,
      this.maxValue,
      this.contentType,
      this.parentId,
      this.parent,
      this.functionId,
      this.lastExit,
      this.qrCode})
      : _externalIdentifiers = externalIdentifiers,
        _csvHeaders = csvHeaders,
        _ranges = ranges,
        _mask = mask;

  factory _$_Sensor.fromJson(Map<String, dynamic> json) =>
      _$$_SensorFromJson(json);

  @override
  final String id;
  @override
  final String name;

  /// [iterationCycle] of the sensor. Only will accept positive values
  @override
  final int iterationCycle;

  /// [slug] of the sensor. Must be unique along of all sensors of the asset.
  @override
  final String slug;

  /// [isInstant] is a boolean to indicate if the sensor is an instant sensor. Means what the sensor execution
  /// returns [null], if it's [true], the sensor is will "disappear" from the calculated sensors, otherwise it will be
  /// take the previous value of the sensor.
  @override
  final bool isInstant;

  /// [icon] of the sensor. To send it to API, will convert to javascript codename, but from Flutter execution
  /// will convert to IconData entity.
  @override
  @IconOrNullConverter()
  final IconData? icon;

  /// [measuringUnit] of the sensor. Can be an estandard unit or a custom one.
  @override
  final String? measuringUnit;

  /// [type] of the sensor.
  @override
  @SensorTypeOrNullConverter()
  final SensorType? type;

  /// [subType] of the sensor.
  @override
  @SensorSubTypeOrNullConverter()
  final SensorSubType? subtype;

  /// [parameter] of the sensor.
  @override
  final String? parameter;
  final List<String>? _externalIdentifiers;
  @override
  List<String>? get externalIdentifiers {
    final value = _externalIdentifiers;
    if (value == null) return null;
    if (_externalIdentifiers is EqualUnmodifiableListView)
      return _externalIdentifiers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String? formula;
  @override
  final String? script;

  /// Only for [SensorType.unpack] and [SensorSubType.csv], [hasHeaders], [csvHeaders] and [csvSeparator] means the configuration
  /// to unpack a CSV data comming from message.
  /// [hasHeaders] is a boolean to indicate if the CSV has headers inside of the message.
  @override
  final bool? hasHeaders;

  /// [csvHeaders] is a list of strings to indicate the names of the columns of the CSV. Only when [hasHeaders] is true.
  final List<String>? _csvHeaders;

  /// [csvHeaders] is a list of strings to indicate the names of the columns of the CSV. Only when [hasHeaders] is true.
  @override
  List<String>? get csvHeaders {
    final value = _csvHeaders;
    if (value == null) return null;
    if (_csvHeaders is EqualUnmodifiableListView) return _csvHeaders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [csvSeparator] is a string to indicate the separator of the CSV.
  @override
  final String? csvSeparator;

  /// [ranges] of the sensor, only for [SensorType.interval] linear conversion.
  /// It's a list of [SensorPair] objects.
  final List<SensorPair>? _ranges;

  /// [ranges] of the sensor, only for [SensorType.interval] linear conversion.
  /// It's a list of [SensorPair] objects.
  @override
  List<SensorPair>? get ranges {
    final value = _ranges;
    if (value == null) return null;
    if (_ranges is EqualUnmodifiableListView) return _ranges;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [mask] of the sensor. Is basically a list of [MaskPoint] objects.
  final List<MaskPoint>? _mask;

  /// [mask] of the sensor. Is basically a list of [MaskPoint] objects.
  @override
  List<MaskPoint>? get mask {
    final value = _mask;
    if (value == null) return null;
    if (_mask is EqualUnmodifiableListView) return _mask;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [hasValidator] is a boolean to indicate if the sensor has a [double] validator. When true, [minValur] and [maxValue]
  /// will define the range, both values can be [null] if the minimum or maximum range is [double.infinity].
  @override
  final bool? hasValidator;

  /// [minValue] is a [double] to indicate the minimum value of the sensor. Only when [hasValidator] is true.
  /// Can return [null] if the minimum range is [double.infinity].
  @override
  final double? minValue;

  /// [maxValue] is a [double] to indicate the maximum value of the sensor. Only when [hasValidator] is true.
  /// [maxValue] must be greater than [minValue].
  /// If [maxValue] is [null], the minimum range is [double.infinity].
  @override
  final double? maxValue;

  /// [contentType] is a string to indicate the content type of the sensor, only used for [SensorType.image],
  /// [SensorType.video] and [SensorType.audio], but only when the [SensorSubType] is [SensorSubType.base64].
  @override
  final String? contentType;

  /// [parentId] is a string to indicate the id of the parent sensor.
  @override
  final String? parentId;

  /// [parent] is a [Sensor] to indicate the parent sensor.
  @override
  final Sensor? parent;

  /// [functionId] is a string to indicate the id of the [Function] of the sensor.
  @override
  final String? functionId;

  /// [lastExit] is the last [AtsExit] registered by this sensor.
  @override
  final AtsExit? lastExit;

  /// [qrCode] is a string to indicate the QR code URI of the sensor.
  @override
  final String? qrCode;

  @override
  String toString() {
    return 'Sensor(id: $id, name: $name, iterationCycle: $iterationCycle, slug: $slug, isInstant: $isInstant, icon: $icon, measuringUnit: $measuringUnit, type: $type, subtype: $subtype, parameter: $parameter, externalIdentifiers: $externalIdentifiers, formula: $formula, script: $script, hasHeaders: $hasHeaders, csvHeaders: $csvHeaders, csvSeparator: $csvSeparator, ranges: $ranges, mask: $mask, hasValidator: $hasValidator, minValue: $minValue, maxValue: $maxValue, contentType: $contentType, parentId: $parentId, parent: $parent, functionId: $functionId, lastExit: $lastExit, qrCode: $qrCode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Sensor &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.iterationCycle, iterationCycle) ||
                other.iterationCycle == iterationCycle) &&
            (identical(other.slug, slug) || other.slug == slug) &&
            (identical(other.isInstant, isInstant) ||
                other.isInstant == isInstant) &&
            (identical(other.icon, icon) || other.icon == icon) &&
            (identical(other.measuringUnit, measuringUnit) ||
                other.measuringUnit == measuringUnit) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.subtype, subtype) || other.subtype == subtype) &&
            (identical(other.parameter, parameter) ||
                other.parameter == parameter) &&
            const DeepCollectionEquality()
                .equals(other._externalIdentifiers, _externalIdentifiers) &&
            (identical(other.formula, formula) || other.formula == formula) &&
            (identical(other.script, script) || other.script == script) &&
            (identical(other.hasHeaders, hasHeaders) ||
                other.hasHeaders == hasHeaders) &&
            const DeepCollectionEquality()
                .equals(other._csvHeaders, _csvHeaders) &&
            (identical(other.csvSeparator, csvSeparator) ||
                other.csvSeparator == csvSeparator) &&
            const DeepCollectionEquality().equals(other._ranges, _ranges) &&
            const DeepCollectionEquality().equals(other._mask, _mask) &&
            (identical(other.hasValidator, hasValidator) ||
                other.hasValidator == hasValidator) &&
            (identical(other.minValue, minValue) ||
                other.minValue == minValue) &&
            (identical(other.maxValue, maxValue) ||
                other.maxValue == maxValue) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            (identical(other.parentId, parentId) ||
                other.parentId == parentId) &&
            (identical(other.parent, parent) || other.parent == parent) &&
            (identical(other.functionId, functionId) ||
                other.functionId == functionId) &&
            (identical(other.lastExit, lastExit) ||
                other.lastExit == lastExit) &&
            (identical(other.qrCode, qrCode) || other.qrCode == qrCode));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        iterationCycle,
        slug,
        isInstant,
        icon,
        measuringUnit,
        type,
        subtype,
        parameter,
        const DeepCollectionEquality().hash(_externalIdentifiers),
        formula,
        script,
        hasHeaders,
        const DeepCollectionEquality().hash(_csvHeaders),
        csvSeparator,
        const DeepCollectionEquality().hash(_ranges),
        const DeepCollectionEquality().hash(_mask),
        hasValidator,
        minValue,
        maxValue,
        contentType,
        parentId,
        parent,
        functionId,
        lastExit,
        qrCode
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SensorCopyWith<_$_Sensor> get copyWith =>
      __$$_SensorCopyWithImpl<_$_Sensor>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SensorToJson(
      this,
    );
  }
}

abstract class _Sensor implements Sensor {
  const factory _Sensor(
      {required final String id,
      required final String name,
      required final int iterationCycle,
      required final String slug,
      required final bool isInstant,
      @IconOrNullConverter() final IconData? icon,
      final String? measuringUnit,
      @SensorTypeOrNullConverter() final SensorType? type,
      @SensorSubTypeOrNullConverter() final SensorSubType? subtype,
      final String? parameter,
      final List<String>? externalIdentifiers,
      final String? formula,
      final String? script,
      final bool? hasHeaders,
      final List<String>? csvHeaders,
      final String? csvSeparator,
      final List<SensorPair>? ranges,
      final List<MaskPoint>? mask,
      final bool? hasValidator,
      final double? minValue,
      final double? maxValue,
      final String? contentType,
      final String? parentId,
      final Sensor? parent,
      final String? functionId,
      final AtsExit? lastExit,
      final String? qrCode}) = _$_Sensor;

  factory _Sensor.fromJson(Map<String, dynamic> json) = _$_Sensor.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override

  /// [iterationCycle] of the sensor. Only will accept positive values
  int get iterationCycle;
  @override

  /// [slug] of the sensor. Must be unique along of all sensors of the asset.
  String get slug;
  @override

  /// [isInstant] is a boolean to indicate if the sensor is an instant sensor. Means what the sensor execution
  /// returns [null], if it's [true], the sensor is will "disappear" from the calculated sensors, otherwise it will be
  /// take the previous value of the sensor.
  bool get isInstant;
  @override

  /// [icon] of the sensor. To send it to API, will convert to javascript codename, but from Flutter execution
  /// will convert to IconData entity.
  @IconOrNullConverter()
  IconData? get icon;
  @override

  /// [measuringUnit] of the sensor. Can be an estandard unit or a custom one.
  String? get measuringUnit;
  @override

  /// [type] of the sensor.
  @SensorTypeOrNullConverter()
  SensorType? get type;
  @override

  /// [subType] of the sensor.
  @SensorSubTypeOrNullConverter()
  SensorSubType? get subtype;
  @override

  /// [parameter] of the sensor.
  String? get parameter;
  @override
  List<String>? get externalIdentifiers;
  @override
  String? get formula;
  @override
  String? get script;
  @override

  /// Only for [SensorType.unpack] and [SensorSubType.csv], [hasHeaders], [csvHeaders] and [csvSeparator] means the configuration
  /// to unpack a CSV data comming from message.
  /// [hasHeaders] is a boolean to indicate if the CSV has headers inside of the message.
  bool? get hasHeaders;
  @override

  /// [csvHeaders] is a list of strings to indicate the names of the columns of the CSV. Only when [hasHeaders] is true.
  List<String>? get csvHeaders;
  @override

  /// [csvSeparator] is a string to indicate the separator of the CSV.
  String? get csvSeparator;
  @override

  /// [ranges] of the sensor, only for [SensorType.interval] linear conversion.
  /// It's a list of [SensorPair] objects.
  List<SensorPair>? get ranges;
  @override

  /// [mask] of the sensor. Is basically a list of [MaskPoint] objects.
  List<MaskPoint>? get mask;
  @override

  /// [hasValidator] is a boolean to indicate if the sensor has a [double] validator. When true, [minValur] and [maxValue]
  /// will define the range, both values can be [null] if the minimum or maximum range is [double.infinity].
  bool? get hasValidator;
  @override

  /// [minValue] is a [double] to indicate the minimum value of the sensor. Only when [hasValidator] is true.
  /// Can return [null] if the minimum range is [double.infinity].
  double? get minValue;
  @override

  /// [maxValue] is a [double] to indicate the maximum value of the sensor. Only when [hasValidator] is true.
  /// [maxValue] must be greater than [minValue].
  /// If [maxValue] is [null], the minimum range is [double.infinity].
  double? get maxValue;
  @override

  /// [contentType] is a string to indicate the content type of the sensor, only used for [SensorType.image],
  /// [SensorType.video] and [SensorType.audio], but only when the [SensorSubType] is [SensorSubType.base64].
  String? get contentType;
  @override

  /// [parentId] is a string to indicate the id of the parent sensor.
  String? get parentId;
  @override

  /// [parent] is a [Sensor] to indicate the parent sensor.
  Sensor? get parent;
  @override

  /// [functionId] is a string to indicate the id of the [Function] of the sensor.
  String? get functionId;
  @override

  /// [lastExit] is the last [AtsExit] registered by this sensor.
  AtsExit? get lastExit;
  @override

  /// [qrCode] is a string to indicate the QR code URI of the sensor.
  String? get qrCode;
  @override
  @JsonKey(ignore: true)
  _$$_SensorCopyWith<_$_Sensor> get copyWith =>
      throw _privateConstructorUsedError;
}

MaskPoint _$MaskPointFromJson(Map<String, dynamic> json) {
  return _MaskPoint.fromJson(json);
}

/// @nodoc
mixin _$MaskPoint {
  /// [color] of the mask point, will convert the color ignoring the dark/light theme setting.
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  /// [text] of the mask point, will replace the value of the mask point when is not null
  String? get text => throw _privateConstructorUsedError;

  /// [value] of the mask point.
  String get value => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MaskPointCopyWith<MaskPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MaskPointCopyWith<$Res> {
  factory $MaskPointCopyWith(MaskPoint value, $Res Function(MaskPoint) then) =
      _$MaskPointCopyWithImpl<$Res, MaskPoint>;
  @useResult
  $Res call({@ColorOrNullConverter() Color? color, String? text, String value});
}

/// @nodoc
class _$MaskPointCopyWithImpl<$Res, $Val extends MaskPoint>
    implements $MaskPointCopyWith<$Res> {
  _$MaskPointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
    Object? text = freezed,
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MaskPointCopyWith<$Res> implements $MaskPointCopyWith<$Res> {
  factory _$$_MaskPointCopyWith(
          _$_MaskPoint value, $Res Function(_$_MaskPoint) then) =
      __$$_MaskPointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@ColorOrNullConverter() Color? color, String? text, String value});
}

/// @nodoc
class __$$_MaskPointCopyWithImpl<$Res>
    extends _$MaskPointCopyWithImpl<$Res, _$_MaskPoint>
    implements _$$_MaskPointCopyWith<$Res> {
  __$$_MaskPointCopyWithImpl(
      _$_MaskPoint _value, $Res Function(_$_MaskPoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
    Object? text = freezed,
    Object? value = null,
  }) {
    return _then(_$_MaskPoint(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      text: freezed == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String?,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MaskPoint implements _MaskPoint {
  const _$_MaskPoint(
      {@ColorOrNullConverter() this.color, this.text, required this.value});

  factory _$_MaskPoint.fromJson(Map<String, dynamic> json) =>
      _$$_MaskPointFromJson(json);

  /// [color] of the mask point, will convert the color ignoring the dark/light theme setting.
  @override
  @ColorOrNullConverter()
  final Color? color;

  /// [text] of the mask point, will replace the value of the mask point when is not null
  @override
  final String? text;

  /// [value] of the mask point.
  @override
  final String value;

  @override
  String toString() {
    return 'MaskPoint(color: $color, text: $text, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MaskPoint &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, color, text, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MaskPointCopyWith<_$_MaskPoint> get copyWith =>
      __$$_MaskPointCopyWithImpl<_$_MaskPoint>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MaskPointToJson(
      this,
    );
  }
}

abstract class _MaskPoint implements MaskPoint {
  const factory _MaskPoint(
      {@ColorOrNullConverter() final Color? color,
      final String? text,
      required final String value}) = _$_MaskPoint;

  factory _MaskPoint.fromJson(Map<String, dynamic> json) =
      _$_MaskPoint.fromJson;

  @override

  /// [color] of the mask point, will convert the color ignoring the dark/light theme setting.
  @ColorOrNullConverter()
  Color? get color;
  @override

  /// [text] of the mask point, will replace the value of the mask point when is not null
  String? get text;
  @override

  /// [value] of the mask point.
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_MaskPointCopyWith<_$_MaskPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

SensorPair _$SensorPairFromJson(Map<String, dynamic> json) {
  return _SensorPair.fromJson(json);
}

/// @nodoc
mixin _$SensorPair {
  /// [x] means the input value of the sensor.
  double get x => throw _privateConstructorUsedError;

  /// [y] means the output value of the sensor.
  double get y => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SensorPairCopyWith<SensorPair> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SensorPairCopyWith<$Res> {
  factory $SensorPairCopyWith(
          SensorPair value, $Res Function(SensorPair) then) =
      _$SensorPairCopyWithImpl<$Res, SensorPair>;
  @useResult
  $Res call({double x, double y});
}

/// @nodoc
class _$SensorPairCopyWithImpl<$Res, $Val extends SensorPair>
    implements $SensorPairCopyWith<$Res> {
  _$SensorPairCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? x = null,
    Object? y = null,
  }) {
    return _then(_value.copyWith(
      x: null == x
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: null == y
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SensorPairCopyWith<$Res>
    implements $SensorPairCopyWith<$Res> {
  factory _$$_SensorPairCopyWith(
          _$_SensorPair value, $Res Function(_$_SensorPair) then) =
      __$$_SensorPairCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double x, double y});
}

/// @nodoc
class __$$_SensorPairCopyWithImpl<$Res>
    extends _$SensorPairCopyWithImpl<$Res, _$_SensorPair>
    implements _$$_SensorPairCopyWith<$Res> {
  __$$_SensorPairCopyWithImpl(
      _$_SensorPair _value, $Res Function(_$_SensorPair) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? x = null,
    Object? y = null,
  }) {
    return _then(_$_SensorPair(
      x: null == x
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: null == y
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SensorPair implements _SensorPair {
  const _$_SensorPair({required this.x, required this.y});

  factory _$_SensorPair.fromJson(Map<String, dynamic> json) =>
      _$$_SensorPairFromJson(json);

  /// [x] means the input value of the sensor.
  @override
  final double x;

  /// [y] means the output value of the sensor.
  @override
  final double y;

  @override
  String toString() {
    return 'SensorPair(x: $x, y: $y)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SensorPair &&
            (identical(other.x, x) || other.x == x) &&
            (identical(other.y, y) || other.y == y));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, x, y);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SensorPairCopyWith<_$_SensorPair> get copyWith =>
      __$$_SensorPairCopyWithImpl<_$_SensorPair>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SensorPairToJson(
      this,
    );
  }
}

abstract class _SensorPair implements SensorPair {
  const factory _SensorPair(
      {required final double x, required final double y}) = _$_SensorPair;

  factory _SensorPair.fromJson(Map<String, dynamic> json) =
      _$_SensorPair.fromJson;

  @override

  /// [x] means the input value of the sensor.
  double get x;
  @override

  /// [y] means the output value of the sensor.
  double get y;
  @override
  @JsonKey(ignore: true)
  _$$_SensorPairCopyWith<_$_SensorPair> get copyWith =>
      throw _privateConstructorUsedError;
}

Guide _$GuideFromJson(Map<String, dynamic> json) {
  return _Guide.fromJson(json);
}

/// @nodoc
mixin _$Guide {
  String get thumbnail => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  String get description => throw _privateConstructorUsedError;
  String get youtubeUrl => throw _privateConstructorUsedError;
  @TimestampConverter()
  DateTime get publishedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GuideCopyWith<Guide> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GuideCopyWith<$Res> {
  factory $GuideCopyWith(Guide value, $Res Function(Guide) then) =
      _$GuideCopyWithImpl<$Res, Guide>;
  @useResult
  $Res call(
      {String thumbnail,
      String title,
      String description,
      String youtubeUrl,
      @TimestampConverter() DateTime publishedAt});
}

/// @nodoc
class _$GuideCopyWithImpl<$Res, $Val extends Guide>
    implements $GuideCopyWith<$Res> {
  _$GuideCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? thumbnail = null,
    Object? title = null,
    Object? description = null,
    Object? youtubeUrl = null,
    Object? publishedAt = null,
  }) {
    return _then(_value.copyWith(
      thumbnail: null == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      youtubeUrl: null == youtubeUrl
          ? _value.youtubeUrl
          : youtubeUrl // ignore: cast_nullable_to_non_nullable
              as String,
      publishedAt: null == publishedAt
          ? _value.publishedAt
          : publishedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GuideCopyWith<$Res> implements $GuideCopyWith<$Res> {
  factory _$$_GuideCopyWith(_$_Guide value, $Res Function(_$_Guide) then) =
      __$$_GuideCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String thumbnail,
      String title,
      String description,
      String youtubeUrl,
      @TimestampConverter() DateTime publishedAt});
}

/// @nodoc
class __$$_GuideCopyWithImpl<$Res> extends _$GuideCopyWithImpl<$Res, _$_Guide>
    implements _$$_GuideCopyWith<$Res> {
  __$$_GuideCopyWithImpl(_$_Guide _value, $Res Function(_$_Guide) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? thumbnail = null,
    Object? title = null,
    Object? description = null,
    Object? youtubeUrl = null,
    Object? publishedAt = null,
  }) {
    return _then(_$_Guide(
      thumbnail: null == thumbnail
          ? _value.thumbnail
          : thumbnail // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      description: null == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String,
      youtubeUrl: null == youtubeUrl
          ? _value.youtubeUrl
          : youtubeUrl // ignore: cast_nullable_to_non_nullable
              as String,
      publishedAt: null == publishedAt
          ? _value.publishedAt
          : publishedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Guide implements _Guide {
  const _$_Guide(
      {required this.thumbnail,
      required this.title,
      required this.description,
      required this.youtubeUrl,
      @TimestampConverter() required this.publishedAt});

  factory _$_Guide.fromJson(Map<String, dynamic> json) =>
      _$$_GuideFromJson(json);

  @override
  final String thumbnail;
  @override
  final String title;
  @override
  final String description;
  @override
  final String youtubeUrl;
  @override
  @TimestampConverter()
  final DateTime publishedAt;

  @override
  String toString() {
    return 'Guide(thumbnail: $thumbnail, title: $title, description: $description, youtubeUrl: $youtubeUrl, publishedAt: $publishedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Guide &&
            (identical(other.thumbnail, thumbnail) ||
                other.thumbnail == thumbnail) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.youtubeUrl, youtubeUrl) ||
                other.youtubeUrl == youtubeUrl) &&
            (identical(other.publishedAt, publishedAt) ||
                other.publishedAt == publishedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, thumbnail, title, description, youtubeUrl, publishedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GuideCopyWith<_$_Guide> get copyWith =>
      __$$_GuideCopyWithImpl<_$_Guide>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GuideToJson(
      this,
    );
  }
}

abstract class _Guide implements Guide {
  const factory _Guide(
      {required final String thumbnail,
      required final String title,
      required final String description,
      required final String youtubeUrl,
      @TimestampConverter() required final DateTime publishedAt}) = _$_Guide;

  factory _Guide.fromJson(Map<String, dynamic> json) = _$_Guide.fromJson;

  @override
  String get thumbnail;
  @override
  String get title;
  @override
  String get description;
  @override
  String get youtubeUrl;
  @override
  @TimestampConverter()
  DateTime get publishedAt;
  @override
  @JsonKey(ignore: true)
  _$$_GuideCopyWith<_$_Guide> get copyWith =>
      throw _privateConstructorUsedError;
}

Connection _$ConnectionFromJson(Map<String, dynamic> json) {
  return _Connection.fromJson(json);
}

/// @nodoc
mixin _$Connection {
  /// Time in seconds to consider online
  @DurationOrNullConverter()
  Duration? get online => throw _privateConstructorUsedError;

  /// Time in seconds to consider in hibernation
  @DurationOrNullConverter()
  Duration? get hibernation => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConnectionCopyWith<Connection> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConnectionCopyWith<$Res> {
  factory $ConnectionCopyWith(
          Connection value, $Res Function(Connection) then) =
      _$ConnectionCopyWithImpl<$Res, Connection>;
  @useResult
  $Res call(
      {@DurationOrNullConverter() Duration? online,
      @DurationOrNullConverter() Duration? hibernation});
}

/// @nodoc
class _$ConnectionCopyWithImpl<$Res, $Val extends Connection>
    implements $ConnectionCopyWith<$Res> {
  _$ConnectionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? online = freezed,
    Object? hibernation = freezed,
  }) {
    return _then(_value.copyWith(
      online: freezed == online
          ? _value.online
          : online // ignore: cast_nullable_to_non_nullable
              as Duration?,
      hibernation: freezed == hibernation
          ? _value.hibernation
          : hibernation // ignore: cast_nullable_to_non_nullable
              as Duration?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ConnectionCopyWith<$Res>
    implements $ConnectionCopyWith<$Res> {
  factory _$$_ConnectionCopyWith(
          _$_Connection value, $Res Function(_$_Connection) then) =
      __$$_ConnectionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@DurationOrNullConverter() Duration? online,
      @DurationOrNullConverter() Duration? hibernation});
}

/// @nodoc
class __$$_ConnectionCopyWithImpl<$Res>
    extends _$ConnectionCopyWithImpl<$Res, _$_Connection>
    implements _$$_ConnectionCopyWith<$Res> {
  __$$_ConnectionCopyWithImpl(
      _$_Connection _value, $Res Function(_$_Connection) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? online = freezed,
    Object? hibernation = freezed,
  }) {
    return _then(_$_Connection(
      online: freezed == online
          ? _value.online
          : online // ignore: cast_nullable_to_non_nullable
              as Duration?,
      hibernation: freezed == hibernation
          ? _value.hibernation
          : hibernation // ignore: cast_nullable_to_non_nullable
              as Duration?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Connection implements _Connection {
  const _$_Connection(
      {@DurationOrNullConverter() this.online,
      @DurationOrNullConverter() this.hibernation});

  factory _$_Connection.fromJson(Map<String, dynamic> json) =>
      _$$_ConnectionFromJson(json);

  /// Time in seconds to consider online
  @override
  @DurationOrNullConverter()
  final Duration? online;

  /// Time in seconds to consider in hibernation
  @override
  @DurationOrNullConverter()
  final Duration? hibernation;

  @override
  String toString() {
    return 'Connection(online: $online, hibernation: $hibernation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Connection &&
            (identical(other.online, online) || other.online == online) &&
            (identical(other.hibernation, hibernation) ||
                other.hibernation == hibernation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, online, hibernation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ConnectionCopyWith<_$_Connection> get copyWith =>
      __$$_ConnectionCopyWithImpl<_$_Connection>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ConnectionToJson(
      this,
    );
  }
}

abstract class _Connection implements Connection {
  const factory _Connection(
      {@DurationOrNullConverter() final Duration? online,
      @DurationOrNullConverter() final Duration? hibernation}) = _$_Connection;

  factory _Connection.fromJson(Map<String, dynamic> json) =
      _$_Connection.fromJson;

  @override

  /// Time in seconds to consider online
  @DurationOrNullConverter()
  Duration? get online;
  @override

  /// Time in seconds to consider in hibernation
  @DurationOrNullConverter()
  Duration? get hibernation;
  @override
  @JsonKey(ignore: true)
  _$$_ConnectionCopyWith<_$_Connection> get copyWith =>
      throw _privateConstructorUsedError;
}

DeviceTelemetry _$DeviceTelemetryFromJson(Map<String, dynamic> json) {
  return _DeviceTelemetry.fromJson(json);
}

/// @nodoc
mixin _$DeviceTelemetry {
  /// ID of the message entity.
  String get id => throw _privateConstructorUsedError;

  /// ID of the unit.
  String? get deviceId => throw _privateConstructorUsedError;

  /// Unix of last reception date.
  @TimestampConverter()
  DateTime get receivedAt => throw _privateConstructorUsedError;

  /// Current position of the message.
  TelemetryPosition? get position => throw _privateConstructorUsedError;

  /// Raw received payload values list of the message.
  List<TelemetrySensor>? get payload => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeviceTelemetryCopyWith<DeviceTelemetry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceTelemetryCopyWith<$Res> {
  factory $DeviceTelemetryCopyWith(
          DeviceTelemetry value, $Res Function(DeviceTelemetry) then) =
      _$DeviceTelemetryCopyWithImpl<$Res, DeviceTelemetry>;
  @useResult
  $Res call(
      {String id,
      String? deviceId,
      @TimestampConverter() DateTime receivedAt,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload});

  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class _$DeviceTelemetryCopyWithImpl<$Res, $Val extends DeviceTelemetry>
    implements $DeviceTelemetryCopyWith<$Res> {
  _$DeviceTelemetryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deviceId = freezed,
    Object? receivedAt = null,
    Object? position = freezed,
    Object? payload = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deviceId: freezed == deviceId
          ? _value.deviceId
          : deviceId // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TelemetryPositionCopyWith<$Res>? get position {
    if (_value.position == null) {
      return null;
    }

    return $TelemetryPositionCopyWith<$Res>(_value.position!, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_DeviceTelemetryCopyWith<$Res>
    implements $DeviceTelemetryCopyWith<$Res> {
  factory _$$_DeviceTelemetryCopyWith(
          _$_DeviceTelemetry value, $Res Function(_$_DeviceTelemetry) then) =
      __$$_DeviceTelemetryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String? deviceId,
      @TimestampConverter() DateTime receivedAt,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload});

  @override
  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class __$$_DeviceTelemetryCopyWithImpl<$Res>
    extends _$DeviceTelemetryCopyWithImpl<$Res, _$_DeviceTelemetry>
    implements _$$_DeviceTelemetryCopyWith<$Res> {
  __$$_DeviceTelemetryCopyWithImpl(
      _$_DeviceTelemetry _value, $Res Function(_$_DeviceTelemetry) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? deviceId = freezed,
    Object? receivedAt = null,
    Object? position = freezed,
    Object? payload = freezed,
  }) {
    return _then(_$_DeviceTelemetry(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      deviceId: freezed == deviceId
          ? _value.deviceId
          : deviceId // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value._payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DeviceTelemetry extends _DeviceTelemetry {
  const _$_DeviceTelemetry(
      {required this.id,
      this.deviceId,
      @TimestampConverter() required this.receivedAt,
      this.position,
      final List<TelemetrySensor>? payload})
      : _payload = payload,
        super._();

  factory _$_DeviceTelemetry.fromJson(Map<String, dynamic> json) =>
      _$$_DeviceTelemetryFromJson(json);

  /// ID of the message entity.
  @override
  final String id;

  /// ID of the unit.
  @override
  final String? deviceId;

  /// Unix of last reception date.
  @override
  @TimestampConverter()
  final DateTime receivedAt;

  /// Current position of the message.
  @override
  final TelemetryPosition? position;

  /// Raw received payload values list of the message.
  final List<TelemetrySensor>? _payload;

  /// Raw received payload values list of the message.
  @override
  List<TelemetrySensor>? get payload {
    final value = _payload;
    if (value == null) return null;
    if (_payload is EqualUnmodifiableListView) return _payload;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'DeviceTelemetry(id: $id, deviceId: $deviceId, receivedAt: $receivedAt, position: $position, payload: $payload)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DeviceTelemetry &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.deviceId, deviceId) ||
                other.deviceId == deviceId) &&
            (identical(other.receivedAt, receivedAt) ||
                other.receivedAt == receivedAt) &&
            (identical(other.position, position) ||
                other.position == position) &&
            const DeepCollectionEquality().equals(other._payload, _payload));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, deviceId, receivedAt,
      position, const DeepCollectionEquality().hash(_payload));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DeviceTelemetryCopyWith<_$_DeviceTelemetry> get copyWith =>
      __$$_DeviceTelemetryCopyWithImpl<_$_DeviceTelemetry>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DeviceTelemetryToJson(
      this,
    );
  }
}

abstract class _DeviceTelemetry extends DeviceTelemetry {
  const factory _DeviceTelemetry(
      {required final String id,
      final String? deviceId,
      @TimestampConverter() required final DateTime receivedAt,
      final TelemetryPosition? position,
      final List<TelemetrySensor>? payload}) = _$_DeviceTelemetry;
  const _DeviceTelemetry._() : super._();

  factory _DeviceTelemetry.fromJson(Map<String, dynamic> json) =
      _$_DeviceTelemetry.fromJson;

  @override

  /// ID of the message entity.
  String get id;
  @override

  /// ID of the unit.
  String? get deviceId;
  @override

  /// Unix of last reception date.
  @TimestampConverter()
  DateTime get receivedAt;
  @override

  /// Current position of the message.
  TelemetryPosition? get position;
  @override

  /// Raw received payload values list of the message.
  List<TelemetrySensor>? get payload;
  @override
  @JsonKey(ignore: true)
  _$$_DeviceTelemetryCopyWith<_$_DeviceTelemetry> get copyWith =>
      throw _privateConstructorUsedError;
}

AssetTelemetry _$AssetTelemetryFromJson(Map<String, dynamic> json) {
  return _AssetTelemetry.fromJson(json);
}

/// @nodoc
mixin _$AssetTelemetry {
  /// ID of the message entity.
  String get id => throw _privateConstructorUsedError;

  /// ID of the unit.
  String? get assetId => throw _privateConstructorUsedError;

  /// Unix of last reception date.
  @TimestampConverter()
  DateTime get receivedAt => throw _privateConstructorUsedError;

  /// Current geofences ID's where the unit is.
  List<String>? get geofenceIds => throw _privateConstructorUsedError;

  /// Current position of the message.
  TelemetryPosition? get position => throw _privateConstructorUsedError;

  /// Raw received payload values list of the message.
  List<TelemetrySensor>? get payload => throw _privateConstructorUsedError;

  /// Current sensor values list of the message.
  List<TelemetrySensor>? get sensors => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetTelemetryCopyWith<AssetTelemetry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetTelemetryCopyWith<$Res> {
  factory $AssetTelemetryCopyWith(
          AssetTelemetry value, $Res Function(AssetTelemetry) then) =
      _$AssetTelemetryCopyWithImpl<$Res, AssetTelemetry>;
  @useResult
  $Res call(
      {String id,
      String? assetId,
      @TimestampConverter() DateTime receivedAt,
      List<String>? geofenceIds,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload,
      List<TelemetrySensor>? sensors});

  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class _$AssetTelemetryCopyWithImpl<$Res, $Val extends AssetTelemetry>
    implements $AssetTelemetryCopyWith<$Res> {
  _$AssetTelemetryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? assetId = freezed,
    Object? receivedAt = null,
    Object? geofenceIds = freezed,
    Object? position = freezed,
    Object? payload = freezed,
    Object? sensors = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      geofenceIds: freezed == geofenceIds
          ? _value.geofenceIds
          : geofenceIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      sensors: freezed == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TelemetryPositionCopyWith<$Res>? get position {
    if (_value.position == null) {
      return null;
    }

    return $TelemetryPositionCopyWith<$Res>(_value.position!, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AssetTelemetryCopyWith<$Res>
    implements $AssetTelemetryCopyWith<$Res> {
  factory _$$_AssetTelemetryCopyWith(
          _$_AssetTelemetry value, $Res Function(_$_AssetTelemetry) then) =
      __$$_AssetTelemetryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String? assetId,
      @TimestampConverter() DateTime receivedAt,
      List<String>? geofenceIds,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload,
      List<TelemetrySensor>? sensors});

  @override
  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class __$$_AssetTelemetryCopyWithImpl<$Res>
    extends _$AssetTelemetryCopyWithImpl<$Res, _$_AssetTelemetry>
    implements _$$_AssetTelemetryCopyWith<$Res> {
  __$$_AssetTelemetryCopyWithImpl(
      _$_AssetTelemetry _value, $Res Function(_$_AssetTelemetry) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? assetId = freezed,
    Object? receivedAt = null,
    Object? geofenceIds = freezed,
    Object? position = freezed,
    Object? payload = freezed,
    Object? sensors = freezed,
  }) {
    return _then(_$_AssetTelemetry(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      geofenceIds: freezed == geofenceIds
          ? _value._geofenceIds
          : geofenceIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value._payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      sensors: freezed == sensors
          ? _value._sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AssetTelemetry extends _AssetTelemetry {
  const _$_AssetTelemetry(
      {required this.id,
      this.assetId,
      @TimestampConverter() required this.receivedAt,
      final List<String>? geofenceIds,
      this.position,
      final List<TelemetrySensor>? payload,
      final List<TelemetrySensor>? sensors})
      : _geofenceIds = geofenceIds,
        _payload = payload,
        _sensors = sensors,
        super._();

  factory _$_AssetTelemetry.fromJson(Map<String, dynamic> json) =>
      _$$_AssetTelemetryFromJson(json);

  /// ID of the message entity.
  @override
  final String id;

  /// ID of the unit.
  @override
  final String? assetId;

  /// Unix of last reception date.
  @override
  @TimestampConverter()
  final DateTime receivedAt;

  /// Current geofences ID's where the unit is.
  final List<String>? _geofenceIds;

  /// Current geofences ID's where the unit is.
  @override
  List<String>? get geofenceIds {
    final value = _geofenceIds;
    if (value == null) return null;
    if (_geofenceIds is EqualUnmodifiableListView) return _geofenceIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Current position of the message.
  @override
  final TelemetryPosition? position;

  /// Raw received payload values list of the message.
  final List<TelemetrySensor>? _payload;

  /// Raw received payload values list of the message.
  @override
  List<TelemetrySensor>? get payload {
    final value = _payload;
    if (value == null) return null;
    if (_payload is EqualUnmodifiableListView) return _payload;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Current sensor values list of the message.
  final List<TelemetrySensor>? _sensors;

  /// Current sensor values list of the message.
  @override
  List<TelemetrySensor>? get sensors {
    final value = _sensors;
    if (value == null) return null;
    if (_sensors is EqualUnmodifiableListView) return _sensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AssetTelemetry(id: $id, assetId: $assetId, receivedAt: $receivedAt, geofenceIds: $geofenceIds, position: $position, payload: $payload, sensors: $sensors)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AssetTelemetry &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.receivedAt, receivedAt) ||
                other.receivedAt == receivedAt) &&
            const DeepCollectionEquality()
                .equals(other._geofenceIds, _geofenceIds) &&
            (identical(other.position, position) ||
                other.position == position) &&
            const DeepCollectionEquality().equals(other._payload, _payload) &&
            const DeepCollectionEquality().equals(other._sensors, _sensors));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      assetId,
      receivedAt,
      const DeepCollectionEquality().hash(_geofenceIds),
      position,
      const DeepCollectionEquality().hash(_payload),
      const DeepCollectionEquality().hash(_sensors));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AssetTelemetryCopyWith<_$_AssetTelemetry> get copyWith =>
      __$$_AssetTelemetryCopyWithImpl<_$_AssetTelemetry>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AssetTelemetryToJson(
      this,
    );
  }
}

abstract class _AssetTelemetry extends AssetTelemetry {
  const factory _AssetTelemetry(
      {required final String id,
      final String? assetId,
      @TimestampConverter() required final DateTime receivedAt,
      final List<String>? geofenceIds,
      final TelemetryPosition? position,
      final List<TelemetrySensor>? payload,
      final List<TelemetrySensor>? sensors}) = _$_AssetTelemetry;
  const _AssetTelemetry._() : super._();

  factory _AssetTelemetry.fromJson(Map<String, dynamic> json) =
      _$_AssetTelemetry.fromJson;

  @override

  /// ID of the message entity.
  String get id;
  @override

  /// ID of the unit.
  String? get assetId;
  @override

  /// Unix of last reception date.
  @TimestampConverter()
  DateTime get receivedAt;
  @override

  /// Current geofences ID's where the unit is.
  List<String>? get geofenceIds;
  @override

  /// Current position of the message.
  TelemetryPosition? get position;
  @override

  /// Raw received payload values list of the message.
  List<TelemetrySensor>? get payload;
  @override

  /// Current sensor values list of the message.
  List<TelemetrySensor>? get sensors;
  @override
  @JsonKey(ignore: true)
  _$$_AssetTelemetryCopyWith<_$_AssetTelemetry> get copyWith =>
      throw _privateConstructorUsedError;
}

TelemetryPosition _$TelemetryPositionFromJson(Map<String, dynamic> json) {
  return _TelemetryPosition.fromJson(json);
}

/// @nodoc
mixin _$TelemetryPosition {
  /// Latitude in decimal degrees format
  double? get latitude => throw _privateConstructorUsedError;

  /// Longitude in decimal degrees format.
  double? get longitude => throw _privateConstructorUsedError;

  /// Registered altitude, defined in Meters.
  double? get altitude => throw _privateConstructorUsedError;

  /// Registered speed, defined in Kilomemters per hour.
  double? get speed => throw _privateConstructorUsedError;

  /// Registered direction, defined in degrees.
  double? get direction => throw _privateConstructorUsedError;

  /// Number of satellites connected to.
  int? get satellites => throw _privateConstructorUsedError;

  /// Horizontal dilution of precision registered for.
  double? get hdop => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TelemetryPositionCopyWith<TelemetryPosition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TelemetryPositionCopyWith<$Res> {
  factory $TelemetryPositionCopyWith(
          TelemetryPosition value, $Res Function(TelemetryPosition) then) =
      _$TelemetryPositionCopyWithImpl<$Res, TelemetryPosition>;
  @useResult
  $Res call(
      {double? latitude,
      double? longitude,
      double? altitude,
      double? speed,
      double? direction,
      int? satellites,
      double? hdop});
}

/// @nodoc
class _$TelemetryPositionCopyWithImpl<$Res, $Val extends TelemetryPosition>
    implements $TelemetryPositionCopyWith<$Res> {
  _$TelemetryPositionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? altitude = freezed,
    Object? speed = freezed,
    Object? direction = freezed,
    Object? satellites = freezed,
    Object? hdop = freezed,
  }) {
    return _then(_value.copyWith(
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
      altitude: freezed == altitude
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as double?,
      speed: freezed == speed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as double?,
      direction: freezed == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as double?,
      satellites: freezed == satellites
          ? _value.satellites
          : satellites // ignore: cast_nullable_to_non_nullable
              as int?,
      hdop: freezed == hdop
          ? _value.hdop
          : hdop // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TelemetryPositionCopyWith<$Res>
    implements $TelemetryPositionCopyWith<$Res> {
  factory _$$_TelemetryPositionCopyWith(_$_TelemetryPosition value,
          $Res Function(_$_TelemetryPosition) then) =
      __$$_TelemetryPositionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? latitude,
      double? longitude,
      double? altitude,
      double? speed,
      double? direction,
      int? satellites,
      double? hdop});
}

/// @nodoc
class __$$_TelemetryPositionCopyWithImpl<$Res>
    extends _$TelemetryPositionCopyWithImpl<$Res, _$_TelemetryPosition>
    implements _$$_TelemetryPositionCopyWith<$Res> {
  __$$_TelemetryPositionCopyWithImpl(
      _$_TelemetryPosition _value, $Res Function(_$_TelemetryPosition) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? altitude = freezed,
    Object? speed = freezed,
    Object? direction = freezed,
    Object? satellites = freezed,
    Object? hdop = freezed,
  }) {
    return _then(_$_TelemetryPosition(
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
      altitude: freezed == altitude
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as double?,
      speed: freezed == speed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as double?,
      direction: freezed == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as double?,
      satellites: freezed == satellites
          ? _value.satellites
          : satellites // ignore: cast_nullable_to_non_nullable
              as int?,
      hdop: freezed == hdop
          ? _value.hdop
          : hdop // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TelemetryPosition extends _TelemetryPosition {
  const _$_TelemetryPosition(
      {this.latitude,
      this.longitude,
      this.altitude,
      this.speed,
      this.direction,
      this.satellites,
      this.hdop})
      : super._();

  factory _$_TelemetryPosition.fromJson(Map<String, dynamic> json) =>
      _$$_TelemetryPositionFromJson(json);

  /// Latitude in decimal degrees format
  @override
  final double? latitude;

  /// Longitude in decimal degrees format.
  @override
  final double? longitude;

  /// Registered altitude, defined in Meters.
  @override
  final double? altitude;

  /// Registered speed, defined in Kilomemters per hour.
  @override
  final double? speed;

  /// Registered direction, defined in degrees.
  @override
  final double? direction;

  /// Number of satellites connected to.
  @override
  final int? satellites;

  /// Horizontal dilution of precision registered for.
  @override
  final double? hdop;

  @override
  String toString() {
    return 'TelemetryPosition(latitude: $latitude, longitude: $longitude, altitude: $altitude, speed: $speed, direction: $direction, satellites: $satellites, hdop: $hdop)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TelemetryPosition &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude) &&
            (identical(other.altitude, altitude) ||
                other.altitude == altitude) &&
            (identical(other.speed, speed) || other.speed == speed) &&
            (identical(other.direction, direction) ||
                other.direction == direction) &&
            (identical(other.satellites, satellites) ||
                other.satellites == satellites) &&
            (identical(other.hdop, hdop) || other.hdop == hdop));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, latitude, longitude, altitude,
      speed, direction, satellites, hdop);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TelemetryPositionCopyWith<_$_TelemetryPosition> get copyWith =>
      __$$_TelemetryPositionCopyWithImpl<_$_TelemetryPosition>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TelemetryPositionToJson(
      this,
    );
  }
}

abstract class _TelemetryPosition extends TelemetryPosition {
  const factory _TelemetryPosition(
      {final double? latitude,
      final double? longitude,
      final double? altitude,
      final double? speed,
      final double? direction,
      final int? satellites,
      final double? hdop}) = _$_TelemetryPosition;
  const _TelemetryPosition._() : super._();

  factory _TelemetryPosition.fromJson(Map<String, dynamic> json) =
      _$_TelemetryPosition.fromJson;

  @override

  /// Latitude in decimal degrees format
  double? get latitude;
  @override

  /// Longitude in decimal degrees format.
  double? get longitude;
  @override

  /// Registered altitude, defined in Meters.
  double? get altitude;
  @override

  /// Registered speed, defined in Kilomemters per hour.
  double? get speed;
  @override

  /// Registered direction, defined in degrees.
  double? get direction;
  @override

  /// Number of satellites connected to.
  int? get satellites;
  @override

  /// Horizontal dilution of precision registered for.
  double? get hdop;
  @override
  @JsonKey(ignore: true)
  _$$_TelemetryPositionCopyWith<_$_TelemetryPosition> get copyWith =>
      throw _privateConstructorUsedError;
}

TelemetrySensor _$TelemetrySensorFromJson(Map<String, dynamic> json) {
  return _TelemetrySensor.fromJson(json);
}

/// @nodoc
mixin _$TelemetrySensor {
  /// Dynamic value registered.
  dynamic get value => throw _privateConstructorUsedError;

  /// Parameter registed.
  String get parameter => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TelemetrySensorCopyWith<TelemetrySensor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TelemetrySensorCopyWith<$Res> {
  factory $TelemetrySensorCopyWith(
          TelemetrySensor value, $Res Function(TelemetrySensor) then) =
      _$TelemetrySensorCopyWithImpl<$Res, TelemetrySensor>;
  @useResult
  $Res call({dynamic value, String parameter});
}

/// @nodoc
class _$TelemetrySensorCopyWithImpl<$Res, $Val extends TelemetrySensor>
    implements $TelemetrySensorCopyWith<$Res> {
  _$TelemetrySensorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? parameter = null,
  }) {
    return _then(_value.copyWith(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
      parameter: null == parameter
          ? _value.parameter
          : parameter // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TelemetrySensorCopyWith<$Res>
    implements $TelemetrySensorCopyWith<$Res> {
  factory _$$_TelemetrySensorCopyWith(
          _$_TelemetrySensor value, $Res Function(_$_TelemetrySensor) then) =
      __$$_TelemetrySensorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic value, String parameter});
}

/// @nodoc
class __$$_TelemetrySensorCopyWithImpl<$Res>
    extends _$TelemetrySensorCopyWithImpl<$Res, _$_TelemetrySensor>
    implements _$$_TelemetrySensorCopyWith<$Res> {
  __$$_TelemetrySensorCopyWithImpl(
      _$_TelemetrySensor _value, $Res Function(_$_TelemetrySensor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
    Object? parameter = null,
  }) {
    return _then(_$_TelemetrySensor(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as dynamic,
      parameter: null == parameter
          ? _value.parameter
          : parameter // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TelemetrySensor extends _TelemetrySensor {
  const _$_TelemetrySensor({required this.value, required this.parameter})
      : super._();

  factory _$_TelemetrySensor.fromJson(Map<String, dynamic> json) =>
      _$$_TelemetrySensorFromJson(json);

  /// Dynamic value registered.
  @override
  final dynamic value;

  /// Parameter registed.
  @override
  final String parameter;

  @override
  String toString() {
    return 'TelemetrySensor(value: $value, parameter: $parameter)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TelemetrySensor &&
            const DeepCollectionEquality().equals(other.value, value) &&
            (identical(other.parameter, parameter) ||
                other.parameter == parameter));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(value), parameter);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TelemetrySensorCopyWith<_$_TelemetrySensor> get copyWith =>
      __$$_TelemetrySensorCopyWithImpl<_$_TelemetrySensor>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TelemetrySensorToJson(
      this,
    );
  }
}

abstract class _TelemetrySensor extends TelemetrySensor {
  const factory _TelemetrySensor(
      {required final dynamic value,
      required final String parameter}) = _$_TelemetrySensor;
  const _TelemetrySensor._() : super._();

  factory _TelemetrySensor.fromJson(Map<String, dynamic> json) =
      _$_TelemetrySensor.fromJson;

  @override

  /// Dynamic value registered.
  dynamic get value;
  @override

  /// Parameter registed.
  String get parameter;
  @override
  @JsonKey(ignore: true)
  _$$_TelemetrySensorCopyWith<_$_TelemetrySensor> get copyWith =>
      throw _privateConstructorUsedError;
}

Trip _$TripFromJson(Map<String, dynamic> json) {
  return _Trip.fromJson(json);
}

/// @nodoc
mixin _$Trip {
  /// ID of the asset.
  String get assetId => throw _privateConstructorUsedError;

  /// Name of the asset.
  String? get assetName => throw _privateConstructorUsedError;

  /// List of trip points. All points are messages, but if receives values from event, means that message contains an event.
  List<Point> get points => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TripCopyWith<Trip> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TripCopyWith<$Res> {
  factory $TripCopyWith(Trip value, $Res Function(Trip) then) =
      _$TripCopyWithImpl<$Res, Trip>;
  @useResult
  $Res call({String assetId, String? assetName, List<Point> points});
}

/// @nodoc
class _$TripCopyWithImpl<$Res, $Val extends Trip>
    implements $TripCopyWith<$Res> {
  _$TripCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = null,
    Object? assetName = freezed,
    Object? points = null,
  }) {
    return _then(_value.copyWith(
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      assetName: freezed == assetName
          ? _value.assetName
          : assetName // ignore: cast_nullable_to_non_nullable
              as String?,
      points: null == points
          ? _value.points
          : points // ignore: cast_nullable_to_non_nullable
              as List<Point>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TripCopyWith<$Res> implements $TripCopyWith<$Res> {
  factory _$$_TripCopyWith(_$_Trip value, $Res Function(_$_Trip) then) =
      __$$_TripCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String assetId, String? assetName, List<Point> points});
}

/// @nodoc
class __$$_TripCopyWithImpl<$Res> extends _$TripCopyWithImpl<$Res, _$_Trip>
    implements _$$_TripCopyWith<$Res> {
  __$$_TripCopyWithImpl(_$_Trip _value, $Res Function(_$_Trip) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = null,
    Object? assetName = freezed,
    Object? points = null,
  }) {
    return _then(_$_Trip(
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      assetName: freezed == assetName
          ? _value.assetName
          : assetName // ignore: cast_nullable_to_non_nullable
              as String?,
      points: null == points
          ? _value._points
          : points // ignore: cast_nullable_to_non_nullable
              as List<Point>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Trip extends _Trip {
  const _$_Trip(
      {required this.assetId,
      this.assetName,
      required final List<Point> points})
      : _points = points,
        super._();

  factory _$_Trip.fromJson(Map<String, dynamic> json) => _$$_TripFromJson(json);

  /// ID of the asset.
  @override
  final String assetId;

  /// Name of the asset.
  @override
  final String? assetName;

  /// List of trip points. All points are messages, but if receives values from event, means that message contains an event.
  final List<Point> _points;

  /// List of trip points. All points are messages, but if receives values from event, means that message contains an event.
  @override
  List<Point> get points {
    if (_points is EqualUnmodifiableListView) return _points;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_points);
  }

  @override
  String toString() {
    return 'Trip(assetId: $assetId, assetName: $assetName, points: $points)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Trip &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.assetName, assetName) ||
                other.assetName == assetName) &&
            const DeepCollectionEquality().equals(other._points, _points));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, assetId, assetName,
      const DeepCollectionEquality().hash(_points));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TripCopyWith<_$_Trip> get copyWith =>
      __$$_TripCopyWithImpl<_$_Trip>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TripToJson(
      this,
    );
  }
}

abstract class _Trip extends Trip {
  const factory _Trip(
      {required final String assetId,
      final String? assetName,
      required final List<Point> points}) = _$_Trip;
  const _Trip._() : super._();

  factory _Trip.fromJson(Map<String, dynamic> json) = _$_Trip.fromJson;

  @override

  /// ID of the asset.
  String get assetId;
  @override

  /// Name of the asset.
  String? get assetName;
  @override

  /// List of trip points. All points are messages, but if receives values from event, means that message contains an event.
  List<Point> get points;
  @override
  @JsonKey(ignore: true)
  _$$_TripCopyWith<_$_Trip> get copyWith => throw _privateConstructorUsedError;
}

Point _$PointFromJson(Map<String, dynamic> json) {
  return _Point.fromJson(json);
}

/// @nodoc
mixin _$Point {
  /// Latitude of the message from asset.
  double get latitude => throw _privateConstructorUsedError;

  /// Longitude of the message from asset.
  double get longitude => throw _privateConstructorUsedError;

  /// Direction or heading of the message from asset.
  double? get direction => throw _privateConstructorUsedError;

  /// ID of the trigger entity. This ID is unique.
  String? get triggerId => throw _privateConstructorUsedError;

  /// Name of the trigger entity.
  String? get triggerName => throw _privateConstructorUsedError;

  /// Unix of last reception date.
  @TimestampConverter()
  DateTime get receivedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PointCopyWith<Point> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PointCopyWith<$Res> {
  factory $PointCopyWith(Point value, $Res Function(Point) then) =
      _$PointCopyWithImpl<$Res, Point>;
  @useResult
  $Res call(
      {double latitude,
      double longitude,
      double? direction,
      String? triggerId,
      String? triggerName,
      @TimestampConverter() DateTime receivedAt});
}

/// @nodoc
class _$PointCopyWithImpl<$Res, $Val extends Point>
    implements $PointCopyWith<$Res> {
  _$PointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = null,
    Object? longitude = null,
    Object? direction = freezed,
    Object? triggerId = freezed,
    Object? triggerName = freezed,
    Object? receivedAt = null,
  }) {
    return _then(_value.copyWith(
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double,
      direction: freezed == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as double?,
      triggerId: freezed == triggerId
          ? _value.triggerId
          : triggerId // ignore: cast_nullable_to_non_nullable
              as String?,
      triggerName: freezed == triggerName
          ? _value.triggerName
          : triggerName // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PointCopyWith<$Res> implements $PointCopyWith<$Res> {
  factory _$$_PointCopyWith(_$_Point value, $Res Function(_$_Point) then) =
      __$$_PointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double latitude,
      double longitude,
      double? direction,
      String? triggerId,
      String? triggerName,
      @TimestampConverter() DateTime receivedAt});
}

/// @nodoc
class __$$_PointCopyWithImpl<$Res> extends _$PointCopyWithImpl<$Res, _$_Point>
    implements _$$_PointCopyWith<$Res> {
  __$$_PointCopyWithImpl(_$_Point _value, $Res Function(_$_Point) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = null,
    Object? longitude = null,
    Object? direction = freezed,
    Object? triggerId = freezed,
    Object? triggerName = freezed,
    Object? receivedAt = null,
  }) {
    return _then(_$_Point(
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double,
      direction: freezed == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as double?,
      triggerId: freezed == triggerId
          ? _value.triggerId
          : triggerId // ignore: cast_nullable_to_non_nullable
              as String?,
      triggerName: freezed == triggerName
          ? _value.triggerName
          : triggerName // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Point extends _Point {
  const _$_Point(
      {required this.latitude,
      required this.longitude,
      this.direction,
      this.triggerId,
      this.triggerName,
      @TimestampConverter() required this.receivedAt})
      : super._();

  factory _$_Point.fromJson(Map<String, dynamic> json) =>
      _$$_PointFromJson(json);

  /// Latitude of the message from asset.
  @override
  final double latitude;

  /// Longitude of the message from asset.
  @override
  final double longitude;

  /// Direction or heading of the message from asset.
  @override
  final double? direction;

  /// ID of the trigger entity. This ID is unique.
  @override
  final String? triggerId;

  /// Name of the trigger entity.
  @override
  final String? triggerName;

  /// Unix of last reception date.
  @override
  @TimestampConverter()
  final DateTime receivedAt;

  @override
  String toString() {
    return 'Point(latitude: $latitude, longitude: $longitude, direction: $direction, triggerId: $triggerId, triggerName: $triggerName, receivedAt: $receivedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Point &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude) &&
            (identical(other.direction, direction) ||
                other.direction == direction) &&
            (identical(other.triggerId, triggerId) ||
                other.triggerId == triggerId) &&
            (identical(other.triggerName, triggerName) ||
                other.triggerName == triggerName) &&
            (identical(other.receivedAt, receivedAt) ||
                other.receivedAt == receivedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, latitude, longitude, direction,
      triggerId, triggerName, receivedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PointCopyWith<_$_Point> get copyWith =>
      __$$_PointCopyWithImpl<_$_Point>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PointToJson(
      this,
    );
  }
}

abstract class _Point extends Point {
  const factory _Point(
      {required final double latitude,
      required final double longitude,
      final double? direction,
      final String? triggerId,
      final String? triggerName,
      @TimestampConverter() required final DateTime receivedAt}) = _$_Point;
  const _Point._() : super._();

  factory _Point.fromJson(Map<String, dynamic> json) = _$_Point.fromJson;

  @override

  /// Latitude of the message from asset.
  double get latitude;
  @override

  /// Longitude of the message from asset.
  double get longitude;
  @override

  /// Direction or heading of the message from asset.
  double? get direction;
  @override

  /// ID of the trigger entity. This ID is unique.
  String? get triggerId;
  @override

  /// Name of the trigger entity.
  String? get triggerName;
  @override

  /// Unix of last reception date.
  @TimestampConverter()
  DateTime get receivedAt;
  @override
  @JsonKey(ignore: true)
  _$$_PointCopyWith<_$_Point> get copyWith =>
      throw _privateConstructorUsedError;
}

Model _$ModelFromJson(Map<String, dynamic> json) {
  return _Model.fromJson(json);
}

/// @nodoc
mixin _$Model {
  /// [id] is the unique identifier of the model.
  String get id => throw _privateConstructorUsedError;

  /// [name] is the name of the model.
  String get name => throw _privateConstructorUsedError;

  /// [flespiId] is the ID of the device in the flespi platform.
  /// Can be null if the model is not connected to a device or is a in-house protocol.
  String? get flespiId => throw _privateConstructorUsedError;

  /// [protocol] is the protocol of the model.
  InboundProtocol? get protocol => throw _privateConstructorUsedError;

  /// [protocolId] is the ID of the protocol
  String? get protocolId => throw _privateConstructorUsedError;

  /// [isGeneric] is true if the model is generic.
  bool? get isGeneric => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ModelCopyWith<Model> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelCopyWith<$Res> {
  factory $ModelCopyWith(Model value, $Res Function(Model) then) =
      _$ModelCopyWithImpl<$Res, Model>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? flespiId,
      InboundProtocol? protocol,
      String? protocolId,
      bool? isGeneric});

  $InboundProtocolCopyWith<$Res>? get protocol;
}

/// @nodoc
class _$ModelCopyWithImpl<$Res, $Val extends Model>
    implements $ModelCopyWith<$Res> {
  _$ModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? flespiId = freezed,
    Object? protocol = freezed,
    Object? protocolId = freezed,
    Object? isGeneric = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      flespiId: freezed == flespiId
          ? _value.flespiId
          : flespiId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      isGeneric: freezed == isGeneric
          ? _value.isGeneric
          : isGeneric // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $InboundProtocolCopyWith<$Res>? get protocol {
    if (_value.protocol == null) {
      return null;
    }

    return $InboundProtocolCopyWith<$Res>(_value.protocol!, (value) {
      return _then(_value.copyWith(protocol: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ModelCopyWith<$Res> implements $ModelCopyWith<$Res> {
  factory _$$_ModelCopyWith(_$_Model value, $Res Function(_$_Model) then) =
      __$$_ModelCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? flespiId,
      InboundProtocol? protocol,
      String? protocolId,
      bool? isGeneric});

  @override
  $InboundProtocolCopyWith<$Res>? get protocol;
}

/// @nodoc
class __$$_ModelCopyWithImpl<$Res> extends _$ModelCopyWithImpl<$Res, _$_Model>
    implements _$$_ModelCopyWith<$Res> {
  __$$_ModelCopyWithImpl(_$_Model _value, $Res Function(_$_Model) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? flespiId = freezed,
    Object? protocol = freezed,
    Object? protocolId = freezed,
    Object? isGeneric = freezed,
  }) {
    return _then(_$_Model(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      flespiId: freezed == flespiId
          ? _value.flespiId
          : flespiId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      isGeneric: freezed == isGeneric
          ? _value.isGeneric
          : isGeneric // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Model implements _Model {
  const _$_Model(
      {required this.id,
      required this.name,
      this.flespiId,
      this.protocol,
      this.protocolId,
      this.isGeneric});

  factory _$_Model.fromJson(Map<String, dynamic> json) =>
      _$$_ModelFromJson(json);

  /// [id] is the unique identifier of the model.
  @override
  final String id;

  /// [name] is the name of the model.
  @override
  final String name;

  /// [flespiId] is the ID of the device in the flespi platform.
  /// Can be null if the model is not connected to a device or is a in-house protocol.
  @override
  final String? flespiId;

  /// [protocol] is the protocol of the model.
  @override
  final InboundProtocol? protocol;

  /// [protocolId] is the ID of the protocol
  @override
  final String? protocolId;

  /// [isGeneric] is true if the model is generic.
  @override
  final bool? isGeneric;

  @override
  String toString() {
    return 'Model(id: $id, name: $name, flespiId: $flespiId, protocol: $protocol, protocolId: $protocolId, isGeneric: $isGeneric)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Model &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.flespiId, flespiId) ||
                other.flespiId == flespiId) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            (identical(other.protocolId, protocolId) ||
                other.protocolId == protocolId) &&
            (identical(other.isGeneric, isGeneric) ||
                other.isGeneric == isGeneric));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, name, flespiId, protocol, protocolId, isGeneric);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ModelCopyWith<_$_Model> get copyWith =>
      __$$_ModelCopyWithImpl<_$_Model>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ModelToJson(
      this,
    );
  }
}

abstract class _Model implements Model {
  const factory _Model(
      {required final String id,
      required final String name,
      final String? flespiId,
      final InboundProtocol? protocol,
      final String? protocolId,
      final bool? isGeneric}) = _$_Model;

  factory _Model.fromJson(Map<String, dynamic> json) = _$_Model.fromJson;

  @override

  /// [id] is the unique identifier of the model.
  String get id;
  @override

  /// [name] is the name of the model.
  String get name;
  @override

  /// [flespiId] is the ID of the device in the flespi platform.
  /// Can be null if the model is not connected to a device or is a in-house protocol.
  String? get flespiId;
  @override

  /// [protocol] is the protocol of the model.
  InboundProtocol? get protocol;
  @override

  /// [protocolId] is the ID of the protocol
  String? get protocolId;
  @override

  /// [isGeneric] is true if the model is generic.
  bool? get isGeneric;
  @override
  @JsonKey(ignore: true)
  _$$_ModelCopyWith<_$_Model> get copyWith =>
      throw _privateConstructorUsedError;
}

Trigger _$TriggerFromJson(Map<String, dynamic> json) {
  return _Trigger.fromJson(json);
}

/// @nodoc
mixin _$Trigger {
  /// [id] is the unique identifier of the trigger.
  String get id => throw _privateConstructorUsedError;

  /// [name] is the name of the trigger.
  String get name => throw _privateConstructorUsedError;

  /// [code] is the code of the trigger.
  String get code => throw _privateConstructorUsedError;

  /// [geofencesIds] is the list of ID's of the linked geofences.
  List<String>? get geofencesIds => throw _privateConstructorUsedError;

  /// [tagsGeofencesIds] is the list of ID's of the linked geofences through tags.
  List<String>? get tagsGeofencesIds => throw _privateConstructorUsedError;

  /// [assetsIds] is the list of ID's of the linked assets.
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  /// [tagsAssetsIds] is the list of ID's of the linked assets through tags.
  List<String>? get tagsAssetsIds => throw _privateConstructorUsedError;

  /// [parameters] is the list of parameters of the trigger.
  List<String>? get parameters => throw _privateConstructorUsedError;

  /// [authAssetsIds] is the list of ID's of the assets for authentication.
  List<String>? get authAssetsIds => throw _privateConstructorUsedError;

  /// [authUsersIds] is the list of ID's of the users for authentication.
  List<String>? get authUsersIds => throw _privateConstructorUsedError;

  /// [authTagsIds] is the list of ID's of the tags for authentication.
  List<String>? get authTagsIds => throw _privateConstructorUsedError;

  /// [kind] is the type of the trigger.
  @TriggerTypeConverter()
  TriggerType get kind => throw _privateConstructorUsedError;

  /// [geofenceKind] is the type of the geofence.
  /// Only used when [kind] is [TriggerType.geofence].
  @TriggerGeofenceDetectionModeOrNullConverter()
  TriggerGeofenceDetectionMode? get geofenceKind =>
      throw _privateConstructorUsedError;

  /// [formula] is the formula of the trigger. Only used when [kind] is [TriggerType.formula].
  /// The formula is a script that returns a boolean value (true or false).
  /// Also, the formula should be written in LCL (Layrz Compute Language)
  String? get formula => throw _privateConstructorUsedError;

  /// [script] is the script of the trigger. Only used when [kind] is [TriggerType.script].
  /// The script is a script that returns a boolean value (true or false).
  /// Also, the script should be written in Python (Version 3.8)
  String? get script => throw _privateConstructorUsedError;

  /// [exactHour] is the exact hour of the trigger. Only used when [kind] is [TriggerType.exactTime].
  String? get exactHour => throw _privateConstructorUsedError;

  /// [crontabFormat] is the crontab format of the trigger. Only used when [kind] is [TriggerType.exactTime].
  /// The crontab format is a string that represents the exact time of the trigger.
  String? get crontabFormat => throw _privateConstructorUsedError;

  /// [weekdays] is the list of weekdays of the trigger. Only used when [kind] is [TriggerType.exactTime].
  /// The weekdays are represented by the [Weekday] enum.
  @WeekdayConverter()
  List<Weekday>? get weekdays => throw _privateConstructorUsedError;

  /// [isPlainCrontab] is a boolean that indicates if the crontab format is plain or not.
  /// Only used when [kind] is [TriggerType.exactTime].
  bool? get isPlainCrontab => throw _privateConstructorUsedError;

  /// [timezoneId] is the ID of the timezone of the trigger.
  /// Only used when [kind] is [TriggerType.exactTime].
  String? get timezoneId => throw _privateConstructorUsedError;

  /// [priority] is the priority of the trigger.
  int? get priority => throw _privateConstructorUsedError;

  /// [color] is the color of the trigger.
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  /// [visualEventEffect] is the visual effect of the trigger.
  @CaseEventEffectOrNullConverter()
  CaseEventEffect? get visualEventEffect => throw _privateConstructorUsedError;

  /// [careProtocolId] is the ID of the care protocol to execute when the trigger is activated.
  String? get careProtocolId => throw _privateConstructorUsedError;

  /// [careProtocol] is the care protocol to execute when the trigger is activated.
  CareProtocol? get careProtocol => throw _privateConstructorUsedError;

  /// [caseKind] represents the type of case to generate when the trigger is activated.
  /// This field is required for `kind=[TriggerType.casesChanges]`.
  @CaseTypeOrNullConverter()
  CaseType? get caseKind => throw _privateConstructorUsedError;

  /// [caseCommentPattern] represents the type of comment pattern to detect changes on cases to perform
  /// actions. This field is required for `kind=[TriggerType.casesChanges]` and
  /// `caseKind=[CaseType.onCommentPattern]`.
  @CaseCommentPatternOrNullConverter()
  CaseCommentPattern? get caseCommentPattern =>
      throw _privateConstructorUsedError;

  /// [caseCommentPatternValue] represents the value of the comment pattern to detect changes on cases to perform
  /// actions. This field is required for `kind=[TriggerType.casesChanges]` and
  /// `caseKind=[CaseType.onCommentPattern]`.
  String? get caseCommentPatternValue => throw _privateConstructorUsedError;

  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  Duration? get cooldownTime => throw _privateConstructorUsedError;

  /// [access] represents the list of accesses to the trigger.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TriggerCopyWith<Trigger> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TriggerCopyWith<$Res> {
  factory $TriggerCopyWith(Trigger value, $Res Function(Trigger) then) =
      _$TriggerCopyWithImpl<$Res, Trigger>;
  @useResult
  $Res call(
      {String id,
      String name,
      String code,
      List<String>? geofencesIds,
      List<String>? tagsGeofencesIds,
      List<String>? assetsIds,
      List<String>? tagsAssetsIds,
      List<String>? parameters,
      List<String>? authAssetsIds,
      List<String>? authUsersIds,
      List<String>? authTagsIds,
      @TriggerTypeConverter() TriggerType kind,
      @TriggerGeofenceDetectionModeOrNullConverter()
      TriggerGeofenceDetectionMode? geofenceKind,
      String? formula,
      String? script,
      String? exactHour,
      String? crontabFormat,
      @WeekdayConverter() List<Weekday>? weekdays,
      bool? isPlainCrontab,
      String? timezoneId,
      int? priority,
      @ColorOrNullConverter() Color? color,
      @CaseEventEffectOrNullConverter() CaseEventEffect? visualEventEffect,
      String? careProtocolId,
      CareProtocol? careProtocol,
      @CaseTypeOrNullConverter() CaseType? caseKind,
      @CaseCommentPatternOrNullConverter()
      CaseCommentPattern? caseCommentPattern,
      String? caseCommentPatternValue,
      @DurationOrNullConverter() Duration? cooldownTime,
      List<Access>? access});

  $CareProtocolCopyWith<$Res>? get careProtocol;
}

/// @nodoc
class _$TriggerCopyWithImpl<$Res, $Val extends Trigger>
    implements $TriggerCopyWith<$Res> {
  _$TriggerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = null,
    Object? geofencesIds = freezed,
    Object? tagsGeofencesIds = freezed,
    Object? assetsIds = freezed,
    Object? tagsAssetsIds = freezed,
    Object? parameters = freezed,
    Object? authAssetsIds = freezed,
    Object? authUsersIds = freezed,
    Object? authTagsIds = freezed,
    Object? kind = null,
    Object? geofenceKind = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? exactHour = freezed,
    Object? crontabFormat = freezed,
    Object? weekdays = freezed,
    Object? isPlainCrontab = freezed,
    Object? timezoneId = freezed,
    Object? priority = freezed,
    Object? color = freezed,
    Object? visualEventEffect = freezed,
    Object? careProtocolId = freezed,
    Object? careProtocol = freezed,
    Object? caseKind = freezed,
    Object? caseCommentPattern = freezed,
    Object? caseCommentPatternValue = freezed,
    Object? cooldownTime = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      geofencesIds: freezed == geofencesIds
          ? _value.geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsGeofencesIds: freezed == tagsGeofencesIds
          ? _value.tagsGeofencesIds
          : tagsGeofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsAssetsIds: freezed == tagsAssetsIds
          ? _value.tagsAssetsIds
          : tagsAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authAssetsIds: freezed == authAssetsIds
          ? _value.authAssetsIds
          : authAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authUsersIds: freezed == authUsersIds
          ? _value.authUsersIds
          : authUsersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authTagsIds: freezed == authTagsIds
          ? _value.authTagsIds
          : authTagsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as TriggerType,
      geofenceKind: freezed == geofenceKind
          ? _value.geofenceKind
          : geofenceKind // ignore: cast_nullable_to_non_nullable
              as TriggerGeofenceDetectionMode?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      exactHour: freezed == exactHour
          ? _value.exactHour
          : exactHour // ignore: cast_nullable_to_non_nullable
              as String?,
      crontabFormat: freezed == crontabFormat
          ? _value.crontabFormat
          : crontabFormat // ignore: cast_nullable_to_non_nullable
              as String?,
      weekdays: freezed == weekdays
          ? _value.weekdays
          : weekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      isPlainCrontab: freezed == isPlainCrontab
          ? _value.isPlainCrontab
          : isPlainCrontab // ignore: cast_nullable_to_non_nullable
              as bool?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      visualEventEffect: freezed == visualEventEffect
          ? _value.visualEventEffect
          : visualEventEffect // ignore: cast_nullable_to_non_nullable
              as CaseEventEffect?,
      careProtocolId: freezed == careProtocolId
          ? _value.careProtocolId
          : careProtocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      careProtocol: freezed == careProtocol
          ? _value.careProtocol
          : careProtocol // ignore: cast_nullable_to_non_nullable
              as CareProtocol?,
      caseKind: freezed == caseKind
          ? _value.caseKind
          : caseKind // ignore: cast_nullable_to_non_nullable
              as CaseType?,
      caseCommentPattern: freezed == caseCommentPattern
          ? _value.caseCommentPattern
          : caseCommentPattern // ignore: cast_nullable_to_non_nullable
              as CaseCommentPattern?,
      caseCommentPatternValue: freezed == caseCommentPatternValue
          ? _value.caseCommentPatternValue
          : caseCommentPatternValue // ignore: cast_nullable_to_non_nullable
              as String?,
      cooldownTime: freezed == cooldownTime
          ? _value.cooldownTime
          : cooldownTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CareProtocolCopyWith<$Res>? get careProtocol {
    if (_value.careProtocol == null) {
      return null;
    }

    return $CareProtocolCopyWith<$Res>(_value.careProtocol!, (value) {
      return _then(_value.copyWith(careProtocol: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TriggerCopyWith<$Res> implements $TriggerCopyWith<$Res> {
  factory _$$_TriggerCopyWith(
          _$_Trigger value, $Res Function(_$_Trigger) then) =
      __$$_TriggerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String code,
      List<String>? geofencesIds,
      List<String>? tagsGeofencesIds,
      List<String>? assetsIds,
      List<String>? tagsAssetsIds,
      List<String>? parameters,
      List<String>? authAssetsIds,
      List<String>? authUsersIds,
      List<String>? authTagsIds,
      @TriggerTypeConverter() TriggerType kind,
      @TriggerGeofenceDetectionModeOrNullConverter()
      TriggerGeofenceDetectionMode? geofenceKind,
      String? formula,
      String? script,
      String? exactHour,
      String? crontabFormat,
      @WeekdayConverter() List<Weekday>? weekdays,
      bool? isPlainCrontab,
      String? timezoneId,
      int? priority,
      @ColorOrNullConverter() Color? color,
      @CaseEventEffectOrNullConverter() CaseEventEffect? visualEventEffect,
      String? careProtocolId,
      CareProtocol? careProtocol,
      @CaseTypeOrNullConverter() CaseType? caseKind,
      @CaseCommentPatternOrNullConverter()
      CaseCommentPattern? caseCommentPattern,
      String? caseCommentPatternValue,
      @DurationOrNullConverter() Duration? cooldownTime,
      List<Access>? access});

  @override
  $CareProtocolCopyWith<$Res>? get careProtocol;
}

/// @nodoc
class __$$_TriggerCopyWithImpl<$Res>
    extends _$TriggerCopyWithImpl<$Res, _$_Trigger>
    implements _$$_TriggerCopyWith<$Res> {
  __$$_TriggerCopyWithImpl(_$_Trigger _value, $Res Function(_$_Trigger) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? code = null,
    Object? geofencesIds = freezed,
    Object? tagsGeofencesIds = freezed,
    Object? assetsIds = freezed,
    Object? tagsAssetsIds = freezed,
    Object? parameters = freezed,
    Object? authAssetsIds = freezed,
    Object? authUsersIds = freezed,
    Object? authTagsIds = freezed,
    Object? kind = null,
    Object? geofenceKind = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? exactHour = freezed,
    Object? crontabFormat = freezed,
    Object? weekdays = freezed,
    Object? isPlainCrontab = freezed,
    Object? timezoneId = freezed,
    Object? priority = freezed,
    Object? color = freezed,
    Object? visualEventEffect = freezed,
    Object? careProtocolId = freezed,
    Object? careProtocol = freezed,
    Object? caseKind = freezed,
    Object? caseCommentPattern = freezed,
    Object? caseCommentPatternValue = freezed,
    Object? cooldownTime = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_Trigger(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      geofencesIds: freezed == geofencesIds
          ? _value._geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsGeofencesIds: freezed == tagsGeofencesIds
          ? _value._tagsGeofencesIds
          : tagsGeofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsAssetsIds: freezed == tagsAssetsIds
          ? _value._tagsAssetsIds
          : tagsAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      parameters: freezed == parameters
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authAssetsIds: freezed == authAssetsIds
          ? _value._authAssetsIds
          : authAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authUsersIds: freezed == authUsersIds
          ? _value._authUsersIds
          : authUsersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authTagsIds: freezed == authTagsIds
          ? _value._authTagsIds
          : authTagsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as TriggerType,
      geofenceKind: freezed == geofenceKind
          ? _value.geofenceKind
          : geofenceKind // ignore: cast_nullable_to_non_nullable
              as TriggerGeofenceDetectionMode?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      exactHour: freezed == exactHour
          ? _value.exactHour
          : exactHour // ignore: cast_nullable_to_non_nullable
              as String?,
      crontabFormat: freezed == crontabFormat
          ? _value.crontabFormat
          : crontabFormat // ignore: cast_nullable_to_non_nullable
              as String?,
      weekdays: freezed == weekdays
          ? _value._weekdays
          : weekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      isPlainCrontab: freezed == isPlainCrontab
          ? _value.isPlainCrontab
          : isPlainCrontab // ignore: cast_nullable_to_non_nullable
              as bool?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      visualEventEffect: freezed == visualEventEffect
          ? _value.visualEventEffect
          : visualEventEffect // ignore: cast_nullable_to_non_nullable
              as CaseEventEffect?,
      careProtocolId: freezed == careProtocolId
          ? _value.careProtocolId
          : careProtocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      careProtocol: freezed == careProtocol
          ? _value.careProtocol
          : careProtocol // ignore: cast_nullable_to_non_nullable
              as CareProtocol?,
      caseKind: freezed == caseKind
          ? _value.caseKind
          : caseKind // ignore: cast_nullable_to_non_nullable
              as CaseType?,
      caseCommentPattern: freezed == caseCommentPattern
          ? _value.caseCommentPattern
          : caseCommentPattern // ignore: cast_nullable_to_non_nullable
              as CaseCommentPattern?,
      caseCommentPatternValue: freezed == caseCommentPatternValue
          ? _value.caseCommentPatternValue
          : caseCommentPatternValue // ignore: cast_nullable_to_non_nullable
              as String?,
      cooldownTime: freezed == cooldownTime
          ? _value.cooldownTime
          : cooldownTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Trigger implements _Trigger {
  const _$_Trigger(
      {required this.id,
      required this.name,
      required this.code,
      final List<String>? geofencesIds,
      final List<String>? tagsGeofencesIds,
      final List<String>? assetsIds,
      final List<String>? tagsAssetsIds,
      final List<String>? parameters,
      final List<String>? authAssetsIds,
      final List<String>? authUsersIds,
      final List<String>? authTagsIds,
      @TriggerTypeConverter() required this.kind,
      @TriggerGeofenceDetectionModeOrNullConverter() this.geofenceKind,
      this.formula,
      this.script,
      this.exactHour,
      this.crontabFormat,
      @WeekdayConverter() final List<Weekday>? weekdays,
      this.isPlainCrontab,
      this.timezoneId,
      this.priority,
      @ColorOrNullConverter() this.color,
      @CaseEventEffectOrNullConverter() this.visualEventEffect,
      this.careProtocolId,
      this.careProtocol,
      @CaseTypeOrNullConverter() this.caseKind,
      @CaseCommentPatternOrNullConverter() this.caseCommentPattern,
      this.caseCommentPatternValue,
      @DurationOrNullConverter() this.cooldownTime,
      final List<Access>? access})
      : _geofencesIds = geofencesIds,
        _tagsGeofencesIds = tagsGeofencesIds,
        _assetsIds = assetsIds,
        _tagsAssetsIds = tagsAssetsIds,
        _parameters = parameters,
        _authAssetsIds = authAssetsIds,
        _authUsersIds = authUsersIds,
        _authTagsIds = authTagsIds,
        _weekdays = weekdays,
        _access = access;

  factory _$_Trigger.fromJson(Map<String, dynamic> json) =>
      _$$_TriggerFromJson(json);

  /// [id] is the unique identifier of the trigger.
  @override
  final String id;

  /// [name] is the name of the trigger.
  @override
  final String name;

  /// [code] is the code of the trigger.
  @override
  final String code;

  /// [geofencesIds] is the list of ID's of the linked geofences.
  final List<String>? _geofencesIds;

  /// [geofencesIds] is the list of ID's of the linked geofences.
  @override
  List<String>? get geofencesIds {
    final value = _geofencesIds;
    if (value == null) return null;
    if (_geofencesIds is EqualUnmodifiableListView) return _geofencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [tagsGeofencesIds] is the list of ID's of the linked geofences through tags.
  final List<String>? _tagsGeofencesIds;

  /// [tagsGeofencesIds] is the list of ID's of the linked geofences through tags.
  @override
  List<String>? get tagsGeofencesIds {
    final value = _tagsGeofencesIds;
    if (value == null) return null;
    if (_tagsGeofencesIds is EqualUnmodifiableListView)
      return _tagsGeofencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [assetsIds] is the list of ID's of the linked assets.
  final List<String>? _assetsIds;

  /// [assetsIds] is the list of ID's of the linked assets.
  @override
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [tagsAssetsIds] is the list of ID's of the linked assets through tags.
  final List<String>? _tagsAssetsIds;

  /// [tagsAssetsIds] is the list of ID's of the linked assets through tags.
  @override
  List<String>? get tagsAssetsIds {
    final value = _tagsAssetsIds;
    if (value == null) return null;
    if (_tagsAssetsIds is EqualUnmodifiableListView) return _tagsAssetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [parameters] is the list of parameters of the trigger.
  final List<String>? _parameters;

  /// [parameters] is the list of parameters of the trigger.
  @override
  List<String>? get parameters {
    final value = _parameters;
    if (value == null) return null;
    if (_parameters is EqualUnmodifiableListView) return _parameters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [authAssetsIds] is the list of ID's of the assets for authentication.
  final List<String>? _authAssetsIds;

  /// [authAssetsIds] is the list of ID's of the assets for authentication.
  @override
  List<String>? get authAssetsIds {
    final value = _authAssetsIds;
    if (value == null) return null;
    if (_authAssetsIds is EqualUnmodifiableListView) return _authAssetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [authUsersIds] is the list of ID's of the users for authentication.
  final List<String>? _authUsersIds;

  /// [authUsersIds] is the list of ID's of the users for authentication.
  @override
  List<String>? get authUsersIds {
    final value = _authUsersIds;
    if (value == null) return null;
    if (_authUsersIds is EqualUnmodifiableListView) return _authUsersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [authTagsIds] is the list of ID's of the tags for authentication.
  final List<String>? _authTagsIds;

  /// [authTagsIds] is the list of ID's of the tags for authentication.
  @override
  List<String>? get authTagsIds {
    final value = _authTagsIds;
    if (value == null) return null;
    if (_authTagsIds is EqualUnmodifiableListView) return _authTagsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [kind] is the type of the trigger.
  @override
  @TriggerTypeConverter()
  final TriggerType kind;

  /// [geofenceKind] is the type of the geofence.
  /// Only used when [kind] is [TriggerType.geofence].
  @override
  @TriggerGeofenceDetectionModeOrNullConverter()
  final TriggerGeofenceDetectionMode? geofenceKind;

  /// [formula] is the formula of the trigger. Only used when [kind] is [TriggerType.formula].
  /// The formula is a script that returns a boolean value (true or false).
  /// Also, the formula should be written in LCL (Layrz Compute Language)
  @override
  final String? formula;

  /// [script] is the script of the trigger. Only used when [kind] is [TriggerType.script].
  /// The script is a script that returns a boolean value (true or false).
  /// Also, the script should be written in Python (Version 3.8)
  @override
  final String? script;

  /// [exactHour] is the exact hour of the trigger. Only used when [kind] is [TriggerType.exactTime].
  @override
  final String? exactHour;

  /// [crontabFormat] is the crontab format of the trigger. Only used when [kind] is [TriggerType.exactTime].
  /// The crontab format is a string that represents the exact time of the trigger.
  @override
  final String? crontabFormat;

  /// [weekdays] is the list of weekdays of the trigger. Only used when [kind] is [TriggerType.exactTime].
  /// The weekdays are represented by the [Weekday] enum.
  final List<Weekday>? _weekdays;

  /// [weekdays] is the list of weekdays of the trigger. Only used when [kind] is [TriggerType.exactTime].
  /// The weekdays are represented by the [Weekday] enum.
  @override
  @WeekdayConverter()
  List<Weekday>? get weekdays {
    final value = _weekdays;
    if (value == null) return null;
    if (_weekdays is EqualUnmodifiableListView) return _weekdays;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [isPlainCrontab] is a boolean that indicates if the crontab format is plain or not.
  /// Only used when [kind] is [TriggerType.exactTime].
  @override
  final bool? isPlainCrontab;

  /// [timezoneId] is the ID of the timezone of the trigger.
  /// Only used when [kind] is [TriggerType.exactTime].
  @override
  final String? timezoneId;

  /// [priority] is the priority of the trigger.
  @override
  final int? priority;

  /// [color] is the color of the trigger.
  @override
  @ColorOrNullConverter()
  final Color? color;

  /// [visualEventEffect] is the visual effect of the trigger.
  @override
  @CaseEventEffectOrNullConverter()
  final CaseEventEffect? visualEventEffect;

  /// [careProtocolId] is the ID of the care protocol to execute when the trigger is activated.
  @override
  final String? careProtocolId;

  /// [careProtocol] is the care protocol to execute when the trigger is activated.
  @override
  final CareProtocol? careProtocol;

  /// [caseKind] represents the type of case to generate when the trigger is activated.
  /// This field is required for `kind=[TriggerType.casesChanges]`.
  @override
  @CaseTypeOrNullConverter()
  final CaseType? caseKind;

  /// [caseCommentPattern] represents the type of comment pattern to detect changes on cases to perform
  /// actions. This field is required for `kind=[TriggerType.casesChanges]` and
  /// `caseKind=[CaseType.onCommentPattern]`.
  @override
  @CaseCommentPatternOrNullConverter()
  final CaseCommentPattern? caseCommentPattern;

  /// [caseCommentPatternValue] represents the value of the comment pattern to detect changes on cases to perform
  /// actions. This field is required for `kind=[TriggerType.casesChanges]` and
  /// `caseKind=[CaseType.onCommentPattern]`.
  @override
  final String? caseCommentPatternValue;

  /// [cooldownTime] represents the cooldown time of the trigger.
  @override
  @DurationOrNullConverter()
  final Duration? cooldownTime;

  /// [access] represents the list of accesses to the trigger.
  final List<Access>? _access;

  /// [access] represents the list of accesses to the trigger.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Trigger(id: $id, name: $name, code: $code, geofencesIds: $geofencesIds, tagsGeofencesIds: $tagsGeofencesIds, assetsIds: $assetsIds, tagsAssetsIds: $tagsAssetsIds, parameters: $parameters, authAssetsIds: $authAssetsIds, authUsersIds: $authUsersIds, authTagsIds: $authTagsIds, kind: $kind, geofenceKind: $geofenceKind, formula: $formula, script: $script, exactHour: $exactHour, crontabFormat: $crontabFormat, weekdays: $weekdays, isPlainCrontab: $isPlainCrontab, timezoneId: $timezoneId, priority: $priority, color: $color, visualEventEffect: $visualEventEffect, careProtocolId: $careProtocolId, careProtocol: $careProtocol, caseKind: $caseKind, caseCommentPattern: $caseCommentPattern, caseCommentPatternValue: $caseCommentPatternValue, cooldownTime: $cooldownTime, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Trigger &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.code, code) || other.code == code) &&
            const DeepCollectionEquality()
                .equals(other._geofencesIds, _geofencesIds) &&
            const DeepCollectionEquality()
                .equals(other._tagsGeofencesIds, _tagsGeofencesIds) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds) &&
            const DeepCollectionEquality()
                .equals(other._tagsAssetsIds, _tagsAssetsIds) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            const DeepCollectionEquality()
                .equals(other._authAssetsIds, _authAssetsIds) &&
            const DeepCollectionEquality()
                .equals(other._authUsersIds, _authUsersIds) &&
            const DeepCollectionEquality()
                .equals(other._authTagsIds, _authTagsIds) &&
            (identical(other.kind, kind) || other.kind == kind) &&
            (identical(other.geofenceKind, geofenceKind) ||
                other.geofenceKind == geofenceKind) &&
            (identical(other.formula, formula) || other.formula == formula) &&
            (identical(other.script, script) || other.script == script) &&
            (identical(other.exactHour, exactHour) ||
                other.exactHour == exactHour) &&
            (identical(other.crontabFormat, crontabFormat) ||
                other.crontabFormat == crontabFormat) &&
            const DeepCollectionEquality().equals(other._weekdays, _weekdays) &&
            (identical(other.isPlainCrontab, isPlainCrontab) ||
                other.isPlainCrontab == isPlainCrontab) &&
            (identical(other.timezoneId, timezoneId) ||
                other.timezoneId == timezoneId) &&
            (identical(other.priority, priority) ||
                other.priority == priority) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.visualEventEffect, visualEventEffect) ||
                other.visualEventEffect == visualEventEffect) &&
            (identical(other.careProtocolId, careProtocolId) ||
                other.careProtocolId == careProtocolId) &&
            (identical(other.careProtocol, careProtocol) ||
                other.careProtocol == careProtocol) &&
            (identical(other.caseKind, caseKind) ||
                other.caseKind == caseKind) &&
            (identical(other.caseCommentPattern, caseCommentPattern) ||
                other.caseCommentPattern == caseCommentPattern) &&
            (identical(
                    other.caseCommentPatternValue, caseCommentPatternValue) ||
                other.caseCommentPatternValue == caseCommentPatternValue) &&
            (identical(other.cooldownTime, cooldownTime) ||
                other.cooldownTime == cooldownTime) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        code,
        const DeepCollectionEquality().hash(_geofencesIds),
        const DeepCollectionEquality().hash(_tagsGeofencesIds),
        const DeepCollectionEquality().hash(_assetsIds),
        const DeepCollectionEquality().hash(_tagsAssetsIds),
        const DeepCollectionEquality().hash(_parameters),
        const DeepCollectionEquality().hash(_authAssetsIds),
        const DeepCollectionEquality().hash(_authUsersIds),
        const DeepCollectionEquality().hash(_authTagsIds),
        kind,
        geofenceKind,
        formula,
        script,
        exactHour,
        crontabFormat,
        const DeepCollectionEquality().hash(_weekdays),
        isPlainCrontab,
        timezoneId,
        priority,
        color,
        visualEventEffect,
        careProtocolId,
        careProtocol,
        caseKind,
        caseCommentPattern,
        caseCommentPatternValue,
        cooldownTime,
        const DeepCollectionEquality().hash(_access)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TriggerCopyWith<_$_Trigger> get copyWith =>
      __$$_TriggerCopyWithImpl<_$_Trigger>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TriggerToJson(
      this,
    );
  }
}

abstract class _Trigger implements Trigger {
  const factory _Trigger(
      {required final String id,
      required final String name,
      required final String code,
      final List<String>? geofencesIds,
      final List<String>? tagsGeofencesIds,
      final List<String>? assetsIds,
      final List<String>? tagsAssetsIds,
      final List<String>? parameters,
      final List<String>? authAssetsIds,
      final List<String>? authUsersIds,
      final List<String>? authTagsIds,
      @TriggerTypeConverter() required final TriggerType kind,
      @TriggerGeofenceDetectionModeOrNullConverter()
      final TriggerGeofenceDetectionMode? geofenceKind,
      final String? formula,
      final String? script,
      final String? exactHour,
      final String? crontabFormat,
      @WeekdayConverter() final List<Weekday>? weekdays,
      final bool? isPlainCrontab,
      final String? timezoneId,
      final int? priority,
      @ColorOrNullConverter() final Color? color,
      @CaseEventEffectOrNullConverter()
      final CaseEventEffect? visualEventEffect,
      final String? careProtocolId,
      final CareProtocol? careProtocol,
      @CaseTypeOrNullConverter() final CaseType? caseKind,
      @CaseCommentPatternOrNullConverter()
      final CaseCommentPattern? caseCommentPattern,
      final String? caseCommentPatternValue,
      @DurationOrNullConverter() final Duration? cooldownTime,
      final List<Access>? access}) = _$_Trigger;

  factory _Trigger.fromJson(Map<String, dynamic> json) = _$_Trigger.fromJson;

  @override

  /// [id] is the unique identifier of the trigger.
  String get id;
  @override

  /// [name] is the name of the trigger.
  String get name;
  @override

  /// [code] is the code of the trigger.
  String get code;
  @override

  /// [geofencesIds] is the list of ID's of the linked geofences.
  List<String>? get geofencesIds;
  @override

  /// [tagsGeofencesIds] is the list of ID's of the linked geofences through tags.
  List<String>? get tagsGeofencesIds;
  @override

  /// [assetsIds] is the list of ID's of the linked assets.
  List<String>? get assetsIds;
  @override

  /// [tagsAssetsIds] is the list of ID's of the linked assets through tags.
  List<String>? get tagsAssetsIds;
  @override

  /// [parameters] is the list of parameters of the trigger.
  List<String>? get parameters;
  @override

  /// [authAssetsIds] is the list of ID's of the assets for authentication.
  List<String>? get authAssetsIds;
  @override

  /// [authUsersIds] is the list of ID's of the users for authentication.
  List<String>? get authUsersIds;
  @override

  /// [authTagsIds] is the list of ID's of the tags for authentication.
  List<String>? get authTagsIds;
  @override

  /// [kind] is the type of the trigger.
  @TriggerTypeConverter()
  TriggerType get kind;
  @override

  /// [geofenceKind] is the type of the geofence.
  /// Only used when [kind] is [TriggerType.geofence].
  @TriggerGeofenceDetectionModeOrNullConverter()
  TriggerGeofenceDetectionMode? get geofenceKind;
  @override

  /// [formula] is the formula of the trigger. Only used when [kind] is [TriggerType.formula].
  /// The formula is a script that returns a boolean value (true or false).
  /// Also, the formula should be written in LCL (Layrz Compute Language)
  String? get formula;
  @override

  /// [script] is the script of the trigger. Only used when [kind] is [TriggerType.script].
  /// The script is a script that returns a boolean value (true or false).
  /// Also, the script should be written in Python (Version 3.8)
  String? get script;
  @override

  /// [exactHour] is the exact hour of the trigger. Only used when [kind] is [TriggerType.exactTime].
  String? get exactHour;
  @override

  /// [crontabFormat] is the crontab format of the trigger. Only used when [kind] is [TriggerType.exactTime].
  /// The crontab format is a string that represents the exact time of the trigger.
  String? get crontabFormat;
  @override

  /// [weekdays] is the list of weekdays of the trigger. Only used when [kind] is [TriggerType.exactTime].
  /// The weekdays are represented by the [Weekday] enum.
  @WeekdayConverter()
  List<Weekday>? get weekdays;
  @override

  /// [isPlainCrontab] is a boolean that indicates if the crontab format is plain or not.
  /// Only used when [kind] is [TriggerType.exactTime].
  bool? get isPlainCrontab;
  @override

  /// [timezoneId] is the ID of the timezone of the trigger.
  /// Only used when [kind] is [TriggerType.exactTime].
  String? get timezoneId;
  @override

  /// [priority] is the priority of the trigger.
  int? get priority;
  @override

  /// [color] is the color of the trigger.
  @ColorOrNullConverter()
  Color? get color;
  @override

  /// [visualEventEffect] is the visual effect of the trigger.
  @CaseEventEffectOrNullConverter()
  CaseEventEffect? get visualEventEffect;
  @override

  /// [careProtocolId] is the ID of the care protocol to execute when the trigger is activated.
  String? get careProtocolId;
  @override

  /// [careProtocol] is the care protocol to execute when the trigger is activated.
  CareProtocol? get careProtocol;
  @override

  /// [caseKind] represents the type of case to generate when the trigger is activated.
  /// This field is required for `kind=[TriggerType.casesChanges]`.
  @CaseTypeOrNullConverter()
  CaseType? get caseKind;
  @override

  /// [caseCommentPattern] represents the type of comment pattern to detect changes on cases to perform
  /// actions. This field is required for `kind=[TriggerType.casesChanges]` and
  /// `caseKind=[CaseType.onCommentPattern]`.
  @CaseCommentPatternOrNullConverter()
  CaseCommentPattern? get caseCommentPattern;
  @override

  /// [caseCommentPatternValue] represents the value of the comment pattern to detect changes on cases to perform
  /// actions. This field is required for `kind=[TriggerType.casesChanges]` and
  /// `caseKind=[CaseType.onCommentPattern]`.
  String? get caseCommentPatternValue;
  @override

  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  Duration? get cooldownTime;
  @override

  /// [access] represents the list of accesses to the trigger.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_TriggerCopyWith<_$_Trigger> get copyWith =>
      throw _privateConstructorUsedError;
}

TriggerActivation _$TriggerActivationFromJson(Map<String, dynamic> json) {
  return _TriggerActivation.fromJson(json);
}

/// @nodoc
mixin _$TriggerActivation {
  /// ID of the trigger activation entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// Is the asset object
  Asset get asset => throw _privateConstructorUsedError;

  /// [trigger] represents the trigger object.
  Trigger? get trigger => throw _privateConstructorUsedError;

  /// [position] represents the position object.
  TelemetryPosition? get position => throw _privateConstructorUsedError;

  /// Is the date of the activation
  @TimestampConverter()
  DateTime get date => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TriggerActivationCopyWith<TriggerActivation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TriggerActivationCopyWith<$Res> {
  factory $TriggerActivationCopyWith(
          TriggerActivation value, $Res Function(TriggerActivation) then) =
      _$TriggerActivationCopyWithImpl<$Res, TriggerActivation>;
  @useResult
  $Res call(
      {String id,
      Asset asset,
      Trigger? trigger,
      TelemetryPosition? position,
      @TimestampConverter() DateTime date});

  $AssetCopyWith<$Res> get asset;
  $TriggerCopyWith<$Res>? get trigger;
  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class _$TriggerActivationCopyWithImpl<$Res, $Val extends TriggerActivation>
    implements $TriggerActivationCopyWith<$Res> {
  _$TriggerActivationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? asset = null,
    Object? trigger = freezed,
    Object? position = freezed,
    Object? date = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      asset: null == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset,
      trigger: freezed == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res> get asset {
    return $AssetCopyWith<$Res>(_value.asset, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TriggerCopyWith<$Res>? get trigger {
    if (_value.trigger == null) {
      return null;
    }

    return $TriggerCopyWith<$Res>(_value.trigger!, (value) {
      return _then(_value.copyWith(trigger: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TelemetryPositionCopyWith<$Res>? get position {
    if (_value.position == null) {
      return null;
    }

    return $TelemetryPositionCopyWith<$Res>(_value.position!, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TriggerActivationCopyWith<$Res>
    implements $TriggerActivationCopyWith<$Res> {
  factory _$$_TriggerActivationCopyWith(_$_TriggerActivation value,
          $Res Function(_$_TriggerActivation) then) =
      __$$_TriggerActivationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      Asset asset,
      Trigger? trigger,
      TelemetryPosition? position,
      @TimestampConverter() DateTime date});

  @override
  $AssetCopyWith<$Res> get asset;
  @override
  $TriggerCopyWith<$Res>? get trigger;
  @override
  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class __$$_TriggerActivationCopyWithImpl<$Res>
    extends _$TriggerActivationCopyWithImpl<$Res, _$_TriggerActivation>
    implements _$$_TriggerActivationCopyWith<$Res> {
  __$$_TriggerActivationCopyWithImpl(
      _$_TriggerActivation _value, $Res Function(_$_TriggerActivation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? asset = null,
    Object? trigger = freezed,
    Object? position = freezed,
    Object? date = null,
  }) {
    return _then(_$_TriggerActivation(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      asset: null == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset,
      trigger: freezed == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      date: null == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TriggerActivation implements _TriggerActivation {
  const _$_TriggerActivation(
      {required this.id,
      required this.asset,
      this.trigger,
      this.position,
      @TimestampConverter() required this.date});

  factory _$_TriggerActivation.fromJson(Map<String, dynamic> json) =>
      _$$_TriggerActivationFromJson(json);

  /// ID of the trigger activation entity. This ID is unique.
  @override
  final String id;

  /// Is the asset object
  @override
  final Asset asset;

  /// [trigger] represents the trigger object.
  @override
  final Trigger? trigger;

  /// [position] represents the position object.
  @override
  final TelemetryPosition? position;

  /// Is the date of the activation
  @override
  @TimestampConverter()
  final DateTime date;

  @override
  String toString() {
    return 'TriggerActivation(id: $id, asset: $asset, trigger: $trigger, position: $position, date: $date)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TriggerActivation &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.trigger, trigger) || other.trigger == trigger) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.date, date) || other.date == date));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, asset, trigger, position, date);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TriggerActivationCopyWith<_$_TriggerActivation> get copyWith =>
      __$$_TriggerActivationCopyWithImpl<_$_TriggerActivation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TriggerActivationToJson(
      this,
    );
  }
}

abstract class _TriggerActivation implements TriggerActivation {
  const factory _TriggerActivation(
          {required final String id,
          required final Asset asset,
          final Trigger? trigger,
          final TelemetryPosition? position,
          @TimestampConverter() required final DateTime date}) =
      _$_TriggerActivation;

  factory _TriggerActivation.fromJson(Map<String, dynamic> json) =
      _$_TriggerActivation.fromJson;

  @override

  /// ID of the trigger activation entity. This ID is unique.
  String get id;
  @override

  /// Is the asset object
  Asset get asset;
  @override

  /// [trigger] represents the trigger object.
  Trigger? get trigger;
  @override

  /// [position] represents the position object.
  TelemetryPosition? get position;
  @override

  /// Is the date of the activation
  @TimestampConverter()
  DateTime get date;
  @override
  @JsonKey(ignore: true)
  _$$_TriggerActivationCopyWith<_$_TriggerActivation> get copyWith =>
      throw _privateConstructorUsedError;
}

TriggerInput _$TriggerInputFromJson(Map<String, dynamic> json) {
  return _TriggerInput.fromJson(json);
}

/// @nodoc
mixin _$TriggerInput {
  /// ID of the trigger entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the trigger entity. This ID is unique.
  set id(String? value) => throw _privateConstructorUsedError;

  /// Name of the trigger.
  String? get name => throw _privateConstructorUsedError;

  /// Name of the trigger.
  set name(String? value) => throw _privateConstructorUsedError;

  /// Code/Identifier of the trigger.
  String? get code => throw _privateConstructorUsedError;

  /// Code/Identifier of the trigger.
  set code(String? value) => throw _privateConstructorUsedError;

  /// List of ID's of the linked geofences
  List<String>? get geofencesIds => throw _privateConstructorUsedError;

  /// List of ID's of the linked geofences
  set geofencesIds(List<String>? value) => throw _privateConstructorUsedError;

  /// List of ID's of the linked geofences through tags
  List<String>? get tagsGeofencesIds => throw _privateConstructorUsedError;

  /// List of ID's of the linked geofences through tags
  set tagsGeofencesIds(List<String>? value) =>
      throw _privateConstructorUsedError;

  ///List of ID's of the linked assets
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  ///List of ID's of the linked assets
  set assetsIds(List<String>? value) => throw _privateConstructorUsedError;

  /// List of ID's of the linked assets through tags
  List<String>? get tagsAssetsIds => throw _privateConstructorUsedError;

  /// List of ID's of the linked assets through tags
  set tagsAssetsIds(List<String>? value) => throw _privateConstructorUsedError;

  /// List of parameters to consider in the authentication procedure
  List<String>? get parameters => throw _privateConstructorUsedError;

  /// List of parameters to consider in the authentication procedure
  set parameters(List<String>? value) => throw _privateConstructorUsedError;

  /// List of ID's of the assets for authentication
  List<String>? get authAssetsIds => throw _privateConstructorUsedError;

  /// List of ID's of the assets for authentication
  set authAssetsIds(List<String>? value) => throw _privateConstructorUsedError;

  /// List of ID's of the users for authentication
  List<String>? get authUsersIds => throw _privateConstructorUsedError;

  /// List of ID's of the users for authentication
  set authUsersIds(List<String>? value) => throw _privateConstructorUsedError;

  /// List of ID's of the users or assets through tags for authentication
  List<String>? get authTagsIds => throw _privateConstructorUsedError;

  /// List of ID's of the users or assets through tags for authentication
  set authTagsIds(List<String>? value) => throw _privateConstructorUsedError;

  /// Mode of activation.
  @TriggerTypeOrNullConverter()
  TriggerType? get kind => throw _privateConstructorUsedError;

  /// Mode of activation.
  @TriggerTypeOrNullConverter()
  set kind(TriggerType? value) => throw _privateConstructorUsedError;

  /// Mode of activation / disparator for [TriggerType.presenceInGeofences].
  @TriggerGeofenceDetectionModeOrNullConverter()
  TriggerGeofenceDetectionMode? get geofenceKind =>
      throw _privateConstructorUsedError;

  /// Mode of activation / disparator for [TriggerType.presenceInGeofences].
  @TriggerGeofenceDetectionModeOrNullConverter()
  set geofenceKind(TriggerGeofenceDetectionMode? value) =>
      throw _privateConstructorUsedError;

  /// Layrz Language formula
  String? get formula => throw _privateConstructorUsedError;

  /// Layrz Language formula
  set formula(String? value) => throw _privateConstructorUsedError;

  /// Script to execute
  String? get script => throw _privateConstructorUsedError;

  /// Script to execute
  set script(String? value) => throw _privateConstructorUsedError;

  /// Mode of activation / disparator for [TriggerType.exactTime].
  String? get exactHour => throw _privateConstructorUsedError;

  /// Mode of activation / disparator for [TriggerType.exactTime].
  set exactHour(String? value) => throw _privateConstructorUsedError;

  /// Crontab structure
  String? get crontabFormat => throw _privateConstructorUsedError;

  /// Crontab structure
  set crontabFormat(String? value) => throw _privateConstructorUsedError;

  /// Indicates the days of the week what will execute the trigger.
  @WeekdayConverter()
  List<Weekday>? get weekdays => throw _privateConstructorUsedError;

  /// Indicates the days of the week what will execute the trigger.
  @WeekdayConverter()
  set weekdays(List<Weekday>? value) => throw _privateConstructorUsedError;

  ///Indicates if the EXACTIME is in Crontab format or assisted format
  bool? get isPlainCrontab => throw _privateConstructorUsedError;

  ///Indicates if the EXACTIME is in Crontab format or assisted format
  set isPlainCrontab(bool? value) => throw _privateConstructorUsedError;

  /// Timezone associated to disparator [TriggerType.exactTime].
  String? get timezoneId => throw _privateConstructorUsedError;

  /// Timezone associated to disparator [TriggerType.exactTime].
  set timezoneId(String? value) => throw _privateConstructorUsedError;

  /// Priority level for the trigger generated cases
  int? get priority => throw _privateConstructorUsedError;

  /// Priority level for the trigger generated cases
  set priority(int? value) => throw _privateConstructorUsedError;

  /// Color of the trigger case
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  /// Color of the trigger case
  @ColorOrNullConverter()
  set color(Color? value) => throw _privateConstructorUsedError;

  /// Visual event effects to use in Monitor Center events received.
  @CaseEventEffectOrNullConverter()
  CaseEventEffect? get visualEventEffect => throw _privateConstructorUsedError;

  /// Visual event effects to use in Monitor Center events received.
  @CaseEventEffectOrNullConverter()
  set visualEventEffect(CaseEventEffect? value) =>
      throw _privateConstructorUsedError;

  /// Care protocol linked to the trigger. This is the rules to follow in the case reception. It can be null.
  String? get careProtocolId => throw _privateConstructorUsedError;

  /// Care protocol linked to the trigger. This is the rules to follow in the case reception. It can be null.
  set careProtocolId(String? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TriggerInputCopyWith<TriggerInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TriggerInputCopyWith<$Res> {
  factory $TriggerInputCopyWith(
          TriggerInput value, $Res Function(TriggerInput) then) =
      _$TriggerInputCopyWithImpl<$Res, TriggerInput>;
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? code,
      List<String>? geofencesIds,
      List<String>? tagsGeofencesIds,
      List<String>? assetsIds,
      List<String>? tagsAssetsIds,
      List<String>? parameters,
      List<String>? authAssetsIds,
      List<String>? authUsersIds,
      List<String>? authTagsIds,
      @TriggerTypeOrNullConverter() TriggerType? kind,
      @TriggerGeofenceDetectionModeOrNullConverter()
      TriggerGeofenceDetectionMode? geofenceKind,
      String? formula,
      String? script,
      String? exactHour,
      String? crontabFormat,
      @WeekdayConverter() List<Weekday>? weekdays,
      bool? isPlainCrontab,
      String? timezoneId,
      int? priority,
      @ColorOrNullConverter() Color? color,
      @CaseEventEffectOrNullConverter() CaseEventEffect? visualEventEffect,
      String? careProtocolId});
}

/// @nodoc
class _$TriggerInputCopyWithImpl<$Res, $Val extends TriggerInput>
    implements $TriggerInputCopyWith<$Res> {
  _$TriggerInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? code = freezed,
    Object? geofencesIds = freezed,
    Object? tagsGeofencesIds = freezed,
    Object? assetsIds = freezed,
    Object? tagsAssetsIds = freezed,
    Object? parameters = freezed,
    Object? authAssetsIds = freezed,
    Object? authUsersIds = freezed,
    Object? authTagsIds = freezed,
    Object? kind = freezed,
    Object? geofenceKind = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? exactHour = freezed,
    Object? crontabFormat = freezed,
    Object? weekdays = freezed,
    Object? isPlainCrontab = freezed,
    Object? timezoneId = freezed,
    Object? priority = freezed,
    Object? color = freezed,
    Object? visualEventEffect = freezed,
    Object? careProtocolId = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      geofencesIds: freezed == geofencesIds
          ? _value.geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsGeofencesIds: freezed == tagsGeofencesIds
          ? _value.tagsGeofencesIds
          : tagsGeofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsAssetsIds: freezed == tagsAssetsIds
          ? _value.tagsAssetsIds
          : tagsAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authAssetsIds: freezed == authAssetsIds
          ? _value.authAssetsIds
          : authAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authUsersIds: freezed == authUsersIds
          ? _value.authUsersIds
          : authUsersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authTagsIds: freezed == authTagsIds
          ? _value.authTagsIds
          : authTagsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as TriggerType?,
      geofenceKind: freezed == geofenceKind
          ? _value.geofenceKind
          : geofenceKind // ignore: cast_nullable_to_non_nullable
              as TriggerGeofenceDetectionMode?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      exactHour: freezed == exactHour
          ? _value.exactHour
          : exactHour // ignore: cast_nullable_to_non_nullable
              as String?,
      crontabFormat: freezed == crontabFormat
          ? _value.crontabFormat
          : crontabFormat // ignore: cast_nullable_to_non_nullable
              as String?,
      weekdays: freezed == weekdays
          ? _value.weekdays
          : weekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      isPlainCrontab: freezed == isPlainCrontab
          ? _value.isPlainCrontab
          : isPlainCrontab // ignore: cast_nullable_to_non_nullable
              as bool?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      visualEventEffect: freezed == visualEventEffect
          ? _value.visualEventEffect
          : visualEventEffect // ignore: cast_nullable_to_non_nullable
              as CaseEventEffect?,
      careProtocolId: freezed == careProtocolId
          ? _value.careProtocolId
          : careProtocolId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TriggerInputCopyWith<$Res>
    implements $TriggerInputCopyWith<$Res> {
  factory _$$_TriggerInputCopyWith(
          _$_TriggerInput value, $Res Function(_$_TriggerInput) then) =
      __$$_TriggerInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? code,
      List<String>? geofencesIds,
      List<String>? tagsGeofencesIds,
      List<String>? assetsIds,
      List<String>? tagsAssetsIds,
      List<String>? parameters,
      List<String>? authAssetsIds,
      List<String>? authUsersIds,
      List<String>? authTagsIds,
      @TriggerTypeOrNullConverter() TriggerType? kind,
      @TriggerGeofenceDetectionModeOrNullConverter()
      TriggerGeofenceDetectionMode? geofenceKind,
      String? formula,
      String? script,
      String? exactHour,
      String? crontabFormat,
      @WeekdayConverter() List<Weekday>? weekdays,
      bool? isPlainCrontab,
      String? timezoneId,
      int? priority,
      @ColorOrNullConverter() Color? color,
      @CaseEventEffectOrNullConverter() CaseEventEffect? visualEventEffect,
      String? careProtocolId});
}

/// @nodoc
class __$$_TriggerInputCopyWithImpl<$Res>
    extends _$TriggerInputCopyWithImpl<$Res, _$_TriggerInput>
    implements _$$_TriggerInputCopyWith<$Res> {
  __$$_TriggerInputCopyWithImpl(
      _$_TriggerInput _value, $Res Function(_$_TriggerInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? code = freezed,
    Object? geofencesIds = freezed,
    Object? tagsGeofencesIds = freezed,
    Object? assetsIds = freezed,
    Object? tagsAssetsIds = freezed,
    Object? parameters = freezed,
    Object? authAssetsIds = freezed,
    Object? authUsersIds = freezed,
    Object? authTagsIds = freezed,
    Object? kind = freezed,
    Object? geofenceKind = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? exactHour = freezed,
    Object? crontabFormat = freezed,
    Object? weekdays = freezed,
    Object? isPlainCrontab = freezed,
    Object? timezoneId = freezed,
    Object? priority = freezed,
    Object? color = freezed,
    Object? visualEventEffect = freezed,
    Object? careProtocolId = freezed,
  }) {
    return _then(_$_TriggerInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String?,
      geofencesIds: freezed == geofencesIds
          ? _value.geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsGeofencesIds: freezed == tagsGeofencesIds
          ? _value.tagsGeofencesIds
          : tagsGeofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      tagsAssetsIds: freezed == tagsAssetsIds
          ? _value.tagsAssetsIds
          : tagsAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      parameters: freezed == parameters
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authAssetsIds: freezed == authAssetsIds
          ? _value.authAssetsIds
          : authAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authUsersIds: freezed == authUsersIds
          ? _value.authUsersIds
          : authUsersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      authTagsIds: freezed == authTagsIds
          ? _value.authTagsIds
          : authTagsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as TriggerType?,
      geofenceKind: freezed == geofenceKind
          ? _value.geofenceKind
          : geofenceKind // ignore: cast_nullable_to_non_nullable
              as TriggerGeofenceDetectionMode?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      exactHour: freezed == exactHour
          ? _value.exactHour
          : exactHour // ignore: cast_nullable_to_non_nullable
              as String?,
      crontabFormat: freezed == crontabFormat
          ? _value.crontabFormat
          : crontabFormat // ignore: cast_nullable_to_non_nullable
              as String?,
      weekdays: freezed == weekdays
          ? _value.weekdays
          : weekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      isPlainCrontab: freezed == isPlainCrontab
          ? _value.isPlainCrontab
          : isPlainCrontab // ignore: cast_nullable_to_non_nullable
              as bool?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      priority: freezed == priority
          ? _value.priority
          : priority // ignore: cast_nullable_to_non_nullable
              as int?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      visualEventEffect: freezed == visualEventEffect
          ? _value.visualEventEffect
          : visualEventEffect // ignore: cast_nullable_to_non_nullable
              as CaseEventEffect?,
      careProtocolId: freezed == careProtocolId
          ? _value.careProtocolId
          : careProtocolId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TriggerInput implements _TriggerInput {
  _$_TriggerInput(
      {this.id,
      this.name,
      this.code,
      this.geofencesIds = const [],
      this.tagsGeofencesIds = const [],
      this.assetsIds = const [],
      this.tagsAssetsIds = const [],
      this.parameters = const [],
      this.authAssetsIds = const [],
      this.authUsersIds = const [],
      this.authTagsIds = const [],
      @TriggerTypeOrNullConverter() this.kind,
      @TriggerGeofenceDetectionModeOrNullConverter() this.geofenceKind,
      this.formula,
      this.script,
      this.exactHour,
      this.crontabFormat,
      @WeekdayConverter() this.weekdays = const [
        Weekday.monday,
        Weekday.tuesday,
        Weekday.wednesday,
        Weekday.thursday,
        Weekday.friday,
        Weekday.saturday,
        Weekday.sunday
      ],
      this.isPlainCrontab = false,
      this.timezoneId,
      this.priority,
      @ColorOrNullConverter() this.color,
      @CaseEventEffectOrNullConverter() this.visualEventEffect,
      this.careProtocolId});

  factory _$_TriggerInput.fromJson(Map<String, dynamic> json) =>
      _$$_TriggerInputFromJson(json);

  /// ID of the trigger entity. This ID is unique.
  @override
  String? id;

  /// Name of the trigger.
  @override
  String? name;

  /// Code/Identifier of the trigger.
  @override
  String? code;

  /// List of ID's of the linked geofences
  @override
  @JsonKey()
  List<String>? geofencesIds;

  /// List of ID's of the linked geofences through tags
  @override
  @JsonKey()
  List<String>? tagsGeofencesIds;

  ///List of ID's of the linked assets
  @override
  @JsonKey()
  List<String>? assetsIds;

  /// List of ID's of the linked assets through tags
  @override
  @JsonKey()
  List<String>? tagsAssetsIds;

  /// List of parameters to consider in the authentication procedure
  @override
  @JsonKey()
  List<String>? parameters;

  /// List of ID's of the assets for authentication
  @override
  @JsonKey()
  List<String>? authAssetsIds;

  /// List of ID's of the users for authentication
  @override
  @JsonKey()
  List<String>? authUsersIds;

  /// List of ID's of the users or assets through tags for authentication
  @override
  @JsonKey()
  List<String>? authTagsIds;

  /// Mode of activation.
  @override
  @TriggerTypeOrNullConverter()
  TriggerType? kind;

  /// Mode of activation / disparator for [TriggerType.presenceInGeofences].
  @override
  @TriggerGeofenceDetectionModeOrNullConverter()
  TriggerGeofenceDetectionMode? geofenceKind;

  /// Layrz Language formula
  @override
  String? formula;

  /// Script to execute
  @override
  String? script;

  /// Mode of activation / disparator for [TriggerType.exactTime].
  @override
  String? exactHour;

  /// Crontab structure
  @override
  String? crontabFormat;

  /// Indicates the days of the week what will execute the trigger.
  @override
  @JsonKey()
  @WeekdayConverter()
  List<Weekday>? weekdays;

  ///Indicates if the EXACTIME is in Crontab format or assisted format
  @override
  @JsonKey()
  bool? isPlainCrontab;

  /// Timezone associated to disparator [TriggerType.exactTime].
  @override
  String? timezoneId;

  /// Priority level for the trigger generated cases
  @override
  int? priority;

  /// Color of the trigger case
  @override
  @ColorOrNullConverter()
  Color? color;

  /// Visual event effects to use in Monitor Center events received.
  @override
  @CaseEventEffectOrNullConverter()
  CaseEventEffect? visualEventEffect;

  /// Care protocol linked to the trigger. This is the rules to follow in the case reception. It can be null.
  @override
  String? careProtocolId;

  @override
  String toString() {
    return 'TriggerInput(id: $id, name: $name, code: $code, geofencesIds: $geofencesIds, tagsGeofencesIds: $tagsGeofencesIds, assetsIds: $assetsIds, tagsAssetsIds: $tagsAssetsIds, parameters: $parameters, authAssetsIds: $authAssetsIds, authUsersIds: $authUsersIds, authTagsIds: $authTagsIds, kind: $kind, geofenceKind: $geofenceKind, formula: $formula, script: $script, exactHour: $exactHour, crontabFormat: $crontabFormat, weekdays: $weekdays, isPlainCrontab: $isPlainCrontab, timezoneId: $timezoneId, priority: $priority, color: $color, visualEventEffect: $visualEventEffect, careProtocolId: $careProtocolId)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TriggerInputCopyWith<_$_TriggerInput> get copyWith =>
      __$$_TriggerInputCopyWithImpl<_$_TriggerInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TriggerInputToJson(
      this,
    );
  }
}

abstract class _TriggerInput implements TriggerInput {
  factory _TriggerInput(
      {String? id,
      String? name,
      String? code,
      List<String>? geofencesIds,
      List<String>? tagsGeofencesIds,
      List<String>? assetsIds,
      List<String>? tagsAssetsIds,
      List<String>? parameters,
      List<String>? authAssetsIds,
      List<String>? authUsersIds,
      List<String>? authTagsIds,
      @TriggerTypeOrNullConverter() TriggerType? kind,
      @TriggerGeofenceDetectionModeOrNullConverter()
      TriggerGeofenceDetectionMode? geofenceKind,
      String? formula,
      String? script,
      String? exactHour,
      String? crontabFormat,
      @WeekdayConverter() List<Weekday>? weekdays,
      bool? isPlainCrontab,
      String? timezoneId,
      int? priority,
      @ColorOrNullConverter() Color? color,
      @CaseEventEffectOrNullConverter() CaseEventEffect? visualEventEffect,
      String? careProtocolId}) = _$_TriggerInput;

  factory _TriggerInput.fromJson(Map<String, dynamic> json) =
      _$_TriggerInput.fromJson;

  @override

  /// ID of the trigger entity. This ID is unique.
  String? get id;

  /// ID of the trigger entity. This ID is unique.
  set id(String? value);
  @override

  /// Name of the trigger.
  String? get name;

  /// Name of the trigger.
  set name(String? value);
  @override

  /// Code/Identifier of the trigger.
  String? get code;

  /// Code/Identifier of the trigger.
  set code(String? value);
  @override

  /// List of ID's of the linked geofences
  List<String>? get geofencesIds;

  /// List of ID's of the linked geofences
  set geofencesIds(List<String>? value);
  @override

  /// List of ID's of the linked geofences through tags
  List<String>? get tagsGeofencesIds;

  /// List of ID's of the linked geofences through tags
  set tagsGeofencesIds(List<String>? value);
  @override

  ///List of ID's of the linked assets
  List<String>? get assetsIds;

  ///List of ID's of the linked assets
  set assetsIds(List<String>? value);
  @override

  /// List of ID's of the linked assets through tags
  List<String>? get tagsAssetsIds;

  /// List of ID's of the linked assets through tags
  set tagsAssetsIds(List<String>? value);
  @override

  /// List of parameters to consider in the authentication procedure
  List<String>? get parameters;

  /// List of parameters to consider in the authentication procedure
  set parameters(List<String>? value);
  @override

  /// List of ID's of the assets for authentication
  List<String>? get authAssetsIds;

  /// List of ID's of the assets for authentication
  set authAssetsIds(List<String>? value);
  @override

  /// List of ID's of the users for authentication
  List<String>? get authUsersIds;

  /// List of ID's of the users for authentication
  set authUsersIds(List<String>? value);
  @override

  /// List of ID's of the users or assets through tags for authentication
  List<String>? get authTagsIds;

  /// List of ID's of the users or assets through tags for authentication
  set authTagsIds(List<String>? value);
  @override

  /// Mode of activation.
  @TriggerTypeOrNullConverter()
  TriggerType? get kind;

  /// Mode of activation.
  @TriggerTypeOrNullConverter()
  set kind(TriggerType? value);
  @override

  /// Mode of activation / disparator for [TriggerType.presenceInGeofences].
  @TriggerGeofenceDetectionModeOrNullConverter()
  TriggerGeofenceDetectionMode? get geofenceKind;

  /// Mode of activation / disparator for [TriggerType.presenceInGeofences].
  @TriggerGeofenceDetectionModeOrNullConverter()
  set geofenceKind(TriggerGeofenceDetectionMode? value);
  @override

  /// Layrz Language formula
  String? get formula;

  /// Layrz Language formula
  set formula(String? value);
  @override

  /// Script to execute
  String? get script;

  /// Script to execute
  set script(String? value);
  @override

  /// Mode of activation / disparator for [TriggerType.exactTime].
  String? get exactHour;

  /// Mode of activation / disparator for [TriggerType.exactTime].
  set exactHour(String? value);
  @override

  /// Crontab structure
  String? get crontabFormat;

  /// Crontab structure
  set crontabFormat(String? value);
  @override

  /// Indicates the days of the week what will execute the trigger.
  @WeekdayConverter()
  List<Weekday>? get weekdays;

  /// Indicates the days of the week what will execute the trigger.
  @WeekdayConverter()
  set weekdays(List<Weekday>? value);
  @override

  ///Indicates if the EXACTIME is in Crontab format or assisted format
  bool? get isPlainCrontab;

  ///Indicates if the EXACTIME is in Crontab format or assisted format
  set isPlainCrontab(bool? value);
  @override

  /// Timezone associated to disparator [TriggerType.exactTime].
  String? get timezoneId;

  /// Timezone associated to disparator [TriggerType.exactTime].
  set timezoneId(String? value);
  @override

  /// Priority level for the trigger generated cases
  int? get priority;

  /// Priority level for the trigger generated cases
  set priority(int? value);
  @override

  /// Color of the trigger case
  @ColorOrNullConverter()
  Color? get color;

  /// Color of the trigger case
  @ColorOrNullConverter()
  set color(Color? value);
  @override

  /// Visual event effects to use in Monitor Center events received.
  @CaseEventEffectOrNullConverter()
  CaseEventEffect? get visualEventEffect;

  /// Visual event effects to use in Monitor Center events received.
  @CaseEventEffectOrNullConverter()
  set visualEventEffect(CaseEventEffect? value);
  @override

  /// Care protocol linked to the trigger. This is the rules to follow in the case reception. It can be null.
  String? get careProtocolId;

  /// Care protocol linked to the trigger. This is the rules to follow in the case reception. It can be null.
  set careProtocolId(String? value);
  @override
  @JsonKey(ignore: true)
  _$$_TriggerInputCopyWith<_$_TriggerInput> get copyWith =>
      throw _privateConstructorUsedError;
}

CareProtocol _$CareProtocolFromJson(Map<String, dynamic> json) {
  return _CareProtocol.fromJson(json);
}

/// @nodoc
mixin _$CareProtocol {
  /// Is the ID
  String get id => throw _privateConstructorUsedError;

  /// The name of the care protocol
  String get name => throw _privateConstructorUsedError;

  /// Indicates the mode of the care protocol
  @CareProtocolModeOrNullConverter()
  CareProtocolMode? get mode => throw _privateConstructorUsedError;

  /// Is the list of tasks to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.simple]
  List<CareTask> get tasks => throw _privateConstructorUsedError;

  /// Is the list of pages to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.concierge]
  List<ConciergeFormPage> get pages => throw _privateConstructorUsedError;

  /// A list of associated triggers
  List<Trigger>? get associatedTriggers => throw _privateConstructorUsedError;

  /// Represents the number of tasks created from this care protocol
  /// Only will come when the [mode] is [CareProtocolMode.simple]
  int? get numOfTasks => throw _privateConstructorUsedError;

  /// Represents the number of pages ([numOfPages]) and blocks ([numOfBlocks]) created from this care protocol
  /// Only will come when the [mode] is [CareProtocolMode.concierge]
  int? get numOfPages => throw _privateConstructorUsedError;
  int? get numOfBlocks => throw _privateConstructorUsedError;

  /// A list of granted access
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CareProtocolCopyWith<CareProtocol> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CareProtocolCopyWith<$Res> {
  factory $CareProtocolCopyWith(
          CareProtocol value, $Res Function(CareProtocol) then) =
      _$CareProtocolCopyWithImpl<$Res, CareProtocol>;
  @useResult
  $Res call(
      {String id,
      String name,
      @CareProtocolModeOrNullConverter() CareProtocolMode? mode,
      List<CareTask> tasks,
      List<ConciergeFormPage> pages,
      List<Trigger>? associatedTriggers,
      int? numOfTasks,
      int? numOfPages,
      int? numOfBlocks,
      List<Access>? access});
}

/// @nodoc
class _$CareProtocolCopyWithImpl<$Res, $Val extends CareProtocol>
    implements $CareProtocolCopyWith<$Res> {
  _$CareProtocolCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? mode = freezed,
    Object? tasks = null,
    Object? pages = null,
    Object? associatedTriggers = freezed,
    Object? numOfTasks = freezed,
    Object? numOfPages = freezed,
    Object? numOfBlocks = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as CareProtocolMode?,
      tasks: null == tasks
          ? _value.tasks
          : tasks // ignore: cast_nullable_to_non_nullable
              as List<CareTask>,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<ConciergeFormPage>,
      associatedTriggers: freezed == associatedTriggers
          ? _value.associatedTriggers
          : associatedTriggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      numOfTasks: freezed == numOfTasks
          ? _value.numOfTasks
          : numOfTasks // ignore: cast_nullable_to_non_nullable
              as int?,
      numOfPages: freezed == numOfPages
          ? _value.numOfPages
          : numOfPages // ignore: cast_nullable_to_non_nullable
              as int?,
      numOfBlocks: freezed == numOfBlocks
          ? _value.numOfBlocks
          : numOfBlocks // ignore: cast_nullable_to_non_nullable
              as int?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CareProtocolCopyWith<$Res>
    implements $CareProtocolCopyWith<$Res> {
  factory _$$_CareProtocolCopyWith(
          _$_CareProtocol value, $Res Function(_$_CareProtocol) then) =
      __$$_CareProtocolCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @CareProtocolModeOrNullConverter() CareProtocolMode? mode,
      List<CareTask> tasks,
      List<ConciergeFormPage> pages,
      List<Trigger>? associatedTriggers,
      int? numOfTasks,
      int? numOfPages,
      int? numOfBlocks,
      List<Access>? access});
}

/// @nodoc
class __$$_CareProtocolCopyWithImpl<$Res>
    extends _$CareProtocolCopyWithImpl<$Res, _$_CareProtocol>
    implements _$$_CareProtocolCopyWith<$Res> {
  __$$_CareProtocolCopyWithImpl(
      _$_CareProtocol _value, $Res Function(_$_CareProtocol) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? mode = freezed,
    Object? tasks = null,
    Object? pages = null,
    Object? associatedTriggers = freezed,
    Object? numOfTasks = freezed,
    Object? numOfPages = freezed,
    Object? numOfBlocks = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_CareProtocol(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      mode: freezed == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as CareProtocolMode?,
      tasks: null == tasks
          ? _value._tasks
          : tasks // ignore: cast_nullable_to_non_nullable
              as List<CareTask>,
      pages: null == pages
          ? _value._pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<ConciergeFormPage>,
      associatedTriggers: freezed == associatedTriggers
          ? _value._associatedTriggers
          : associatedTriggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      numOfTasks: freezed == numOfTasks
          ? _value.numOfTasks
          : numOfTasks // ignore: cast_nullable_to_non_nullable
              as int?,
      numOfPages: freezed == numOfPages
          ? _value.numOfPages
          : numOfPages // ignore: cast_nullable_to_non_nullable
              as int?,
      numOfBlocks: freezed == numOfBlocks
          ? _value.numOfBlocks
          : numOfBlocks // ignore: cast_nullable_to_non_nullable
              as int?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CareProtocol implements _CareProtocol {
  const _$_CareProtocol(
      {required this.id,
      required this.name,
      @CareProtocolModeOrNullConverter() this.mode,
      final List<CareTask> tasks = const <CareTask>[],
      final List<ConciergeFormPage> pages = const <ConciergeFormPage>[],
      final List<Trigger>? associatedTriggers,
      this.numOfTasks,
      this.numOfPages,
      this.numOfBlocks,
      final List<Access>? access})
      : _tasks = tasks,
        _pages = pages,
        _associatedTriggers = associatedTriggers,
        _access = access;

  factory _$_CareProtocol.fromJson(Map<String, dynamic> json) =>
      _$$_CareProtocolFromJson(json);

  /// Is the ID
  @override
  final String id;

  /// The name of the care protocol
  @override
  final String name;

  /// Indicates the mode of the care protocol
  @override
  @CareProtocolModeOrNullConverter()
  final CareProtocolMode? mode;

  /// Is the list of tasks to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.simple]
  final List<CareTask> _tasks;

  /// Is the list of tasks to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.simple]
  @override
  @JsonKey()
  List<CareTask> get tasks {
    if (_tasks is EqualUnmodifiableListView) return _tasks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tasks);
  }

  /// Is the list of pages to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.concierge]
  final List<ConciergeFormPage> _pages;

  /// Is the list of pages to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.concierge]
  @override
  @JsonKey()
  List<ConciergeFormPage> get pages {
    if (_pages is EqualUnmodifiableListView) return _pages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pages);
  }

  /// A list of associated triggers
  final List<Trigger>? _associatedTriggers;

  /// A list of associated triggers
  @override
  List<Trigger>? get associatedTriggers {
    final value = _associatedTriggers;
    if (value == null) return null;
    if (_associatedTriggers is EqualUnmodifiableListView)
      return _associatedTriggers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Represents the number of tasks created from this care protocol
  /// Only will come when the [mode] is [CareProtocolMode.simple]
  @override
  final int? numOfTasks;

  /// Represents the number of pages ([numOfPages]) and blocks ([numOfBlocks]) created from this care protocol
  /// Only will come when the [mode] is [CareProtocolMode.concierge]
  @override
  final int? numOfPages;
  @override
  final int? numOfBlocks;

  /// A list of granted access
  final List<Access>? _access;

  /// A list of granted access
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'CareProtocol(id: $id, name: $name, mode: $mode, tasks: $tasks, pages: $pages, associatedTriggers: $associatedTriggers, numOfTasks: $numOfTasks, numOfPages: $numOfPages, numOfBlocks: $numOfBlocks, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CareProtocol &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            const DeepCollectionEquality().equals(other._tasks, _tasks) &&
            const DeepCollectionEquality().equals(other._pages, _pages) &&
            const DeepCollectionEquality()
                .equals(other._associatedTriggers, _associatedTriggers) &&
            (identical(other.numOfTasks, numOfTasks) ||
                other.numOfTasks == numOfTasks) &&
            (identical(other.numOfPages, numOfPages) ||
                other.numOfPages == numOfPages) &&
            (identical(other.numOfBlocks, numOfBlocks) ||
                other.numOfBlocks == numOfBlocks) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      mode,
      const DeepCollectionEquality().hash(_tasks),
      const DeepCollectionEquality().hash(_pages),
      const DeepCollectionEquality().hash(_associatedTriggers),
      numOfTasks,
      numOfPages,
      numOfBlocks,
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CareProtocolCopyWith<_$_CareProtocol> get copyWith =>
      __$$_CareProtocolCopyWithImpl<_$_CareProtocol>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CareProtocolToJson(
      this,
    );
  }
}

abstract class _CareProtocol implements CareProtocol {
  const factory _CareProtocol(
      {required final String id,
      required final String name,
      @CareProtocolModeOrNullConverter() final CareProtocolMode? mode,
      final List<CareTask> tasks,
      final List<ConciergeFormPage> pages,
      final List<Trigger>? associatedTriggers,
      final int? numOfTasks,
      final int? numOfPages,
      final int? numOfBlocks,
      final List<Access>? access}) = _$_CareProtocol;

  factory _CareProtocol.fromJson(Map<String, dynamic> json) =
      _$_CareProtocol.fromJson;

  @override

  /// Is the ID
  String get id;
  @override

  /// The name of the care protocol
  String get name;
  @override

  /// Indicates the mode of the care protocol
  @CareProtocolModeOrNullConverter()
  CareProtocolMode? get mode;
  @override

  /// Is the list of tasks to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.simple]
  List<CareTask> get tasks;
  @override

  /// Is the list of pages to complete or fill before the case submission. Only will be valid to consider when
  /// the [mode] is [CareProtocolMode.concierge]
  List<ConciergeFormPage> get pages;
  @override

  /// A list of associated triggers
  List<Trigger>? get associatedTriggers;
  @override

  /// Represents the number of tasks created from this care protocol
  /// Only will come when the [mode] is [CareProtocolMode.simple]
  int? get numOfTasks;
  @override

  /// Represents the number of pages ([numOfPages]) and blocks ([numOfBlocks]) created from this care protocol
  /// Only will come when the [mode] is [CareProtocolMode.concierge]
  int? get numOfPages;
  @override
  int? get numOfBlocks;
  @override

  /// A list of granted access
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_CareProtocolCopyWith<_$_CareProtocol> get copyWith =>
      throw _privateConstructorUsedError;
}

CareTask _$CareTaskFromJson(Map<String, dynamic> json) {
  return _CareTask.fromJson(json);
}

/// @nodoc
mixin _$CareTask {
  /// Is the question to prompt
  String get question => throw _privateConstructorUsedError;

  /// Is the type of answer
  @AnswerKindConverter()
  AnswerKind get answer => throw _privateConstructorUsedError;

  /// When [answer] = [AnswerKind.choice], [choices] represents the list of possible values
  List<String> get choices => throw _privateConstructorUsedError;

  /// When [answer] = [AnswerKind.range], [minValue] and [maxValue] represents the range of possible values
  int get minValue => throw _privateConstructorUsedError;
  int get maxValue => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CareTaskCopyWith<CareTask> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CareTaskCopyWith<$Res> {
  factory $CareTaskCopyWith(CareTask value, $Res Function(CareTask) then) =
      _$CareTaskCopyWithImpl<$Res, CareTask>;
  @useResult
  $Res call(
      {String question,
      @AnswerKindConverter() AnswerKind answer,
      List<String> choices,
      int minValue,
      int maxValue});
}

/// @nodoc
class _$CareTaskCopyWithImpl<$Res, $Val extends CareTask>
    implements $CareTaskCopyWith<$Res> {
  _$CareTaskCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? question = null,
    Object? answer = null,
    Object? choices = null,
    Object? minValue = null,
    Object? maxValue = null,
  }) {
    return _then(_value.copyWith(
      question: null == question
          ? _value.question
          : question // ignore: cast_nullable_to_non_nullable
              as String,
      answer: null == answer
          ? _value.answer
          : answer // ignore: cast_nullable_to_non_nullable
              as AnswerKind,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<String>,
      minValue: null == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxValue: null == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CareTaskCopyWith<$Res> implements $CareTaskCopyWith<$Res> {
  factory _$$_CareTaskCopyWith(
          _$_CareTask value, $Res Function(_$_CareTask) then) =
      __$$_CareTaskCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String question,
      @AnswerKindConverter() AnswerKind answer,
      List<String> choices,
      int minValue,
      int maxValue});
}

/// @nodoc
class __$$_CareTaskCopyWithImpl<$Res>
    extends _$CareTaskCopyWithImpl<$Res, _$_CareTask>
    implements _$$_CareTaskCopyWith<$Res> {
  __$$_CareTaskCopyWithImpl(
      _$_CareTask _value, $Res Function(_$_CareTask) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? question = null,
    Object? answer = null,
    Object? choices = null,
    Object? minValue = null,
    Object? maxValue = null,
  }) {
    return _then(_$_CareTask(
      question: null == question
          ? _value.question
          : question // ignore: cast_nullable_to_non_nullable
              as String,
      answer: null == answer
          ? _value.answer
          : answer // ignore: cast_nullable_to_non_nullable
              as AnswerKind,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<String>,
      minValue: null == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as int,
      maxValue: null == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CareTask implements _CareTask {
  const _$_CareTask(
      {required this.question,
      @AnswerKindConverter() required this.answer,
      final List<String> choices = const [],
      this.minValue = 0,
      this.maxValue = 0})
      : _choices = choices;

  factory _$_CareTask.fromJson(Map<String, dynamic> json) =>
      _$$_CareTaskFromJson(json);

  /// Is the question to prompt
  @override
  final String question;

  /// Is the type of answer
  @override
  @AnswerKindConverter()
  final AnswerKind answer;

  /// When [answer] = [AnswerKind.choice], [choices] represents the list of possible values
  final List<String> _choices;

  /// When [answer] = [AnswerKind.choice], [choices] represents the list of possible values
  @override
  @JsonKey()
  List<String> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  /// When [answer] = [AnswerKind.range], [minValue] and [maxValue] represents the range of possible values
  @override
  @JsonKey()
  final int minValue;
  @override
  @JsonKey()
  final int maxValue;

  @override
  String toString() {
    return 'CareTask(question: $question, answer: $answer, choices: $choices, minValue: $minValue, maxValue: $maxValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CareTask &&
            (identical(other.question, question) ||
                other.question == question) &&
            (identical(other.answer, answer) || other.answer == answer) &&
            const DeepCollectionEquality().equals(other._choices, _choices) &&
            (identical(other.minValue, minValue) ||
                other.minValue == minValue) &&
            (identical(other.maxValue, maxValue) ||
                other.maxValue == maxValue));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, question, answer,
      const DeepCollectionEquality().hash(_choices), minValue, maxValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CareTaskCopyWith<_$_CareTask> get copyWith =>
      __$$_CareTaskCopyWithImpl<_$_CareTask>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CareTaskToJson(
      this,
    );
  }
}

abstract class _CareTask implements CareTask {
  const factory _CareTask(
      {required final String question,
      @AnswerKindConverter() required final AnswerKind answer,
      final List<String> choices,
      final int minValue,
      final int maxValue}) = _$_CareTask;

  factory _CareTask.fromJson(Map<String, dynamic> json) = _$_CareTask.fromJson;

  @override

  /// Is the question to prompt
  String get question;
  @override

  /// Is the type of answer
  @AnswerKindConverter()
  AnswerKind get answer;
  @override

  /// When [answer] = [AnswerKind.choice], [choices] represents the list of possible values
  List<String> get choices;
  @override

  /// When [answer] = [AnswerKind.range], [minValue] and [maxValue] represents the range of possible values
  int get minValue;
  @override
  int get maxValue;
  @override
  @JsonKey(ignore: true)
  _$$_CareTaskCopyWith<_$_CareTask> get copyWith =>
      throw _privateConstructorUsedError;
}

ConciergeForm _$ConciergeFormFromJson(Map<String, dynamic> json) {
  return _ConciergeForm.fromJson(json);
}

/// @nodoc
mixin _$ConciergeForm {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConciergeFormCopyWith<ConciergeForm> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConciergeFormCopyWith<$Res> {
  factory $ConciergeFormCopyWith(
          ConciergeForm value, $Res Function(ConciergeForm) then) =
      _$ConciergeFormCopyWithImpl<$Res, ConciergeForm>;
  @useResult
  $Res call({String id, String name});
}

/// @nodoc
class _$ConciergeFormCopyWithImpl<$Res, $Val extends ConciergeForm>
    implements $ConciergeFormCopyWith<$Res> {
  _$ConciergeFormCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ConciergeFormCopyWith<$Res>
    implements $ConciergeFormCopyWith<$Res> {
  factory _$$_ConciergeFormCopyWith(
          _$_ConciergeForm value, $Res Function(_$_ConciergeForm) then) =
      __$$_ConciergeFormCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name});
}

/// @nodoc
class __$$_ConciergeFormCopyWithImpl<$Res>
    extends _$ConciergeFormCopyWithImpl<$Res, _$_ConciergeForm>
    implements _$$_ConciergeFormCopyWith<$Res> {
  __$$_ConciergeFormCopyWithImpl(
      _$_ConciergeForm _value, $Res Function(_$_ConciergeForm) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
  }) {
    return _then(_$_ConciergeForm(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ConciergeForm implements _ConciergeForm {
  const _$_ConciergeForm({required this.id, required this.name});

  factory _$_ConciergeForm.fromJson(Map<String, dynamic> json) =>
      _$$_ConciergeFormFromJson(json);

  @override
  final String id;
  @override
  final String name;

  @override
  String toString() {
    return 'ConciergeForm(id: $id, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConciergeForm &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ConciergeFormCopyWith<_$_ConciergeForm> get copyWith =>
      __$$_ConciergeFormCopyWithImpl<_$_ConciergeForm>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ConciergeFormToJson(
      this,
    );
  }
}

abstract class _ConciergeForm implements ConciergeForm {
  const factory _ConciergeForm(
      {required final String id,
      required final String name}) = _$_ConciergeForm;

  factory _ConciergeForm.fromJson(Map<String, dynamic> json) =
      _$_ConciergeForm.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$_ConciergeFormCopyWith<_$_ConciergeForm> get copyWith =>
      throw _privateConstructorUsedError;
}

OutboundService _$OutboundServiceFromJson(Map<String, dynamic> json) {
  return _OutboundService.fromJson(json);
}

/// @nodoc
mixin _$OutboundService {
  /// IS the ID of the entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// Is the Assigned service name, cannot be translated for other languages.
  String get name => throw _privateConstructorUsedError;

  /// Is the Credential object, check the documentation for more information.
  Map<String, dynamic>? get credentials => throw _privateConstructorUsedError;

  /// Is the Protocol entity.
  OutboundProtocol? get protocol => throw _privateConstructorUsedError;

  /// Is the Protocol ID.
  String? get protocolId => throw _privateConstructorUsedError;

  /// Is the Current transmission status.
  bool? get isEnabled => throw _privateConstructorUsedError;

  /// Is the Structure of the outbound protocol, only used for Omega REST Outbound protocol.
  List<OutboundStructure>? get structure => throw _privateConstructorUsedError;

  /// Is the Token to authenticate the request, only used for Alpha REST Inbound protocol
  String? get token => throw _privateConstructorUsedError;

  /// Is the Assets IDs linked to the service.
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  /// Is the Assets linked to the service.
  List<Asset>? get assets => throw _privateConstructorUsedError;

  /// Is the Groups (Tags) IDs linked to the service.
  List<String>? get groupsIds => throw _privateConstructorUsedError;

  /// Is the Groups (Tags) linked to the service.
  List<Tag>? get groups => throw _privateConstructorUsedError;

  /// A list of custom access permissions.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OutboundServiceCopyWith<OutboundService> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OutboundServiceCopyWith<$Res> {
  factory $OutboundServiceCopyWith(
          OutboundService value, $Res Function(OutboundService) then) =
      _$OutboundServiceCopyWithImpl<$Res, OutboundService>;
  @useResult
  $Res call(
      {String id,
      String name,
      Map<String, dynamic>? credentials,
      OutboundProtocol? protocol,
      String? protocolId,
      bool? isEnabled,
      List<OutboundStructure>? structure,
      String? token,
      List<String>? assetsIds,
      List<Asset>? assets,
      List<String>? groupsIds,
      List<Tag>? groups,
      List<Access>? access});

  $OutboundProtocolCopyWith<$Res>? get protocol;
}

/// @nodoc
class _$OutboundServiceCopyWithImpl<$Res, $Val extends OutboundService>
    implements $OutboundServiceCopyWith<$Res> {
  _$OutboundServiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? credentials = freezed,
    Object? protocol = freezed,
    Object? protocolId = freezed,
    Object? isEnabled = freezed,
    Object? structure = freezed,
    Object? token = freezed,
    Object? assetsIds = freezed,
    Object? assets = freezed,
    Object? groupsIds = freezed,
    Object? groups = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      credentials: freezed == credentials
          ? _value.credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as OutboundProtocol?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      isEnabled: freezed == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as List<OutboundStructure>?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assets: freezed == assets
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      groupsIds: freezed == groupsIds
          ? _value.groupsIds
          : groupsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      groups: freezed == groups
          ? _value.groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $OutboundProtocolCopyWith<$Res>? get protocol {
    if (_value.protocol == null) {
      return null;
    }

    return $OutboundProtocolCopyWith<$Res>(_value.protocol!, (value) {
      return _then(_value.copyWith(protocol: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_OutboundServiceCopyWith<$Res>
    implements $OutboundServiceCopyWith<$Res> {
  factory _$$_OutboundServiceCopyWith(
          _$_OutboundService value, $Res Function(_$_OutboundService) then) =
      __$$_OutboundServiceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      Map<String, dynamic>? credentials,
      OutboundProtocol? protocol,
      String? protocolId,
      bool? isEnabled,
      List<OutboundStructure>? structure,
      String? token,
      List<String>? assetsIds,
      List<Asset>? assets,
      List<String>? groupsIds,
      List<Tag>? groups,
      List<Access>? access});

  @override
  $OutboundProtocolCopyWith<$Res>? get protocol;
}

/// @nodoc
class __$$_OutboundServiceCopyWithImpl<$Res>
    extends _$OutboundServiceCopyWithImpl<$Res, _$_OutboundService>
    implements _$$_OutboundServiceCopyWith<$Res> {
  __$$_OutboundServiceCopyWithImpl(
      _$_OutboundService _value, $Res Function(_$_OutboundService) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? credentials = freezed,
    Object? protocol = freezed,
    Object? protocolId = freezed,
    Object? isEnabled = freezed,
    Object? structure = freezed,
    Object? token = freezed,
    Object? assetsIds = freezed,
    Object? assets = freezed,
    Object? groupsIds = freezed,
    Object? groups = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_OutboundService(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      credentials: freezed == credentials
          ? _value._credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as OutboundProtocol?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      isEnabled: freezed == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      structure: freezed == structure
          ? _value._structure
          : structure // ignore: cast_nullable_to_non_nullable
              as List<OutboundStructure>?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assets: freezed == assets
          ? _value._assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      groupsIds: freezed == groupsIds
          ? _value._groupsIds
          : groupsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      groups: freezed == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OutboundService implements _OutboundService {
  const _$_OutboundService(
      {required this.id,
      required this.name,
      final Map<String, dynamic>? credentials,
      this.protocol,
      this.protocolId,
      this.isEnabled,
      final List<OutboundStructure>? structure,
      this.token,
      final List<String>? assetsIds,
      final List<Asset>? assets,
      final List<String>? groupsIds,
      final List<Tag>? groups,
      final List<Access>? access})
      : _credentials = credentials,
        _structure = structure,
        _assetsIds = assetsIds,
        _assets = assets,
        _groupsIds = groupsIds,
        _groups = groups,
        _access = access;

  factory _$_OutboundService.fromJson(Map<String, dynamic> json) =>
      _$$_OutboundServiceFromJson(json);

  /// IS the ID of the entity. This ID is unique.
  @override
  final String id;

  /// Is the Assigned service name, cannot be translated for other languages.
  @override
  final String name;

  /// Is the Credential object, check the documentation for more information.
  final Map<String, dynamic>? _credentials;

  /// Is the Credential object, check the documentation for more information.
  @override
  Map<String, dynamic>? get credentials {
    final value = _credentials;
    if (value == null) return null;
    if (_credentials is EqualUnmodifiableMapView) return _credentials;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Is the Protocol entity.
  @override
  final OutboundProtocol? protocol;

  /// Is the Protocol ID.
  @override
  final String? protocolId;

  /// Is the Current transmission status.
  @override
  final bool? isEnabled;

  /// Is the Structure of the outbound protocol, only used for Omega REST Outbound protocol.
  final List<OutboundStructure>? _structure;

  /// Is the Structure of the outbound protocol, only used for Omega REST Outbound protocol.
  @override
  List<OutboundStructure>? get structure {
    final value = _structure;
    if (value == null) return null;
    if (_structure is EqualUnmodifiableListView) return _structure;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the Token to authenticate the request, only used for Alpha REST Inbound protocol
  @override
  final String? token;

  /// Is the Assets IDs linked to the service.
  final List<String>? _assetsIds;

  /// Is the Assets IDs linked to the service.
  @override
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the Assets linked to the service.
  final List<Asset>? _assets;

  /// Is the Assets linked to the service.
  @override
  List<Asset>? get assets {
    final value = _assets;
    if (value == null) return null;
    if (_assets is EqualUnmodifiableListView) return _assets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the Groups (Tags) IDs linked to the service.
  final List<String>? _groupsIds;

  /// Is the Groups (Tags) IDs linked to the service.
  @override
  List<String>? get groupsIds {
    final value = _groupsIds;
    if (value == null) return null;
    if (_groupsIds is EqualUnmodifiableListView) return _groupsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the Groups (Tags) linked to the service.
  final List<Tag>? _groups;

  /// Is the Groups (Tags) linked to the service.
  @override
  List<Tag>? get groups {
    final value = _groups;
    if (value == null) return null;
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// A list of custom access permissions.
  final List<Access>? _access;

  /// A list of custom access permissions.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'OutboundService(id: $id, name: $name, credentials: $credentials, protocol: $protocol, protocolId: $protocolId, isEnabled: $isEnabled, structure: $structure, token: $token, assetsIds: $assetsIds, assets: $assets, groupsIds: $groupsIds, groups: $groups, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OutboundService &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._credentials, _credentials) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            (identical(other.protocolId, protocolId) ||
                other.protocolId == protocolId) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            const DeepCollectionEquality()
                .equals(other._structure, _structure) &&
            (identical(other.token, token) || other.token == token) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds) &&
            const DeepCollectionEquality().equals(other._assets, _assets) &&
            const DeepCollectionEquality()
                .equals(other._groupsIds, _groupsIds) &&
            const DeepCollectionEquality().equals(other._groups, _groups) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      const DeepCollectionEquality().hash(_credentials),
      protocol,
      protocolId,
      isEnabled,
      const DeepCollectionEquality().hash(_structure),
      token,
      const DeepCollectionEquality().hash(_assetsIds),
      const DeepCollectionEquality().hash(_assets),
      const DeepCollectionEquality().hash(_groupsIds),
      const DeepCollectionEquality().hash(_groups),
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OutboundServiceCopyWith<_$_OutboundService> get copyWith =>
      __$$_OutboundServiceCopyWithImpl<_$_OutboundService>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OutboundServiceToJson(
      this,
    );
  }
}

abstract class _OutboundService implements OutboundService {
  const factory _OutboundService(
      {required final String id,
      required final String name,
      final Map<String, dynamic>? credentials,
      final OutboundProtocol? protocol,
      final String? protocolId,
      final bool? isEnabled,
      final List<OutboundStructure>? structure,
      final String? token,
      final List<String>? assetsIds,
      final List<Asset>? assets,
      final List<String>? groupsIds,
      final List<Tag>? groups,
      final List<Access>? access}) = _$_OutboundService;

  factory _OutboundService.fromJson(Map<String, dynamic> json) =
      _$_OutboundService.fromJson;

  @override

  /// IS the ID of the entity. This ID is unique.
  String get id;
  @override

  /// Is the Assigned service name, cannot be translated for other languages.
  String get name;
  @override

  /// Is the Credential object, check the documentation for more information.
  Map<String, dynamic>? get credentials;
  @override

  /// Is the Protocol entity.
  OutboundProtocol? get protocol;
  @override

  /// Is the Protocol ID.
  String? get protocolId;
  @override

  /// Is the Current transmission status.
  bool? get isEnabled;
  @override

  /// Is the Structure of the outbound protocol, only used for Omega REST Outbound protocol.
  List<OutboundStructure>? get structure;
  @override

  /// Is the Token to authenticate the request, only used for Alpha REST Inbound protocol
  String? get token;
  @override

  /// Is the Assets IDs linked to the service.
  List<String>? get assetsIds;
  @override

  /// Is the Assets linked to the service.
  List<Asset>? get assets;
  @override

  /// Is the Groups (Tags) IDs linked to the service.
  List<String>? get groupsIds;
  @override

  /// Is the Groups (Tags) linked to the service.
  List<Tag>? get groups;
  @override

  /// A list of custom access permissions.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_OutboundServiceCopyWith<_$_OutboundService> get copyWith =>
      throw _privateConstructorUsedError;
}

OutboundStructure _$OutboundStructureFromJson(Map<String, dynamic> json) {
  return _OutboundStructure.fromJson(json);
}

/// @nodoc
mixin _$OutboundStructure {
  String get field => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get value => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OutboundStructureCopyWith<OutboundStructure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OutboundStructureCopyWith<$Res> {
  factory $OutboundStructureCopyWith(
          OutboundStructure value, $Res Function(OutboundStructure) then) =
      _$OutboundStructureCopyWithImpl<$Res, OutboundStructure>;
  @useResult
  $Res call({String field, String type, String value});
}

/// @nodoc
class _$OutboundStructureCopyWithImpl<$Res, $Val extends OutboundStructure>
    implements $OutboundStructureCopyWith<$Res> {
  _$OutboundStructureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? type = null,
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_OutboundStructureCopyWith<$Res>
    implements $OutboundStructureCopyWith<$Res> {
  factory _$$_OutboundStructureCopyWith(_$_OutboundStructure value,
          $Res Function(_$_OutboundStructure) then) =
      __$$_OutboundStructureCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String field, String type, String value});
}

/// @nodoc
class __$$_OutboundStructureCopyWithImpl<$Res>
    extends _$OutboundStructureCopyWithImpl<$Res, _$_OutboundStructure>
    implements _$$_OutboundStructureCopyWith<$Res> {
  __$$_OutboundStructureCopyWithImpl(
      _$_OutboundStructure _value, $Res Function(_$_OutboundStructure) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? type = null,
    Object? value = null,
  }) {
    return _then(_$_OutboundStructure(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OutboundStructure implements _OutboundStructure {
  const _$_OutboundStructure(
      {required this.field, required this.type, required this.value});

  factory _$_OutboundStructure.fromJson(Map<String, dynamic> json) =>
      _$$_OutboundStructureFromJson(json);

  @override
  final String field;
  @override
  final String type;
  @override
  final String value;

  @override
  String toString() {
    return 'OutboundStructure(field: $field, type: $type, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_OutboundStructure &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field, type, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OutboundStructureCopyWith<_$_OutboundStructure> get copyWith =>
      __$$_OutboundStructureCopyWithImpl<_$_OutboundStructure>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OutboundStructureToJson(
      this,
    );
  }
}

abstract class _OutboundStructure implements OutboundStructure {
  const factory _OutboundStructure(
      {required final String field,
      required final String type,
      required final String value}) = _$_OutboundStructure;

  factory _OutboundStructure.fromJson(Map<String, dynamic> json) =
      _$_OutboundStructure.fromJson;

  @override
  String get field;
  @override
  String get type;
  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_OutboundStructureCopyWith<_$_OutboundStructure> get copyWith =>
      throw _privateConstructorUsedError;
}

InboundService _$InboundServiceFromJson(Map<String, dynamic> json) {
  return _InboundService.fromJson(json);
}

/// @nodoc
mixin _$InboundService {
  /// IS the ID of the entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// Is the Assigned service name, cannot be translated for other languages.
  String get name => throw _privateConstructorUsedError;

  /// Is the Credential object, check the documentation for more information.
  Map<String, dynamic>? get credentials => throw _privateConstructorUsedError;

  /// Is the ID of the External Account.
  String? get accountId => throw _privateConstructorUsedError;

  /// Is the update time of the service.
  @DurationOrNullConverter()
  Duration? get updateTime => throw _privateConstructorUsedError;

  /// Is the Protocol entity.
  InboundProtocol? get protocol => throw _privateConstructorUsedError;

  /// Is the Protocol ID.
  String? get protocolId => throw _privateConstructorUsedError;

  /// Is the Current transmission status.
  bool? get isEnabled => throw _privateConstructorUsedError;

  /// Is the Token to authenticate the request, only used for Alpha REST Inbound protocol
  String? get token => throw _privateConstructorUsedError;

  /// Is the Structure of the inbound protocol, only used for Omega REST Inbound protocol.
  InboundStructure? get structure => throw _privateConstructorUsedError;

  /// A list of custom access permissions.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InboundServiceCopyWith<InboundService> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InboundServiceCopyWith<$Res> {
  factory $InboundServiceCopyWith(
          InboundService value, $Res Function(InboundService) then) =
      _$InboundServiceCopyWithImpl<$Res, InboundService>;
  @useResult
  $Res call(
      {String id,
      String name,
      Map<String, dynamic>? credentials,
      String? accountId,
      @DurationOrNullConverter() Duration? updateTime,
      InboundProtocol? protocol,
      String? protocolId,
      bool? isEnabled,
      String? token,
      InboundStructure? structure,
      List<Access>? access});

  $InboundProtocolCopyWith<$Res>? get protocol;
  $InboundStructureCopyWith<$Res>? get structure;
}

/// @nodoc
class _$InboundServiceCopyWithImpl<$Res, $Val extends InboundService>
    implements $InboundServiceCopyWith<$Res> {
  _$InboundServiceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? credentials = freezed,
    Object? accountId = freezed,
    Object? updateTime = freezed,
    Object? protocol = freezed,
    Object? protocolId = freezed,
    Object? isEnabled = freezed,
    Object? token = freezed,
    Object? structure = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      credentials: freezed == credentials
          ? _value.credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      accountId: freezed == accountId
          ? _value.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String?,
      updateTime: freezed == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      isEnabled: freezed == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as InboundStructure?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $InboundProtocolCopyWith<$Res>? get protocol {
    if (_value.protocol == null) {
      return null;
    }

    return $InboundProtocolCopyWith<$Res>(_value.protocol!, (value) {
      return _then(_value.copyWith(protocol: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $InboundStructureCopyWith<$Res>? get structure {
    if (_value.structure == null) {
      return null;
    }

    return $InboundStructureCopyWith<$Res>(_value.structure!, (value) {
      return _then(_value.copyWith(structure: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_InboundServiceCopyWith<$Res>
    implements $InboundServiceCopyWith<$Res> {
  factory _$$_InboundServiceCopyWith(
          _$_InboundService value, $Res Function(_$_InboundService) then) =
      __$$_InboundServiceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      Map<String, dynamic>? credentials,
      String? accountId,
      @DurationOrNullConverter() Duration? updateTime,
      InboundProtocol? protocol,
      String? protocolId,
      bool? isEnabled,
      String? token,
      InboundStructure? structure,
      List<Access>? access});

  @override
  $InboundProtocolCopyWith<$Res>? get protocol;
  @override
  $InboundStructureCopyWith<$Res>? get structure;
}

/// @nodoc
class __$$_InboundServiceCopyWithImpl<$Res>
    extends _$InboundServiceCopyWithImpl<$Res, _$_InboundService>
    implements _$$_InboundServiceCopyWith<$Res> {
  __$$_InboundServiceCopyWithImpl(
      _$_InboundService _value, $Res Function(_$_InboundService) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? credentials = freezed,
    Object? accountId = freezed,
    Object? updateTime = freezed,
    Object? protocol = freezed,
    Object? protocolId = freezed,
    Object? isEnabled = freezed,
    Object? token = freezed,
    Object? structure = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_InboundService(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      credentials: freezed == credentials
          ? _value._credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      accountId: freezed == accountId
          ? _value.accountId
          : accountId // ignore: cast_nullable_to_non_nullable
              as String?,
      updateTime: freezed == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      isEnabled: freezed == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as InboundStructure?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_InboundService implements _InboundService {
  const _$_InboundService(
      {required this.id,
      required this.name,
      final Map<String, dynamic>? credentials,
      this.accountId,
      @DurationOrNullConverter() this.updateTime,
      this.protocol,
      this.protocolId,
      this.isEnabled,
      this.token,
      this.structure,
      final List<Access>? access})
      : _credentials = credentials,
        _access = access;

  factory _$_InboundService.fromJson(Map<String, dynamic> json) =>
      _$$_InboundServiceFromJson(json);

  /// IS the ID of the entity. This ID is unique.
  @override
  final String id;

  /// Is the Assigned service name, cannot be translated for other languages.
  @override
  final String name;

  /// Is the Credential object, check the documentation for more information.
  final Map<String, dynamic>? _credentials;

  /// Is the Credential object, check the documentation for more information.
  @override
  Map<String, dynamic>? get credentials {
    final value = _credentials;
    if (value == null) return null;
    if (_credentials is EqualUnmodifiableMapView) return _credentials;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// Is the ID of the External Account.
  @override
  final String? accountId;

  /// Is the update time of the service.
  @override
  @DurationOrNullConverter()
  final Duration? updateTime;

  /// Is the Protocol entity.
  @override
  final InboundProtocol? protocol;

  /// Is the Protocol ID.
  @override
  final String? protocolId;

  /// Is the Current transmission status.
  @override
  final bool? isEnabled;

  /// Is the Token to authenticate the request, only used for Alpha REST Inbound protocol
  @override
  final String? token;

  /// Is the Structure of the inbound protocol, only used for Omega REST Inbound protocol.
  @override
  final InboundStructure? structure;

  /// A list of custom access permissions.
  final List<Access>? _access;

  /// A list of custom access permissions.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'InboundService(id: $id, name: $name, credentials: $credentials, accountId: $accountId, updateTime: $updateTime, protocol: $protocol, protocolId: $protocolId, isEnabled: $isEnabled, token: $token, structure: $structure, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InboundService &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._credentials, _credentials) &&
            (identical(other.accountId, accountId) ||
                other.accountId == accountId) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            (identical(other.protocolId, protocolId) ||
                other.protocolId == protocolId) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            (identical(other.token, token) || other.token == token) &&
            (identical(other.structure, structure) ||
                other.structure == structure) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      const DeepCollectionEquality().hash(_credentials),
      accountId,
      updateTime,
      protocol,
      protocolId,
      isEnabled,
      token,
      structure,
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InboundServiceCopyWith<_$_InboundService> get copyWith =>
      __$$_InboundServiceCopyWithImpl<_$_InboundService>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InboundServiceToJson(
      this,
    );
  }
}

abstract class _InboundService implements InboundService {
  const factory _InboundService(
      {required final String id,
      required final String name,
      final Map<String, dynamic>? credentials,
      final String? accountId,
      @DurationOrNullConverter() final Duration? updateTime,
      final InboundProtocol? protocol,
      final String? protocolId,
      final bool? isEnabled,
      final String? token,
      final InboundStructure? structure,
      final List<Access>? access}) = _$_InboundService;

  factory _InboundService.fromJson(Map<String, dynamic> json) =
      _$_InboundService.fromJson;

  @override

  /// IS the ID of the entity. This ID is unique.
  String get id;
  @override

  /// Is the Assigned service name, cannot be translated for other languages.
  String get name;
  @override

  /// Is the Credential object, check the documentation for more information.
  Map<String, dynamic>? get credentials;
  @override

  /// Is the ID of the External Account.
  String? get accountId;
  @override

  /// Is the update time of the service.
  @DurationOrNullConverter()
  Duration? get updateTime;
  @override

  /// Is the Protocol entity.
  InboundProtocol? get protocol;
  @override

  /// Is the Protocol ID.
  String? get protocolId;
  @override

  /// Is the Current transmission status.
  bool? get isEnabled;
  @override

  /// Is the Token to authenticate the request, only used for Alpha REST Inbound protocol
  String? get token;
  @override

  /// Is the Structure of the inbound protocol, only used for Omega REST Inbound protocol.
  InboundStructure? get structure;
  @override

  /// A list of custom access permissions.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_InboundServiceCopyWith<_$_InboundService> get copyWith =>
      throw _privateConstructorUsedError;
}

InboundStructure _$InboundStructureFromJson(Map<String, dynamic> json) {
  return _InboundStructure.fromJson(json);
}

/// @nodoc
mixin _$InboundStructure {
  bool get hasPosition => throw _privateConstructorUsedError;
  InboundPositionStructure get position => throw _privateConstructorUsedError;
  bool get hasPayload => throw _privateConstructorUsedError;
  List<InboundPayloadStructure> get payload =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InboundStructureCopyWith<InboundStructure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InboundStructureCopyWith<$Res> {
  factory $InboundStructureCopyWith(
          InboundStructure value, $Res Function(InboundStructure) then) =
      _$InboundStructureCopyWithImpl<$Res, InboundStructure>;
  @useResult
  $Res call(
      {bool hasPosition,
      InboundPositionStructure position,
      bool hasPayload,
      List<InboundPayloadStructure> payload});

  $InboundPositionStructureCopyWith<$Res> get position;
}

/// @nodoc
class _$InboundStructureCopyWithImpl<$Res, $Val extends InboundStructure>
    implements $InboundStructureCopyWith<$Res> {
  _$InboundStructureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hasPosition = null,
    Object? position = null,
    Object? hasPayload = null,
    Object? payload = null,
  }) {
    return _then(_value.copyWith(
      hasPosition: null == hasPosition
          ? _value.hasPosition
          : hasPosition // ignore: cast_nullable_to_non_nullable
              as bool,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as InboundPositionStructure,
      hasPayload: null == hasPayload
          ? _value.hasPayload
          : hasPayload // ignore: cast_nullable_to_non_nullable
              as bool,
      payload: null == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<InboundPayloadStructure>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $InboundPositionStructureCopyWith<$Res> get position {
    return $InboundPositionStructureCopyWith<$Res>(_value.position, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_InboundStructureCopyWith<$Res>
    implements $InboundStructureCopyWith<$Res> {
  factory _$$_InboundStructureCopyWith(
          _$_InboundStructure value, $Res Function(_$_InboundStructure) then) =
      __$$_InboundStructureCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool hasPosition,
      InboundPositionStructure position,
      bool hasPayload,
      List<InboundPayloadStructure> payload});

  @override
  $InboundPositionStructureCopyWith<$Res> get position;
}

/// @nodoc
class __$$_InboundStructureCopyWithImpl<$Res>
    extends _$InboundStructureCopyWithImpl<$Res, _$_InboundStructure>
    implements _$$_InboundStructureCopyWith<$Res> {
  __$$_InboundStructureCopyWithImpl(
      _$_InboundStructure _value, $Res Function(_$_InboundStructure) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hasPosition = null,
    Object? position = null,
    Object? hasPayload = null,
    Object? payload = null,
  }) {
    return _then(_$_InboundStructure(
      hasPosition: null == hasPosition
          ? _value.hasPosition
          : hasPosition // ignore: cast_nullable_to_non_nullable
              as bool,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as InboundPositionStructure,
      hasPayload: null == hasPayload
          ? _value.hasPayload
          : hasPayload // ignore: cast_nullable_to_non_nullable
              as bool,
      payload: null == payload
          ? _value._payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<InboundPayloadStructure>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_InboundStructure implements _InboundStructure {
  const _$_InboundStructure(
      {required this.hasPosition,
      required this.position,
      required this.hasPayload,
      required final List<InboundPayloadStructure> payload})
      : _payload = payload;

  factory _$_InboundStructure.fromJson(Map<String, dynamic> json) =>
      _$$_InboundStructureFromJson(json);

  @override
  final bool hasPosition;
  @override
  final InboundPositionStructure position;
  @override
  final bool hasPayload;
  final List<InboundPayloadStructure> _payload;
  @override
  List<InboundPayloadStructure> get payload {
    if (_payload is EqualUnmodifiableListView) return _payload;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_payload);
  }

  @override
  String toString() {
    return 'InboundStructure(hasPosition: $hasPosition, position: $position, hasPayload: $hasPayload, payload: $payload)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InboundStructure &&
            (identical(other.hasPosition, hasPosition) ||
                other.hasPosition == hasPosition) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.hasPayload, hasPayload) ||
                other.hasPayload == hasPayload) &&
            const DeepCollectionEquality().equals(other._payload, _payload));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, hasPosition, position,
      hasPayload, const DeepCollectionEquality().hash(_payload));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InboundStructureCopyWith<_$_InboundStructure> get copyWith =>
      __$$_InboundStructureCopyWithImpl<_$_InboundStructure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InboundStructureToJson(
      this,
    );
  }
}

abstract class _InboundStructure implements InboundStructure {
  const factory _InboundStructure(
          {required final bool hasPosition,
          required final InboundPositionStructure position,
          required final bool hasPayload,
          required final List<InboundPayloadStructure> payload}) =
      _$_InboundStructure;

  factory _InboundStructure.fromJson(Map<String, dynamic> json) =
      _$_InboundStructure.fromJson;

  @override
  bool get hasPosition;
  @override
  InboundPositionStructure get position;
  @override
  bool get hasPayload;
  @override
  List<InboundPayloadStructure> get payload;
  @override
  @JsonKey(ignore: true)
  _$$_InboundStructureCopyWith<_$_InboundStructure> get copyWith =>
      throw _privateConstructorUsedError;
}

InboundPositionStructure _$InboundPositionStructureFromJson(
    Map<String, dynamic> json) {
  return _InboundPositionStructure.fromJson(json);
}

/// @nodoc
mixin _$InboundPositionStructure {
  bool get latitude => throw _privateConstructorUsedError;
  bool get longitude => throw _privateConstructorUsedError;
  bool get altitude => throw _privateConstructorUsedError;
  bool get speed => throw _privateConstructorUsedError;
  bool get direction => throw _privateConstructorUsedError;
  bool get hdop => throw _privateConstructorUsedError;
  bool get satellites => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InboundPositionStructureCopyWith<InboundPositionStructure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InboundPositionStructureCopyWith<$Res> {
  factory $InboundPositionStructureCopyWith(InboundPositionStructure value,
          $Res Function(InboundPositionStructure) then) =
      _$InboundPositionStructureCopyWithImpl<$Res, InboundPositionStructure>;
  @useResult
  $Res call(
      {bool latitude,
      bool longitude,
      bool altitude,
      bool speed,
      bool direction,
      bool hdop,
      bool satellites});
}

/// @nodoc
class _$InboundPositionStructureCopyWithImpl<$Res,
        $Val extends InboundPositionStructure>
    implements $InboundPositionStructureCopyWith<$Res> {
  _$InboundPositionStructureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = null,
    Object? longitude = null,
    Object? altitude = null,
    Object? speed = null,
    Object? direction = null,
    Object? hdop = null,
    Object? satellites = null,
  }) {
    return _then(_value.copyWith(
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as bool,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as bool,
      altitude: null == altitude
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as bool,
      speed: null == speed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as bool,
      direction: null == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as bool,
      hdop: null == hdop
          ? _value.hdop
          : hdop // ignore: cast_nullable_to_non_nullable
              as bool,
      satellites: null == satellites
          ? _value.satellites
          : satellites // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_InboundPositionStructureCopyWith<$Res>
    implements $InboundPositionStructureCopyWith<$Res> {
  factory _$$_InboundPositionStructureCopyWith(
          _$_InboundPositionStructure value,
          $Res Function(_$_InboundPositionStructure) then) =
      __$$_InboundPositionStructureCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool latitude,
      bool longitude,
      bool altitude,
      bool speed,
      bool direction,
      bool hdop,
      bool satellites});
}

/// @nodoc
class __$$_InboundPositionStructureCopyWithImpl<$Res>
    extends _$InboundPositionStructureCopyWithImpl<$Res,
        _$_InboundPositionStructure>
    implements _$$_InboundPositionStructureCopyWith<$Res> {
  __$$_InboundPositionStructureCopyWithImpl(_$_InboundPositionStructure _value,
      $Res Function(_$_InboundPositionStructure) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = null,
    Object? longitude = null,
    Object? altitude = null,
    Object? speed = null,
    Object? direction = null,
    Object? hdop = null,
    Object? satellites = null,
  }) {
    return _then(_$_InboundPositionStructure(
      latitude: null == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as bool,
      longitude: null == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as bool,
      altitude: null == altitude
          ? _value.altitude
          : altitude // ignore: cast_nullable_to_non_nullable
              as bool,
      speed: null == speed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as bool,
      direction: null == direction
          ? _value.direction
          : direction // ignore: cast_nullable_to_non_nullable
              as bool,
      hdop: null == hdop
          ? _value.hdop
          : hdop // ignore: cast_nullable_to_non_nullable
              as bool,
      satellites: null == satellites
          ? _value.satellites
          : satellites // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_InboundPositionStructure implements _InboundPositionStructure {
  const _$_InboundPositionStructure(
      {required this.latitude,
      required this.longitude,
      required this.altitude,
      required this.speed,
      required this.direction,
      required this.hdop,
      required this.satellites});

  factory _$_InboundPositionStructure.fromJson(Map<String, dynamic> json) =>
      _$$_InboundPositionStructureFromJson(json);

  @override
  final bool latitude;
  @override
  final bool longitude;
  @override
  final bool altitude;
  @override
  final bool speed;
  @override
  final bool direction;
  @override
  final bool hdop;
  @override
  final bool satellites;

  @override
  String toString() {
    return 'InboundPositionStructure(latitude: $latitude, longitude: $longitude, altitude: $altitude, speed: $speed, direction: $direction, hdop: $hdop, satellites: $satellites)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InboundPositionStructure &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude) &&
            (identical(other.altitude, altitude) ||
                other.altitude == altitude) &&
            (identical(other.speed, speed) || other.speed == speed) &&
            (identical(other.direction, direction) ||
                other.direction == direction) &&
            (identical(other.hdop, hdop) || other.hdop == hdop) &&
            (identical(other.satellites, satellites) ||
                other.satellites == satellites));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, latitude, longitude, altitude,
      speed, direction, hdop, satellites);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InboundPositionStructureCopyWith<_$_InboundPositionStructure>
      get copyWith => __$$_InboundPositionStructureCopyWithImpl<
          _$_InboundPositionStructure>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InboundPositionStructureToJson(
      this,
    );
  }
}

abstract class _InboundPositionStructure implements InboundPositionStructure {
  const factory _InboundPositionStructure(
      {required final bool latitude,
      required final bool longitude,
      required final bool altitude,
      required final bool speed,
      required final bool direction,
      required final bool hdop,
      required final bool satellites}) = _$_InboundPositionStructure;

  factory _InboundPositionStructure.fromJson(Map<String, dynamic> json) =
      _$_InboundPositionStructure.fromJson;

  @override
  bool get latitude;
  @override
  bool get longitude;
  @override
  bool get altitude;
  @override
  bool get speed;
  @override
  bool get direction;
  @override
  bool get hdop;
  @override
  bool get satellites;
  @override
  @JsonKey(ignore: true)
  _$$_InboundPositionStructureCopyWith<_$_InboundPositionStructure>
      get copyWith => throw _privateConstructorUsedError;
}

InboundPayloadStructure _$InboundPayloadStructureFromJson(
    Map<String, dynamic> json) {
  return _InboundPayloadStructure.fromJson(json);
}

/// @nodoc
mixin _$InboundPayloadStructure {
  String get field => throw _privateConstructorUsedError;
  @InboundPayloadStructureTypeConverter()
  InboundPayloadStructureType get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $InboundPayloadStructureCopyWith<InboundPayloadStructure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InboundPayloadStructureCopyWith<$Res> {
  factory $InboundPayloadStructureCopyWith(InboundPayloadStructure value,
          $Res Function(InboundPayloadStructure) then) =
      _$InboundPayloadStructureCopyWithImpl<$Res, InboundPayloadStructure>;
  @useResult
  $Res call(
      {String field,
      @InboundPayloadStructureTypeConverter()
      InboundPayloadStructureType type});
}

/// @nodoc
class _$InboundPayloadStructureCopyWithImpl<$Res,
        $Val extends InboundPayloadStructure>
    implements $InboundPayloadStructureCopyWith<$Res> {
  _$InboundPayloadStructureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InboundPayloadStructureType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_InboundPayloadStructureCopyWith<$Res>
    implements $InboundPayloadStructureCopyWith<$Res> {
  factory _$$_InboundPayloadStructureCopyWith(_$_InboundPayloadStructure value,
          $Res Function(_$_InboundPayloadStructure) then) =
      __$$_InboundPayloadStructureCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String field,
      @InboundPayloadStructureTypeConverter()
      InboundPayloadStructureType type});
}

/// @nodoc
class __$$_InboundPayloadStructureCopyWithImpl<$Res>
    extends _$InboundPayloadStructureCopyWithImpl<$Res,
        _$_InboundPayloadStructure>
    implements _$$_InboundPayloadStructureCopyWith<$Res> {
  __$$_InboundPayloadStructureCopyWithImpl(_$_InboundPayloadStructure _value,
      $Res Function(_$_InboundPayloadStructure) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? type = null,
  }) {
    return _then(_$_InboundPayloadStructure(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as InboundPayloadStructureType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_InboundPayloadStructure implements _InboundPayloadStructure {
  const _$_InboundPayloadStructure(
      {required this.field,
      @InboundPayloadStructureTypeConverter() required this.type});

  factory _$_InboundPayloadStructure.fromJson(Map<String, dynamic> json) =>
      _$$_InboundPayloadStructureFromJson(json);

  @override
  final String field;
  @override
  @InboundPayloadStructureTypeConverter()
  final InboundPayloadStructureType type;

  @override
  String toString() {
    return 'InboundPayloadStructure(field: $field, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_InboundPayloadStructure &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, field, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_InboundPayloadStructureCopyWith<_$_InboundPayloadStructure>
      get copyWith =>
          __$$_InboundPayloadStructureCopyWithImpl<_$_InboundPayloadStructure>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_InboundPayloadStructureToJson(
      this,
    );
  }
}

abstract class _InboundPayloadStructure implements InboundPayloadStructure {
  const factory _InboundPayloadStructure(
          {required final String field,
          @InboundPayloadStructureTypeConverter()
          required final InboundPayloadStructureType type}) =
      _$_InboundPayloadStructure;

  factory _InboundPayloadStructure.fromJson(Map<String, dynamic> json) =
      _$_InboundPayloadStructure.fromJson;

  @override
  String get field;
  @override
  @InboundPayloadStructureTypeConverter()
  InboundPayloadStructureType get type;
  @override
  @JsonKey(ignore: true)
  _$$_InboundPayloadStructureCopyWith<_$_InboundPayloadStructure>
      get copyWith => throw _privateConstructorUsedError;
}

Timezone _$TimezoneFromJson(Map<String, dynamic> json) {
  return _Timezone.fromJson(json);
}

/// @nodoc
mixin _$Timezone {
  /// Is the id of the timezone
  String get id => throw _privateConstructorUsedError;

  /// Is the name of the timezone
  /// Example: "Europe/Paris"
  String get name => throw _privateConstructorUsedError;

  /// Is the offset of the timezone
  /// Example: +00:00
  String get offset => throw _privateConstructorUsedError;

  /// Is the country of the timezone
  Country? get country => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TimezoneCopyWith<Timezone> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TimezoneCopyWith<$Res> {
  factory $TimezoneCopyWith(Timezone value, $Res Function(Timezone) then) =
      _$TimezoneCopyWithImpl<$Res, Timezone>;
  @useResult
  $Res call({String id, String name, String offset, Country? country});

  $CountryCopyWith<$Res>? get country;
}

/// @nodoc
class _$TimezoneCopyWithImpl<$Res, $Val extends Timezone>
    implements $TimezoneCopyWith<$Res> {
  _$TimezoneCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? offset = null,
    Object? country = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as String,
      country: freezed == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as Country?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CountryCopyWith<$Res>? get country {
    if (_value.country == null) {
      return null;
    }

    return $CountryCopyWith<$Res>(_value.country!, (value) {
      return _then(_value.copyWith(country: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_TimezoneCopyWith<$Res> implements $TimezoneCopyWith<$Res> {
  factory _$$_TimezoneCopyWith(
          _$_Timezone value, $Res Function(_$_Timezone) then) =
      __$$_TimezoneCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name, String offset, Country? country});

  @override
  $CountryCopyWith<$Res>? get country;
}

/// @nodoc
class __$$_TimezoneCopyWithImpl<$Res>
    extends _$TimezoneCopyWithImpl<$Res, _$_Timezone>
    implements _$$_TimezoneCopyWith<$Res> {
  __$$_TimezoneCopyWithImpl(
      _$_Timezone _value, $Res Function(_$_Timezone) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? offset = null,
    Object? country = freezed,
  }) {
    return _then(_$_Timezone(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as String,
      country: freezed == country
          ? _value.country
          : country // ignore: cast_nullable_to_non_nullable
              as Country?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Timezone implements _Timezone {
  const _$_Timezone(
      {required this.id,
      required this.name,
      required this.offset,
      this.country});

  factory _$_Timezone.fromJson(Map<String, dynamic> json) =>
      _$$_TimezoneFromJson(json);

  /// Is the id of the timezone
  @override
  final String id;

  /// Is the name of the timezone
  /// Example: "Europe/Paris"
  @override
  final String name;

  /// Is the offset of the timezone
  /// Example: +00:00
  @override
  final String offset;

  /// Is the country of the timezone
  @override
  final Country? country;

  @override
  String toString() {
    return 'Timezone(id: $id, name: $name, offset: $offset, country: $country)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Timezone &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.country, country) || other.country == country));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, offset, country);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TimezoneCopyWith<_$_Timezone> get copyWith =>
      __$$_TimezoneCopyWithImpl<_$_Timezone>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TimezoneToJson(
      this,
    );
  }
}

abstract class _Timezone implements Timezone {
  const factory _Timezone(
      {required final String id,
      required final String name,
      required final String offset,
      final Country? country}) = _$_Timezone;

  factory _Timezone.fromJson(Map<String, dynamic> json) = _$_Timezone.fromJson;

  @override

  /// Is the id of the timezone
  String get id;
  @override

  /// Is the name of the timezone
  /// Example: "Europe/Paris"
  String get name;
  @override

  /// Is the offset of the timezone
  /// Example: +00:00
  String get offset;
  @override

  /// Is the country of the timezone
  Country? get country;
  @override
  @JsonKey(ignore: true)
  _$$_TimezoneCopyWith<_$_Timezone> get copyWith =>
      throw _privateConstructorUsedError;
}

LintError _$LintErrorFromJson(Map<String, dynamic> json) {
  return _LintError.fromJson(json);
}

/// @nodoc
mixin _$LintError {
  String get code => throw _privateConstructorUsedError;
  int? get line => throw _privateConstructorUsedError;
  String? get function => throw _privateConstructorUsedError;
  int? get given => throw _privateConstructorUsedError;
  @JsonKey(name: 'required')
  int? get req => throw _privateConstructorUsedError;
  String? get element => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LintErrorCopyWith<LintError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LintErrorCopyWith<$Res> {
  factory $LintErrorCopyWith(LintError value, $Res Function(LintError) then) =
      _$LintErrorCopyWithImpl<$Res, LintError>;
  @useResult
  $Res call(
      {String code,
      int? line,
      String? function,
      int? given,
      @JsonKey(name: 'required') int? req,
      String? element});
}

/// @nodoc
class _$LintErrorCopyWithImpl<$Res, $Val extends LintError>
    implements $LintErrorCopyWith<$Res> {
  _$LintErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? line = freezed,
    Object? function = freezed,
    Object? given = freezed,
    Object? req = freezed,
    Object? element = freezed,
  }) {
    return _then(_value.copyWith(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      line: freezed == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as String?,
      given: freezed == given
          ? _value.given
          : given // ignore: cast_nullable_to_non_nullable
              as int?,
      req: freezed == req
          ? _value.req
          : req // ignore: cast_nullable_to_non_nullable
              as int?,
      element: freezed == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LintErrorCopyWith<$Res> implements $LintErrorCopyWith<$Res> {
  factory _$$_LintErrorCopyWith(
          _$_LintError value, $Res Function(_$_LintError) then) =
      __$$_LintErrorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String code,
      int? line,
      String? function,
      int? given,
      @JsonKey(name: 'required') int? req,
      String? element});
}

/// @nodoc
class __$$_LintErrorCopyWithImpl<$Res>
    extends _$LintErrorCopyWithImpl<$Res, _$_LintError>
    implements _$$_LintErrorCopyWith<$Res> {
  __$$_LintErrorCopyWithImpl(
      _$_LintError _value, $Res Function(_$_LintError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = null,
    Object? line = freezed,
    Object? function = freezed,
    Object? given = freezed,
    Object? req = freezed,
    Object? element = freezed,
  }) {
    return _then(_$_LintError(
      code: null == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      line: freezed == line
          ? _value.line
          : line // ignore: cast_nullable_to_non_nullable
              as int?,
      function: freezed == function
          ? _value.function
          : function // ignore: cast_nullable_to_non_nullable
              as String?,
      given: freezed == given
          ? _value.given
          : given // ignore: cast_nullable_to_non_nullable
              as int?,
      req: freezed == req
          ? _value.req
          : req // ignore: cast_nullable_to_non_nullable
              as int?,
      element: freezed == element
          ? _value.element
          : element // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LintError implements _LintError {
  const _$_LintError(
      {required this.code,
      this.line,
      this.function,
      this.given,
      @JsonKey(name: 'required') this.req,
      this.element});

  factory _$_LintError.fromJson(Map<String, dynamic> json) =>
      _$$_LintErrorFromJson(json);

  @override
  final String code;
  @override
  final int? line;
  @override
  final String? function;
  @override
  final int? given;
  @override
  @JsonKey(name: 'required')
  final int? req;
  @override
  final String? element;

  @override
  String toString() {
    return 'LintError(code: $code, line: $line, function: $function, given: $given, req: $req, element: $element)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LintError &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.line, line) || other.line == line) &&
            (identical(other.function, function) ||
                other.function == function) &&
            (identical(other.given, given) || other.given == given) &&
            (identical(other.req, req) || other.req == req) &&
            (identical(other.element, element) || other.element == element));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, code, line, function, given, req, element);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LintErrorCopyWith<_$_LintError> get copyWith =>
      __$$_LintErrorCopyWithImpl<_$_LintError>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LintErrorToJson(
      this,
    );
  }
}

abstract class _LintError implements LintError {
  const factory _LintError(
      {required final String code,
      final int? line,
      final String? function,
      final int? given,
      @JsonKey(name: 'required') final int? req,
      final String? element}) = _$_LintError;

  factory _LintError.fromJson(Map<String, dynamic> json) =
      _$_LintError.fromJson;

  @override
  String get code;
  @override
  int? get line;
  @override
  String? get function;
  @override
  int? get given;
  @override
  @JsonKey(name: 'required')
  int? get req;
  @override
  String? get element;
  @override
  @JsonKey(ignore: true)
  _$$_LintErrorCopyWith<_$_LintError> get copyWith =>
      throw _privateConstructorUsedError;
}

Operation _$OperationFromJson(Map<String, dynamic> json) {
  return _Operation.fromJson(json);
}

/// @nodoc
mixin _$Operation {
  /// Is the ID of the operation.
  String get id => throw _privateConstructorUsedError;

  /// Is the name of the operation.
  String get name => throw _privateConstructorUsedError;

  /// Is the type of operation.
  @OperationTypeConverter()
  OperationType get operationType => throw _privateConstructorUsedError;

  /// Is the HTTP Request type to perform, only available for [OperationType.webhook].
  @HttpRequestTypeOrNullConverter()
  HttpRequestType? get requestType => throw _privateConstructorUsedError;

  /// Is the URL to perform the request, only available for [OperationType.webhook].
  String? get url => throw _privateConstructorUsedError;

  /// Is the headers to send in the HTTP request, only available for [OperationType.webhook].
  List<HttpHeader>? get headers => throw _privateConstructorUsedError;

  /// Is the payload to send in the submission.
  String? get payload => throw _privateConstructorUsedError;

  /// Is the language ID of the message. Used to define the default language of the message.
  String? get languageId => throw _privateConstructorUsedError;

  /// [timezone] Is the timezone of the message. Used to define the default timezone of the message.
  Timezone? get timezone => throw _privateConstructorUsedError;

  /// [timezoneId] is the timezone ID of the message. Used to define the default timezone of the message.
  String? get timezoneId => throw _privateConstructorUsedError;

  /// Is the reception email to send the message, only available for [OperationType.email].
  List<String>? get receptionEmails => throw _privateConstructorUsedError;

  /// Is the subject of the email, only available for [OperationType.email].
  String? get emailSubject => throw _privateConstructorUsedError;

  /// Is the color of the inline notification. Only available for [OperationType.inAppNotification].
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  /// Is the text color of the inline notification. Only available for [OperationType.inAppNotification].
  @ColorOrNullConverter()
  Color? get textColor => throw _privateConstructorUsedError;

  /// Is the receiver numbers to send the message, only available for [OperationType.twilio].
  List<PhoneNumber>? get destinationPhones =>
      throw _privateConstructorUsedError;

  /// Is the Notification type to perform, only available for [OperationType.twilio].
  @NotificationTypeOrNullConverter()
  NotificationType? get notificationType => throw _privateConstructorUsedError;

  /// The [externalAccountId] of the operation. Only the ID
  String? get externalAccountId => throw _privateConstructorUsedError;

  /// Is the list of granted access of the operation.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// Is the list of associated triggers (directly or indirectly) of the operation.
  List<Trigger>? get triggers => throw _privateConstructorUsedError;

  /// [useAssetContactsInstead] is a flag to use the asset contacts instead of the submission contacts.
  bool? get useAssetContactsInstead => throw _privateConstructorUsedError;

  /// [attachImage] is a flag to attach the image of the submission to the email.
  bool? get attachImage => throw _privateConstructorUsedError;

  /// The [emailTemplateId] of the operation. Only the ID
  String? get emailTemplateId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OperationCopyWith<Operation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperationCopyWith<$Res> {
  factory $OperationCopyWith(Operation value, $Res Function(Operation) then) =
      _$OperationCopyWithImpl<$Res, Operation>;
  @useResult
  $Res call(
      {String id,
      String name,
      @OperationTypeConverter() OperationType operationType,
      @HttpRequestTypeOrNullConverter() HttpRequestType? requestType,
      String? url,
      List<HttpHeader>? headers,
      String? payload,
      String? languageId,
      Timezone? timezone,
      String? timezoneId,
      List<String>? receptionEmails,
      String? emailSubject,
      @ColorOrNullConverter() Color? color,
      @ColorOrNullConverter() Color? textColor,
      List<PhoneNumber>? destinationPhones,
      @NotificationTypeOrNullConverter() NotificationType? notificationType,
      String? externalAccountId,
      List<Access>? access,
      List<Trigger>? triggers,
      bool? useAssetContactsInstead,
      bool? attachImage,
      String? emailTemplateId});

  $TimezoneCopyWith<$Res>? get timezone;
}

/// @nodoc
class _$OperationCopyWithImpl<$Res, $Val extends Operation>
    implements $OperationCopyWith<$Res> {
  _$OperationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? operationType = null,
    Object? requestType = freezed,
    Object? url = freezed,
    Object? headers = freezed,
    Object? payload = freezed,
    Object? languageId = freezed,
    Object? timezone = freezed,
    Object? timezoneId = freezed,
    Object? receptionEmails = freezed,
    Object? emailSubject = freezed,
    Object? color = freezed,
    Object? textColor = freezed,
    Object? destinationPhones = freezed,
    Object? notificationType = freezed,
    Object? externalAccountId = freezed,
    Object? access = freezed,
    Object? triggers = freezed,
    Object? useAssetContactsInstead = freezed,
    Object? attachImage = freezed,
    Object? emailTemplateId = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      operationType: null == operationType
          ? _value.operationType
          : operationType // ignore: cast_nullable_to_non_nullable
              as OperationType,
      requestType: freezed == requestType
          ? _value.requestType
          : requestType // ignore: cast_nullable_to_non_nullable
              as HttpRequestType?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<HttpHeader>?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as String?,
      languageId: freezed == languageId
          ? _value.languageId
          : languageId // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: freezed == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as Timezone?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      receptionEmails: freezed == receptionEmails
          ? _value.receptionEmails
          : receptionEmails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      emailSubject: freezed == emailSubject
          ? _value.emailSubject
          : emailSubject // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      textColor: freezed == textColor
          ? _value.textColor
          : textColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      destinationPhones: freezed == destinationPhones
          ? _value.destinationPhones
          : destinationPhones // ignore: cast_nullable_to_non_nullable
              as List<PhoneNumber>?,
      notificationType: freezed == notificationType
          ? _value.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationType?,
      externalAccountId: freezed == externalAccountId
          ? _value.externalAccountId
          : externalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      triggers: freezed == triggers
          ? _value.triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      useAssetContactsInstead: freezed == useAssetContactsInstead
          ? _value.useAssetContactsInstead
          : useAssetContactsInstead // ignore: cast_nullable_to_non_nullable
              as bool?,
      attachImage: freezed == attachImage
          ? _value.attachImage
          : attachImage // ignore: cast_nullable_to_non_nullable
              as bool?,
      emailTemplateId: freezed == emailTemplateId
          ? _value.emailTemplateId
          : emailTemplateId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TimezoneCopyWith<$Res>? get timezone {
    if (_value.timezone == null) {
      return null;
    }

    return $TimezoneCopyWith<$Res>(_value.timezone!, (value) {
      return _then(_value.copyWith(timezone: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_OperationCopyWith<$Res> implements $OperationCopyWith<$Res> {
  factory _$$_OperationCopyWith(
          _$_Operation value, $Res Function(_$_Operation) then) =
      __$$_OperationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @OperationTypeConverter() OperationType operationType,
      @HttpRequestTypeOrNullConverter() HttpRequestType? requestType,
      String? url,
      List<HttpHeader>? headers,
      String? payload,
      String? languageId,
      Timezone? timezone,
      String? timezoneId,
      List<String>? receptionEmails,
      String? emailSubject,
      @ColorOrNullConverter() Color? color,
      @ColorOrNullConverter() Color? textColor,
      List<PhoneNumber>? destinationPhones,
      @NotificationTypeOrNullConverter() NotificationType? notificationType,
      String? externalAccountId,
      List<Access>? access,
      List<Trigger>? triggers,
      bool? useAssetContactsInstead,
      bool? attachImage,
      String? emailTemplateId});

  @override
  $TimezoneCopyWith<$Res>? get timezone;
}

/// @nodoc
class __$$_OperationCopyWithImpl<$Res>
    extends _$OperationCopyWithImpl<$Res, _$_Operation>
    implements _$$_OperationCopyWith<$Res> {
  __$$_OperationCopyWithImpl(
      _$_Operation _value, $Res Function(_$_Operation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? operationType = null,
    Object? requestType = freezed,
    Object? url = freezed,
    Object? headers = freezed,
    Object? payload = freezed,
    Object? languageId = freezed,
    Object? timezone = freezed,
    Object? timezoneId = freezed,
    Object? receptionEmails = freezed,
    Object? emailSubject = freezed,
    Object? color = freezed,
    Object? textColor = freezed,
    Object? destinationPhones = freezed,
    Object? notificationType = freezed,
    Object? externalAccountId = freezed,
    Object? access = freezed,
    Object? triggers = freezed,
    Object? useAssetContactsInstead = freezed,
    Object? attachImage = freezed,
    Object? emailTemplateId = freezed,
  }) {
    return _then(_$_Operation(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      operationType: null == operationType
          ? _value.operationType
          : operationType // ignore: cast_nullable_to_non_nullable
              as OperationType,
      requestType: freezed == requestType
          ? _value.requestType
          : requestType // ignore: cast_nullable_to_non_nullable
              as HttpRequestType?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      headers: freezed == headers
          ? _value._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<HttpHeader>?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as String?,
      languageId: freezed == languageId
          ? _value.languageId
          : languageId // ignore: cast_nullable_to_non_nullable
              as String?,
      timezone: freezed == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as Timezone?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      receptionEmails: freezed == receptionEmails
          ? _value._receptionEmails
          : receptionEmails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      emailSubject: freezed == emailSubject
          ? _value.emailSubject
          : emailSubject // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      textColor: freezed == textColor
          ? _value.textColor
          : textColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      destinationPhones: freezed == destinationPhones
          ? _value._destinationPhones
          : destinationPhones // ignore: cast_nullable_to_non_nullable
              as List<PhoneNumber>?,
      notificationType: freezed == notificationType
          ? _value.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationType?,
      externalAccountId: freezed == externalAccountId
          ? _value.externalAccountId
          : externalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      triggers: freezed == triggers
          ? _value._triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      useAssetContactsInstead: freezed == useAssetContactsInstead
          ? _value.useAssetContactsInstead
          : useAssetContactsInstead // ignore: cast_nullable_to_non_nullable
              as bool?,
      attachImage: freezed == attachImage
          ? _value.attachImage
          : attachImage // ignore: cast_nullable_to_non_nullable
              as bool?,
      emailTemplateId: freezed == emailTemplateId
          ? _value.emailTemplateId
          : emailTemplateId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Operation implements _Operation {
  const _$_Operation(
      {required this.id,
      required this.name,
      @OperationTypeConverter() required this.operationType,
      @HttpRequestTypeOrNullConverter() this.requestType,
      this.url,
      final List<HttpHeader>? headers = const [],
      this.payload,
      this.languageId,
      this.timezone,
      this.timezoneId,
      final List<String>? receptionEmails = const [],
      this.emailSubject,
      @ColorOrNullConverter() this.color,
      @ColorOrNullConverter() this.textColor,
      final List<PhoneNumber>? destinationPhones,
      @NotificationTypeOrNullConverter() this.notificationType,
      this.externalAccountId,
      final List<Access>? access,
      final List<Trigger>? triggers,
      this.useAssetContactsInstead,
      this.attachImage,
      this.emailTemplateId})
      : _headers = headers,
        _receptionEmails = receptionEmails,
        _destinationPhones = destinationPhones,
        _access = access,
        _triggers = triggers;

  factory _$_Operation.fromJson(Map<String, dynamic> json) =>
      _$$_OperationFromJson(json);

  /// Is the ID of the operation.
  @override
  final String id;

  /// Is the name of the operation.
  @override
  final String name;

  /// Is the type of operation.
  @override
  @OperationTypeConverter()
  final OperationType operationType;

  /// Is the HTTP Request type to perform, only available for [OperationType.webhook].
  @override
  @HttpRequestTypeOrNullConverter()
  final HttpRequestType? requestType;

  /// Is the URL to perform the request, only available for [OperationType.webhook].
  @override
  final String? url;

  /// Is the headers to send in the HTTP request, only available for [OperationType.webhook].
  final List<HttpHeader>? _headers;

  /// Is the headers to send in the HTTP request, only available for [OperationType.webhook].
  @override
  @JsonKey()
  List<HttpHeader>? get headers {
    final value = _headers;
    if (value == null) return null;
    if (_headers is EqualUnmodifiableListView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the payload to send in the submission.
  @override
  final String? payload;

  /// Is the language ID of the message. Used to define the default language of the message.
  @override
  final String? languageId;

  /// [timezone] Is the timezone of the message. Used to define the default timezone of the message.
  @override
  final Timezone? timezone;

  /// [timezoneId] is the timezone ID of the message. Used to define the default timezone of the message.
  @override
  final String? timezoneId;

  /// Is the reception email to send the message, only available for [OperationType.email].
  final List<String>? _receptionEmails;

  /// Is the reception email to send the message, only available for [OperationType.email].
  @override
  @JsonKey()
  List<String>? get receptionEmails {
    final value = _receptionEmails;
    if (value == null) return null;
    if (_receptionEmails is EqualUnmodifiableListView) return _receptionEmails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the subject of the email, only available for [OperationType.email].
  @override
  final String? emailSubject;

  /// Is the color of the inline notification. Only available for [OperationType.inAppNotification].
  @override
  @ColorOrNullConverter()
  final Color? color;

  /// Is the text color of the inline notification. Only available for [OperationType.inAppNotification].
  @override
  @ColorOrNullConverter()
  final Color? textColor;

  /// Is the receiver numbers to send the message, only available for [OperationType.twilio].
  final List<PhoneNumber>? _destinationPhones;

  /// Is the receiver numbers to send the message, only available for [OperationType.twilio].
  @override
  List<PhoneNumber>? get destinationPhones {
    final value = _destinationPhones;
    if (value == null) return null;
    if (_destinationPhones is EqualUnmodifiableListView)
      return _destinationPhones;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the Notification type to perform, only available for [OperationType.twilio].
  @override
  @NotificationTypeOrNullConverter()
  final NotificationType? notificationType;

  /// The [externalAccountId] of the operation. Only the ID
  @override
  final String? externalAccountId;

  /// Is the list of granted access of the operation.
  final List<Access>? _access;

  /// Is the list of granted access of the operation.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of associated triggers (directly or indirectly) of the operation.
  final List<Trigger>? _triggers;

  /// Is the list of associated triggers (directly or indirectly) of the operation.
  @override
  List<Trigger>? get triggers {
    final value = _triggers;
    if (value == null) return null;
    if (_triggers is EqualUnmodifiableListView) return _triggers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [useAssetContactsInstead] is a flag to use the asset contacts instead of the submission contacts.
  @override
  final bool? useAssetContactsInstead;

  /// [attachImage] is a flag to attach the image of the submission to the email.
  @override
  final bool? attachImage;

  /// The [emailTemplateId] of the operation. Only the ID
  @override
  final String? emailTemplateId;

  @override
  String toString() {
    return 'Operation(id: $id, name: $name, operationType: $operationType, requestType: $requestType, url: $url, headers: $headers, payload: $payload, languageId: $languageId, timezone: $timezone, timezoneId: $timezoneId, receptionEmails: $receptionEmails, emailSubject: $emailSubject, color: $color, textColor: $textColor, destinationPhones: $destinationPhones, notificationType: $notificationType, externalAccountId: $externalAccountId, access: $access, triggers: $triggers, useAssetContactsInstead: $useAssetContactsInstead, attachImage: $attachImage, emailTemplateId: $emailTemplateId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Operation &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.operationType, operationType) ||
                other.operationType == operationType) &&
            (identical(other.requestType, requestType) ||
                other.requestType == requestType) &&
            (identical(other.url, url) || other.url == url) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            (identical(other.payload, payload) || other.payload == payload) &&
            (identical(other.languageId, languageId) ||
                other.languageId == languageId) &&
            (identical(other.timezone, timezone) ||
                other.timezone == timezone) &&
            (identical(other.timezoneId, timezoneId) ||
                other.timezoneId == timezoneId) &&
            const DeepCollectionEquality()
                .equals(other._receptionEmails, _receptionEmails) &&
            (identical(other.emailSubject, emailSubject) ||
                other.emailSubject == emailSubject) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.textColor, textColor) ||
                other.textColor == textColor) &&
            const DeepCollectionEquality()
                .equals(other._destinationPhones, _destinationPhones) &&
            (identical(other.notificationType, notificationType) ||
                other.notificationType == notificationType) &&
            (identical(other.externalAccountId, externalAccountId) ||
                other.externalAccountId == externalAccountId) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            const DeepCollectionEquality().equals(other._triggers, _triggers) &&
            (identical(
                    other.useAssetContactsInstead, useAssetContactsInstead) ||
                other.useAssetContactsInstead == useAssetContactsInstead) &&
            (identical(other.attachImage, attachImage) ||
                other.attachImage == attachImage) &&
            (identical(other.emailTemplateId, emailTemplateId) ||
                other.emailTemplateId == emailTemplateId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        operationType,
        requestType,
        url,
        const DeepCollectionEquality().hash(_headers),
        payload,
        languageId,
        timezone,
        timezoneId,
        const DeepCollectionEquality().hash(_receptionEmails),
        emailSubject,
        color,
        textColor,
        const DeepCollectionEquality().hash(_destinationPhones),
        notificationType,
        externalAccountId,
        const DeepCollectionEquality().hash(_access),
        const DeepCollectionEquality().hash(_triggers),
        useAssetContactsInstead,
        attachImage,
        emailTemplateId
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OperationCopyWith<_$_Operation> get copyWith =>
      __$$_OperationCopyWithImpl<_$_Operation>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OperationToJson(
      this,
    );
  }
}

abstract class _Operation implements Operation {
  const factory _Operation(
      {required final String id,
      required final String name,
      @OperationTypeConverter() required final OperationType operationType,
      @HttpRequestTypeOrNullConverter() final HttpRequestType? requestType,
      final String? url,
      final List<HttpHeader>? headers,
      final String? payload,
      final String? languageId,
      final Timezone? timezone,
      final String? timezoneId,
      final List<String>? receptionEmails,
      final String? emailSubject,
      @ColorOrNullConverter() final Color? color,
      @ColorOrNullConverter() final Color? textColor,
      final List<PhoneNumber>? destinationPhones,
      @NotificationTypeOrNullConverter()
      final NotificationType? notificationType,
      final String? externalAccountId,
      final List<Access>? access,
      final List<Trigger>? triggers,
      final bool? useAssetContactsInstead,
      final bool? attachImage,
      final String? emailTemplateId}) = _$_Operation;

  factory _Operation.fromJson(Map<String, dynamic> json) =
      _$_Operation.fromJson;

  @override

  /// Is the ID of the operation.
  String get id;
  @override

  /// Is the name of the operation.
  String get name;
  @override

  /// Is the type of operation.
  @OperationTypeConverter()
  OperationType get operationType;
  @override

  /// Is the HTTP Request type to perform, only available for [OperationType.webhook].
  @HttpRequestTypeOrNullConverter()
  HttpRequestType? get requestType;
  @override

  /// Is the URL to perform the request, only available for [OperationType.webhook].
  String? get url;
  @override

  /// Is the headers to send in the HTTP request, only available for [OperationType.webhook].
  List<HttpHeader>? get headers;
  @override

  /// Is the payload to send in the submission.
  String? get payload;
  @override

  /// Is the language ID of the message. Used to define the default language of the message.
  String? get languageId;
  @override

  /// [timezone] Is the timezone of the message. Used to define the default timezone of the message.
  Timezone? get timezone;
  @override

  /// [timezoneId] is the timezone ID of the message. Used to define the default timezone of the message.
  String? get timezoneId;
  @override

  /// Is the reception email to send the message, only available for [OperationType.email].
  List<String>? get receptionEmails;
  @override

  /// Is the subject of the email, only available for [OperationType.email].
  String? get emailSubject;
  @override

  /// Is the color of the inline notification. Only available for [OperationType.inAppNotification].
  @ColorOrNullConverter()
  Color? get color;
  @override

  /// Is the text color of the inline notification. Only available for [OperationType.inAppNotification].
  @ColorOrNullConverter()
  Color? get textColor;
  @override

  /// Is the receiver numbers to send the message, only available for [OperationType.twilio].
  List<PhoneNumber>? get destinationPhones;
  @override

  /// Is the Notification type to perform, only available for [OperationType.twilio].
  @NotificationTypeOrNullConverter()
  NotificationType? get notificationType;
  @override

  /// The [externalAccountId] of the operation. Only the ID
  String? get externalAccountId;
  @override

  /// Is the list of granted access of the operation.
  List<Access>? get access;
  @override

  /// Is the list of associated triggers (directly or indirectly) of the operation.
  List<Trigger>? get triggers;
  @override

  /// [useAssetContactsInstead] is a flag to use the asset contacts instead of the submission contacts.
  bool? get useAssetContactsInstead;
  @override

  /// [attachImage] is a flag to attach the image of the submission to the email.
  bool? get attachImage;
  @override

  /// The [emailTemplateId] of the operation. Only the ID
  String? get emailTemplateId;
  @override
  @JsonKey(ignore: true)
  _$$_OperationCopyWith<_$_Operation> get copyWith =>
      throw _privateConstructorUsedError;
}

HttpHeader _$HttpHeaderFromJson(Map<String, dynamic> json) {
  return _HttpHeader.fromJson(json);
}

/// @nodoc
mixin _$HttpHeader {
  String get name => throw _privateConstructorUsedError;
  String get value => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $HttpHeaderCopyWith<HttpHeader> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HttpHeaderCopyWith<$Res> {
  factory $HttpHeaderCopyWith(
          HttpHeader value, $Res Function(HttpHeader) then) =
      _$HttpHeaderCopyWithImpl<$Res, HttpHeader>;
  @useResult
  $Res call({String name, String value});
}

/// @nodoc
class _$HttpHeaderCopyWithImpl<$Res, $Val extends HttpHeader>
    implements $HttpHeaderCopyWith<$Res> {
  _$HttpHeaderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_HttpHeaderCopyWith<$Res>
    implements $HttpHeaderCopyWith<$Res> {
  factory _$$_HttpHeaderCopyWith(
          _$_HttpHeader value, $Res Function(_$_HttpHeader) then) =
      __$$_HttpHeaderCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String value});
}

/// @nodoc
class __$$_HttpHeaderCopyWithImpl<$Res>
    extends _$HttpHeaderCopyWithImpl<$Res, _$_HttpHeader>
    implements _$$_HttpHeaderCopyWith<$Res> {
  __$$_HttpHeaderCopyWithImpl(
      _$_HttpHeader _value, $Res Function(_$_HttpHeader) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? value = null,
  }) {
    return _then(_$_HttpHeader(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_HttpHeader implements _HttpHeader {
  const _$_HttpHeader({required this.name, required this.value});

  factory _$_HttpHeader.fromJson(Map<String, dynamic> json) =>
      _$$_HttpHeaderFromJson(json);

  @override
  final String name;
  @override
  final String value;

  @override
  String toString() {
    return 'HttpHeader(name: $name, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_HttpHeader &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.value, value) || other.value == value));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_HttpHeaderCopyWith<_$_HttpHeader> get copyWith =>
      __$$_HttpHeaderCopyWithImpl<_$_HttpHeader>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_HttpHeaderToJson(
      this,
    );
  }
}

abstract class _HttpHeader implements HttpHeader {
  const factory _HttpHeader(
      {required final String name,
      required final String value}) = _$_HttpHeader;

  factory _HttpHeader.fromJson(Map<String, dynamic> json) =
      _$_HttpHeader.fromJson;

  @override
  String get name;
  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_HttpHeaderCopyWith<_$_HttpHeader> get copyWith =>
      throw _privateConstructorUsedError;
}

OperationInput _$OperationInputFromJson(Map<String, dynamic> json) {
  return _OperationInput.fromJson(json);
}

/// @nodoc
mixin _$OperationInput {
  /// Notification color. Only used for "INAPPNOTIFICATION" operation.
  String? get color => throw _privateConstructorUsedError;

  /// Notification color. Only used for "INAPPNOTIFICATION" operation.
  set color(String? value) => throw _privateConstructorUsedError;

  /// Subject of the email sended.
  String? get emailSubject => throw _privateConstructorUsedError;

  /// Subject of the email sended.
  set emailSubject(String? value) => throw _privateConstructorUsedError;

  /// Headers linked to the request, read the documentation of HeaderInput for more details.
  List<HttpHeader>? get headers => throw _privateConstructorUsedError;

  /// Headers linked to the request, read the documentation of HeaderInput for more details.
  set headers(List<HttpHeader>? value) => throw _privateConstructorUsedError;

  /// ID of the operation entity. This ID is unique. Only required for "editOperation" mutation.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the operation entity. This ID is unique. Only required for "editOperation" mutation.
  set id(String? value) => throw _privateConstructorUsedError;

  /// ID of the language for the operation entity. This support multiples languages.
  String? get languageId => throw _privateConstructorUsedError;

  /// ID of the language for the operation entity. This support multiples languages.
  set languageId(String? value) => throw _privateConstructorUsedError;

  /// Identifier of the operation. Should be greater than 3 characteres and less than 255 characters.
  String? get name => throw _privateConstructorUsedError;

  /// Identifier of the operation. Should be greater than 3 characteres and less than 255 characters.
  set name(String? value) => throw _privateConstructorUsedError;

  /// Type of the operation, please read the documentation of OperationType for more information about the operations types.
  @OperationTypeOrNullConverter()
  OperationType? get operationType => throw _privateConstructorUsedError;

  /// Type of the operation, please read the documentation of OperationType for more information about the operations types.
  @OperationTypeOrNullConverter()
  set operationType(OperationType? value) => throw _privateConstructorUsedError;

  /// Body of the request. Here will detail the params for the message event.
  String? get payload => throw _privateConstructorUsedError;

  /// Body of the request. Here will detail the params for the message event.
  set payload(String? value) => throw _privateConstructorUsedError;

  /// List of the reception emails for send the event created.
  List<String>? get receptionEmails => throw _privateConstructorUsedError;

  /// List of the reception emails for send the event created.
  set receptionEmails(List<String>? value) =>
      throw _privateConstructorUsedError;

  /// Type of request method, please read the documentation of RequestType for more information about the requests types.
  @HttpRequestTypeOrNullConverter()
  HttpRequestType? get requestType => throw _privateConstructorUsedError;

  /// Type of request method, please read the documentation of RequestType for more information about the requests types.
  @HttpRequestTypeOrNullConverter()
  set requestType(HttpRequestType? value) => throw _privateConstructorUsedError;

  /// Notification text color. Only used for "INAPPNOTIFICATION" operation.
  String? get textColor => throw _privateConstructorUsedError;

  /// Notification text color. Only used for "INAPPNOTIFICATION" operation.
  set textColor(String? value) => throw _privateConstructorUsedError;

  /// ID of the timezone used by the operation.
  String? get timezoneId => throw _privateConstructorUsedError;

  /// ID of the timezone used by the operation.
  set timezoneId(String? value) => throw _privateConstructorUsedError;

  /// URL of the endpoint for the event.
  String? get url => throw _privateConstructorUsedError;

  /// URL of the endpoint for the event.
  set url(String? value) => throw _privateConstructorUsedError;

  /// List of the receiver numbers for send the event created.
  List<PhoneNumber>? get destinationPhones =>
      throw _privateConstructorUsedError;

  /// List of the receiver numbers for send the event created.
  set destinationPhones(List<PhoneNumber>? value) =>
      throw _privateConstructorUsedError;

  /// Type of notification method, please read the documentation of NotificationType for more information about the notification types.
  @NotificationTypeOrNullConverter()
  NotificationType get notificationType => throw _privateConstructorUsedError;

  /// Type of notification method, please read the documentation of NotificationType for more information about the notification types.
  @NotificationTypeOrNullConverter()
  set notificationType(NotificationType value) =>
      throw _privateConstructorUsedError;

  /// ID of the external account (optional).
  String? get externalAccountId => throw _privateConstructorUsedError;

  /// ID of the external account (optional).
  set externalAccountId(String? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $OperationInputCopyWith<OperationInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperationInputCopyWith<$Res> {
  factory $OperationInputCopyWith(
          OperationInput value, $Res Function(OperationInput) then) =
      _$OperationInputCopyWithImpl<$Res, OperationInput>;
  @useResult
  $Res call(
      {String? color,
      String? emailSubject,
      List<HttpHeader>? headers,
      String? id,
      String? languageId,
      String? name,
      @OperationTypeOrNullConverter() OperationType? operationType,
      String? payload,
      List<String>? receptionEmails,
      @HttpRequestTypeOrNullConverter() HttpRequestType? requestType,
      String? textColor,
      String? timezoneId,
      String? url,
      List<PhoneNumber>? destinationPhones,
      @NotificationTypeOrNullConverter() NotificationType notificationType,
      String? externalAccountId});
}

/// @nodoc
class _$OperationInputCopyWithImpl<$Res, $Val extends OperationInput>
    implements $OperationInputCopyWith<$Res> {
  _$OperationInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
    Object? emailSubject = freezed,
    Object? headers = freezed,
    Object? id = freezed,
    Object? languageId = freezed,
    Object? name = freezed,
    Object? operationType = freezed,
    Object? payload = freezed,
    Object? receptionEmails = freezed,
    Object? requestType = freezed,
    Object? textColor = freezed,
    Object? timezoneId = freezed,
    Object? url = freezed,
    Object? destinationPhones = freezed,
    Object? notificationType = null,
    Object? externalAccountId = freezed,
  }) {
    return _then(_value.copyWith(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      emailSubject: freezed == emailSubject
          ? _value.emailSubject
          : emailSubject // ignore: cast_nullable_to_non_nullable
              as String?,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<HttpHeader>?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      languageId: freezed == languageId
          ? _value.languageId
          : languageId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      operationType: freezed == operationType
          ? _value.operationType
          : operationType // ignore: cast_nullable_to_non_nullable
              as OperationType?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as String?,
      receptionEmails: freezed == receptionEmails
          ? _value.receptionEmails
          : receptionEmails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      requestType: freezed == requestType
          ? _value.requestType
          : requestType // ignore: cast_nullable_to_non_nullable
              as HttpRequestType?,
      textColor: freezed == textColor
          ? _value.textColor
          : textColor // ignore: cast_nullable_to_non_nullable
              as String?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      destinationPhones: freezed == destinationPhones
          ? _value.destinationPhones
          : destinationPhones // ignore: cast_nullable_to_non_nullable
              as List<PhoneNumber>?,
      notificationType: null == notificationType
          ? _value.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationType,
      externalAccountId: freezed == externalAccountId
          ? _value.externalAccountId
          : externalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_OperationInputCopyWith<$Res>
    implements $OperationInputCopyWith<$Res> {
  factory _$$_OperationInputCopyWith(
          _$_OperationInput value, $Res Function(_$_OperationInput) then) =
      __$$_OperationInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? color,
      String? emailSubject,
      List<HttpHeader>? headers,
      String? id,
      String? languageId,
      String? name,
      @OperationTypeOrNullConverter() OperationType? operationType,
      String? payload,
      List<String>? receptionEmails,
      @HttpRequestTypeOrNullConverter() HttpRequestType? requestType,
      String? textColor,
      String? timezoneId,
      String? url,
      List<PhoneNumber>? destinationPhones,
      @NotificationTypeOrNullConverter() NotificationType notificationType,
      String? externalAccountId});
}

/// @nodoc
class __$$_OperationInputCopyWithImpl<$Res>
    extends _$OperationInputCopyWithImpl<$Res, _$_OperationInput>
    implements _$$_OperationInputCopyWith<$Res> {
  __$$_OperationInputCopyWithImpl(
      _$_OperationInput _value, $Res Function(_$_OperationInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = freezed,
    Object? emailSubject = freezed,
    Object? headers = freezed,
    Object? id = freezed,
    Object? languageId = freezed,
    Object? name = freezed,
    Object? operationType = freezed,
    Object? payload = freezed,
    Object? receptionEmails = freezed,
    Object? requestType = freezed,
    Object? textColor = freezed,
    Object? timezoneId = freezed,
    Object? url = freezed,
    Object? destinationPhones = freezed,
    Object? notificationType = null,
    Object? externalAccountId = freezed,
  }) {
    return _then(_$_OperationInput(
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      emailSubject: freezed == emailSubject
          ? _value.emailSubject
          : emailSubject // ignore: cast_nullable_to_non_nullable
              as String?,
      headers: freezed == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as List<HttpHeader>?,
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      languageId: freezed == languageId
          ? _value.languageId
          : languageId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      operationType: freezed == operationType
          ? _value.operationType
          : operationType // ignore: cast_nullable_to_non_nullable
              as OperationType?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as String?,
      receptionEmails: freezed == receptionEmails
          ? _value.receptionEmails
          : receptionEmails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      requestType: freezed == requestType
          ? _value.requestType
          : requestType // ignore: cast_nullable_to_non_nullable
              as HttpRequestType?,
      textColor: freezed == textColor
          ? _value.textColor
          : textColor // ignore: cast_nullable_to_non_nullable
              as String?,
      timezoneId: freezed == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      destinationPhones: freezed == destinationPhones
          ? _value.destinationPhones
          : destinationPhones // ignore: cast_nullable_to_non_nullable
              as List<PhoneNumber>?,
      notificationType: null == notificationType
          ? _value.notificationType
          : notificationType // ignore: cast_nullable_to_non_nullable
              as NotificationType,
      externalAccountId: freezed == externalAccountId
          ? _value.externalAccountId
          : externalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_OperationInput implements _OperationInput {
  _$_OperationInput(
      {this.color,
      this.emailSubject,
      this.headers = const [],
      this.id,
      this.languageId,
      this.name,
      @OperationTypeOrNullConverter() this.operationType,
      this.payload,
      this.receptionEmails,
      @HttpRequestTypeOrNullConverter() this.requestType,
      this.textColor,
      this.timezoneId,
      this.url,
      this.destinationPhones = const [],
      @NotificationTypeOrNullConverter()
      this.notificationType = NotificationType.sms,
      this.externalAccountId});

  factory _$_OperationInput.fromJson(Map<String, dynamic> json) =>
      _$$_OperationInputFromJson(json);

  /// Notification color. Only used for "INAPPNOTIFICATION" operation.
  @override
  String? color;

  /// Subject of the email sended.
  @override
  String? emailSubject;

  /// Headers linked to the request, read the documentation of HeaderInput for more details.
  @override
  @JsonKey()
  List<HttpHeader>? headers;

  /// ID of the operation entity. This ID is unique. Only required for "editOperation" mutation.
  @override
  String? id;

  /// ID of the language for the operation entity. This support multiples languages.
  @override
  String? languageId;

  /// Identifier of the operation. Should be greater than 3 characteres and less than 255 characters.
  @override
  String? name;

  /// Type of the operation, please read the documentation of OperationType for more information about the operations types.
  @override
  @OperationTypeOrNullConverter()
  OperationType? operationType;

  /// Body of the request. Here will detail the params for the message event.
  @override
  String? payload;

  /// List of the reception emails for send the event created.
  @override
  List<String>? receptionEmails;

  /// Type of request method, please read the documentation of RequestType for more information about the requests types.
  @override
  @HttpRequestTypeOrNullConverter()
  HttpRequestType? requestType;

  /// Notification text color. Only used for "INAPPNOTIFICATION" operation.
  @override
  String? textColor;

  /// ID of the timezone used by the operation.
  @override
  String? timezoneId;

  /// URL of the endpoint for the event.
  @override
  String? url;

  /// List of the receiver numbers for send the event created.
  @override
  @JsonKey()
  List<PhoneNumber>? destinationPhones;

  /// Type of notification method, please read the documentation of NotificationType for more information about the notification types.
  @override
  @JsonKey()
  @NotificationTypeOrNullConverter()
  NotificationType notificationType;

  /// ID of the external account (optional).
  @override
  String? externalAccountId;

  @override
  String toString() {
    return 'OperationInput(color: $color, emailSubject: $emailSubject, headers: $headers, id: $id, languageId: $languageId, name: $name, operationType: $operationType, payload: $payload, receptionEmails: $receptionEmails, requestType: $requestType, textColor: $textColor, timezoneId: $timezoneId, url: $url, destinationPhones: $destinationPhones, notificationType: $notificationType, externalAccountId: $externalAccountId)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_OperationInputCopyWith<_$_OperationInput> get copyWith =>
      __$$_OperationInputCopyWithImpl<_$_OperationInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_OperationInputToJson(
      this,
    );
  }
}

abstract class _OperationInput implements OperationInput {
  factory _OperationInput(
      {String? color,
      String? emailSubject,
      List<HttpHeader>? headers,
      String? id,
      String? languageId,
      String? name,
      @OperationTypeOrNullConverter() OperationType? operationType,
      String? payload,
      List<String>? receptionEmails,
      @HttpRequestTypeOrNullConverter() HttpRequestType? requestType,
      String? textColor,
      String? timezoneId,
      String? url,
      List<PhoneNumber>? destinationPhones,
      @NotificationTypeOrNullConverter() NotificationType notificationType,
      String? externalAccountId}) = _$_OperationInput;

  factory _OperationInput.fromJson(Map<String, dynamic> json) =
      _$_OperationInput.fromJson;

  @override

  /// Notification color. Only used for "INAPPNOTIFICATION" operation.
  String? get color;

  /// Notification color. Only used for "INAPPNOTIFICATION" operation.
  set color(String? value);
  @override

  /// Subject of the email sended.
  String? get emailSubject;

  /// Subject of the email sended.
  set emailSubject(String? value);
  @override

  /// Headers linked to the request, read the documentation of HeaderInput for more details.
  List<HttpHeader>? get headers;

  /// Headers linked to the request, read the documentation of HeaderInput for more details.
  set headers(List<HttpHeader>? value);
  @override

  /// ID of the operation entity. This ID is unique. Only required for "editOperation" mutation.
  String? get id;

  /// ID of the operation entity. This ID is unique. Only required for "editOperation" mutation.
  set id(String? value);
  @override

  /// ID of the language for the operation entity. This support multiples languages.
  String? get languageId;

  /// ID of the language for the operation entity. This support multiples languages.
  set languageId(String? value);
  @override

  /// Identifier of the operation. Should be greater than 3 characteres and less than 255 characters.
  String? get name;

  /// Identifier of the operation. Should be greater than 3 characteres and less than 255 characters.
  set name(String? value);
  @override

  /// Type of the operation, please read the documentation of OperationType for more information about the operations types.
  @OperationTypeOrNullConverter()
  OperationType? get operationType;

  /// Type of the operation, please read the documentation of OperationType for more information about the operations types.
  @OperationTypeOrNullConverter()
  set operationType(OperationType? value);
  @override

  /// Body of the request. Here will detail the params for the message event.
  String? get payload;

  /// Body of the request. Here will detail the params for the message event.
  set payload(String? value);
  @override

  /// List of the reception emails for send the event created.
  List<String>? get receptionEmails;

  /// List of the reception emails for send the event created.
  set receptionEmails(List<String>? value);
  @override

  /// Type of request method, please read the documentation of RequestType for more information about the requests types.
  @HttpRequestTypeOrNullConverter()
  HttpRequestType? get requestType;

  /// Type of request method, please read the documentation of RequestType for more information about the requests types.
  @HttpRequestTypeOrNullConverter()
  set requestType(HttpRequestType? value);
  @override

  /// Notification text color. Only used for "INAPPNOTIFICATION" operation.
  String? get textColor;

  /// Notification text color. Only used for "INAPPNOTIFICATION" operation.
  set textColor(String? value);
  @override

  /// ID of the timezone used by the operation.
  String? get timezoneId;

  /// ID of the timezone used by the operation.
  set timezoneId(String? value);
  @override

  /// URL of the endpoint for the event.
  String? get url;

  /// URL of the endpoint for the event.
  set url(String? value);
  @override

  /// List of the receiver numbers for send the event created.
  List<PhoneNumber>? get destinationPhones;

  /// List of the receiver numbers for send the event created.
  set destinationPhones(List<PhoneNumber>? value);
  @override

  /// Type of notification method, please read the documentation of NotificationType for more information about the notification types.
  @NotificationTypeOrNullConverter()
  NotificationType get notificationType;

  /// Type of notification method, please read the documentation of NotificationType for more information about the notification types.
  @NotificationTypeOrNullConverter()
  set notificationType(NotificationType value);
  @override

  /// ID of the external account (optional).
  String? get externalAccountId;

  /// ID of the external account (optional).
  set externalAccountId(String? value);
  @override
  @JsonKey(ignore: true)
  _$$_OperationInputCopyWith<_$_OperationInput> get copyWith =>
      throw _privateConstructorUsedError;
}

Action _$ActionFromJson(Map<String, dynamic> json) {
  return _Action.fromJson(json);
}

/// @nodoc
mixin _$Action {
  /// Is the ID of the action.
  String get id => throw _privateConstructorUsedError;

  /// Is the name of the action.
  String get name => throw _privateConstructorUsedError;

  /// Is the type of the action.
  @ActionTypeConverter()
  ActionType get kind => throw _privateConstructorUsedError;

  /// Is the subtype of the action.
  @ActionSubtypeConverter()
  ActionSubtype get subkind => throw _privateConstructorUsedError;

  /// Is the ID of tag to perform commands.
  String? get commandId => throw _privateConstructorUsedError;

  /// Is the list of Triggers or triggers' IDs.
  List<Trigger>? get triggers => throw _privateConstructorUsedError;
  List<String>? get triggersIds => throw _privateConstructorUsedError;

  /// Is the list of Outbound Servives or outbound services' IDs.
  List<OutboundService>? get outboundServices =>
      throw _privateConstructorUsedError;
  List<String>? get outboundServicesIds => throw _privateConstructorUsedError;

  /// Is the list of Operations or operations' IDs.
  List<Operation>? get operations => throw _privateConstructorUsedError;
  List<String>? get operationsIds => throw _privateConstructorUsedError;

  /// Is a list of granted access to this entity.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  bool? get watchImage => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ActionCopyWith<Action> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ActionCopyWith<$Res> {
  factory $ActionCopyWith(Action value, $Res Function(Action) then) =
      _$ActionCopyWithImpl<$Res, Action>;
  @useResult
  $Res call(
      {String id,
      String name,
      @ActionTypeConverter() ActionType kind,
      @ActionSubtypeConverter() ActionSubtype subkind,
      String? commandId,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      List<OutboundService>? outboundServices,
      List<String>? outboundServicesIds,
      List<Operation>? operations,
      List<String>? operationsIds,
      List<Access>? access,
      bool? watchImage});
}

/// @nodoc
class _$ActionCopyWithImpl<$Res, $Val extends Action>
    implements $ActionCopyWith<$Res> {
  _$ActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? kind = null,
    Object? subkind = null,
    Object? commandId = freezed,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? outboundServices = freezed,
    Object? outboundServicesIds = freezed,
    Object? operations = freezed,
    Object? operationsIds = freezed,
    Object? access = freezed,
    Object? watchImage = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as ActionType,
      subkind: null == subkind
          ? _value.subkind
          : subkind // ignore: cast_nullable_to_non_nullable
              as ActionSubtype,
      commandId: freezed == commandId
          ? _value.commandId
          : commandId // ignore: cast_nullable_to_non_nullable
              as String?,
      triggers: freezed == triggers
          ? _value.triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value.triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServices: freezed == outboundServices
          ? _value.outboundServices
          : outboundServices // ignore: cast_nullable_to_non_nullable
              as List<OutboundService>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value.outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      operations: freezed == operations
          ? _value.operations
          : operations // ignore: cast_nullable_to_non_nullable
              as List<Operation>?,
      operationsIds: freezed == operationsIds
          ? _value.operationsIds
          : operationsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      watchImage: freezed == watchImage
          ? _value.watchImage
          : watchImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ActionCopyWith<$Res> implements $ActionCopyWith<$Res> {
  factory _$$_ActionCopyWith(_$_Action value, $Res Function(_$_Action) then) =
      __$$_ActionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @ActionTypeConverter() ActionType kind,
      @ActionSubtypeConverter() ActionSubtype subkind,
      String? commandId,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      List<OutboundService>? outboundServices,
      List<String>? outboundServicesIds,
      List<Operation>? operations,
      List<String>? operationsIds,
      List<Access>? access,
      bool? watchImage});
}

/// @nodoc
class __$$_ActionCopyWithImpl<$Res>
    extends _$ActionCopyWithImpl<$Res, _$_Action>
    implements _$$_ActionCopyWith<$Res> {
  __$$_ActionCopyWithImpl(_$_Action _value, $Res Function(_$_Action) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? kind = null,
    Object? subkind = null,
    Object? commandId = freezed,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? outboundServices = freezed,
    Object? outboundServicesIds = freezed,
    Object? operations = freezed,
    Object? operationsIds = freezed,
    Object? access = freezed,
    Object? watchImage = freezed,
  }) {
    return _then(_$_Action(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as ActionType,
      subkind: null == subkind
          ? _value.subkind
          : subkind // ignore: cast_nullable_to_non_nullable
              as ActionSubtype,
      commandId: freezed == commandId
          ? _value.commandId
          : commandId // ignore: cast_nullable_to_non_nullable
              as String?,
      triggers: freezed == triggers
          ? _value._triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value._triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServices: freezed == outboundServices
          ? _value._outboundServices
          : outboundServices // ignore: cast_nullable_to_non_nullable
              as List<OutboundService>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value._outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      operations: freezed == operations
          ? _value._operations
          : operations // ignore: cast_nullable_to_non_nullable
              as List<Operation>?,
      operationsIds: freezed == operationsIds
          ? _value._operationsIds
          : operationsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      watchImage: freezed == watchImage
          ? _value.watchImage
          : watchImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Action implements _Action {
  const _$_Action(
      {required this.id,
      required this.name,
      @ActionTypeConverter() required this.kind,
      @ActionSubtypeConverter() this.subkind = ActionSubtype.unused,
      this.commandId,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      final List<OutboundService>? outboundServices,
      final List<String>? outboundServicesIds,
      final List<Operation>? operations,
      final List<String>? operationsIds,
      final List<Access>? access,
      this.watchImage})
      : _triggers = triggers,
        _triggersIds = triggersIds,
        _outboundServices = outboundServices,
        _outboundServicesIds = outboundServicesIds,
        _operations = operations,
        _operationsIds = operationsIds,
        _access = access;

  factory _$_Action.fromJson(Map<String, dynamic> json) =>
      _$$_ActionFromJson(json);

  /// Is the ID of the action.
  @override
  final String id;

  /// Is the name of the action.
  @override
  final String name;

  /// Is the type of the action.
  @override
  @ActionTypeConverter()
  final ActionType kind;

  /// Is the subtype of the action.
  @override
  @JsonKey()
  @ActionSubtypeConverter()
  final ActionSubtype subkind;

  /// Is the ID of tag to perform commands.
  @override
  final String? commandId;

  /// Is the list of Triggers or triggers' IDs.
  final List<Trigger>? _triggers;

  /// Is the list of Triggers or triggers' IDs.
  @override
  List<Trigger>? get triggers {
    final value = _triggers;
    if (value == null) return null;
    if (_triggers is EqualUnmodifiableListView) return _triggers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _triggersIds;
  @override
  List<String>? get triggersIds {
    final value = _triggersIds;
    if (value == null) return null;
    if (_triggersIds is EqualUnmodifiableListView) return _triggersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of Outbound Servives or outbound services' IDs.
  final List<OutboundService>? _outboundServices;

  /// Is the list of Outbound Servives or outbound services' IDs.
  @override
  List<OutboundService>? get outboundServices {
    final value = _outboundServices;
    if (value == null) return null;
    if (_outboundServices is EqualUnmodifiableListView)
      return _outboundServices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _outboundServicesIds;
  @override
  List<String>? get outboundServicesIds {
    final value = _outboundServicesIds;
    if (value == null) return null;
    if (_outboundServicesIds is EqualUnmodifiableListView)
      return _outboundServicesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of Operations or operations' IDs.
  final List<Operation>? _operations;

  /// Is the list of Operations or operations' IDs.
  @override
  List<Operation>? get operations {
    final value = _operations;
    if (value == null) return null;
    if (_operations is EqualUnmodifiableListView) return _operations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _operationsIds;
  @override
  List<String>? get operationsIds {
    final value = _operationsIds;
    if (value == null) return null;
    if (_operationsIds is EqualUnmodifiableListView) return _operationsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is a list of granted access to this entity.
  final List<Access>? _access;

  /// Is a list of granted access to this entity.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  @override
  final bool? watchImage;

  @override
  String toString() {
    return 'Action(id: $id, name: $name, kind: $kind, subkind: $subkind, commandId: $commandId, triggers: $triggers, triggersIds: $triggersIds, outboundServices: $outboundServices, outboundServicesIds: $outboundServicesIds, operations: $operations, operationsIds: $operationsIds, access: $access, watchImage: $watchImage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Action &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.kind, kind) || other.kind == kind) &&
            (identical(other.subkind, subkind) || other.subkind == subkind) &&
            (identical(other.commandId, commandId) ||
                other.commandId == commandId) &&
            const DeepCollectionEquality().equals(other._triggers, _triggers) &&
            const DeepCollectionEquality()
                .equals(other._triggersIds, _triggersIds) &&
            const DeepCollectionEquality()
                .equals(other._outboundServices, _outboundServices) &&
            const DeepCollectionEquality()
                .equals(other._outboundServicesIds, _outboundServicesIds) &&
            const DeepCollectionEquality()
                .equals(other._operations, _operations) &&
            const DeepCollectionEquality()
                .equals(other._operationsIds, _operationsIds) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            (identical(other.watchImage, watchImage) ||
                other.watchImage == watchImage));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      kind,
      subkind,
      commandId,
      const DeepCollectionEquality().hash(_triggers),
      const DeepCollectionEquality().hash(_triggersIds),
      const DeepCollectionEquality().hash(_outboundServices),
      const DeepCollectionEquality().hash(_outboundServicesIds),
      const DeepCollectionEquality().hash(_operations),
      const DeepCollectionEquality().hash(_operationsIds),
      const DeepCollectionEquality().hash(_access),
      watchImage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ActionCopyWith<_$_Action> get copyWith =>
      __$$_ActionCopyWithImpl<_$_Action>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ActionToJson(
      this,
    );
  }
}

abstract class _Action implements Action {
  const factory _Action(
      {required final String id,
      required final String name,
      @ActionTypeConverter() required final ActionType kind,
      @ActionSubtypeConverter() final ActionSubtype subkind,
      final String? commandId,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      final List<OutboundService>? outboundServices,
      final List<String>? outboundServicesIds,
      final List<Operation>? operations,
      final List<String>? operationsIds,
      final List<Access>? access,
      final bool? watchImage}) = _$_Action;

  factory _Action.fromJson(Map<String, dynamic> json) = _$_Action.fromJson;

  @override

  /// Is the ID of the action.
  String get id;
  @override

  /// Is the name of the action.
  String get name;
  @override

  /// Is the type of the action.
  @ActionTypeConverter()
  ActionType get kind;
  @override

  /// Is the subtype of the action.
  @ActionSubtypeConverter()
  ActionSubtype get subkind;
  @override

  /// Is the ID of tag to perform commands.
  String? get commandId;
  @override

  /// Is the list of Triggers or triggers' IDs.
  List<Trigger>? get triggers;
  @override
  List<String>? get triggersIds;
  @override

  /// Is the list of Outbound Servives or outbound services' IDs.
  List<OutboundService>? get outboundServices;
  @override
  List<String>? get outboundServicesIds;
  @override

  /// Is the list of Operations or operations' IDs.
  List<Operation>? get operations;
  @override
  List<String>? get operationsIds;
  @override

  /// Is a list of granted access to this entity.
  List<Access>? get access;
  @override

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  bool? get watchImage;
  @override
  @JsonKey(ignore: true)
  _$$_ActionCopyWith<_$_Action> get copyWith =>
      throw _privateConstructorUsedError;
}

ActionInput _$ActionInputFromJson(Map<String, dynamic> json) {
  return _ActionInput.fromJson(json);
}

/// @nodoc
mixin _$ActionInput {
  /// ID of the trigger entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the trigger entity. This ID is unique.
  set id(String? value) => throw _privateConstructorUsedError;

  /// ID of the linked Commands Tag.
  String? get commandId => throw _privateConstructorUsedError;

  /// ID of the linked Commands Tag.
  set commandId(String? value) => throw _privateConstructorUsedError;

  /// Action type, please read the documentation of ActionType for more information about the actions.
  @ActionTypeOrNullConverter()
  ActionType? get kind => throw _privateConstructorUsedError;

  /// Action type, please read the documentation of ActionType for more information about the actions.
  @ActionTypeOrNullConverter()
  set kind(ActionType? value) => throw _privateConstructorUsedError;

  /// Name of the trigger.
  String? get name => throw _privateConstructorUsedError;

  /// Name of the trigger.
  set name(String? value) => throw _privateConstructorUsedError;

  /// List of opearations IDs enabled for handle this action. Only for ActionType.PERFORMOPERATION
  List<String>? get operationsIds => throw _privateConstructorUsedError;

  /// List of opearations IDs enabled for handle this action. Only for ActionType.PERFORMOPERATION
  set operationsIds(List<String>? value) => throw _privateConstructorUsedError;

  /// List of Outbound services IDs to broadcast. Only for ActionType.SENDTOOMEGA
  List<String>? get outboundServicesIds => throw _privateConstructorUsedError;

  /// List of Outbound services IDs to broadcast. Only for ActionType.SENDTOOMEGA
  set outboundServicesIds(List<String>? value) =>
      throw _privateConstructorUsedError;

  /// Subkind
  @ActionSubtypeOrNullConverter()
  ActionSubtype? get subkind => throw _privateConstructorUsedError;

  /// Subkind
  @ActionSubtypeOrNullConverter()
  set subkind(ActionSubtype? value) => throw _privateConstructorUsedError;

  /// List of triggers IDs enabled for handle this action.
  List<String>? get triggersIds => throw _privateConstructorUsedError;

  /// List of triggers IDs enabled for handle this action.
  set triggersIds(List<String>? value) => throw _privateConstructorUsedError;

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  bool? get watchImage => throw _privateConstructorUsedError;

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  set watchImage(bool? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ActionInputCopyWith<ActionInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ActionInputCopyWith<$Res> {
  factory $ActionInputCopyWith(
          ActionInput value, $Res Function(ActionInput) then) =
      _$ActionInputCopyWithImpl<$Res, ActionInput>;
  @useResult
  $Res call(
      {String? id,
      String? commandId,
      @ActionTypeOrNullConverter() ActionType? kind,
      String? name,
      List<String>? operationsIds,
      List<String>? outboundServicesIds,
      @ActionSubtypeOrNullConverter() ActionSubtype? subkind,
      List<String>? triggersIds,
      bool? watchImage});
}

/// @nodoc
class _$ActionInputCopyWithImpl<$Res, $Val extends ActionInput>
    implements $ActionInputCopyWith<$Res> {
  _$ActionInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? commandId = freezed,
    Object? kind = freezed,
    Object? name = freezed,
    Object? operationsIds = freezed,
    Object? outboundServicesIds = freezed,
    Object? subkind = freezed,
    Object? triggersIds = freezed,
    Object? watchImage = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      commandId: freezed == commandId
          ? _value.commandId
          : commandId // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as ActionType?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      operationsIds: freezed == operationsIds
          ? _value.operationsIds
          : operationsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value.outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      subkind: freezed == subkind
          ? _value.subkind
          : subkind // ignore: cast_nullable_to_non_nullable
              as ActionSubtype?,
      triggersIds: freezed == triggersIds
          ? _value.triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      watchImage: freezed == watchImage
          ? _value.watchImage
          : watchImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ActionInputCopyWith<$Res>
    implements $ActionInputCopyWith<$Res> {
  factory _$$_ActionInputCopyWith(
          _$_ActionInput value, $Res Function(_$_ActionInput) then) =
      __$$_ActionInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? commandId,
      @ActionTypeOrNullConverter() ActionType? kind,
      String? name,
      List<String>? operationsIds,
      List<String>? outboundServicesIds,
      @ActionSubtypeOrNullConverter() ActionSubtype? subkind,
      List<String>? triggersIds,
      bool? watchImage});
}

/// @nodoc
class __$$_ActionInputCopyWithImpl<$Res>
    extends _$ActionInputCopyWithImpl<$Res, _$_ActionInput>
    implements _$$_ActionInputCopyWith<$Res> {
  __$$_ActionInputCopyWithImpl(
      _$_ActionInput _value, $Res Function(_$_ActionInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? commandId = freezed,
    Object? kind = freezed,
    Object? name = freezed,
    Object? operationsIds = freezed,
    Object? outboundServicesIds = freezed,
    Object? subkind = freezed,
    Object? triggersIds = freezed,
    Object? watchImage = freezed,
  }) {
    return _then(_$_ActionInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      commandId: freezed == commandId
          ? _value.commandId
          : commandId // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as ActionType?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      operationsIds: freezed == operationsIds
          ? _value.operationsIds
          : operationsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value.outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      subkind: freezed == subkind
          ? _value.subkind
          : subkind // ignore: cast_nullable_to_non_nullable
              as ActionSubtype?,
      triggersIds: freezed == triggersIds
          ? _value.triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      watchImage: freezed == watchImage
          ? _value.watchImage
          : watchImage // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ActionInput implements _ActionInput {
  _$_ActionInput(
      {this.id,
      this.commandId,
      @ActionTypeOrNullConverter() this.kind,
      this.name,
      this.operationsIds = const [],
      this.outboundServicesIds = const [],
      @ActionSubtypeOrNullConverter() this.subkind,
      this.triggersIds = const [],
      this.watchImage = false});

  factory _$_ActionInput.fromJson(Map<String, dynamic> json) =>
      _$$_ActionInputFromJson(json);

  /// ID of the trigger entity. This ID is unique.
  @override
  String? id;

  /// ID of the linked Commands Tag.
  @override
  String? commandId;

  /// Action type, please read the documentation of ActionType for more information about the actions.
  @override
  @ActionTypeOrNullConverter()
  ActionType? kind;

  /// Name of the trigger.
  @override
  String? name;

  /// List of opearations IDs enabled for handle this action. Only for ActionType.PERFORMOPERATION
  @override
  @JsonKey()
  List<String>? operationsIds;

  /// List of Outbound services IDs to broadcast. Only for ActionType.SENDTOOMEGA
  @override
  @JsonKey()
  List<String>? outboundServicesIds;

  /// Subkind
  @override
  @ActionSubtypeOrNullConverter()
  ActionSubtype? subkind;

  /// List of triggers IDs enabled for handle this action.
  @override
  @JsonKey()
  List<String>? triggersIds;

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  @override
  @JsonKey()
  bool? watchImage;

  @override
  String toString() {
    return 'ActionInput(id: $id, commandId: $commandId, kind: $kind, name: $name, operationsIds: $operationsIds, outboundServicesIds: $outboundServicesIds, subkind: $subkind, triggersIds: $triggersIds, watchImage: $watchImage)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ActionInputCopyWith<_$_ActionInput> get copyWith =>
      __$$_ActionInputCopyWithImpl<_$_ActionInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ActionInputToJson(
      this,
    );
  }
}

abstract class _ActionInput implements ActionInput {
  factory _ActionInput(
      {String? id,
      String? commandId,
      @ActionTypeOrNullConverter() ActionType? kind,
      String? name,
      List<String>? operationsIds,
      List<String>? outboundServicesIds,
      @ActionSubtypeOrNullConverter() ActionSubtype? subkind,
      List<String>? triggersIds,
      bool? watchImage}) = _$_ActionInput;

  factory _ActionInput.fromJson(Map<String, dynamic> json) =
      _$_ActionInput.fromJson;

  @override

  /// ID of the trigger entity. This ID is unique.
  String? get id;

  /// ID of the trigger entity. This ID is unique.
  set id(String? value);
  @override

  /// ID of the linked Commands Tag.
  String? get commandId;

  /// ID of the linked Commands Tag.
  set commandId(String? value);
  @override

  /// Action type, please read the documentation of ActionType for more information about the actions.
  @ActionTypeOrNullConverter()
  ActionType? get kind;

  /// Action type, please read the documentation of ActionType for more information about the actions.
  @ActionTypeOrNullConverter()
  set kind(ActionType? value);
  @override

  /// Name of the trigger.
  String? get name;

  /// Name of the trigger.
  set name(String? value);
  @override

  /// List of opearations IDs enabled for handle this action. Only for ActionType.PERFORMOPERATION
  List<String>? get operationsIds;

  /// List of opearations IDs enabled for handle this action. Only for ActionType.PERFORMOPERATION
  set operationsIds(List<String>? value);
  @override

  /// List of Outbound services IDs to broadcast. Only for ActionType.SENDTOOMEGA
  List<String>? get outboundServicesIds;

  /// List of Outbound services IDs to broadcast. Only for ActionType.SENDTOOMEGA
  set outboundServicesIds(List<String>? value);
  @override

  /// Subkind
  @ActionSubtypeOrNullConverter()
  ActionSubtype? get subkind;

  /// Subkind
  @ActionSubtypeOrNullConverter()
  set subkind(ActionSubtype? value);
  @override

  /// List of triggers IDs enabled for handle this action.
  List<String>? get triggersIds;

  /// List of triggers IDs enabled for handle this action.
  set triggersIds(List<String>? value);
  @override

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  bool? get watchImage;

  /// If kind == ActionType.sendToMonitorCenter is true, this field will be used if the arriving data need image convertion.
  set watchImage(bool? value);
  @override
  @JsonKey(ignore: true)
  _$$_ActionInputCopyWith<_$_ActionInput> get copyWith =>
      throw _privateConstructorUsedError;
}

ReportTemplate _$ReportTemplateFromJson(Map<String, dynamic> json) {
  return _ReportTemplate.fromJson(json);
}

/// @nodoc
mixin _$ReportTemplate {
  /// Is the report template ID
  String get id => throw _privateConstructorUsedError;

  /// Is the report template name
  String get name => throw _privateConstructorUsedError;

  /// Structure
  List<ReportTemplatePage>? get structure => throw _privateConstructorUsedError;

  /// Is the report template linked assets or assets' IDs
  List<Asset>? get assets => throw _privateConstructorUsedError;
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  /// Is the report template linked outbound services or outbound services' IDs
  List<OutboundService>? get outboundServices =>
      throw _privateConstructorUsedError;
  List<String>? get outboundServicesIds => throw _privateConstructorUsedError;

  /// Controls the access of this entity.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ReportTemplateCopyWith<ReportTemplate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReportTemplateCopyWith<$Res> {
  factory $ReportTemplateCopyWith(
          ReportTemplate value, $Res Function(ReportTemplate) then) =
      _$ReportTemplateCopyWithImpl<$Res, ReportTemplate>;
  @useResult
  $Res call(
      {String id,
      String name,
      List<ReportTemplatePage>? structure,
      List<Asset>? assets,
      List<String>? assetsIds,
      List<OutboundService>? outboundServices,
      List<String>? outboundServicesIds,
      List<Access>? access});
}

/// @nodoc
class _$ReportTemplateCopyWithImpl<$Res, $Val extends ReportTemplate>
    implements $ReportTemplateCopyWith<$Res> {
  _$ReportTemplateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? structure = freezed,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? outboundServices = freezed,
    Object? outboundServicesIds = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      structure: freezed == structure
          ? _value.structure
          : structure // ignore: cast_nullable_to_non_nullable
              as List<ReportTemplatePage>?,
      assets: freezed == assets
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServices: freezed == outboundServices
          ? _value.outboundServices
          : outboundServices // ignore: cast_nullable_to_non_nullable
              as List<OutboundService>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value.outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ReportTemplateCopyWith<$Res>
    implements $ReportTemplateCopyWith<$Res> {
  factory _$$_ReportTemplateCopyWith(
          _$_ReportTemplate value, $Res Function(_$_ReportTemplate) then) =
      __$$_ReportTemplateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      List<ReportTemplatePage>? structure,
      List<Asset>? assets,
      List<String>? assetsIds,
      List<OutboundService>? outboundServices,
      List<String>? outboundServicesIds,
      List<Access>? access});
}

/// @nodoc
class __$$_ReportTemplateCopyWithImpl<$Res>
    extends _$ReportTemplateCopyWithImpl<$Res, _$_ReportTemplate>
    implements _$$_ReportTemplateCopyWith<$Res> {
  __$$_ReportTemplateCopyWithImpl(
      _$_ReportTemplate _value, $Res Function(_$_ReportTemplate) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? structure = freezed,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? outboundServices = freezed,
    Object? outboundServicesIds = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_ReportTemplate(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      structure: freezed == structure
          ? _value._structure
          : structure // ignore: cast_nullable_to_non_nullable
              as List<ReportTemplatePage>?,
      assets: freezed == assets
          ? _value._assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      outboundServices: freezed == outboundServices
          ? _value._outboundServices
          : outboundServices // ignore: cast_nullable_to_non_nullable
              as List<OutboundService>?,
      outboundServicesIds: freezed == outboundServicesIds
          ? _value._outboundServicesIds
          : outboundServicesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ReportTemplate implements _ReportTemplate {
  const _$_ReportTemplate(
      {required this.id,
      required this.name,
      final List<ReportTemplatePage>? structure,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      final List<OutboundService>? outboundServices,
      final List<String>? outboundServicesIds,
      final List<Access>? access})
      : _structure = structure,
        _assets = assets,
        _assetsIds = assetsIds,
        _outboundServices = outboundServices,
        _outboundServicesIds = outboundServicesIds,
        _access = access;

  factory _$_ReportTemplate.fromJson(Map<String, dynamic> json) =>
      _$$_ReportTemplateFromJson(json);

  /// Is the report template ID
  @override
  final String id;

  /// Is the report template name
  @override
  final String name;

  /// Structure
  final List<ReportTemplatePage>? _structure;

  /// Structure
  @override
  List<ReportTemplatePage>? get structure {
    final value = _structure;
    if (value == null) return null;
    if (_structure is EqualUnmodifiableListView) return _structure;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the report template linked assets or assets' IDs
  final List<Asset>? _assets;

  /// Is the report template linked assets or assets' IDs
  @override
  List<Asset>? get assets {
    final value = _assets;
    if (value == null) return null;
    if (_assets is EqualUnmodifiableListView) return _assets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _assetsIds;
  @override
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the report template linked outbound services or outbound services' IDs
  final List<OutboundService>? _outboundServices;

  /// Is the report template linked outbound services or outbound services' IDs
  @override
  List<OutboundService>? get outboundServices {
    final value = _outboundServices;
    if (value == null) return null;
    if (_outboundServices is EqualUnmodifiableListView)
      return _outboundServices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _outboundServicesIds;
  @override
  List<String>? get outboundServicesIds {
    final value = _outboundServicesIds;
    if (value == null) return null;
    if (_outboundServicesIds is EqualUnmodifiableListView)
      return _outboundServicesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Controls the access of this entity.
  final List<Access>? _access;

  /// Controls the access of this entity.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ReportTemplate(id: $id, name: $name, structure: $structure, assets: $assets, assetsIds: $assetsIds, outboundServices: $outboundServices, outboundServicesIds: $outboundServicesIds, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ReportTemplate &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._structure, _structure) &&
            const DeepCollectionEquality().equals(other._assets, _assets) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds) &&
            const DeepCollectionEquality()
                .equals(other._outboundServices, _outboundServices) &&
            const DeepCollectionEquality()
                .equals(other._outboundServicesIds, _outboundServicesIds) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      const DeepCollectionEquality().hash(_structure),
      const DeepCollectionEquality().hash(_assets),
      const DeepCollectionEquality().hash(_assetsIds),
      const DeepCollectionEquality().hash(_outboundServices),
      const DeepCollectionEquality().hash(_outboundServicesIds),
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ReportTemplateCopyWith<_$_ReportTemplate> get copyWith =>
      __$$_ReportTemplateCopyWithImpl<_$_ReportTemplate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ReportTemplateToJson(
      this,
    );
  }
}

abstract class _ReportTemplate implements ReportTemplate {
  const factory _ReportTemplate(
      {required final String id,
      required final String name,
      final List<ReportTemplatePage>? structure,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      final List<OutboundService>? outboundServices,
      final List<String>? outboundServicesIds,
      final List<Access>? access}) = _$_ReportTemplate;

  factory _ReportTemplate.fromJson(Map<String, dynamic> json) =
      _$_ReportTemplate.fromJson;

  @override

  /// Is the report template ID
  String get id;
  @override

  /// Is the report template name
  String get name;
  @override

  /// Structure
  List<ReportTemplatePage>? get structure;
  @override

  /// Is the report template linked assets or assets' IDs
  List<Asset>? get assets;
  @override
  List<String>? get assetsIds;
  @override

  /// Is the report template linked outbound services or outbound services' IDs
  List<OutboundService>? get outboundServices;
  @override
  List<String>? get outboundServicesIds;
  @override

  /// Controls the access of this entity.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_ReportTemplateCopyWith<_$_ReportTemplate> get copyWith =>
      throw _privateConstructorUsedError;
}

ReportTemplatePage _$ReportTemplatePageFromJson(Map<String, dynamic> json) {
  return _ReportTemplatePage.fromJson(json);
}

/// @nodoc
mixin _$ReportTemplatePage {
  /// Is the page title
  String get title => throw _privateConstructorUsedError;

  /// Is the page source
  @ReportTemplateSourceConverter()
  ReportTemplateSource get source => throw _privateConstructorUsedError;

  /// Is the algorithm used to generate the page data.
  @ReportTemplateAlgorithmConverter()
  ReportTemplateAlgorithm get algorithm => throw _privateConstructorUsedError;

  /// Is the page data, aka, the cols. Only used when [algorithm] is [ReportTemplateAlgorithm.auto]
  List<ReportTemplateCol>? get cols => throw _privateConstructorUsedError;

  /// Is the script in Python to generate the page data. Only used when [algorithm] is [ReportTemplateAlgorithm.python]
  String? get script => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ReportTemplatePageCopyWith<ReportTemplatePage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReportTemplatePageCopyWith<$Res> {
  factory $ReportTemplatePageCopyWith(
          ReportTemplatePage value, $Res Function(ReportTemplatePage) then) =
      _$ReportTemplatePageCopyWithImpl<$Res, ReportTemplatePage>;
  @useResult
  $Res call(
      {String title,
      @ReportTemplateSourceConverter() ReportTemplateSource source,
      @ReportTemplateAlgorithmConverter() ReportTemplateAlgorithm algorithm,
      List<ReportTemplateCol>? cols,
      String? script});
}

/// @nodoc
class _$ReportTemplatePageCopyWithImpl<$Res, $Val extends ReportTemplatePage>
    implements $ReportTemplatePageCopyWith<$Res> {
  _$ReportTemplatePageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? source = null,
    Object? algorithm = null,
    Object? cols = freezed,
    Object? script = freezed,
  }) {
    return _then(_value.copyWith(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ReportTemplateSource,
      algorithm: null == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as ReportTemplateAlgorithm,
      cols: freezed == cols
          ? _value.cols
          : cols // ignore: cast_nullable_to_non_nullable
              as List<ReportTemplateCol>?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ReportTemplatePageCopyWith<$Res>
    implements $ReportTemplatePageCopyWith<$Res> {
  factory _$$_ReportTemplatePageCopyWith(_$_ReportTemplatePage value,
          $Res Function(_$_ReportTemplatePage) then) =
      __$$_ReportTemplatePageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String title,
      @ReportTemplateSourceConverter() ReportTemplateSource source,
      @ReportTemplateAlgorithmConverter() ReportTemplateAlgorithm algorithm,
      List<ReportTemplateCol>? cols,
      String? script});
}

/// @nodoc
class __$$_ReportTemplatePageCopyWithImpl<$Res>
    extends _$ReportTemplatePageCopyWithImpl<$Res, _$_ReportTemplatePage>
    implements _$$_ReportTemplatePageCopyWith<$Res> {
  __$$_ReportTemplatePageCopyWithImpl(
      _$_ReportTemplatePage _value, $Res Function(_$_ReportTemplatePage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? source = null,
    Object? algorithm = null,
    Object? cols = freezed,
    Object? script = freezed,
  }) {
    return _then(_$_ReportTemplatePage(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ReportTemplateSource,
      algorithm: null == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as ReportTemplateAlgorithm,
      cols: freezed == cols
          ? _value._cols
          : cols // ignore: cast_nullable_to_non_nullable
              as List<ReportTemplateCol>?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ReportTemplatePage implements _ReportTemplatePage {
  const _$_ReportTemplatePage(
      {required this.title,
      @ReportTemplateSourceConverter() required this.source,
      @ReportTemplateAlgorithmConverter()
      this.algorithm = ReportTemplateAlgorithm.auto,
      final List<ReportTemplateCol>? cols,
      this.script})
      : _cols = cols;

  factory _$_ReportTemplatePage.fromJson(Map<String, dynamic> json) =>
      _$$_ReportTemplatePageFromJson(json);

  /// Is the page title
  @override
  final String title;

  /// Is the page source
  @override
  @ReportTemplateSourceConverter()
  final ReportTemplateSource source;

  /// Is the algorithm used to generate the page data.
  @override
  @JsonKey()
  @ReportTemplateAlgorithmConverter()
  final ReportTemplateAlgorithm algorithm;

  /// Is the page data, aka, the cols. Only used when [algorithm] is [ReportTemplateAlgorithm.auto]
  final List<ReportTemplateCol>? _cols;

  /// Is the page data, aka, the cols. Only used when [algorithm] is [ReportTemplateAlgorithm.auto]
  @override
  List<ReportTemplateCol>? get cols {
    final value = _cols;
    if (value == null) return null;
    if (_cols is EqualUnmodifiableListView) return _cols;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the script in Python to generate the page data. Only used when [algorithm] is [ReportTemplateAlgorithm.python]
  @override
  final String? script;

  @override
  String toString() {
    return 'ReportTemplatePage(title: $title, source: $source, algorithm: $algorithm, cols: $cols, script: $script)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ReportTemplatePage &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.algorithm, algorithm) ||
                other.algorithm == algorithm) &&
            const DeepCollectionEquality().equals(other._cols, _cols) &&
            (identical(other.script, script) || other.script == script));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, title, source, algorithm,
      const DeepCollectionEquality().hash(_cols), script);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ReportTemplatePageCopyWith<_$_ReportTemplatePage> get copyWith =>
      __$$_ReportTemplatePageCopyWithImpl<_$_ReportTemplatePage>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ReportTemplatePageToJson(
      this,
    );
  }
}

abstract class _ReportTemplatePage implements ReportTemplatePage {
  const factory _ReportTemplatePage(
      {required final String title,
      @ReportTemplateSourceConverter()
      required final ReportTemplateSource source,
      @ReportTemplateAlgorithmConverter()
      final ReportTemplateAlgorithm algorithm,
      final List<ReportTemplateCol>? cols,
      final String? script}) = _$_ReportTemplatePage;

  factory _ReportTemplatePage.fromJson(Map<String, dynamic> json) =
      _$_ReportTemplatePage.fromJson;

  @override

  /// Is the page title
  String get title;
  @override

  /// Is the page source
  @ReportTemplateSourceConverter()
  ReportTemplateSource get source;
  @override

  /// Is the algorithm used to generate the page data.
  @ReportTemplateAlgorithmConverter()
  ReportTemplateAlgorithm get algorithm;
  @override

  /// Is the page data, aka, the cols. Only used when [algorithm] is [ReportTemplateAlgorithm.auto]
  List<ReportTemplateCol>? get cols;
  @override

  /// Is the script in Python to generate the page data. Only used when [algorithm] is [ReportTemplateAlgorithm.python]
  String? get script;
  @override
  @JsonKey(ignore: true)
  _$$_ReportTemplatePageCopyWith<_$_ReportTemplatePage> get copyWith =>
      throw _privateConstructorUsedError;
}

ReportTemplateCol _$ReportTemplateColFromJson(Map<String, dynamic> json) {
  return _ReportTemplateCol.fromJson(json);
}

/// @nodoc
mixin _$ReportTemplateCol {
  /// Is the col name
  String get name => throw _privateConstructorUsedError;

  /// Is the col field name
  String get field => throw _privateConstructorUsedError;

  /// Is the visibility of the field
  bool get visible => throw _privateConstructorUsedError;

  /// Is the col custom identifier
  bool get isCustom => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ReportTemplateColCopyWith<ReportTemplateCol> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReportTemplateColCopyWith<$Res> {
  factory $ReportTemplateColCopyWith(
          ReportTemplateCol value, $Res Function(ReportTemplateCol) then) =
      _$ReportTemplateColCopyWithImpl<$Res, ReportTemplateCol>;
  @useResult
  $Res call({String name, String field, bool visible, bool isCustom});
}

/// @nodoc
class _$ReportTemplateColCopyWithImpl<$Res, $Val extends ReportTemplateCol>
    implements $ReportTemplateColCopyWith<$Res> {
  _$ReportTemplateColCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? field = null,
    Object? visible = null,
    Object? isCustom = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      isCustom: null == isCustom
          ? _value.isCustom
          : isCustom // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ReportTemplateColCopyWith<$Res>
    implements $ReportTemplateColCopyWith<$Res> {
  factory _$$_ReportTemplateColCopyWith(_$_ReportTemplateCol value,
          $Res Function(_$_ReportTemplateCol) then) =
      __$$_ReportTemplateColCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String field, bool visible, bool isCustom});
}

/// @nodoc
class __$$_ReportTemplateColCopyWithImpl<$Res>
    extends _$ReportTemplateColCopyWithImpl<$Res, _$_ReportTemplateCol>
    implements _$$_ReportTemplateColCopyWith<$Res> {
  __$$_ReportTemplateColCopyWithImpl(
      _$_ReportTemplateCol _value, $Res Function(_$_ReportTemplateCol) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? field = null,
    Object? visible = null,
    Object? isCustom = null,
  }) {
    return _then(_$_ReportTemplateCol(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as String,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      isCustom: null == isCustom
          ? _value.isCustom
          : isCustom // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ReportTemplateCol implements _ReportTemplateCol {
  const _$_ReportTemplateCol(
      {required this.name,
      required this.field,
      required this.visible,
      required this.isCustom});

  factory _$_ReportTemplateCol.fromJson(Map<String, dynamic> json) =>
      _$$_ReportTemplateColFromJson(json);

  /// Is the col name
  @override
  final String name;

  /// Is the col field name
  @override
  final String field;

  /// Is the visibility of the field
  @override
  final bool visible;

  /// Is the col custom identifier
  @override
  final bool isCustom;

  @override
  String toString() {
    return 'ReportTemplateCol(name: $name, field: $field, visible: $visible, isCustom: $isCustom)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ReportTemplateCol &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.isCustom, isCustom) ||
                other.isCustom == isCustom));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, field, visible, isCustom);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ReportTemplateColCopyWith<_$_ReportTemplateCol> get copyWith =>
      __$$_ReportTemplateColCopyWithImpl<_$_ReportTemplateCol>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ReportTemplateColToJson(
      this,
    );
  }
}

abstract class _ReportTemplateCol implements ReportTemplateCol {
  const factory _ReportTemplateCol(
      {required final String name,
      required final String field,
      required final bool visible,
      required final bool isCustom}) = _$_ReportTemplateCol;

  factory _ReportTemplateCol.fromJson(Map<String, dynamic> json) =
      _$_ReportTemplateCol.fromJson;

  @override

  /// Is the col name
  String get name;
  @override

  /// Is the col field name
  String get field;
  @override

  /// Is the visibility of the field
  bool get visible;
  @override

  /// Is the col custom identifier
  bool get isCustom;
  @override
  @JsonKey(ignore: true)
  _$$_ReportTemplateColCopyWith<_$_ReportTemplateCol> get copyWith =>
      throw _privateConstructorUsedError;
}

CloudEntry _$CloudEntryFromJson(Map<String, dynamic> json) {
  return _CloudEntry.fromJson(json);
}

/// @nodoc
mixin _$CloudEntry {
  /// Defines the name of the entry. If the name starts with [translate:], means
  /// that the name is a translation key.
  String get name => throw _privateConstructorUsedError;

  /// Is the type of the entry.
  @CloudEntryTypeConverter()
  CloudEntryType get type => throw _privateConstructorUsedError;

  /// Is the absolute path of the entry.
  String get path => throw _privateConstructorUsedError;

  /// Is the file serial. Only used for [CloudEntryType.file].
  String? get serial => throw _privateConstructorUsedError;

  /// Is the file ID of the file. Only used for [CloudEntryType.file].
  String? get fileId => throw _privateConstructorUsedError;

  /// Is the size of the file. Only used for [CloudEntryType.file].
  /// This field is defined in bytes.
  int? get size => throw _privateConstructorUsedError;

  /// Is the last modified date of the file. Only used for [CloudEntryType.file].
  @TimestampOrNullConverter()
  DateTime? get lastModified => throw _privateConstructorUsedError;

  /// Is the content type of the file. Only used for [CloudEntryType.file].
  String? get contentType => throw _privateConstructorUsedError;

  /// Is the metadata of the file. Only used for [CloudEntryType.file].
  /// Currently only works for images.
  Map<String, dynamic>? get metadata => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CloudEntryCopyWith<CloudEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CloudEntryCopyWith<$Res> {
  factory $CloudEntryCopyWith(
          CloudEntry value, $Res Function(CloudEntry) then) =
      _$CloudEntryCopyWithImpl<$Res, CloudEntry>;
  @useResult
  $Res call(
      {String name,
      @CloudEntryTypeConverter() CloudEntryType type,
      String path,
      String? serial,
      String? fileId,
      int? size,
      @TimestampOrNullConverter() DateTime? lastModified,
      String? contentType,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class _$CloudEntryCopyWithImpl<$Res, $Val extends CloudEntry>
    implements $CloudEntryCopyWith<$Res> {
  _$CloudEntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? type = null,
    Object? path = null,
    Object? serial = freezed,
    Object? fileId = freezed,
    Object? size = freezed,
    Object? lastModified = freezed,
    Object? contentType = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CloudEntryType,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      serial: freezed == serial
          ? _value.serial
          : serial // ignore: cast_nullable_to_non_nullable
              as String?,
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      lastModified: freezed == lastModified
          ? _value.lastModified
          : lastModified // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CloudEntryCopyWith<$Res>
    implements $CloudEntryCopyWith<$Res> {
  factory _$$_CloudEntryCopyWith(
          _$_CloudEntry value, $Res Function(_$_CloudEntry) then) =
      __$$_CloudEntryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String name,
      @CloudEntryTypeConverter() CloudEntryType type,
      String path,
      String? serial,
      String? fileId,
      int? size,
      @TimestampOrNullConverter() DateTime? lastModified,
      String? contentType,
      Map<String, dynamic>? metadata});
}

/// @nodoc
class __$$_CloudEntryCopyWithImpl<$Res>
    extends _$CloudEntryCopyWithImpl<$Res, _$_CloudEntry>
    implements _$$_CloudEntryCopyWith<$Res> {
  __$$_CloudEntryCopyWithImpl(
      _$_CloudEntry _value, $Res Function(_$_CloudEntry) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? type = null,
    Object? path = null,
    Object? serial = freezed,
    Object? fileId = freezed,
    Object? size = freezed,
    Object? lastModified = freezed,
    Object? contentType = freezed,
    Object? metadata = freezed,
  }) {
    return _then(_$_CloudEntry(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CloudEntryType,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      serial: freezed == serial
          ? _value.serial
          : serial // ignore: cast_nullable_to_non_nullable
              as String?,
      fileId: freezed == fileId
          ? _value.fileId
          : fileId // ignore: cast_nullable_to_non_nullable
              as String?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      lastModified: freezed == lastModified
          ? _value.lastModified
          : lastModified // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      contentType: freezed == contentType
          ? _value.contentType
          : contentType // ignore: cast_nullable_to_non_nullable
              as String?,
      metadata: freezed == metadata
          ? _value._metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CloudEntry implements _CloudEntry {
  const _$_CloudEntry(
      {required this.name,
      @CloudEntryTypeConverter() required this.type,
      required this.path,
      this.serial,
      this.fileId,
      this.size,
      @TimestampOrNullConverter() this.lastModified,
      this.contentType,
      final Map<String, dynamic>? metadata})
      : _metadata = metadata;

  factory _$_CloudEntry.fromJson(Map<String, dynamic> json) =>
      _$$_CloudEntryFromJson(json);

  /// Defines the name of the entry. If the name starts with [translate:], means
  /// that the name is a translation key.
  @override
  final String name;

  /// Is the type of the entry.
  @override
  @CloudEntryTypeConverter()
  final CloudEntryType type;

  /// Is the absolute path of the entry.
  @override
  final String path;

  /// Is the file serial. Only used for [CloudEntryType.file].
  @override
  final String? serial;

  /// Is the file ID of the file. Only used for [CloudEntryType.file].
  @override
  final String? fileId;

  /// Is the size of the file. Only used for [CloudEntryType.file].
  /// This field is defined in bytes.
  @override
  final int? size;

  /// Is the last modified date of the file. Only used for [CloudEntryType.file].
  @override
  @TimestampOrNullConverter()
  final DateTime? lastModified;

  /// Is the content type of the file. Only used for [CloudEntryType.file].
  @override
  final String? contentType;

  /// Is the metadata of the file. Only used for [CloudEntryType.file].
  /// Currently only works for images.
  final Map<String, dynamic>? _metadata;

  /// Is the metadata of the file. Only used for [CloudEntryType.file].
  /// Currently only works for images.
  @override
  Map<String, dynamic>? get metadata {
    final value = _metadata;
    if (value == null) return null;
    if (_metadata is EqualUnmodifiableMapView) return _metadata;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'CloudEntry(name: $name, type: $type, path: $path, serial: $serial, fileId: $fileId, size: $size, lastModified: $lastModified, contentType: $contentType, metadata: $metadata)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CloudEntry &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.serial, serial) || other.serial == serial) &&
            (identical(other.fileId, fileId) || other.fileId == fileId) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.lastModified, lastModified) ||
                other.lastModified == lastModified) &&
            (identical(other.contentType, contentType) ||
                other.contentType == contentType) &&
            const DeepCollectionEquality().equals(other._metadata, _metadata));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      name,
      type,
      path,
      serial,
      fileId,
      size,
      lastModified,
      contentType,
      const DeepCollectionEquality().hash(_metadata));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CloudEntryCopyWith<_$_CloudEntry> get copyWith =>
      __$$_CloudEntryCopyWithImpl<_$_CloudEntry>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CloudEntryToJson(
      this,
    );
  }
}

abstract class _CloudEntry implements CloudEntry {
  const factory _CloudEntry(
      {required final String name,
      @CloudEntryTypeConverter() required final CloudEntryType type,
      required final String path,
      final String? serial,
      final String? fileId,
      final int? size,
      @TimestampOrNullConverter() final DateTime? lastModified,
      final String? contentType,
      final Map<String, dynamic>? metadata}) = _$_CloudEntry;

  factory _CloudEntry.fromJson(Map<String, dynamic> json) =
      _$_CloudEntry.fromJson;

  @override

  /// Defines the name of the entry. If the name starts with [translate:], means
  /// that the name is a translation key.
  String get name;
  @override

  /// Is the type of the entry.
  @CloudEntryTypeConverter()
  CloudEntryType get type;
  @override

  /// Is the absolute path of the entry.
  String get path;
  @override

  /// Is the file serial. Only used for [CloudEntryType.file].
  String? get serial;
  @override

  /// Is the file ID of the file. Only used for [CloudEntryType.file].
  String? get fileId;
  @override

  /// Is the size of the file. Only used for [CloudEntryType.file].
  /// This field is defined in bytes.
  int? get size;
  @override

  /// Is the last modified date of the file. Only used for [CloudEntryType.file].
  @TimestampOrNullConverter()
  DateTime? get lastModified;
  @override

  /// Is the content type of the file. Only used for [CloudEntryType.file].
  String? get contentType;
  @override

  /// Is the metadata of the file. Only used for [CloudEntryType.file].
  /// Currently only works for images.
  Map<String, dynamic>? get metadata;
  @override
  @JsonKey(ignore: true)
  _$$_CloudEntryCopyWith<_$_CloudEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

DeviceCommand _$DeviceCommandFromJson(Map<String, dynamic> json) {
  return _DeviceCommand.fromJson(json);
}

/// @nodoc
mixin _$DeviceCommand {
  String get id => throw _privateConstructorUsedError;

  /// Is name of the command. (Only reference, does not affect the command itself)
  String get name => throw _privateConstructorUsedError;

  /// Is the source of the command.
  @CommandSourceConverter()
  CommandSource get source => throw _privateConstructorUsedError;

  /// Is the tag id of the command for "multi" execution from any [Action].
  String? get tagId => throw _privateConstructorUsedError;

  /// Is the [deviceId] that the command is for.
  /// Only will comes when the command comes from the asset or device query.
  String? get deviceId => throw _privateConstructorUsedError;

  /// Is the [protocol], [protocolId] and the [model], [modelId] of the command.
  /// Only will comes when the command is a "template"
  String? get protocolId => throw _privateConstructorUsedError;
  InboundProtocol? get protocol => throw _privateConstructorUsedError;
  String? get modelId => throw _privateConstructorUsedError;
  Model? get model => throw _privateConstructorUsedError;

  /// Is The command to execute.
  String? get command => throw _privateConstructorUsedError;

  /// Is is the password for the device. Will return null when not apply.
  String? get devicePassword => throw _privateConstructorUsedError;

  /// Is menas the raw payload to send.
  String? get payload => throw _privateConstructorUsedError;

  /// Is the internal ID of the command. (Refer to the Ruptela documentation for more information)
  /// only for Ruptela devices
  String? get commandId => throw _privateConstructorUsedError;

  /// Is the command is in Hexadecimal format.
  /// only for Ruptela devices
  bool? get isHexCoded => throw _privateConstructorUsedError;

  /// Is the EasyLogic username. only for Galileosky devices
  String? get username => throw _privateConstructorUsedError;

  /// Is the EasyLogic script name. only for Galileosky devices
  String? get scriptName => throw _privateConstructorUsedError;

  /// Is the external account for the command when source is [CommandSource.sms].
  ExternalAccount? get externalAccount => throw _privateConstructorUsedError;

  /// Is the external account ID for the command when source is [CommandSource.sms].
  String? get externalAccountId => throw _privateConstructorUsedError;

  /// Is a list of granted access to this entity.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// List of possible devices that can perform this command.
  List<Device>? get possibleDevices => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DeviceCommandCopyWith<DeviceCommand> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceCommandCopyWith<$Res> {
  factory $DeviceCommandCopyWith(
          DeviceCommand value, $Res Function(DeviceCommand) then) =
      _$DeviceCommandCopyWithImpl<$Res, DeviceCommand>;
  @useResult
  $Res call(
      {String id,
      String name,
      @CommandSourceConverter() CommandSource source,
      String? tagId,
      String? deviceId,
      String? protocolId,
      InboundProtocol? protocol,
      String? modelId,
      Model? model,
      String? command,
      String? devicePassword,
      String? payload,
      String? commandId,
      bool? isHexCoded,
      String? username,
      String? scriptName,
      ExternalAccount? externalAccount,
      String? externalAccountId,
      List<Access>? access,
      List<Device>? possibleDevices});

  $InboundProtocolCopyWith<$Res>? get protocol;
  $ModelCopyWith<$Res>? get model;
  $ExternalAccountCopyWith<$Res>? get externalAccount;
}

/// @nodoc
class _$DeviceCommandCopyWithImpl<$Res, $Val extends DeviceCommand>
    implements $DeviceCommandCopyWith<$Res> {
  _$DeviceCommandCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? source = null,
    Object? tagId = freezed,
    Object? deviceId = freezed,
    Object? protocolId = freezed,
    Object? protocol = freezed,
    Object? modelId = freezed,
    Object? model = freezed,
    Object? command = freezed,
    Object? devicePassword = freezed,
    Object? payload = freezed,
    Object? commandId = freezed,
    Object? isHexCoded = freezed,
    Object? username = freezed,
    Object? scriptName = freezed,
    Object? externalAccount = freezed,
    Object? externalAccountId = freezed,
    Object? access = freezed,
    Object? possibleDevices = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as CommandSource,
      tagId: freezed == tagId
          ? _value.tagId
          : tagId // ignore: cast_nullable_to_non_nullable
              as String?,
      deviceId: freezed == deviceId
          ? _value.deviceId
          : deviceId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      modelId: freezed == modelId
          ? _value.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as Model?,
      command: freezed == command
          ? _value.command
          : command // ignore: cast_nullable_to_non_nullable
              as String?,
      devicePassword: freezed == devicePassword
          ? _value.devicePassword
          : devicePassword // ignore: cast_nullable_to_non_nullable
              as String?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as String?,
      commandId: freezed == commandId
          ? _value.commandId
          : commandId // ignore: cast_nullable_to_non_nullable
              as String?,
      isHexCoded: freezed == isHexCoded
          ? _value.isHexCoded
          : isHexCoded // ignore: cast_nullable_to_non_nullable
              as bool?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      scriptName: freezed == scriptName
          ? _value.scriptName
          : scriptName // ignore: cast_nullable_to_non_nullable
              as String?,
      externalAccount: freezed == externalAccount
          ? _value.externalAccount
          : externalAccount // ignore: cast_nullable_to_non_nullable
              as ExternalAccount?,
      externalAccountId: freezed == externalAccountId
          ? _value.externalAccountId
          : externalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      possibleDevices: freezed == possibleDevices
          ? _value.possibleDevices
          : possibleDevices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $InboundProtocolCopyWith<$Res>? get protocol {
    if (_value.protocol == null) {
      return null;
    }

    return $InboundProtocolCopyWith<$Res>(_value.protocol!, (value) {
      return _then(_value.copyWith(protocol: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ModelCopyWith<$Res>? get model {
    if (_value.model == null) {
      return null;
    }

    return $ModelCopyWith<$Res>(_value.model!, (value) {
      return _then(_value.copyWith(model: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ExternalAccountCopyWith<$Res>? get externalAccount {
    if (_value.externalAccount == null) {
      return null;
    }

    return $ExternalAccountCopyWith<$Res>(_value.externalAccount!, (value) {
      return _then(_value.copyWith(externalAccount: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_DeviceCommandCopyWith<$Res>
    implements $DeviceCommandCopyWith<$Res> {
  factory _$$_DeviceCommandCopyWith(
          _$_DeviceCommand value, $Res Function(_$_DeviceCommand) then) =
      __$$_DeviceCommandCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @CommandSourceConverter() CommandSource source,
      String? tagId,
      String? deviceId,
      String? protocolId,
      InboundProtocol? protocol,
      String? modelId,
      Model? model,
      String? command,
      String? devicePassword,
      String? payload,
      String? commandId,
      bool? isHexCoded,
      String? username,
      String? scriptName,
      ExternalAccount? externalAccount,
      String? externalAccountId,
      List<Access>? access,
      List<Device>? possibleDevices});

  @override
  $InboundProtocolCopyWith<$Res>? get protocol;
  @override
  $ModelCopyWith<$Res>? get model;
  @override
  $ExternalAccountCopyWith<$Res>? get externalAccount;
}

/// @nodoc
class __$$_DeviceCommandCopyWithImpl<$Res>
    extends _$DeviceCommandCopyWithImpl<$Res, _$_DeviceCommand>
    implements _$$_DeviceCommandCopyWith<$Res> {
  __$$_DeviceCommandCopyWithImpl(
      _$_DeviceCommand _value, $Res Function(_$_DeviceCommand) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? source = null,
    Object? tagId = freezed,
    Object? deviceId = freezed,
    Object? protocolId = freezed,
    Object? protocol = freezed,
    Object? modelId = freezed,
    Object? model = freezed,
    Object? command = freezed,
    Object? devicePassword = freezed,
    Object? payload = freezed,
    Object? commandId = freezed,
    Object? isHexCoded = freezed,
    Object? username = freezed,
    Object? scriptName = freezed,
    Object? externalAccount = freezed,
    Object? externalAccountId = freezed,
    Object? access = freezed,
    Object? possibleDevices = freezed,
  }) {
    return _then(_$_DeviceCommand(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      source: null == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as CommandSource,
      tagId: freezed == tagId
          ? _value.tagId
          : tagId // ignore: cast_nullable_to_non_nullable
              as String?,
      deviceId: freezed == deviceId
          ? _value.deviceId
          : deviceId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocolId: freezed == protocolId
          ? _value.protocolId
          : protocolId // ignore: cast_nullable_to_non_nullable
              as String?,
      protocol: freezed == protocol
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as InboundProtocol?,
      modelId: freezed == modelId
          ? _value.modelId
          : modelId // ignore: cast_nullable_to_non_nullable
              as String?,
      model: freezed == model
          ? _value.model
          : model // ignore: cast_nullable_to_non_nullable
              as Model?,
      command: freezed == command
          ? _value.command
          : command // ignore: cast_nullable_to_non_nullable
              as String?,
      devicePassword: freezed == devicePassword
          ? _value.devicePassword
          : devicePassword // ignore: cast_nullable_to_non_nullable
              as String?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as String?,
      commandId: freezed == commandId
          ? _value.commandId
          : commandId // ignore: cast_nullable_to_non_nullable
              as String?,
      isHexCoded: freezed == isHexCoded
          ? _value.isHexCoded
          : isHexCoded // ignore: cast_nullable_to_non_nullable
              as bool?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      scriptName: freezed == scriptName
          ? _value.scriptName
          : scriptName // ignore: cast_nullable_to_non_nullable
              as String?,
      externalAccount: freezed == externalAccount
          ? _value.externalAccount
          : externalAccount // ignore: cast_nullable_to_non_nullable
              as ExternalAccount?,
      externalAccountId: freezed == externalAccountId
          ? _value.externalAccountId
          : externalAccountId // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      possibleDevices: freezed == possibleDevices
          ? _value._possibleDevices
          : possibleDevices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_DeviceCommand implements _DeviceCommand {
  const _$_DeviceCommand(
      {required this.id,
      required this.name,
      @CommandSourceConverter() required this.source,
      this.tagId,
      this.deviceId,
      this.protocolId,
      this.protocol,
      this.modelId,
      this.model,
      this.command,
      this.devicePassword,
      this.payload,
      this.commandId,
      this.isHexCoded,
      this.username,
      this.scriptName,
      this.externalAccount,
      this.externalAccountId,
      final List<Access>? access,
      final List<Device>? possibleDevices})
      : _access = access,
        _possibleDevices = possibleDevices;

  factory _$_DeviceCommand.fromJson(Map<String, dynamic> json) =>
      _$$_DeviceCommandFromJson(json);

  @override
  final String id;

  /// Is name of the command. (Only reference, does not affect the command itself)
  @override
  final String name;

  /// Is the source of the command.
  @override
  @CommandSourceConverter()
  final CommandSource source;

  /// Is the tag id of the command for "multi" execution from any [Action].
  @override
  final String? tagId;

  /// Is the [deviceId] that the command is for.
  /// Only will comes when the command comes from the asset or device query.
  @override
  final String? deviceId;

  /// Is the [protocol], [protocolId] and the [model], [modelId] of the command.
  /// Only will comes when the command is a "template"
  @override
  final String? protocolId;
  @override
  final InboundProtocol? protocol;
  @override
  final String? modelId;
  @override
  final Model? model;

  /// Is The command to execute.
  @override
  final String? command;

  /// Is is the password for the device. Will return null when not apply.
  @override
  final String? devicePassword;

  /// Is menas the raw payload to send.
  @override
  final String? payload;

  /// Is the internal ID of the command. (Refer to the Ruptela documentation for more information)
  /// only for Ruptela devices
  @override
  final String? commandId;

  /// Is the command is in Hexadecimal format.
  /// only for Ruptela devices
  @override
  final bool? isHexCoded;

  /// Is the EasyLogic username. only for Galileosky devices
  @override
  final String? username;

  /// Is the EasyLogic script name. only for Galileosky devices
  @override
  final String? scriptName;

  /// Is the external account for the command when source is [CommandSource.sms].
  @override
  final ExternalAccount? externalAccount;

  /// Is the external account ID for the command when source is [CommandSource.sms].
  @override
  final String? externalAccountId;

  /// Is a list of granted access to this entity.
  final List<Access>? _access;

  /// Is a list of granted access to this entity.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of possible devices that can perform this command.
  final List<Device>? _possibleDevices;

  /// List of possible devices that can perform this command.
  @override
  List<Device>? get possibleDevices {
    final value = _possibleDevices;
    if (value == null) return null;
    if (_possibleDevices is EqualUnmodifiableListView) return _possibleDevices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'DeviceCommand(id: $id, name: $name, source: $source, tagId: $tagId, deviceId: $deviceId, protocolId: $protocolId, protocol: $protocol, modelId: $modelId, model: $model, command: $command, devicePassword: $devicePassword, payload: $payload, commandId: $commandId, isHexCoded: $isHexCoded, username: $username, scriptName: $scriptName, externalAccount: $externalAccount, externalAccountId: $externalAccountId, access: $access, possibleDevices: $possibleDevices)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DeviceCommand &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.tagId, tagId) || other.tagId == tagId) &&
            (identical(other.deviceId, deviceId) ||
                other.deviceId == deviceId) &&
            (identical(other.protocolId, protocolId) ||
                other.protocolId == protocolId) &&
            (identical(other.protocol, protocol) ||
                other.protocol == protocol) &&
            (identical(other.modelId, modelId) || other.modelId == modelId) &&
            (identical(other.model, model) || other.model == model) &&
            (identical(other.command, command) || other.command == command) &&
            (identical(other.devicePassword, devicePassword) ||
                other.devicePassword == devicePassword) &&
            (identical(other.payload, payload) || other.payload == payload) &&
            (identical(other.commandId, commandId) ||
                other.commandId == commandId) &&
            (identical(other.isHexCoded, isHexCoded) ||
                other.isHexCoded == isHexCoded) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.scriptName, scriptName) ||
                other.scriptName == scriptName) &&
            (identical(other.externalAccount, externalAccount) ||
                other.externalAccount == externalAccount) &&
            (identical(other.externalAccountId, externalAccountId) ||
                other.externalAccountId == externalAccountId) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            const DeepCollectionEquality()
                .equals(other._possibleDevices, _possibleDevices));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        source,
        tagId,
        deviceId,
        protocolId,
        protocol,
        modelId,
        model,
        command,
        devicePassword,
        payload,
        commandId,
        isHexCoded,
        username,
        scriptName,
        externalAccount,
        externalAccountId,
        const DeepCollectionEquality().hash(_access),
        const DeepCollectionEquality().hash(_possibleDevices)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DeviceCommandCopyWith<_$_DeviceCommand> get copyWith =>
      __$$_DeviceCommandCopyWithImpl<_$_DeviceCommand>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DeviceCommandToJson(
      this,
    );
  }
}

abstract class _DeviceCommand implements DeviceCommand {
  const factory _DeviceCommand(
      {required final String id,
      required final String name,
      @CommandSourceConverter() required final CommandSource source,
      final String? tagId,
      final String? deviceId,
      final String? protocolId,
      final InboundProtocol? protocol,
      final String? modelId,
      final Model? model,
      final String? command,
      final String? devicePassword,
      final String? payload,
      final String? commandId,
      final bool? isHexCoded,
      final String? username,
      final String? scriptName,
      final ExternalAccount? externalAccount,
      final String? externalAccountId,
      final List<Access>? access,
      final List<Device>? possibleDevices}) = _$_DeviceCommand;

  factory _DeviceCommand.fromJson(Map<String, dynamic> json) =
      _$_DeviceCommand.fromJson;

  @override
  String get id;
  @override

  /// Is name of the command. (Only reference, does not affect the command itself)
  String get name;
  @override

  /// Is the source of the command.
  @CommandSourceConverter()
  CommandSource get source;
  @override

  /// Is the tag id of the command for "multi" execution from any [Action].
  String? get tagId;
  @override

  /// Is the [deviceId] that the command is for.
  /// Only will comes when the command comes from the asset or device query.
  String? get deviceId;
  @override

  /// Is the [protocol], [protocolId] and the [model], [modelId] of the command.
  /// Only will comes when the command is a "template"
  String? get protocolId;
  @override
  InboundProtocol? get protocol;
  @override
  String? get modelId;
  @override
  Model? get model;
  @override

  /// Is The command to execute.
  String? get command;
  @override

  /// Is is the password for the device. Will return null when not apply.
  String? get devicePassword;
  @override

  /// Is menas the raw payload to send.
  String? get payload;
  @override

  /// Is the internal ID of the command. (Refer to the Ruptela documentation for more information)
  /// only for Ruptela devices
  String? get commandId;
  @override

  /// Is the command is in Hexadecimal format.
  /// only for Ruptela devices
  bool? get isHexCoded;
  @override

  /// Is the EasyLogic username. only for Galileosky devices
  String? get username;
  @override

  /// Is the EasyLogic script name. only for Galileosky devices
  String? get scriptName;
  @override

  /// Is the external account for the command when source is [CommandSource.sms].
  ExternalAccount? get externalAccount;
  @override

  /// Is the external account ID for the command when source is [CommandSource.sms].
  String? get externalAccountId;
  @override

  /// Is a list of granted access to this entity.
  List<Access>? get access;
  @override

  /// List of possible devices that can perform this command.
  List<Device>? get possibleDevices;
  @override
  @JsonKey(ignore: true)
  _$$_DeviceCommandCopyWith<_$_DeviceCommand> get copyWith =>
      throw _privateConstructorUsedError;
}

Preset _$PresetFromJson(Map<String, dynamic> json) {
  return _Preset.fromJson(json);
}

/// @nodoc
mixin _$Preset {
  /// Is the ID
  String get id => throw _privateConstructorUsedError;

  /// Is the name, only used as reference
  String get name => throw _privateConstructorUsedError;

  /// Is the maximum validate time of the preset
  @TimestampOrNullConverter()
  DateTime? get validBefore => throw _privateConstructorUsedError;

  /// Indicates if the preset is expired or not
  bool get isExpired => throw _privateConstructorUsedError;

  /// Is the list or list of ID's of the associated triggers
  List<Trigger>? get triggers => throw _privateConstructorUsedError;
  List<String>? get triggersIds => throw _privateConstructorUsedError;

  /// Is the comment to place on the case when the preset is applied
  String? get comment => throw _privateConstructorUsedError;

  /// Is the list of granted access
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PresetCopyWith<Preset> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PresetCopyWith<$Res> {
  factory $PresetCopyWith(Preset value, $Res Function(Preset) then) =
      _$PresetCopyWithImpl<$Res, Preset>;
  @useResult
  $Res call(
      {String id,
      String name,
      @TimestampOrNullConverter() DateTime? validBefore,
      bool isExpired,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      String? comment,
      List<Access>? access});
}

/// @nodoc
class _$PresetCopyWithImpl<$Res, $Val extends Preset>
    implements $PresetCopyWith<$Res> {
  _$PresetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? validBefore = freezed,
    Object? isExpired = null,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? comment = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      validBefore: freezed == validBefore
          ? _value.validBefore
          : validBefore // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isExpired: null == isExpired
          ? _value.isExpired
          : isExpired // ignore: cast_nullable_to_non_nullable
              as bool,
      triggers: freezed == triggers
          ? _value.triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value.triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PresetCopyWith<$Res> implements $PresetCopyWith<$Res> {
  factory _$$_PresetCopyWith(_$_Preset value, $Res Function(_$_Preset) then) =
      __$$_PresetCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @TimestampOrNullConverter() DateTime? validBefore,
      bool isExpired,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      String? comment,
      List<Access>? access});
}

/// @nodoc
class __$$_PresetCopyWithImpl<$Res>
    extends _$PresetCopyWithImpl<$Res, _$_Preset>
    implements _$$_PresetCopyWith<$Res> {
  __$$_PresetCopyWithImpl(_$_Preset _value, $Res Function(_$_Preset) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? validBefore = freezed,
    Object? isExpired = null,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? comment = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_Preset(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      validBefore: freezed == validBefore
          ? _value.validBefore
          : validBefore // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isExpired: null == isExpired
          ? _value.isExpired
          : isExpired // ignore: cast_nullable_to_non_nullable
              as bool,
      triggers: freezed == triggers
          ? _value._triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value._triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Preset implements _Preset {
  const _$_Preset(
      {required this.id,
      required this.name,
      @TimestampOrNullConverter() this.validBefore,
      this.isExpired = true,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      this.comment,
      final List<Access>? access})
      : _triggers = triggers,
        _triggersIds = triggersIds,
        _access = access;

  factory _$_Preset.fromJson(Map<String, dynamic> json) =>
      _$$_PresetFromJson(json);

  /// Is the ID
  @override
  final String id;

  /// Is the name, only used as reference
  @override
  final String name;

  /// Is the maximum validate time of the preset
  @override
  @TimestampOrNullConverter()
  final DateTime? validBefore;

  /// Indicates if the preset is expired or not
  @override
  @JsonKey()
  final bool isExpired;

  /// Is the list or list of ID's of the associated triggers
  final List<Trigger>? _triggers;

  /// Is the list or list of ID's of the associated triggers
  @override
  List<Trigger>? get triggers {
    final value = _triggers;
    if (value == null) return null;
    if (_triggers is EqualUnmodifiableListView) return _triggers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _triggersIds;
  @override
  List<String>? get triggersIds {
    final value = _triggersIds;
    if (value == null) return null;
    if (_triggersIds is EqualUnmodifiableListView) return _triggersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the comment to place on the case when the preset is applied
  @override
  final String? comment;

  /// Is the list of granted access
  final List<Access>? _access;

  /// Is the list of granted access
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Preset(id: $id, name: $name, validBefore: $validBefore, isExpired: $isExpired, triggers: $triggers, triggersIds: $triggersIds, comment: $comment, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Preset &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.validBefore, validBefore) ||
                other.validBefore == validBefore) &&
            (identical(other.isExpired, isExpired) ||
                other.isExpired == isExpired) &&
            const DeepCollectionEquality().equals(other._triggers, _triggers) &&
            const DeepCollectionEquality()
                .equals(other._triggersIds, _triggersIds) &&
            (identical(other.comment, comment) || other.comment == comment) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      validBefore,
      isExpired,
      const DeepCollectionEquality().hash(_triggers),
      const DeepCollectionEquality().hash(_triggersIds),
      comment,
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PresetCopyWith<_$_Preset> get copyWith =>
      __$$_PresetCopyWithImpl<_$_Preset>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_PresetToJson(
      this,
    );
  }
}

abstract class _Preset implements Preset {
  const factory _Preset(
      {required final String id,
      required final String name,
      @TimestampOrNullConverter() final DateTime? validBefore,
      final bool isExpired,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      final String? comment,
      final List<Access>? access}) = _$_Preset;

  factory _Preset.fromJson(Map<String, dynamic> json) = _$_Preset.fromJson;

  @override

  /// Is the ID
  String get id;
  @override

  /// Is the name, only used as reference
  String get name;
  @override

  /// Is the maximum validate time of the preset
  @TimestampOrNullConverter()
  DateTime? get validBefore;
  @override

  /// Indicates if the preset is expired or not
  bool get isExpired;
  @override

  /// Is the list or list of ID's of the associated triggers
  List<Trigger>? get triggers;
  @override
  List<String>? get triggersIds;
  @override

  /// Is the comment to place on the case when the preset is applied
  String? get comment;
  @override

  /// Is the list of granted access
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_PresetCopyWith<_$_Preset> get copyWith =>
      throw _privateConstructorUsedError;
}

Checkpoint _$CheckpointFromJson(Map<String, dynamic> json) {
  return _Checkpoint.fromJson(json);
}

/// @nodoc
mixin _$Checkpoint {
  /// ID of the checkpoint entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// Name of the checkpoint.
  String get name => throw _privateConstructorUsedError;

  /// Asset tag ID of the checkpoint.
  String? get assetId => throw _privateConstructorUsedError;

  /// List of waypoints in the checkpoint. See the documention of the Type.
  List<Waypoint>? get waypoints => throw _privateConstructorUsedError;

  /// Boolean value that determines if the checkpoint is active.
  bool? get isActive => throw _privateConstructorUsedError;

  /// List of custom access permissions.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// IDs of the linked Assets.
  List<LinkedAssetToCheckpointId>? get linkedAssetsIds =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CheckpointCopyWith<Checkpoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CheckpointCopyWith<$Res> {
  factory $CheckpointCopyWith(
          Checkpoint value, $Res Function(Checkpoint) then) =
      _$CheckpointCopyWithImpl<$Res, Checkpoint>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? assetId,
      List<Waypoint>? waypoints,
      bool? isActive,
      List<Access>? access,
      List<LinkedAssetToCheckpointId>? linkedAssetsIds});
}

/// @nodoc
class _$CheckpointCopyWithImpl<$Res, $Val extends Checkpoint>
    implements $CheckpointCopyWith<$Res> {
  _$CheckpointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? assetId = freezed,
    Object? waypoints = freezed,
    Object? isActive = freezed,
    Object? access = freezed,
    Object? linkedAssetsIds = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      waypoints: freezed == waypoints
          ? _value.waypoints
          : waypoints // ignore: cast_nullable_to_non_nullable
              as List<Waypoint>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      linkedAssetsIds: freezed == linkedAssetsIds
          ? _value.linkedAssetsIds
          : linkedAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<LinkedAssetToCheckpointId>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CheckpointCopyWith<$Res>
    implements $CheckpointCopyWith<$Res> {
  factory _$$_CheckpointCopyWith(
          _$_Checkpoint value, $Res Function(_$_Checkpoint) then) =
      __$$_CheckpointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? assetId,
      List<Waypoint>? waypoints,
      bool? isActive,
      List<Access>? access,
      List<LinkedAssetToCheckpointId>? linkedAssetsIds});
}

/// @nodoc
class __$$_CheckpointCopyWithImpl<$Res>
    extends _$CheckpointCopyWithImpl<$Res, _$_Checkpoint>
    implements _$$_CheckpointCopyWith<$Res> {
  __$$_CheckpointCopyWithImpl(
      _$_Checkpoint _value, $Res Function(_$_Checkpoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? assetId = freezed,
    Object? waypoints = freezed,
    Object? isActive = freezed,
    Object? access = freezed,
    Object? linkedAssetsIds = freezed,
  }) {
    return _then(_$_Checkpoint(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      waypoints: freezed == waypoints
          ? _value._waypoints
          : waypoints // ignore: cast_nullable_to_non_nullable
              as List<Waypoint>?,
      isActive: freezed == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      linkedAssetsIds: freezed == linkedAssetsIds
          ? _value._linkedAssetsIds
          : linkedAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<LinkedAssetToCheckpointId>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Checkpoint implements _Checkpoint {
  const _$_Checkpoint(
      {required this.id,
      required this.name,
      this.assetId,
      final List<Waypoint>? waypoints,
      this.isActive,
      final List<Access>? access,
      final List<LinkedAssetToCheckpointId>? linkedAssetsIds})
      : _waypoints = waypoints,
        _access = access,
        _linkedAssetsIds = linkedAssetsIds;

  factory _$_Checkpoint.fromJson(Map<String, dynamic> json) =>
      _$$_CheckpointFromJson(json);

  /// ID of the checkpoint entity. This ID is unique.
  @override
  final String id;

  /// Name of the checkpoint.
  @override
  final String name;

  /// Asset tag ID of the checkpoint.
  @override
  final String? assetId;

  /// List of waypoints in the checkpoint. See the documention of the Type.
  final List<Waypoint>? _waypoints;

  /// List of waypoints in the checkpoint. See the documention of the Type.
  @override
  List<Waypoint>? get waypoints {
    final value = _waypoints;
    if (value == null) return null;
    if (_waypoints is EqualUnmodifiableListView) return _waypoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Boolean value that determines if the checkpoint is active.
  @override
  final bool? isActive;

  /// List of custom access permissions.
  final List<Access>? _access;

  /// List of custom access permissions.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// IDs of the linked Assets.
  final List<LinkedAssetToCheckpointId>? _linkedAssetsIds;

  /// IDs of the linked Assets.
  @override
  List<LinkedAssetToCheckpointId>? get linkedAssetsIds {
    final value = _linkedAssetsIds;
    if (value == null) return null;
    if (_linkedAssetsIds is EqualUnmodifiableListView) return _linkedAssetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Checkpoint(id: $id, name: $name, assetId: $assetId, waypoints: $waypoints, isActive: $isActive, access: $access, linkedAssetsIds: $linkedAssetsIds)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Checkpoint &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            const DeepCollectionEquality()
                .equals(other._waypoints, _waypoints) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            const DeepCollectionEquality()
                .equals(other._linkedAssetsIds, _linkedAssetsIds));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      assetId,
      const DeepCollectionEquality().hash(_waypoints),
      isActive,
      const DeepCollectionEquality().hash(_access),
      const DeepCollectionEquality().hash(_linkedAssetsIds));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CheckpointCopyWith<_$_Checkpoint> get copyWith =>
      __$$_CheckpointCopyWithImpl<_$_Checkpoint>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CheckpointToJson(
      this,
    );
  }
}

abstract class _Checkpoint implements Checkpoint {
  const factory _Checkpoint(
      {required final String id,
      required final String name,
      final String? assetId,
      final List<Waypoint>? waypoints,
      final bool? isActive,
      final List<Access>? access,
      final List<LinkedAssetToCheckpointId>? linkedAssetsIds}) = _$_Checkpoint;

  factory _Checkpoint.fromJson(Map<String, dynamic> json) =
      _$_Checkpoint.fromJson;

  @override

  /// ID of the checkpoint entity. This ID is unique.
  String get id;
  @override

  /// Name of the checkpoint.
  String get name;
  @override

  /// Asset tag ID of the checkpoint.
  String? get assetId;
  @override

  /// List of waypoints in the checkpoint. See the documention of the Type.
  List<Waypoint>? get waypoints;
  @override

  /// Boolean value that determines if the checkpoint is active.
  bool? get isActive;
  @override

  /// List of custom access permissions.
  List<Access>? get access;
  @override

  /// IDs of the linked Assets.
  List<LinkedAssetToCheckpointId>? get linkedAssetsIds;
  @override
  @JsonKey(ignore: true)
  _$$_CheckpointCopyWith<_$_Checkpoint> get copyWith =>
      throw _privateConstructorUsedError;
}

Waypoint _$WaypointFromJson(Map<String, dynamic> json) {
  return _Waypoint.fromJson(json);
}

/// @nodoc
mixin _$Waypoint {
  /// ID of the waypoint entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// Geofence associated to the route as checkpoint.
  String? get geofenceId => throw _privateConstructorUsedError;
  Geofence? get geofence => throw _privateConstructorUsedError;

  /// This is the time between two waypoints or the time inside of the geofence.
  String? get time => throw _privateConstructorUsedError;

  /// It can be POINT or PATHWAY. See the documentation for more information.
  @WaypointKindOrNullConverter()
  WaypointKind? get kind => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WaypointCopyWith<Waypoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WaypointCopyWith<$Res> {
  factory $WaypointCopyWith(Waypoint value, $Res Function(Waypoint) then) =
      _$WaypointCopyWithImpl<$Res, Waypoint>;
  @useResult
  $Res call(
      {String id,
      String? geofenceId,
      Geofence? geofence,
      String? time,
      @WaypointKindOrNullConverter() WaypointKind? kind});

  $GeofenceCopyWith<$Res>? get geofence;
}

/// @nodoc
class _$WaypointCopyWithImpl<$Res, $Val extends Waypoint>
    implements $WaypointCopyWith<$Res> {
  _$WaypointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? geofenceId = freezed,
    Object? geofence = freezed,
    Object? time = freezed,
    Object? kind = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      geofenceId: freezed == geofenceId
          ? _value.geofenceId
          : geofenceId // ignore: cast_nullable_to_non_nullable
              as String?,
      geofence: freezed == geofence
          ? _value.geofence
          : geofence // ignore: cast_nullable_to_non_nullable
              as Geofence?,
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as WaypointKind?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GeofenceCopyWith<$Res>? get geofence {
    if (_value.geofence == null) {
      return null;
    }

    return $GeofenceCopyWith<$Res>(_value.geofence!, (value) {
      return _then(_value.copyWith(geofence: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_WaypointCopyWith<$Res> implements $WaypointCopyWith<$Res> {
  factory _$$_WaypointCopyWith(
          _$_Waypoint value, $Res Function(_$_Waypoint) then) =
      __$$_WaypointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String? geofenceId,
      Geofence? geofence,
      String? time,
      @WaypointKindOrNullConverter() WaypointKind? kind});

  @override
  $GeofenceCopyWith<$Res>? get geofence;
}

/// @nodoc
class __$$_WaypointCopyWithImpl<$Res>
    extends _$WaypointCopyWithImpl<$Res, _$_Waypoint>
    implements _$$_WaypointCopyWith<$Res> {
  __$$_WaypointCopyWithImpl(
      _$_Waypoint _value, $Res Function(_$_Waypoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? geofenceId = freezed,
    Object? geofence = freezed,
    Object? time = freezed,
    Object? kind = freezed,
  }) {
    return _then(_$_Waypoint(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      geofenceId: freezed == geofenceId
          ? _value.geofenceId
          : geofenceId // ignore: cast_nullable_to_non_nullable
              as String?,
      geofence: freezed == geofence
          ? _value.geofence
          : geofence // ignore: cast_nullable_to_non_nullable
              as Geofence?,
      time: freezed == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as String?,
      kind: freezed == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as WaypointKind?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Waypoint implements _Waypoint {
  const _$_Waypoint(
      {required this.id,
      this.geofenceId,
      this.geofence,
      this.time,
      @WaypointKindOrNullConverter() this.kind});

  factory _$_Waypoint.fromJson(Map<String, dynamic> json) =>
      _$$_WaypointFromJson(json);

  /// ID of the waypoint entity. This ID is unique.
  @override
  final String id;

  /// Geofence associated to the route as checkpoint.
  @override
  final String? geofenceId;
  @override
  final Geofence? geofence;

  /// This is the time between two waypoints or the time inside of the geofence.
  @override
  final String? time;

  /// It can be POINT or PATHWAY. See the documentation for more information.
  @override
  @WaypointKindOrNullConverter()
  final WaypointKind? kind;

  @override
  String toString() {
    return 'Waypoint(id: $id, geofenceId: $geofenceId, geofence: $geofence, time: $time, kind: $kind)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Waypoint &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.geofenceId, geofenceId) ||
                other.geofenceId == geofenceId) &&
            (identical(other.geofence, geofence) ||
                other.geofence == geofence) &&
            (identical(other.time, time) || other.time == time) &&
            (identical(other.kind, kind) || other.kind == kind));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, geofenceId, geofence, time, kind);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WaypointCopyWith<_$_Waypoint> get copyWith =>
      __$$_WaypointCopyWithImpl<_$_Waypoint>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WaypointToJson(
      this,
    );
  }
}

abstract class _Waypoint implements Waypoint {
  const factory _Waypoint(
      {required final String id,
      final String? geofenceId,
      final Geofence? geofence,
      final String? time,
      @WaypointKindOrNullConverter() final WaypointKind? kind}) = _$_Waypoint;

  factory _Waypoint.fromJson(Map<String, dynamic> json) = _$_Waypoint.fromJson;

  @override

  /// ID of the waypoint entity. This ID is unique.
  String get id;
  @override

  /// Geofence associated to the route as checkpoint.
  String? get geofenceId;
  @override
  Geofence? get geofence;
  @override

  /// This is the time between two waypoints or the time inside of the geofence.
  String? get time;
  @override

  /// It can be POINT or PATHWAY. See the documentation for more information.
  @WaypointKindOrNullConverter()
  WaypointKind? get kind;
  @override
  @JsonKey(ignore: true)
  _$$_WaypointCopyWith<_$_Waypoint> get copyWith =>
      throw _privateConstructorUsedError;
}

LinkedAssetToCheckpointId _$LinkedAssetToCheckpointIdFromJson(
    Map<String, dynamic> json) {
  return _LinkedAssetToCheckpointId.fromJson(json);
}

/// @nodoc
mixin _$LinkedAssetToCheckpointId {
  String get itemId => throw _privateConstructorUsedError;
  @LinkedAssetEntityConverter()
  LinkedAssetEntity get entity => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LinkedAssetToCheckpointIdCopyWith<LinkedAssetToCheckpointId> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LinkedAssetToCheckpointIdCopyWith<$Res> {
  factory $LinkedAssetToCheckpointIdCopyWith(LinkedAssetToCheckpointId value,
          $Res Function(LinkedAssetToCheckpointId) then) =
      _$LinkedAssetToCheckpointIdCopyWithImpl<$Res, LinkedAssetToCheckpointId>;
  @useResult
  $Res call(
      {String itemId, @LinkedAssetEntityConverter() LinkedAssetEntity entity});
}

/// @nodoc
class _$LinkedAssetToCheckpointIdCopyWithImpl<$Res,
        $Val extends LinkedAssetToCheckpointId>
    implements $LinkedAssetToCheckpointIdCopyWith<$Res> {
  _$LinkedAssetToCheckpointIdCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? itemId = null,
    Object? entity = null,
  }) {
    return _then(_value.copyWith(
      itemId: null == itemId
          ? _value.itemId
          : itemId // ignore: cast_nullable_to_non_nullable
              as String,
      entity: null == entity
          ? _value.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as LinkedAssetEntity,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LinkedAssetToCheckpointIdCopyWith<$Res>
    implements $LinkedAssetToCheckpointIdCopyWith<$Res> {
  factory _$$_LinkedAssetToCheckpointIdCopyWith(
          _$_LinkedAssetToCheckpointId value,
          $Res Function(_$_LinkedAssetToCheckpointId) then) =
      __$$_LinkedAssetToCheckpointIdCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String itemId, @LinkedAssetEntityConverter() LinkedAssetEntity entity});
}

/// @nodoc
class __$$_LinkedAssetToCheckpointIdCopyWithImpl<$Res>
    extends _$LinkedAssetToCheckpointIdCopyWithImpl<$Res,
        _$_LinkedAssetToCheckpointId>
    implements _$$_LinkedAssetToCheckpointIdCopyWith<$Res> {
  __$$_LinkedAssetToCheckpointIdCopyWithImpl(
      _$_LinkedAssetToCheckpointId _value,
      $Res Function(_$_LinkedAssetToCheckpointId) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? itemId = null,
    Object? entity = null,
  }) {
    return _then(_$_LinkedAssetToCheckpointId(
      itemId: null == itemId
          ? _value.itemId
          : itemId // ignore: cast_nullable_to_non_nullable
              as String,
      entity: null == entity
          ? _value.entity
          : entity // ignore: cast_nullable_to_non_nullable
              as LinkedAssetEntity,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LinkedAssetToCheckpointId implements _LinkedAssetToCheckpointId {
  const _$_LinkedAssetToCheckpointId(
      {required this.itemId,
      @LinkedAssetEntityConverter() required this.entity});

  factory _$_LinkedAssetToCheckpointId.fromJson(Map<String, dynamic> json) =>
      _$$_LinkedAssetToCheckpointIdFromJson(json);

  @override
  final String itemId;
  @override
  @LinkedAssetEntityConverter()
  final LinkedAssetEntity entity;

  @override
  String toString() {
    return 'LinkedAssetToCheckpointId(itemId: $itemId, entity: $entity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LinkedAssetToCheckpointId &&
            (identical(other.itemId, itemId) || other.itemId == itemId) &&
            (identical(other.entity, entity) || other.entity == entity));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, itemId, entity);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LinkedAssetToCheckpointIdCopyWith<_$_LinkedAssetToCheckpointId>
      get copyWith => __$$_LinkedAssetToCheckpointIdCopyWithImpl<
          _$_LinkedAssetToCheckpointId>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LinkedAssetToCheckpointIdToJson(
      this,
    );
  }
}

abstract class _LinkedAssetToCheckpointId implements LinkedAssetToCheckpointId {
  const factory _LinkedAssetToCheckpointId(
      {required final String itemId,
      @LinkedAssetEntityConverter()
      required final LinkedAssetEntity entity}) = _$_LinkedAssetToCheckpointId;

  factory _LinkedAssetToCheckpointId.fromJson(Map<String, dynamic> json) =
      _$_LinkedAssetToCheckpointId.fromJson;

  @override
  String get itemId;
  @override
  @LinkedAssetEntityConverter()
  LinkedAssetEntity get entity;
  @override
  @JsonKey(ignore: true)
  _$$_LinkedAssetToCheckpointIdCopyWith<_$_LinkedAssetToCheckpointId>
      get copyWith => throw _privateConstructorUsedError;
}

CheckpointInput _$CheckpointInputFromJson(Map<String, dynamic> json) {
  return _CheckpointInput.fromJson(json);
}

/// @nodoc
mixin _$CheckpointInput {
  /// ID of the preset entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the preset entity. This ID is unique.
  set id(String? value) => throw _privateConstructorUsedError;

  /// Name of the route.
  String? get name => throw _privateConstructorUsedError;

  /// Name of the route.
  set name(String? value) => throw _privateConstructorUsedError;

  /// Tag asset ID of the route.
  String? get assetId => throw _privateConstructorUsedError;

  /// Tag asset ID of the route.
  set assetId(String? value) => throw _privateConstructorUsedError;

  /// List of waypoints in the route. See the documention of the Type.
  List<Waypoint>? get waypointsJson => throw _privateConstructorUsedError;

  /// List of waypoints in the route. See the documention of the Type.
  set waypointsJson(List<Waypoint>? value) =>
      throw _privateConstructorUsedError;

  /// Linked Asset entity ID, only required for
  List<LinkedAssetToCheckpointId>? get linkedAssetsIds =>
      throw _privateConstructorUsedError;

  /// Linked Asset entity ID, only required for
  set linkedAssetsIds(List<LinkedAssetToCheckpointId>? value) =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CheckpointInputCopyWith<CheckpointInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CheckpointInputCopyWith<$Res> {
  factory $CheckpointInputCopyWith(
          CheckpointInput value, $Res Function(CheckpointInput) then) =
      _$CheckpointInputCopyWithImpl<$Res, CheckpointInput>;
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? assetId,
      List<Waypoint>? waypointsJson,
      List<LinkedAssetToCheckpointId>? linkedAssetsIds});
}

/// @nodoc
class _$CheckpointInputCopyWithImpl<$Res, $Val extends CheckpointInput>
    implements $CheckpointInputCopyWith<$Res> {
  _$CheckpointInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? assetId = freezed,
    Object? waypointsJson = freezed,
    Object? linkedAssetsIds = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      waypointsJson: freezed == waypointsJson
          ? _value.waypointsJson
          : waypointsJson // ignore: cast_nullable_to_non_nullable
              as List<Waypoint>?,
      linkedAssetsIds: freezed == linkedAssetsIds
          ? _value.linkedAssetsIds
          : linkedAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<LinkedAssetToCheckpointId>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CheckpointInputCopyWith<$Res>
    implements $CheckpointInputCopyWith<$Res> {
  factory _$$_CheckpointInputCopyWith(
          _$_CheckpointInput value, $Res Function(_$_CheckpointInput) then) =
      __$$_CheckpointInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? name,
      String? assetId,
      List<Waypoint>? waypointsJson,
      List<LinkedAssetToCheckpointId>? linkedAssetsIds});
}

/// @nodoc
class __$$_CheckpointInputCopyWithImpl<$Res>
    extends _$CheckpointInputCopyWithImpl<$Res, _$_CheckpointInput>
    implements _$$_CheckpointInputCopyWith<$Res> {
  __$$_CheckpointInputCopyWithImpl(
      _$_CheckpointInput _value, $Res Function(_$_CheckpointInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = freezed,
    Object? assetId = freezed,
    Object? waypointsJson = freezed,
    Object? linkedAssetsIds = freezed,
  }) {
    return _then(_$_CheckpointInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      waypointsJson: freezed == waypointsJson
          ? _value.waypointsJson
          : waypointsJson // ignore: cast_nullable_to_non_nullable
              as List<Waypoint>?,
      linkedAssetsIds: freezed == linkedAssetsIds
          ? _value.linkedAssetsIds
          : linkedAssetsIds // ignore: cast_nullable_to_non_nullable
              as List<LinkedAssetToCheckpointId>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CheckpointInput implements _CheckpointInput {
  _$_CheckpointInput(
      {this.id,
      this.name,
      this.assetId,
      this.waypointsJson = const [],
      this.linkedAssetsIds = const []});

  factory _$_CheckpointInput.fromJson(Map<String, dynamic> json) =>
      _$$_CheckpointInputFromJson(json);

  /// ID of the preset entity. This ID is unique.
  @override
  String? id;

  /// Name of the route.
  @override
  String? name;

  /// Tag asset ID of the route.
  @override
  String? assetId;

  /// List of waypoints in the route. See the documention of the Type.
  @override
  @JsonKey()
  List<Waypoint>? waypointsJson;

  /// Linked Asset entity ID, only required for
  @override
  @JsonKey()
  List<LinkedAssetToCheckpointId>? linkedAssetsIds;

  @override
  String toString() {
    return 'CheckpointInput(id: $id, name: $name, assetId: $assetId, waypointsJson: $waypointsJson, linkedAssetsIds: $linkedAssetsIds)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CheckpointInputCopyWith<_$_CheckpointInput> get copyWith =>
      __$$_CheckpointInputCopyWithImpl<_$_CheckpointInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CheckpointInputToJson(
      this,
    );
  }
}

abstract class _CheckpointInput implements CheckpointInput {
  factory _CheckpointInput(
      {String? id,
      String? name,
      String? assetId,
      List<Waypoint>? waypointsJson,
      List<LinkedAssetToCheckpointId>? linkedAssetsIds}) = _$_CheckpointInput;

  factory _CheckpointInput.fromJson(Map<String, dynamic> json) =
      _$_CheckpointInput.fromJson;

  @override

  /// ID of the preset entity. This ID is unique.
  String? get id;

  /// ID of the preset entity. This ID is unique.
  set id(String? value);
  @override

  /// Name of the route.
  String? get name;

  /// Name of the route.
  set name(String? value);
  @override

  /// Tag asset ID of the route.
  String? get assetId;

  /// Tag asset ID of the route.
  set assetId(String? value);
  @override

  /// List of waypoints in the route. See the documention of the Type.
  List<Waypoint>? get waypointsJson;

  /// List of waypoints in the route. See the documention of the Type.
  set waypointsJson(List<Waypoint>? value);
  @override

  /// Linked Asset entity ID, only required for
  List<LinkedAssetToCheckpointId>? get linkedAssetsIds;

  /// Linked Asset entity ID, only required for
  set linkedAssetsIds(List<LinkedAssetToCheckpointId>? value);
  @override
  @JsonKey(ignore: true)
  _$$_CheckpointInputCopyWith<_$_CheckpointInput> get copyWith =>
      throw _privateConstructorUsedError;
}

LayrzChart _$LayrzChartFromJson(Map<String, dynamic> json) {
  return _LayrzChart.fromJson(json);
}

/// @nodoc
mixin _$LayrzChart {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;
  String? get formula => throw _privateConstructorUsedError;
  String? get script => throw _privateConstructorUsedError;
  List<String>? get sensors => throw _privateConstructorUsedError;
  @ChartTypeOrNullConverter()
  ChartType? get type => throw _privateConstructorUsedError;
  @ChartAlgorithmOrNullConverter()
  ChartAlgorithm? get algorithm => throw _privateConstructorUsedError;
  @ChartDataSourceOrNullConverter()
  ChartDataSource? get dataSource => throw _privateConstructorUsedError;

  /// Is a list of granted access to this entity.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LayrzChartCopyWith<LayrzChart> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LayrzChartCopyWith<$Res> {
  factory $LayrzChartCopyWith(
          LayrzChart value, $Res Function(LayrzChart) then) =
      _$LayrzChartCopyWithImpl<$Res, LayrzChart>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? description,
      String? formula,
      String? script,
      List<String>? sensors,
      @ChartTypeOrNullConverter() ChartType? type,
      @ChartAlgorithmOrNullConverter() ChartAlgorithm? algorithm,
      @ChartDataSourceOrNullConverter() ChartDataSource? dataSource,
      List<Access>? access});
}

/// @nodoc
class _$LayrzChartCopyWithImpl<$Res, $Val extends LayrzChart>
    implements $LayrzChartCopyWith<$Res> {
  _$LayrzChartCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? sensors = freezed,
    Object? type = freezed,
    Object? algorithm = freezed,
    Object? dataSource = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      sensors: freezed == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChartType?,
      algorithm: freezed == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as ChartAlgorithm?,
      dataSource: freezed == dataSource
          ? _value.dataSource
          : dataSource // ignore: cast_nullable_to_non_nullable
              as ChartDataSource?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LayrzChartCopyWith<$Res>
    implements $LayrzChartCopyWith<$Res> {
  factory _$$_LayrzChartCopyWith(
          _$_LayrzChart value, $Res Function(_$_LayrzChart) then) =
      __$$_LayrzChartCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? description,
      String? formula,
      String? script,
      List<String>? sensors,
      @ChartTypeOrNullConverter() ChartType? type,
      @ChartAlgorithmOrNullConverter() ChartAlgorithm? algorithm,
      @ChartDataSourceOrNullConverter() ChartDataSource? dataSource,
      List<Access>? access});
}

/// @nodoc
class __$$_LayrzChartCopyWithImpl<$Res>
    extends _$LayrzChartCopyWithImpl<$Res, _$_LayrzChart>
    implements _$$_LayrzChartCopyWith<$Res> {
  __$$_LayrzChartCopyWithImpl(
      _$_LayrzChart _value, $Res Function(_$_LayrzChart) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? description = freezed,
    Object? formula = freezed,
    Object? script = freezed,
    Object? sensors = freezed,
    Object? type = freezed,
    Object? algorithm = freezed,
    Object? dataSource = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_LayrzChart(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      formula: freezed == formula
          ? _value.formula
          : formula // ignore: cast_nullable_to_non_nullable
              as String?,
      script: freezed == script
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String?,
      sensors: freezed == sensors
          ? _value._sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      type: freezed == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as ChartType?,
      algorithm: freezed == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as ChartAlgorithm?,
      dataSource: freezed == dataSource
          ? _value.dataSource
          : dataSource // ignore: cast_nullable_to_non_nullable
              as ChartDataSource?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LayrzChart implements _LayrzChart {
  const _$_LayrzChart(
      {required this.id,
      required this.name,
      this.description,
      this.formula,
      this.script,
      final List<String>? sensors,
      @ChartTypeOrNullConverter() this.type,
      @ChartAlgorithmOrNullConverter() this.algorithm,
      @ChartDataSourceOrNullConverter() this.dataSource,
      final List<Access>? access})
      : _sensors = sensors,
        _access = access;

  factory _$_LayrzChart.fromJson(Map<String, dynamic> json) =>
      _$$_LayrzChartFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String? description;
  @override
  final String? formula;
  @override
  final String? script;
  final List<String>? _sensors;
  @override
  List<String>? get sensors {
    final value = _sensors;
    if (value == null) return null;
    if (_sensors is EqualUnmodifiableListView) return _sensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @ChartTypeOrNullConverter()
  final ChartType? type;
  @override
  @ChartAlgorithmOrNullConverter()
  final ChartAlgorithm? algorithm;
  @override
  @ChartDataSourceOrNullConverter()
  final ChartDataSource? dataSource;

  /// Is a list of granted access to this entity.
  final List<Access>? _access;

  /// Is a list of granted access to this entity.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'LayrzChart(id: $id, name: $name, description: $description, formula: $formula, script: $script, sensors: $sensors, type: $type, algorithm: $algorithm, dataSource: $dataSource, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LayrzChart &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.formula, formula) || other.formula == formula) &&
            (identical(other.script, script) || other.script == script) &&
            const DeepCollectionEquality().equals(other._sensors, _sensors) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.algorithm, algorithm) ||
                other.algorithm == algorithm) &&
            (identical(other.dataSource, dataSource) ||
                other.dataSource == dataSource) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      description,
      formula,
      script,
      const DeepCollectionEquality().hash(_sensors),
      type,
      algorithm,
      dataSource,
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LayrzChartCopyWith<_$_LayrzChart> get copyWith =>
      __$$_LayrzChartCopyWithImpl<_$_LayrzChart>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LayrzChartToJson(
      this,
    );
  }
}

abstract class _LayrzChart implements LayrzChart {
  const factory _LayrzChart(
      {required final String id,
      required final String name,
      final String? description,
      final String? formula,
      final String? script,
      final List<String>? sensors,
      @ChartTypeOrNullConverter() final ChartType? type,
      @ChartAlgorithmOrNullConverter() final ChartAlgorithm? algorithm,
      @ChartDataSourceOrNullConverter() final ChartDataSource? dataSource,
      final List<Access>? access}) = _$_LayrzChart;

  factory _LayrzChart.fromJson(Map<String, dynamic> json) =
      _$_LayrzChart.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String? get description;
  @override
  String? get formula;
  @override
  String? get script;
  @override
  List<String>? get sensors;
  @override
  @ChartTypeOrNullConverter()
  ChartType? get type;
  @override
  @ChartAlgorithmOrNullConverter()
  ChartAlgorithm? get algorithm;
  @override
  @ChartDataSourceOrNullConverter()
  ChartDataSource? get dataSource;
  @override

  /// Is a list of granted access to this entity.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_LayrzChartCopyWith<_$_LayrzChart> get copyWith =>
      throw _privateConstructorUsedError;
}

CommentOwner _$CommentOwnerFromJson(Map<String, dynamic> json) {
  return _CommentOwner.fromJson(json);
}

/// @nodoc
mixin _$CommentOwner {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String? get avatar => throw _privateConstructorUsedError;
  Avatar? get dynamicAvatar => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CommentOwnerCopyWith<CommentOwner> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CommentOwnerCopyWith<$Res> {
  factory $CommentOwnerCopyWith(
          CommentOwner value, $Res Function(CommentOwner) then) =
      _$CommentOwnerCopyWithImpl<$Res, CommentOwner>;
  @useResult
  $Res call({String id, String name, String? avatar, Avatar? dynamicAvatar});

  $AvatarCopyWith<$Res>? get dynamicAvatar;
}

/// @nodoc
class _$CommentOwnerCopyWithImpl<$Res, $Val extends CommentOwner>
    implements $CommentOwnerCopyWith<$Res> {
  _$CommentOwnerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? avatar = freezed,
    Object? dynamicAvatar = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      avatar: freezed == avatar
          ? _value.avatar
          : avatar // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicAvatar: freezed == dynamicAvatar
          ? _value.dynamicAvatar
          : dynamicAvatar // ignore: cast_nullable_to_non_nullable
              as Avatar?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AvatarCopyWith<$Res>? get dynamicAvatar {
    if (_value.dynamicAvatar == null) {
      return null;
    }

    return $AvatarCopyWith<$Res>(_value.dynamicAvatar!, (value) {
      return _then(_value.copyWith(dynamicAvatar: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_CommentOwnerCopyWith<$Res>
    implements $CommentOwnerCopyWith<$Res> {
  factory _$$_CommentOwnerCopyWith(
          _$_CommentOwner value, $Res Function(_$_CommentOwner) then) =
      __$$_CommentOwnerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name, String? avatar, Avatar? dynamicAvatar});

  @override
  $AvatarCopyWith<$Res>? get dynamicAvatar;
}

/// @nodoc
class __$$_CommentOwnerCopyWithImpl<$Res>
    extends _$CommentOwnerCopyWithImpl<$Res, _$_CommentOwner>
    implements _$$_CommentOwnerCopyWith<$Res> {
  __$$_CommentOwnerCopyWithImpl(
      _$_CommentOwner _value, $Res Function(_$_CommentOwner) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? avatar = freezed,
    Object? dynamicAvatar = freezed,
  }) {
    return _then(_$_CommentOwner(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      avatar: freezed == avatar
          ? _value.avatar
          : avatar // ignore: cast_nullable_to_non_nullable
              as String?,
      dynamicAvatar: freezed == dynamicAvatar
          ? _value.dynamicAvatar
          : dynamicAvatar // ignore: cast_nullable_to_non_nullable
              as Avatar?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CommentOwner implements _CommentOwner {
  const _$_CommentOwner(
      {required this.id, required this.name, this.avatar, this.dynamicAvatar});

  factory _$_CommentOwner.fromJson(Map<String, dynamic> json) =>
      _$$_CommentOwnerFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String? avatar;
  @override
  final Avatar? dynamicAvatar;

  @override
  String toString() {
    return 'CommentOwner(id: $id, name: $name, avatar: $avatar, dynamicAvatar: $dynamicAvatar)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CommentOwner &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.avatar, avatar) || other.avatar == avatar) &&
            (identical(other.dynamicAvatar, dynamicAvatar) ||
                other.dynamicAvatar == dynamicAvatar));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, avatar, dynamicAvatar);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CommentOwnerCopyWith<_$_CommentOwner> get copyWith =>
      __$$_CommentOwnerCopyWithImpl<_$_CommentOwner>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CommentOwnerToJson(
      this,
    );
  }
}

abstract class _CommentOwner implements CommentOwner {
  const factory _CommentOwner(
      {required final String id,
      required final String name,
      final String? avatar,
      final Avatar? dynamicAvatar}) = _$_CommentOwner;

  factory _CommentOwner.fromJson(Map<String, dynamic> json) =
      _$_CommentOwner.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String? get avatar;
  @override
  Avatar? get dynamicAvatar;
  @override
  @JsonKey(ignore: true)
  _$$_CommentOwnerCopyWith<_$_CommentOwner> get copyWith =>
      throw _privateConstructorUsedError;
}

CaseComment _$CaseCommentFromJson(Map<String, dynamic> json) {
  return _CaseComment.fromJson(json);
}

/// @nodoc
mixin _$CaseComment {
  String get id => throw _privateConstructorUsedError;
  @TimestampConverter()
  DateTime get at => throw _privateConstructorUsedError;
  CommentOwner? get owner => throw _privateConstructorUsedError;
  String get comment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CaseCommentCopyWith<CaseComment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CaseCommentCopyWith<$Res> {
  factory $CaseCommentCopyWith(
          CaseComment value, $Res Function(CaseComment) then) =
      _$CaseCommentCopyWithImpl<$Res, CaseComment>;
  @useResult
  $Res call(
      {String id,
      @TimestampConverter() DateTime at,
      CommentOwner? owner,
      String comment});

  $CommentOwnerCopyWith<$Res>? get owner;
}

/// @nodoc
class _$CaseCommentCopyWithImpl<$Res, $Val extends CaseComment>
    implements $CaseCommentCopyWith<$Res> {
  _$CaseCommentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? at = null,
    Object? owner = freezed,
    Object? comment = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      at: null == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as CommentOwner?,
      comment: null == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CommentOwnerCopyWith<$Res>? get owner {
    if (_value.owner == null) {
      return null;
    }

    return $CommentOwnerCopyWith<$Res>(_value.owner!, (value) {
      return _then(_value.copyWith(owner: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_CaseCommentCopyWith<$Res>
    implements $CaseCommentCopyWith<$Res> {
  factory _$$_CaseCommentCopyWith(
          _$_CaseComment value, $Res Function(_$_CaseComment) then) =
      __$$_CaseCommentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @TimestampConverter() DateTime at,
      CommentOwner? owner,
      String comment});

  @override
  $CommentOwnerCopyWith<$Res>? get owner;
}

/// @nodoc
class __$$_CaseCommentCopyWithImpl<$Res>
    extends _$CaseCommentCopyWithImpl<$Res, _$_CaseComment>
    implements _$$_CaseCommentCopyWith<$Res> {
  __$$_CaseCommentCopyWithImpl(
      _$_CaseComment _value, $Res Function(_$_CaseComment) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? at = null,
    Object? owner = freezed,
    Object? comment = null,
  }) {
    return _then(_$_CaseComment(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      at: null == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as CommentOwner?,
      comment: null == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CaseComment implements _CaseComment {
  const _$_CaseComment(
      {required this.id,
      @TimestampConverter() required this.at,
      this.owner,
      required this.comment});

  factory _$_CaseComment.fromJson(Map<String, dynamic> json) =>
      _$$_CaseCommentFromJson(json);

  @override
  final String id;
  @override
  @TimestampConverter()
  final DateTime at;
  @override
  final CommentOwner? owner;
  @override
  final String comment;

  @override
  String toString() {
    return 'CaseComment(id: $id, at: $at, owner: $owner, comment: $comment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CaseComment &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.at, at) || other.at == at) &&
            (identical(other.owner, owner) || other.owner == owner) &&
            (identical(other.comment, comment) || other.comment == comment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, at, owner, comment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CaseCommentCopyWith<_$_CaseComment> get copyWith =>
      __$$_CaseCommentCopyWithImpl<_$_CaseComment>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CaseCommentToJson(
      this,
    );
  }
}

abstract class _CaseComment implements CaseComment {
  const factory _CaseComment(
      {required final String id,
      @TimestampConverter() required final DateTime at,
      final CommentOwner? owner,
      required final String comment}) = _$_CaseComment;

  factory _CaseComment.fromJson(Map<String, dynamic> json) =
      _$_CaseComment.fromJson;

  @override
  String get id;
  @override
  @TimestampConverter()
  DateTime get at;
  @override
  CommentOwner? get owner;
  @override
  String get comment;
  @override
  @JsonKey(ignore: true)
  _$$_CaseCommentCopyWith<_$_CaseComment> get copyWith =>
      throw _privateConstructorUsedError;
}

Case _$CaseFromJson(Map<String, dynamic> json) {
  return _Case.fromJson(json);
}

/// @nodoc
mixin _$Case {
  String get id => throw _privateConstructorUsedError;
  @JsonKey(name: 'dateReceived')
  @TimestampConverter()
  DateTime get receivedAt => throw _privateConstructorUsedError;
  @CaseStatusConverter()
  CaseStatus get status => throw _privateConstructorUsedError;
  @CaseIgnoredStatusOrNullConverter()
  CaseIgnoredStatus? get ignoredStatus => throw _privateConstructorUsedError;
  Asset get asset => throw _privateConstructorUsedError;
  Trigger get trigger => throw _privateConstructorUsedError;
  int? get sequence => throw _privateConstructorUsedError;
  List<CaseComment> get comments => throw _privateConstructorUsedError;
  TelemetryPosition? get position => throw _privateConstructorUsedError;
  List<TelemetrySensor>? get payload => throw _privateConstructorUsedError;
  List<TelemetrySensor>? get sensors => throw _privateConstructorUsedError;
  CloudEntry? get file => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CaseCopyWith<Case> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CaseCopyWith<$Res> {
  factory $CaseCopyWith(Case value, $Res Function(Case) then) =
      _$CaseCopyWithImpl<$Res, Case>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'dateReceived') @TimestampConverter() DateTime receivedAt,
      @CaseStatusConverter() CaseStatus status,
      @CaseIgnoredStatusOrNullConverter() CaseIgnoredStatus? ignoredStatus,
      Asset asset,
      Trigger trigger,
      int? sequence,
      List<CaseComment> comments,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload,
      List<TelemetrySensor>? sensors,
      CloudEntry? file});

  $AssetCopyWith<$Res> get asset;
  $TriggerCopyWith<$Res> get trigger;
  $TelemetryPositionCopyWith<$Res>? get position;
  $CloudEntryCopyWith<$Res>? get file;
}

/// @nodoc
class _$CaseCopyWithImpl<$Res, $Val extends Case>
    implements $CaseCopyWith<$Res> {
  _$CaseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? receivedAt = null,
    Object? status = null,
    Object? ignoredStatus = freezed,
    Object? asset = null,
    Object? trigger = null,
    Object? sequence = freezed,
    Object? comments = null,
    Object? position = freezed,
    Object? payload = freezed,
    Object? sensors = freezed,
    Object? file = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CaseStatus,
      ignoredStatus: freezed == ignoredStatus
          ? _value.ignoredStatus
          : ignoredStatus // ignore: cast_nullable_to_non_nullable
              as CaseIgnoredStatus?,
      asset: null == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset,
      trigger: null == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as int?,
      comments: null == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as List<CaseComment>,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      sensors: freezed == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      file: freezed == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as CloudEntry?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res> get asset {
    return $AssetCopyWith<$Res>(_value.asset, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TriggerCopyWith<$Res> get trigger {
    return $TriggerCopyWith<$Res>(_value.trigger, (value) {
      return _then(_value.copyWith(trigger: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TelemetryPositionCopyWith<$Res>? get position {
    if (_value.position == null) {
      return null;
    }

    return $TelemetryPositionCopyWith<$Res>(_value.position!, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $CloudEntryCopyWith<$Res>? get file {
    if (_value.file == null) {
      return null;
    }

    return $CloudEntryCopyWith<$Res>(_value.file!, (value) {
      return _then(_value.copyWith(file: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_CaseCopyWith<$Res> implements $CaseCopyWith<$Res> {
  factory _$$_CaseCopyWith(_$_Case value, $Res Function(_$_Case) then) =
      __$$_CaseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'dateReceived') @TimestampConverter() DateTime receivedAt,
      @CaseStatusConverter() CaseStatus status,
      @CaseIgnoredStatusOrNullConverter() CaseIgnoredStatus? ignoredStatus,
      Asset asset,
      Trigger trigger,
      int? sequence,
      List<CaseComment> comments,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload,
      List<TelemetrySensor>? sensors,
      CloudEntry? file});

  @override
  $AssetCopyWith<$Res> get asset;
  @override
  $TriggerCopyWith<$Res> get trigger;
  @override
  $TelemetryPositionCopyWith<$Res>? get position;
  @override
  $CloudEntryCopyWith<$Res>? get file;
}

/// @nodoc
class __$$_CaseCopyWithImpl<$Res> extends _$CaseCopyWithImpl<$Res, _$_Case>
    implements _$$_CaseCopyWith<$Res> {
  __$$_CaseCopyWithImpl(_$_Case _value, $Res Function(_$_Case) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? receivedAt = null,
    Object? status = null,
    Object? ignoredStatus = freezed,
    Object? asset = null,
    Object? trigger = null,
    Object? sequence = freezed,
    Object? comments = null,
    Object? position = freezed,
    Object? payload = freezed,
    Object? sensors = freezed,
    Object? file = freezed,
  }) {
    return _then(_$_Case(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as CaseStatus,
      ignoredStatus: freezed == ignoredStatus
          ? _value.ignoredStatus
          : ignoredStatus // ignore: cast_nullable_to_non_nullable
              as CaseIgnoredStatus?,
      asset: null == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset,
      trigger: null == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger,
      sequence: freezed == sequence
          ? _value.sequence
          : sequence // ignore: cast_nullable_to_non_nullable
              as int?,
      comments: null == comments
          ? _value._comments
          : comments // ignore: cast_nullable_to_non_nullable
              as List<CaseComment>,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value._payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      sensors: freezed == sensors
          ? _value._sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      file: freezed == file
          ? _value.file
          : file // ignore: cast_nullable_to_non_nullable
              as CloudEntry?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Case implements _Case {
  const _$_Case(
      {required this.id,
      @JsonKey(name: 'dateReceived')
      @TimestampConverter()
      required this.receivedAt,
      @CaseStatusConverter() required this.status,
      @CaseIgnoredStatusOrNullConverter() this.ignoredStatus,
      required this.asset,
      required this.trigger,
      this.sequence,
      final List<CaseComment> comments = const [],
      this.position,
      final List<TelemetrySensor>? payload,
      final List<TelemetrySensor>? sensors,
      this.file})
      : _comments = comments,
        _payload = payload,
        _sensors = sensors;

  factory _$_Case.fromJson(Map<String, dynamic> json) => _$$_CaseFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: 'dateReceived')
  @TimestampConverter()
  final DateTime receivedAt;
  @override
  @CaseStatusConverter()
  final CaseStatus status;
  @override
  @CaseIgnoredStatusOrNullConverter()
  final CaseIgnoredStatus? ignoredStatus;
  @override
  final Asset asset;
  @override
  final Trigger trigger;
  @override
  final int? sequence;
  final List<CaseComment> _comments;
  @override
  @JsonKey()
  List<CaseComment> get comments {
    if (_comments is EqualUnmodifiableListView) return _comments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_comments);
  }

  @override
  final TelemetryPosition? position;
  final List<TelemetrySensor>? _payload;
  @override
  List<TelemetrySensor>? get payload {
    final value = _payload;
    if (value == null) return null;
    if (_payload is EqualUnmodifiableListView) return _payload;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<TelemetrySensor>? _sensors;
  @override
  List<TelemetrySensor>? get sensors {
    final value = _sensors;
    if (value == null) return null;
    if (_sensors is EqualUnmodifiableListView) return _sensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final CloudEntry? file;

  @override
  String toString() {
    return 'Case(id: $id, receivedAt: $receivedAt, status: $status, ignoredStatus: $ignoredStatus, asset: $asset, trigger: $trigger, sequence: $sequence, comments: $comments, position: $position, payload: $payload, sensors: $sensors, file: $file)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Case &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.receivedAt, receivedAt) ||
                other.receivedAt == receivedAt) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.ignoredStatus, ignoredStatus) ||
                other.ignoredStatus == ignoredStatus) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.trigger, trigger) || other.trigger == trigger) &&
            (identical(other.sequence, sequence) ||
                other.sequence == sequence) &&
            const DeepCollectionEquality().equals(other._comments, _comments) &&
            (identical(other.position, position) ||
                other.position == position) &&
            const DeepCollectionEquality().equals(other._payload, _payload) &&
            const DeepCollectionEquality().equals(other._sensors, _sensors) &&
            (identical(other.file, file) || other.file == file));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      receivedAt,
      status,
      ignoredStatus,
      asset,
      trigger,
      sequence,
      const DeepCollectionEquality().hash(_comments),
      position,
      const DeepCollectionEquality().hash(_payload),
      const DeepCollectionEquality().hash(_sensors),
      file);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CaseCopyWith<_$_Case> get copyWith =>
      __$$_CaseCopyWithImpl<_$_Case>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CaseToJson(
      this,
    );
  }
}

abstract class _Case implements Case {
  const factory _Case(
      {required final String id,
      @JsonKey(name: 'dateReceived')
      @TimestampConverter()
      required final DateTime receivedAt,
      @CaseStatusConverter() required final CaseStatus status,
      @CaseIgnoredStatusOrNullConverter()
      final CaseIgnoredStatus? ignoredStatus,
      required final Asset asset,
      required final Trigger trigger,
      final int? sequence,
      final List<CaseComment> comments,
      final TelemetryPosition? position,
      final List<TelemetrySensor>? payload,
      final List<TelemetrySensor>? sensors,
      final CloudEntry? file}) = _$_Case;

  factory _Case.fromJson(Map<String, dynamic> json) = _$_Case.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: 'dateReceived')
  @TimestampConverter()
  DateTime get receivedAt;
  @override
  @CaseStatusConverter()
  CaseStatus get status;
  @override
  @CaseIgnoredStatusOrNullConverter()
  CaseIgnoredStatus? get ignoredStatus;
  @override
  Asset get asset;
  @override
  Trigger get trigger;
  @override
  int? get sequence;
  @override
  List<CaseComment> get comments;
  @override
  TelemetryPosition? get position;
  @override
  List<TelemetrySensor>? get payload;
  @override
  List<TelemetrySensor>? get sensors;
  @override
  CloudEntry? get file;
  @override
  @JsonKey(ignore: true)
  _$$_CaseCopyWith<_$_Case> get copyWith => throw _privateConstructorUsedError;
}

Avatar _$AvatarFromJson(Map<String, dynamic> json) {
  return _Avatar.fromJson(json);
}

/// @nodoc
mixin _$Avatar {
  /// Represents the type of avatar.
  @AvatarTypeConverter()
  AvatarType get type => throw _privateConstructorUsedError;

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  String? get emoji => throw _privateConstructorUsedError;
  @IconOrNullConverter()
  IconData? get icon => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get base64 => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AvatarCopyWith<Avatar> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AvatarCopyWith<$Res> {
  factory $AvatarCopyWith(Avatar value, $Res Function(Avatar) then) =
      _$AvatarCopyWithImpl<$Res, Avatar>;
  @useResult
  $Res call(
      {@AvatarTypeConverter() AvatarType type,
      String? emoji,
      @IconOrNullConverter() IconData? icon,
      String? url,
      String? base64});
}

/// @nodoc
class _$AvatarCopyWithImpl<$Res, $Val extends Avatar>
    implements $AvatarCopyWith<$Res> {
  _$AvatarCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? emoji = freezed,
    Object? icon = freezed,
    Object? url = freezed,
    Object? base64 = freezed,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AvatarType,
      emoji: freezed == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      base64: freezed == base64
          ? _value.base64
          : base64 // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AvatarCopyWith<$Res> implements $AvatarCopyWith<$Res> {
  factory _$$_AvatarCopyWith(_$_Avatar value, $Res Function(_$_Avatar) then) =
      __$$_AvatarCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@AvatarTypeConverter() AvatarType type,
      String? emoji,
      @IconOrNullConverter() IconData? icon,
      String? url,
      String? base64});
}

/// @nodoc
class __$$_AvatarCopyWithImpl<$Res>
    extends _$AvatarCopyWithImpl<$Res, _$_Avatar>
    implements _$$_AvatarCopyWith<$Res> {
  __$$_AvatarCopyWithImpl(_$_Avatar _value, $Res Function(_$_Avatar) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? emoji = freezed,
    Object? icon = freezed,
    Object? url = freezed,
    Object? base64 = freezed,
  }) {
    return _then(_$_Avatar(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AvatarType,
      emoji: freezed == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      base64: freezed == base64
          ? _value.base64
          : base64 // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Avatar implements _Avatar {
  const _$_Avatar(
      {@AvatarTypeConverter() required this.type,
      this.emoji,
      @IconOrNullConverter() this.icon,
      this.url,
      this.base64});

  factory _$_Avatar.fromJson(Map<String, dynamic> json) =>
      _$$_AvatarFromJson(json);

  /// Represents the type of avatar.
  @override
  @AvatarTypeConverter()
  final AvatarType type;

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  @override
  final String? emoji;
  @override
  @IconOrNullConverter()
  final IconData? icon;
  @override
  final String? url;
  @override
  final String? base64;

  @override
  String toString() {
    return 'Avatar(type: $type, emoji: $emoji, icon: $icon, url: $url, base64: $base64)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Avatar &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.emoji, emoji) || other.emoji == emoji) &&
            (identical(other.icon, icon) || other.icon == icon) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.base64, base64) || other.base64 == base64));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, emoji, icon, url, base64);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AvatarCopyWith<_$_Avatar> get copyWith =>
      __$$_AvatarCopyWithImpl<_$_Avatar>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AvatarToJson(
      this,
    );
  }
}

abstract class _Avatar implements Avatar {
  const factory _Avatar(
      {@AvatarTypeConverter() required final AvatarType type,
      final String? emoji,
      @IconOrNullConverter() final IconData? icon,
      final String? url,
      final String? base64}) = _$_Avatar;

  factory _Avatar.fromJson(Map<String, dynamic> json) = _$_Avatar.fromJson;

  @override

  /// Represents the type of avatar.
  @AvatarTypeConverter()
  AvatarType get type;
  @override

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  String? get emoji;
  @override
  @IconOrNullConverter()
  IconData? get icon;
  @override
  String? get url;
  @override
  String? get base64;
  @override
  @JsonKey(ignore: true)
  _$$_AvatarCopyWith<_$_Avatar> get copyWith =>
      throw _privateConstructorUsedError;
}

AvatarInput _$AvatarInputFromJson(Map<String, dynamic> json) {
  return _AvatarInput.fromJson(json);
}

/// @nodoc
mixin _$AvatarInput {
  /// Represents the type of avatarInput.
  @AvatarTypeConverter()
  AvatarType get type => throw _privateConstructorUsedError;

  /// Represents the type of avatarInput.
  @AvatarTypeConverter()
  set type(AvatarType value) => throw _privateConstructorUsedError;

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  String? get emoji => throw _privateConstructorUsedError;

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  set emoji(String? value) => throw _privateConstructorUsedError;
  @IconOrNullConverter()
  IconData? get icon => throw _privateConstructorUsedError;
  @IconOrNullConverter()
  set icon(IconData? value) => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  set url(String? value) => throw _privateConstructorUsedError;
  String? get base64 => throw _privateConstructorUsedError;
  set base64(String? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AvatarInputCopyWith<AvatarInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AvatarInputCopyWith<$Res> {
  factory $AvatarInputCopyWith(
          AvatarInput value, $Res Function(AvatarInput) then) =
      _$AvatarInputCopyWithImpl<$Res, AvatarInput>;
  @useResult
  $Res call(
      {@AvatarTypeConverter() AvatarType type,
      String? emoji,
      @IconOrNullConverter() IconData? icon,
      String? url,
      String? base64});
}

/// @nodoc
class _$AvatarInputCopyWithImpl<$Res, $Val extends AvatarInput>
    implements $AvatarInputCopyWith<$Res> {
  _$AvatarInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? emoji = freezed,
    Object? icon = freezed,
    Object? url = freezed,
    Object? base64 = freezed,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AvatarType,
      emoji: freezed == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      base64: freezed == base64
          ? _value.base64
          : base64 // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AvatarInputCopyWith<$Res>
    implements $AvatarInputCopyWith<$Res> {
  factory _$$_AvatarInputCopyWith(
          _$_AvatarInput value, $Res Function(_$_AvatarInput) then) =
      __$$_AvatarInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@AvatarTypeConverter() AvatarType type,
      String? emoji,
      @IconOrNullConverter() IconData? icon,
      String? url,
      String? base64});
}

/// @nodoc
class __$$_AvatarInputCopyWithImpl<$Res>
    extends _$AvatarInputCopyWithImpl<$Res, _$_AvatarInput>
    implements _$$_AvatarInputCopyWith<$Res> {
  __$$_AvatarInputCopyWithImpl(
      _$_AvatarInput _value, $Res Function(_$_AvatarInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? emoji = freezed,
    Object? icon = freezed,
    Object? url = freezed,
    Object? base64 = freezed,
  }) {
    return _then(_$_AvatarInput(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as AvatarType,
      emoji: freezed == emoji
          ? _value.emoji
          : emoji // ignore: cast_nullable_to_non_nullable
              as String?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      url: freezed == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      base64: freezed == base64
          ? _value.base64
          : base64 // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AvatarInput implements _AvatarInput {
  _$_AvatarInput(
      {@AvatarTypeConverter() this.type = AvatarType.none,
      this.emoji,
      @IconOrNullConverter() this.icon,
      this.url,
      this.base64});

  factory _$_AvatarInput.fromJson(Map<String, dynamic> json) =>
      _$$_AvatarInputFromJson(json);

  /// Represents the type of avatarInput.
  @override
  @JsonKey()
  @AvatarTypeConverter()
  AvatarType type;

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  @override
  String? emoji;
  @override
  @IconOrNullConverter()
  IconData? icon;
  @override
  String? url;
  @override
  String? base64;

  @override
  String toString() {
    return 'AvatarInput(type: $type, emoji: $emoji, icon: $icon, url: $url, base64: $base64)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AvatarInputCopyWith<_$_AvatarInput> get copyWith =>
      __$$_AvatarInputCopyWithImpl<_$_AvatarInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AvatarInputToJson(
      this,
    );
  }
}

abstract class _AvatarInput implements AvatarInput {
  factory _AvatarInput(
      {@AvatarTypeConverter() AvatarType type,
      String? emoji,
      @IconOrNullConverter() IconData? icon,
      String? url,
      String? base64}) = _$_AvatarInput;

  factory _AvatarInput.fromJson(Map<String, dynamic> json) =
      _$_AvatarInput.fromJson;

  @override

  /// Represents the type of avatarInput.
  @AvatarTypeConverter()
  AvatarType get type;

  /// Represents the type of avatarInput.
  @AvatarTypeConverter()
  set type(AvatarType value);
  @override

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  String? get emoji;

  /// [emoji], [icon], [url] or [base64] depending on the [type].
  /// [emoni], [url] and [base64] are [String].
  /// And [icon] is [IconData].
  set emoji(String? value);
  @override
  @IconOrNullConverter()
  IconData? get icon;
  @IconOrNullConverter()
  set icon(IconData? value);
  @override
  String? get url;
  set url(String? value);
  @override
  String? get base64;
  set base64(String? value);
  @override
  @JsonKey(ignore: true)
  _$$_AvatarInputCopyWith<_$_AvatarInput> get copyWith =>
      throw _privateConstructorUsedError;
}

EmailTemplate _$EmailTemplateFromJson(Map<String, dynamic> json) {
  return _EmailTemplate.fromJson(json);
}

/// @nodoc
mixin _$EmailTemplate {
  /// Is the id of the email template
  String get id => throw _privateConstructorUsedError;

  /// Is the name of the email template
  String get name => throw _privateConstructorUsedError;

  /// Is the MJML content of the email template
  String? get contentMjml => throw _privateConstructorUsedError;

  /// Is the TXT content of the email template
  String? get contentTxt => throw _privateConstructorUsedError;

  /// The [access] of the device.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EmailTemplateCopyWith<EmailTemplate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmailTemplateCopyWith<$Res> {
  factory $EmailTemplateCopyWith(
          EmailTemplate value, $Res Function(EmailTemplate) then) =
      _$EmailTemplateCopyWithImpl<$Res, EmailTemplate>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? contentMjml,
      String? contentTxt,
      List<Access>? access});
}

/// @nodoc
class _$EmailTemplateCopyWithImpl<$Res, $Val extends EmailTemplate>
    implements $EmailTemplateCopyWith<$Res> {
  _$EmailTemplateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? contentMjml = freezed,
    Object? contentTxt = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      contentMjml: freezed == contentMjml
          ? _value.contentMjml
          : contentMjml // ignore: cast_nullable_to_non_nullable
              as String?,
      contentTxt: freezed == contentTxt
          ? _value.contentTxt
          : contentTxt // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_EmailTemplateCopyWith<$Res>
    implements $EmailTemplateCopyWith<$Res> {
  factory _$$_EmailTemplateCopyWith(
          _$_EmailTemplate value, $Res Function(_$_EmailTemplate) then) =
      __$$_EmailTemplateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? contentMjml,
      String? contentTxt,
      List<Access>? access});
}

/// @nodoc
class __$$_EmailTemplateCopyWithImpl<$Res>
    extends _$EmailTemplateCopyWithImpl<$Res, _$_EmailTemplate>
    implements _$$_EmailTemplateCopyWith<$Res> {
  __$$_EmailTemplateCopyWithImpl(
      _$_EmailTemplate _value, $Res Function(_$_EmailTemplate) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? contentMjml = freezed,
    Object? contentTxt = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_EmailTemplate(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      contentMjml: freezed == contentMjml
          ? _value.contentMjml
          : contentMjml // ignore: cast_nullable_to_non_nullable
              as String?,
      contentTxt: freezed == contentTxt
          ? _value.contentTxt
          : contentTxt // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_EmailTemplate implements _EmailTemplate {
  const _$_EmailTemplate(
      {required this.id,
      required this.name,
      this.contentMjml,
      this.contentTxt,
      final List<Access>? access})
      : _access = access;

  factory _$_EmailTemplate.fromJson(Map<String, dynamic> json) =>
      _$$_EmailTemplateFromJson(json);

  /// Is the id of the email template
  @override
  final String id;

  /// Is the name of the email template
  @override
  final String name;

  /// Is the MJML content of the email template
  @override
  final String? contentMjml;

  /// Is the TXT content of the email template
  @override
  final String? contentTxt;

  /// The [access] of the device.
  final List<Access>? _access;

  /// The [access] of the device.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'EmailTemplate(id: $id, name: $name, contentMjml: $contentMjml, contentTxt: $contentTxt, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EmailTemplate &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.contentMjml, contentMjml) ||
                other.contentMjml == contentMjml) &&
            (identical(other.contentTxt, contentTxt) ||
                other.contentTxt == contentTxt) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, contentMjml,
      contentTxt, const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EmailTemplateCopyWith<_$_EmailTemplate> get copyWith =>
      __$$_EmailTemplateCopyWithImpl<_$_EmailTemplate>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_EmailTemplateToJson(
      this,
    );
  }
}

abstract class _EmailTemplate implements EmailTemplate {
  const factory _EmailTemplate(
      {required final String id,
      required final String name,
      final String? contentMjml,
      final String? contentTxt,
      final List<Access>? access}) = _$_EmailTemplate;

  factory _EmailTemplate.fromJson(Map<String, dynamic> json) =
      _$_EmailTemplate.fromJson;

  @override

  /// Is the id of the email template
  String get id;
  @override

  /// Is the name of the email template
  String get name;
  @override

  /// Is the MJML content of the email template
  String? get contentMjml;
  @override

  /// Is the TXT content of the email template
  String? get contentTxt;
  @override

  /// The [access] of the device.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_EmailTemplateCopyWith<_$_EmailTemplate> get copyWith =>
      throw _privateConstructorUsedError;
}

FtpAccount _$FtpAccountFromJson(Map<String, dynamic> json) {
  return _FtpAccount.fromJson(json);
}

/// @nodoc
mixin _$FtpAccount {
  /// [host] is the host of the ftp account.
  String? get host => throw _privateConstructorUsedError;

  /// [port] is the port of the ftp account.
  int? get port => throw _privateConstructorUsedError;

  /// [username] is the username of the ftp account.
  String? get username => throw _privateConstructorUsedError;

  /// [password] is the password of the ftp account.
  String? get password => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FtpAccountCopyWith<FtpAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FtpAccountCopyWith<$Res> {
  factory $FtpAccountCopyWith(
          FtpAccount value, $Res Function(FtpAccount) then) =
      _$FtpAccountCopyWithImpl<$Res, FtpAccount>;
  @useResult
  $Res call({String? host, int? port, String? username, String? password});
}

/// @nodoc
class _$FtpAccountCopyWithImpl<$Res, $Val extends FtpAccount>
    implements $FtpAccountCopyWith<$Res> {
  _$FtpAccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? host = freezed,
    Object? port = freezed,
    Object? username = freezed,
    Object? password = freezed,
  }) {
    return _then(_value.copyWith(
      host: freezed == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String?,
      port: freezed == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_FtpAccountCopyWith<$Res>
    implements $FtpAccountCopyWith<$Res> {
  factory _$$_FtpAccountCopyWith(
          _$_FtpAccount value, $Res Function(_$_FtpAccount) then) =
      __$$_FtpAccountCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? host, int? port, String? username, String? password});
}

/// @nodoc
class __$$_FtpAccountCopyWithImpl<$Res>
    extends _$FtpAccountCopyWithImpl<$Res, _$_FtpAccount>
    implements _$$_FtpAccountCopyWith<$Res> {
  __$$_FtpAccountCopyWithImpl(
      _$_FtpAccount _value, $Res Function(_$_FtpAccount) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? host = freezed,
    Object? port = freezed,
    Object? username = freezed,
    Object? password = freezed,
  }) {
    return _then(_$_FtpAccount(
      host: freezed == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String?,
      port: freezed == port
          ? _value.port
          : port // ignore: cast_nullable_to_non_nullable
              as int?,
      username: freezed == username
          ? _value.username
          : username // ignore: cast_nullable_to_non_nullable
              as String?,
      password: freezed == password
          ? _value.password
          : password // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_FtpAccount implements _FtpAccount {
  const _$_FtpAccount({this.host, this.port, this.username, this.password});

  factory _$_FtpAccount.fromJson(Map<String, dynamic> json) =>
      _$$_FtpAccountFromJson(json);

  /// [host] is the host of the ftp account.
  @override
  final String? host;

  /// [port] is the port of the ftp account.
  @override
  final int? port;

  /// [username] is the username of the ftp account.
  @override
  final String? username;

  /// [password] is the password of the ftp account.
  @override
  final String? password;

  @override
  String toString() {
    return 'FtpAccount(host: $host, port: $port, username: $username, password: $password)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FtpAccount &&
            (identical(other.host, host) || other.host == host) &&
            (identical(other.port, port) || other.port == port) &&
            (identical(other.username, username) ||
                other.username == username) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, host, port, username, password);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FtpAccountCopyWith<_$_FtpAccount> get copyWith =>
      __$$_FtpAccountCopyWithImpl<_$_FtpAccount>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FtpAccountToJson(
      this,
    );
  }
}

abstract class _FtpAccount implements FtpAccount {
  const factory _FtpAccount(
      {final String? host,
      final int? port,
      final String? username,
      final String? password}) = _$_FtpAccount;

  factory _FtpAccount.fromJson(Map<String, dynamic> json) =
      _$_FtpAccount.fromJson;

  @override

  /// [host] is the host of the ftp account.
  String? get host;
  @override

  /// [port] is the port of the ftp account.
  int? get port;
  @override

  /// [username] is the username of the ftp account.
  String? get username;
  @override

  /// [password] is the password of the ftp account.
  String? get password;
  @override
  @JsonKey(ignore: true)
  _$$_FtpAccountCopyWith<_$_FtpAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

LayrzFunction _$LayrzFunctionFromJson(Map<String, dynamic> json) {
  return _LayrzFunction.fromJson(json);
}

/// @nodoc
mixin _$LayrzFunction {
  /// [id] is the unique identifier of the function.
  String get id => throw _privateConstructorUsedError;

  /// [name] is the name of the function.
  String get name => throw _privateConstructorUsedError;

  /// [algorithmId] is the unique identifier of the algorithm.
  String? get algorithmId => throw _privateConstructorUsedError;

  /// [algorithm] is the algorithm of the function.
  Algorithm? get algorithm => throw _privateConstructorUsedError;

  /// [maximumTime] is the minimum time of the function.
  /// Defined in minutes.
  double? get maximumTime => throw _privateConstructorUsedError;

  /// [minutesDelta] is the minutes delta of the function.
  /// Defined in minutes.
  double? get minutesDelta => throw _privateConstructorUsedError;

  /// [externalIdentifiers] is the external identifiers of the function.
  List<String>? get externalIdentifiers => throw _privateConstructorUsedError;

  /// [token] is the token of the function.
  String? get token => throw _privateConstructorUsedError;

  /// [credentials] is the credentials of the function.
  Map<String, dynamic>? get credentials => throw _privateConstructorUsedError;

  /// [ftp] is the ftp of the function.
  FtpAccount? get ftp => throw _privateConstructorUsedError;

  /// [groupsIds] is the groups ids of the function.
  List<String>? get groupsIds => throw _privateConstructorUsedError;

  /// [groups] is the groups of the function.
  List<Tag>? get groups => throw _privateConstructorUsedError;

  /// [assetsIds] is the assets ids of the function.
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  /// [assets] is the assets of the function.
  List<Asset>? get assets => throw _privateConstructorUsedError;

  /// [access] is the access of the function.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LayrzFunctionCopyWith<LayrzFunction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LayrzFunctionCopyWith<$Res> {
  factory $LayrzFunctionCopyWith(
          LayrzFunction value, $Res Function(LayrzFunction) then) =
      _$LayrzFunctionCopyWithImpl<$Res, LayrzFunction>;
  @useResult
  $Res call(
      {String id,
      String name,
      String? algorithmId,
      Algorithm? algorithm,
      double? maximumTime,
      double? minutesDelta,
      List<String>? externalIdentifiers,
      String? token,
      Map<String, dynamic>? credentials,
      FtpAccount? ftp,
      List<String>? groupsIds,
      List<Tag>? groups,
      List<String>? assetsIds,
      List<Asset>? assets,
      List<Access>? access});

  $AlgorithmCopyWith<$Res>? get algorithm;
  $FtpAccountCopyWith<$Res>? get ftp;
}

/// @nodoc
class _$LayrzFunctionCopyWithImpl<$Res, $Val extends LayrzFunction>
    implements $LayrzFunctionCopyWith<$Res> {
  _$LayrzFunctionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? algorithmId = freezed,
    Object? algorithm = freezed,
    Object? maximumTime = freezed,
    Object? minutesDelta = freezed,
    Object? externalIdentifiers = freezed,
    Object? token = freezed,
    Object? credentials = freezed,
    Object? ftp = freezed,
    Object? groupsIds = freezed,
    Object? groups = freezed,
    Object? assetsIds = freezed,
    Object? assets = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      algorithmId: freezed == algorithmId
          ? _value.algorithmId
          : algorithmId // ignore: cast_nullable_to_non_nullable
              as String?,
      algorithm: freezed == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as Algorithm?,
      maximumTime: freezed == maximumTime
          ? _value.maximumTime
          : maximumTime // ignore: cast_nullable_to_non_nullable
              as double?,
      minutesDelta: freezed == minutesDelta
          ? _value.minutesDelta
          : minutesDelta // ignore: cast_nullable_to_non_nullable
              as double?,
      externalIdentifiers: freezed == externalIdentifiers
          ? _value.externalIdentifiers
          : externalIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      credentials: freezed == credentials
          ? _value.credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      ftp: freezed == ftp
          ? _value.ftp
          : ftp // ignore: cast_nullable_to_non_nullable
              as FtpAccount?,
      groupsIds: freezed == groupsIds
          ? _value.groupsIds
          : groupsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      groups: freezed == groups
          ? _value.groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assets: freezed == assets
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AlgorithmCopyWith<$Res>? get algorithm {
    if (_value.algorithm == null) {
      return null;
    }

    return $AlgorithmCopyWith<$Res>(_value.algorithm!, (value) {
      return _then(_value.copyWith(algorithm: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $FtpAccountCopyWith<$Res>? get ftp {
    if (_value.ftp == null) {
      return null;
    }

    return $FtpAccountCopyWith<$Res>(_value.ftp!, (value) {
      return _then(_value.copyWith(ftp: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_LayrzFunctionCopyWith<$Res>
    implements $LayrzFunctionCopyWith<$Res> {
  factory _$$_LayrzFunctionCopyWith(
          _$_LayrzFunction value, $Res Function(_$_LayrzFunction) then) =
      __$$_LayrzFunctionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String? algorithmId,
      Algorithm? algorithm,
      double? maximumTime,
      double? minutesDelta,
      List<String>? externalIdentifiers,
      String? token,
      Map<String, dynamic>? credentials,
      FtpAccount? ftp,
      List<String>? groupsIds,
      List<Tag>? groups,
      List<String>? assetsIds,
      List<Asset>? assets,
      List<Access>? access});

  @override
  $AlgorithmCopyWith<$Res>? get algorithm;
  @override
  $FtpAccountCopyWith<$Res>? get ftp;
}

/// @nodoc
class __$$_LayrzFunctionCopyWithImpl<$Res>
    extends _$LayrzFunctionCopyWithImpl<$Res, _$_LayrzFunction>
    implements _$$_LayrzFunctionCopyWith<$Res> {
  __$$_LayrzFunctionCopyWithImpl(
      _$_LayrzFunction _value, $Res Function(_$_LayrzFunction) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? algorithmId = freezed,
    Object? algorithm = freezed,
    Object? maximumTime = freezed,
    Object? minutesDelta = freezed,
    Object? externalIdentifiers = freezed,
    Object? token = freezed,
    Object? credentials = freezed,
    Object? ftp = freezed,
    Object? groupsIds = freezed,
    Object? groups = freezed,
    Object? assetsIds = freezed,
    Object? assets = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_LayrzFunction(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      algorithmId: freezed == algorithmId
          ? _value.algorithmId
          : algorithmId // ignore: cast_nullable_to_non_nullable
              as String?,
      algorithm: freezed == algorithm
          ? _value.algorithm
          : algorithm // ignore: cast_nullable_to_non_nullable
              as Algorithm?,
      maximumTime: freezed == maximumTime
          ? _value.maximumTime
          : maximumTime // ignore: cast_nullable_to_non_nullable
              as double?,
      minutesDelta: freezed == minutesDelta
          ? _value.minutesDelta
          : minutesDelta // ignore: cast_nullable_to_non_nullable
              as double?,
      externalIdentifiers: freezed == externalIdentifiers
          ? _value._externalIdentifiers
          : externalIdentifiers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      token: freezed == token
          ? _value.token
          : token // ignore: cast_nullable_to_non_nullable
              as String?,
      credentials: freezed == credentials
          ? _value._credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      ftp: freezed == ftp
          ? _value.ftp
          : ftp // ignore: cast_nullable_to_non_nullable
              as FtpAccount?,
      groupsIds: freezed == groupsIds
          ? _value._groupsIds
          : groupsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      groups: freezed == groups
          ? _value._groups
          : groups // ignore: cast_nullable_to_non_nullable
              as List<Tag>?,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assets: freezed == assets
          ? _value._assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LayrzFunction implements _LayrzFunction {
  const _$_LayrzFunction(
      {required this.id,
      required this.name,
      this.algorithmId,
      this.algorithm,
      this.maximumTime,
      this.minutesDelta,
      final List<String>? externalIdentifiers,
      this.token,
      final Map<String, dynamic>? credentials,
      this.ftp,
      final List<String>? groupsIds,
      final List<Tag>? groups,
      final List<String>? assetsIds,
      final List<Asset>? assets,
      final List<Access>? access})
      : _externalIdentifiers = externalIdentifiers,
        _credentials = credentials,
        _groupsIds = groupsIds,
        _groups = groups,
        _assetsIds = assetsIds,
        _assets = assets,
        _access = access;

  factory _$_LayrzFunction.fromJson(Map<String, dynamic> json) =>
      _$$_LayrzFunctionFromJson(json);

  /// [id] is the unique identifier of the function.
  @override
  final String id;

  /// [name] is the name of the function.
  @override
  final String name;

  /// [algorithmId] is the unique identifier of the algorithm.
  @override
  final String? algorithmId;

  /// [algorithm] is the algorithm of the function.
  @override
  final Algorithm? algorithm;

  /// [maximumTime] is the minimum time of the function.
  /// Defined in minutes.
  @override
  final double? maximumTime;

  /// [minutesDelta] is the minutes delta of the function.
  /// Defined in minutes.
  @override
  final double? minutesDelta;

  /// [externalIdentifiers] is the external identifiers of the function.
  final List<String>? _externalIdentifiers;

  /// [externalIdentifiers] is the external identifiers of the function.
  @override
  List<String>? get externalIdentifiers {
    final value = _externalIdentifiers;
    if (value == null) return null;
    if (_externalIdentifiers is EqualUnmodifiableListView)
      return _externalIdentifiers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [token] is the token of the function.
  @override
  final String? token;

  /// [credentials] is the credentials of the function.
  final Map<String, dynamic>? _credentials;

  /// [credentials] is the credentials of the function.
  @override
  Map<String, dynamic>? get credentials {
    final value = _credentials;
    if (value == null) return null;
    if (_credentials is EqualUnmodifiableMapView) return _credentials;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// [ftp] is the ftp of the function.
  @override
  final FtpAccount? ftp;

  /// [groupsIds] is the groups ids of the function.
  final List<String>? _groupsIds;

  /// [groupsIds] is the groups ids of the function.
  @override
  List<String>? get groupsIds {
    final value = _groupsIds;
    if (value == null) return null;
    if (_groupsIds is EqualUnmodifiableListView) return _groupsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [groups] is the groups of the function.
  final List<Tag>? _groups;

  /// [groups] is the groups of the function.
  @override
  List<Tag>? get groups {
    final value = _groups;
    if (value == null) return null;
    if (_groups is EqualUnmodifiableListView) return _groups;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [assetsIds] is the assets ids of the function.
  final List<String>? _assetsIds;

  /// [assetsIds] is the assets ids of the function.
  @override
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [assets] is the assets of the function.
  final List<Asset>? _assets;

  /// [assets] is the assets of the function.
  @override
  List<Asset>? get assets {
    final value = _assets;
    if (value == null) return null;
    if (_assets is EqualUnmodifiableListView) return _assets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [access] is the access of the function.
  final List<Access>? _access;

  /// [access] is the access of the function.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'LayrzFunction(id: $id, name: $name, algorithmId: $algorithmId, algorithm: $algorithm, maximumTime: $maximumTime, minutesDelta: $minutesDelta, externalIdentifiers: $externalIdentifiers, token: $token, credentials: $credentials, ftp: $ftp, groupsIds: $groupsIds, groups: $groups, assetsIds: $assetsIds, assets: $assets, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LayrzFunction &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.algorithmId, algorithmId) ||
                other.algorithmId == algorithmId) &&
            (identical(other.algorithm, algorithm) ||
                other.algorithm == algorithm) &&
            (identical(other.maximumTime, maximumTime) ||
                other.maximumTime == maximumTime) &&
            (identical(other.minutesDelta, minutesDelta) ||
                other.minutesDelta == minutesDelta) &&
            const DeepCollectionEquality()
                .equals(other._externalIdentifiers, _externalIdentifiers) &&
            (identical(other.token, token) || other.token == token) &&
            const DeepCollectionEquality()
                .equals(other._credentials, _credentials) &&
            (identical(other.ftp, ftp) || other.ftp == ftp) &&
            const DeepCollectionEquality()
                .equals(other._groupsIds, _groupsIds) &&
            const DeepCollectionEquality().equals(other._groups, _groups) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds) &&
            const DeepCollectionEquality().equals(other._assets, _assets) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      algorithmId,
      algorithm,
      maximumTime,
      minutesDelta,
      const DeepCollectionEquality().hash(_externalIdentifiers),
      token,
      const DeepCollectionEquality().hash(_credentials),
      ftp,
      const DeepCollectionEquality().hash(_groupsIds),
      const DeepCollectionEquality().hash(_groups),
      const DeepCollectionEquality().hash(_assetsIds),
      const DeepCollectionEquality().hash(_assets),
      const DeepCollectionEquality().hash(_access));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LayrzFunctionCopyWith<_$_LayrzFunction> get copyWith =>
      __$$_LayrzFunctionCopyWithImpl<_$_LayrzFunction>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LayrzFunctionToJson(
      this,
    );
  }
}

abstract class _LayrzFunction implements LayrzFunction {
  const factory _LayrzFunction(
      {required final String id,
      required final String name,
      final String? algorithmId,
      final Algorithm? algorithm,
      final double? maximumTime,
      final double? minutesDelta,
      final List<String>? externalIdentifiers,
      final String? token,
      final Map<String, dynamic>? credentials,
      final FtpAccount? ftp,
      final List<String>? groupsIds,
      final List<Tag>? groups,
      final List<String>? assetsIds,
      final List<Asset>? assets,
      final List<Access>? access}) = _$_LayrzFunction;

  factory _LayrzFunction.fromJson(Map<String, dynamic> json) =
      _$_LayrzFunction.fromJson;

  @override

  /// [id] is the unique identifier of the function.
  String get id;
  @override

  /// [name] is the name of the function.
  String get name;
  @override

  /// [algorithmId] is the unique identifier of the algorithm.
  String? get algorithmId;
  @override

  /// [algorithm] is the algorithm of the function.
  Algorithm? get algorithm;
  @override

  /// [maximumTime] is the minimum time of the function.
  /// Defined in minutes.
  double? get maximumTime;
  @override

  /// [minutesDelta] is the minutes delta of the function.
  /// Defined in minutes.
  double? get minutesDelta;
  @override

  /// [externalIdentifiers] is the external identifiers of the function.
  List<String>? get externalIdentifiers;
  @override

  /// [token] is the token of the function.
  String? get token;
  @override

  /// [credentials] is the credentials of the function.
  Map<String, dynamic>? get credentials;
  @override

  /// [ftp] is the ftp of the function.
  FtpAccount? get ftp;
  @override

  /// [groupsIds] is the groups ids of the function.
  List<String>? get groupsIds;
  @override

  /// [groups] is the groups of the function.
  List<Tag>? get groups;
  @override

  /// [assetsIds] is the assets ids of the function.
  List<String>? get assetsIds;
  @override

  /// [assets] is the assets of the function.
  List<Asset>? get assets;
  @override

  /// [access] is the access of the function.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_LayrzFunctionCopyWith<_$_LayrzFunction> get copyWith =>
      throw _privateConstructorUsedError;
}

ExternalSource _$ExternalSourceFromJson(Map<String, dynamic> json) {
  return _ExternalSource.fromJson(json);
}

/// @nodoc
mixin _$ExternalSource {
  /// [id] represents the DB ID.
  String get id => throw _privateConstructorUsedError;

  /// [name] represents the name of the external account.
  String get name => throw _privateConstructorUsedError;

  /// [color] represents the color of the external account.
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;

  /// [isEnabled] represents if the external account is enabled.
  bool get isEnabled => throw _privateConstructorUsedError;

  /// [requiredFields] represents the required fields of the external account.
  List<CredentialField> get requiredFields =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExternalSourceCopyWith<ExternalSource> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExternalSourceCopyWith<$Res> {
  factory $ExternalSourceCopyWith(
          ExternalSource value, $Res Function(ExternalSource) then) =
      _$ExternalSourceCopyWithImpl<$Res, ExternalSource>;
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      bool isEnabled,
      List<CredentialField> requiredFields});
}

/// @nodoc
class _$ExternalSourceCopyWithImpl<$Res, $Val extends ExternalSource>
    implements $ExternalSourceCopyWith<$Res> {
  _$ExternalSourceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? isEnabled = null,
    Object? requiredFields = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      requiredFields: null == requiredFields
          ? _value.requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExternalSourceCopyWith<$Res>
    implements $ExternalSourceCopyWith<$Res> {
  factory _$$_ExternalSourceCopyWith(
          _$_ExternalSource value, $Res Function(_$_ExternalSource) then) =
      __$$_ExternalSourceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @ColorConverter() Color color,
      bool isEnabled,
      List<CredentialField> requiredFields});
}

/// @nodoc
class __$$_ExternalSourceCopyWithImpl<$Res>
    extends _$ExternalSourceCopyWithImpl<$Res, _$_ExternalSource>
    implements _$$_ExternalSourceCopyWith<$Res> {
  __$$_ExternalSourceCopyWithImpl(
      _$_ExternalSource _value, $Res Function(_$_ExternalSource) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? color = null,
    Object? isEnabled = null,
    Object? requiredFields = null,
  }) {
    return _then(_$_ExternalSource(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      isEnabled: null == isEnabled
          ? _value.isEnabled
          : isEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
      requiredFields: null == requiredFields
          ? _value._requiredFields
          : requiredFields // ignore: cast_nullable_to_non_nullable
              as List<CredentialField>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ExternalSource implements _ExternalSource {
  const _$_ExternalSource(
      {required this.id,
      required this.name,
      @ColorConverter() required this.color,
      required this.isEnabled,
      final List<CredentialField> requiredFields = const []})
      : _requiredFields = requiredFields;

  factory _$_ExternalSource.fromJson(Map<String, dynamic> json) =>
      _$$_ExternalSourceFromJson(json);

  /// [id] represents the DB ID.
  @override
  final String id;

  /// [name] represents the name of the external account.
  @override
  final String name;

  /// [color] represents the color of the external account.
  @override
  @ColorConverter()
  final Color color;

  /// [isEnabled] represents if the external account is enabled.
  @override
  final bool isEnabled;

  /// [requiredFields] represents the required fields of the external account.
  final List<CredentialField> _requiredFields;

  /// [requiredFields] represents the required fields of the external account.
  @override
  @JsonKey()
  List<CredentialField> get requiredFields {
    if (_requiredFields is EqualUnmodifiableListView) return _requiredFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requiredFields);
  }

  @override
  String toString() {
    return 'ExternalSource(id: $id, name: $name, color: $color, isEnabled: $isEnabled, requiredFields: $requiredFields)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExternalSource &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isEnabled, isEnabled) ||
                other.isEnabled == isEnabled) &&
            const DeepCollectionEquality()
                .equals(other._requiredFields, _requiredFields));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, color, isEnabled,
      const DeepCollectionEquality().hash(_requiredFields));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExternalSourceCopyWith<_$_ExternalSource> get copyWith =>
      __$$_ExternalSourceCopyWithImpl<_$_ExternalSource>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExternalSourceToJson(
      this,
    );
  }
}

abstract class _ExternalSource implements ExternalSource {
  const factory _ExternalSource(
      {required final String id,
      required final String name,
      @ColorConverter() required final Color color,
      required final bool isEnabled,
      final List<CredentialField> requiredFields}) = _$_ExternalSource;

  factory _ExternalSource.fromJson(Map<String, dynamic> json) =
      _$_ExternalSource.fromJson;

  @override

  /// [id] represents the DB ID.
  String get id;
  @override

  /// [name] represents the name of the external account.
  String get name;
  @override

  /// [color] represents the color of the external account.
  @ColorConverter()
  Color get color;
  @override

  /// [isEnabled] represents if the external account is enabled.
  bool get isEnabled;
  @override

  /// [requiredFields] represents the required fields of the external account.
  List<CredentialField> get requiredFields;
  @override
  @JsonKey(ignore: true)
  _$$_ExternalSourceCopyWith<_$_ExternalSource> get copyWith =>
      throw _privateConstructorUsedError;
}

ExternalAccount _$ExternalAccountFromJson(Map<String, dynamic> json) {
  return _ExternalAccount.fromJson(json);
}

/// @nodoc
mixin _$ExternalAccount {
  /// [id] represents the DB ID.
  String get id => throw _privateConstructorUsedError;

  /// [name] represents the name of the external account.
  String get name => throw _privateConstructorUsedError;

  /// [credentials] represents the credentials of the external account.
  Map<String, dynamic>? get credentials => throw _privateConstructorUsedError;

  /// [source] represents the protocol
  ExternalSource? get source => throw _privateConstructorUsedError;

  /// [sourceId] represents the source ID.
  String? get sourceId => throw _privateConstructorUsedError;

  /// [access] represents the access of the external account.
  List<Access>? get access => throw _privateConstructorUsedError;

  /// [devices] represents the devices imported from the external account.
  List<Device>? get devices => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExternalAccountCopyWith<ExternalAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExternalAccountCopyWith<$Res> {
  factory $ExternalAccountCopyWith(
          ExternalAccount value, $Res Function(ExternalAccount) then) =
      _$ExternalAccountCopyWithImpl<$Res, ExternalAccount>;
  @useResult
  $Res call(
      {String id,
      String name,
      Map<String, dynamic>? credentials,
      ExternalSource? source,
      String? sourceId,
      List<Access>? access,
      List<Device>? devices});

  $ExternalSourceCopyWith<$Res>? get source;
}

/// @nodoc
class _$ExternalAccountCopyWithImpl<$Res, $Val extends ExternalAccount>
    implements $ExternalAccountCopyWith<$Res> {
  _$ExternalAccountCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? credentials = freezed,
    Object? source = freezed,
    Object? sourceId = freezed,
    Object? access = freezed,
    Object? devices = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      credentials: freezed == credentials
          ? _value.credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ExternalSource?,
      sourceId: freezed == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      devices: freezed == devices
          ? _value.devices
          : devices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ExternalSourceCopyWith<$Res>? get source {
    if (_value.source == null) {
      return null;
    }

    return $ExternalSourceCopyWith<$Res>(_value.source!, (value) {
      return _then(_value.copyWith(source: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ExternalAccountCopyWith<$Res>
    implements $ExternalAccountCopyWith<$Res> {
  factory _$$_ExternalAccountCopyWith(
          _$_ExternalAccount value, $Res Function(_$_ExternalAccount) then) =
      __$$_ExternalAccountCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      Map<String, dynamic>? credentials,
      ExternalSource? source,
      String? sourceId,
      List<Access>? access,
      List<Device>? devices});

  @override
  $ExternalSourceCopyWith<$Res>? get source;
}

/// @nodoc
class __$$_ExternalAccountCopyWithImpl<$Res>
    extends _$ExternalAccountCopyWithImpl<$Res, _$_ExternalAccount>
    implements _$$_ExternalAccountCopyWith<$Res> {
  __$$_ExternalAccountCopyWithImpl(
      _$_ExternalAccount _value, $Res Function(_$_ExternalAccount) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? credentials = freezed,
    Object? source = freezed,
    Object? sourceId = freezed,
    Object? access = freezed,
    Object? devices = freezed,
  }) {
    return _then(_$_ExternalAccount(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      credentials: freezed == credentials
          ? _value._credentials
          : credentials // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as ExternalSource?,
      sourceId: freezed == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as String?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
      devices: freezed == devices
          ? _value._devices
          : devices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ExternalAccount implements _ExternalAccount {
  const _$_ExternalAccount(
      {required this.id,
      required this.name,
      final Map<String, dynamic>? credentials,
      this.source,
      this.sourceId,
      final List<Access>? access,
      final List<Device>? devices})
      : _credentials = credentials,
        _access = access,
        _devices = devices;

  factory _$_ExternalAccount.fromJson(Map<String, dynamic> json) =>
      _$$_ExternalAccountFromJson(json);

  /// [id] represents the DB ID.
  @override
  final String id;

  /// [name] represents the name of the external account.
  @override
  final String name;

  /// [credentials] represents the credentials of the external account.
  final Map<String, dynamic>? _credentials;

  /// [credentials] represents the credentials of the external account.
  @override
  Map<String, dynamic>? get credentials {
    final value = _credentials;
    if (value == null) return null;
    if (_credentials is EqualUnmodifiableMapView) return _credentials;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  /// [source] represents the protocol
  @override
  final ExternalSource? source;

  /// [sourceId] represents the source ID.
  @override
  final String? sourceId;

  /// [access] represents the access of the external account.
  final List<Access>? _access;

  /// [access] represents the access of the external account.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [devices] represents the devices imported from the external account.
  final List<Device>? _devices;

  /// [devices] represents the devices imported from the external account.
  @override
  List<Device>? get devices {
    final value = _devices;
    if (value == null) return null;
    if (_devices is EqualUnmodifiableListView) return _devices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'ExternalAccount(id: $id, name: $name, credentials: $credentials, source: $source, sourceId: $sourceId, access: $access, devices: $devices)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExternalAccount &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._credentials, _credentials) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.sourceId, sourceId) ||
                other.sourceId == sourceId) &&
            const DeepCollectionEquality().equals(other._access, _access) &&
            const DeepCollectionEquality().equals(other._devices, _devices));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      const DeepCollectionEquality().hash(_credentials),
      source,
      sourceId,
      const DeepCollectionEquality().hash(_access),
      const DeepCollectionEquality().hash(_devices));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExternalAccountCopyWith<_$_ExternalAccount> get copyWith =>
      __$$_ExternalAccountCopyWithImpl<_$_ExternalAccount>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExternalAccountToJson(
      this,
    );
  }
}

abstract class _ExternalAccount implements ExternalAccount {
  const factory _ExternalAccount(
      {required final String id,
      required final String name,
      final Map<String, dynamic>? credentials,
      final ExternalSource? source,
      final String? sourceId,
      final List<Access>? access,
      final List<Device>? devices}) = _$_ExternalAccount;

  factory _ExternalAccount.fromJson(Map<String, dynamic> json) =
      _$_ExternalAccount.fromJson;

  @override

  /// [id] represents the DB ID.
  String get id;
  @override

  /// [name] represents the name of the external account.
  String get name;
  @override

  /// [credentials] represents the credentials of the external account.
  Map<String, dynamic>? get credentials;
  @override

  /// [source] represents the protocol
  ExternalSource? get source;
  @override

  /// [sourceId] represents the source ID.
  String? get sourceId;
  @override

  /// [access] represents the access of the external account.
  List<Access>? get access;
  @override

  /// [devices] represents the devices imported from the external account.
  List<Device>? get devices;
  @override
  @JsonKey(ignore: true)
  _$$_ExternalAccountCopyWith<_$_ExternalAccount> get copyWith =>
      throw _privateConstructorUsedError;
}

ExternalUnit _$ExternalUnitFromJson(Map<String, dynamic> json) {
  return _ExternalUnit.fromJson(json);
}

/// @nodoc
mixin _$ExternalUnit {
  String? get externalId => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get ident => throw _privateConstructorUsedError;
  Map<String, dynamic> get additionalFields =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExternalUnitCopyWith<ExternalUnit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExternalUnitCopyWith<$Res> {
  factory $ExternalUnitCopyWith(
          ExternalUnit value, $Res Function(ExternalUnit) then) =
      _$ExternalUnitCopyWithImpl<$Res, ExternalUnit>;
  @useResult
  $Res call(
      {String? externalId,
      String name,
      String ident,
      Map<String, dynamic> additionalFields});
}

/// @nodoc
class _$ExternalUnitCopyWithImpl<$Res, $Val extends ExternalUnit>
    implements $ExternalUnitCopyWith<$Res> {
  _$ExternalUnitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? externalId = freezed,
    Object? name = null,
    Object? ident = null,
    Object? additionalFields = null,
  }) {
    return _then(_value.copyWith(
      externalId: freezed == externalId
          ? _value.externalId
          : externalId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      ident: null == ident
          ? _value.ident
          : ident // ignore: cast_nullable_to_non_nullable
              as String,
      additionalFields: null == additionalFields
          ? _value.additionalFields
          : additionalFields // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExternalUnitCopyWith<$Res>
    implements $ExternalUnitCopyWith<$Res> {
  factory _$$_ExternalUnitCopyWith(
          _$_ExternalUnit value, $Res Function(_$_ExternalUnit) then) =
      __$$_ExternalUnitCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? externalId,
      String name,
      String ident,
      Map<String, dynamic> additionalFields});
}

/// @nodoc
class __$$_ExternalUnitCopyWithImpl<$Res>
    extends _$ExternalUnitCopyWithImpl<$Res, _$_ExternalUnit>
    implements _$$_ExternalUnitCopyWith<$Res> {
  __$$_ExternalUnitCopyWithImpl(
      _$_ExternalUnit _value, $Res Function(_$_ExternalUnit) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? externalId = freezed,
    Object? name = null,
    Object? ident = null,
    Object? additionalFields = null,
  }) {
    return _then(_$_ExternalUnit(
      externalId: freezed == externalId
          ? _value.externalId
          : externalId // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      ident: null == ident
          ? _value.ident
          : ident // ignore: cast_nullable_to_non_nullable
              as String,
      additionalFields: null == additionalFields
          ? _value._additionalFields
          : additionalFields // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ExternalUnit implements _ExternalUnit {
  const _$_ExternalUnit(
      {this.externalId,
      required this.name,
      required this.ident,
      required final Map<String, dynamic> additionalFields})
      : _additionalFields = additionalFields;

  factory _$_ExternalUnit.fromJson(Map<String, dynamic> json) =>
      _$$_ExternalUnitFromJson(json);

  @override
  final String? externalId;
  @override
  final String name;
  @override
  final String ident;
  final Map<String, dynamic> _additionalFields;
  @override
  Map<String, dynamic> get additionalFields {
    if (_additionalFields is EqualUnmodifiableMapView) return _additionalFields;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_additionalFields);
  }

  @override
  String toString() {
    return 'ExternalUnit(externalId: $externalId, name: $name, ident: $ident, additionalFields: $additionalFields)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExternalUnit &&
            (identical(other.externalId, externalId) ||
                other.externalId == externalId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.ident, ident) || other.ident == ident) &&
            const DeepCollectionEquality()
                .equals(other._additionalFields, _additionalFields));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, externalId, name, ident,
      const DeepCollectionEquality().hash(_additionalFields));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExternalUnitCopyWith<_$_ExternalUnit> get copyWith =>
      __$$_ExternalUnitCopyWithImpl<_$_ExternalUnit>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExternalUnitToJson(
      this,
    );
  }
}

abstract class _ExternalUnit implements ExternalUnit {
  const factory _ExternalUnit(
      {final String? externalId,
      required final String name,
      required final String ident,
      required final Map<String, dynamic> additionalFields}) = _$_ExternalUnit;

  factory _ExternalUnit.fromJson(Map<String, dynamic> json) =
      _$_ExternalUnit.fromJson;

  @override
  String? get externalId;
  @override
  String get name;
  @override
  String get ident;
  @override
  Map<String, dynamic> get additionalFields;
  @override
  @JsonKey(ignore: true)
  _$$_ExternalUnitCopyWith<_$_ExternalUnit> get copyWith =>
      throw _privateConstructorUsedError;
}

ExternalResource _$ExternalResourceFromJson(Map<String, dynamic> json) {
  return _ExternalResource.fromJson(json);
}

/// @nodoc
mixin _$ExternalResource {
  /// [wialonId] represents the ID from Wialon (Hosting or local).
  String get wialonId => throw _privateConstructorUsedError;

  /// [name] represents the name of the resource in Wialon.
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExternalResourceCopyWith<ExternalResource> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExternalResourceCopyWith<$Res> {
  factory $ExternalResourceCopyWith(
          ExternalResource value, $Res Function(ExternalResource) then) =
      _$ExternalResourceCopyWithImpl<$Res, ExternalResource>;
  @useResult
  $Res call({String wialonId, String name});
}

/// @nodoc
class _$ExternalResourceCopyWithImpl<$Res, $Val extends ExternalResource>
    implements $ExternalResourceCopyWith<$Res> {
  _$ExternalResourceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wialonId = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      wialonId: null == wialonId
          ? _value.wialonId
          : wialonId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExternalResourceCopyWith<$Res>
    implements $ExternalResourceCopyWith<$Res> {
  factory _$$_ExternalResourceCopyWith(
          _$_ExternalResource value, $Res Function(_$_ExternalResource) then) =
      __$$_ExternalResourceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String wialonId, String name});
}

/// @nodoc
class __$$_ExternalResourceCopyWithImpl<$Res>
    extends _$ExternalResourceCopyWithImpl<$Res, _$_ExternalResource>
    implements _$$_ExternalResourceCopyWith<$Res> {
  __$$_ExternalResourceCopyWithImpl(
      _$_ExternalResource _value, $Res Function(_$_ExternalResource) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wialonId = null,
    Object? name = null,
  }) {
    return _then(_$_ExternalResource(
      wialonId: null == wialonId
          ? _value.wialonId
          : wialonId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ExternalResource implements _ExternalResource {
  const _$_ExternalResource({required this.wialonId, required this.name});

  factory _$_ExternalResource.fromJson(Map<String, dynamic> json) =>
      _$$_ExternalResourceFromJson(json);

  /// [wialonId] represents the ID from Wialon (Hosting or local).
  @override
  final String wialonId;

  /// [name] represents the name of the resource in Wialon.
  @override
  final String name;

  @override
  String toString() {
    return 'ExternalResource(wialonId: $wialonId, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExternalResource &&
            (identical(other.wialonId, wialonId) ||
                other.wialonId == wialonId) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, wialonId, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExternalResourceCopyWith<_$_ExternalResource> get copyWith =>
      __$$_ExternalResourceCopyWithImpl<_$_ExternalResource>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExternalResourceToJson(
      this,
    );
  }
}

abstract class _ExternalResource implements ExternalResource {
  const factory _ExternalResource(
      {required final String wialonId,
      required final String name}) = _$_ExternalResource;

  factory _ExternalResource.fromJson(Map<String, dynamic> json) =
      _$_ExternalResource.fromJson;

  @override

  /// [wialonId] represents the ID from Wialon (Hosting or local).
  String get wialonId;
  @override

  /// [name] represents the name of the resource in Wialon.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$_ExternalResourceCopyWith<_$_ExternalResource> get copyWith =>
      throw _privateConstructorUsedError;
}

ExternalGeofence _$ExternalGeofenceFromJson(Map<String, dynamic> json) {
  return _ExternalGeofence.fromJson(json);
}

/// @nodoc
mixin _$ExternalGeofence {
  /// [wialonId] represents the ID from Wialon (Hosting or local).
  String get wialonId => throw _privateConstructorUsedError;

  /// [name] represents the name of the geofence in Wialon.
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ExternalGeofenceCopyWith<ExternalGeofence> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExternalGeofenceCopyWith<$Res> {
  factory $ExternalGeofenceCopyWith(
          ExternalGeofence value, $Res Function(ExternalGeofence) then) =
      _$ExternalGeofenceCopyWithImpl<$Res, ExternalGeofence>;
  @useResult
  $Res call({String wialonId, String name});
}

/// @nodoc
class _$ExternalGeofenceCopyWithImpl<$Res, $Val extends ExternalGeofence>
    implements $ExternalGeofenceCopyWith<$Res> {
  _$ExternalGeofenceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wialonId = null,
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      wialonId: null == wialonId
          ? _value.wialonId
          : wialonId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExternalGeofenceCopyWith<$Res>
    implements $ExternalGeofenceCopyWith<$Res> {
  factory _$$_ExternalGeofenceCopyWith(
          _$_ExternalGeofence value, $Res Function(_$_ExternalGeofence) then) =
      __$$_ExternalGeofenceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String wialonId, String name});
}

/// @nodoc
class __$$_ExternalGeofenceCopyWithImpl<$Res>
    extends _$ExternalGeofenceCopyWithImpl<$Res, _$_ExternalGeofence>
    implements _$$_ExternalGeofenceCopyWith<$Res> {
  __$$_ExternalGeofenceCopyWithImpl(
      _$_ExternalGeofence _value, $Res Function(_$_ExternalGeofence) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? wialonId = null,
    Object? name = null,
  }) {
    return _then(_$_ExternalGeofence(
      wialonId: null == wialonId
          ? _value.wialonId
          : wialonId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ExternalGeofence implements _ExternalGeofence {
  const _$_ExternalGeofence({required this.wialonId, required this.name});

  factory _$_ExternalGeofence.fromJson(Map<String, dynamic> json) =>
      _$$_ExternalGeofenceFromJson(json);

  /// [wialonId] represents the ID from Wialon (Hosting or local).
  @override
  final String wialonId;

  /// [name] represents the name of the geofence in Wialon.
  @override
  final String name;

  @override
  String toString() {
    return 'ExternalGeofence(wialonId: $wialonId, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExternalGeofence &&
            (identical(other.wialonId, wialonId) ||
                other.wialonId == wialonId) &&
            (identical(other.name, name) || other.name == name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, wialonId, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExternalGeofenceCopyWith<_$_ExternalGeofence> get copyWith =>
      __$$_ExternalGeofenceCopyWithImpl<_$_ExternalGeofence>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ExternalGeofenceToJson(
      this,
    );
  }
}

abstract class _ExternalGeofence implements ExternalGeofence {
  const factory _ExternalGeofence(
      {required final String wialonId,
      required final String name}) = _$_ExternalGeofence;

  factory _ExternalGeofence.fromJson(Map<String, dynamic> json) =
      _$_ExternalGeofence.fromJson;

  @override

  /// [wialonId] represents the ID from Wialon (Hosting or local).
  String get wialonId;
  @override

  /// [name] represents the name of the geofence in Wialon.
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$_ExternalGeofenceCopyWith<_$_ExternalGeofence> get copyWith =>
      throw _privateConstructorUsedError;
}

Workspace _$WorkspaceFromJson(Map<String, dynamic> json) {
  return _Workspace.fromJson(json);
}

/// @nodoc
mixin _$Workspace {
  /// Is the ID
  String get id => throw _privateConstructorUsedError;

  /// Is the name
  String get name => throw _privateConstructorUsedError;

  /// Is the type of the App
  @AppInternalIdentifierOrNullConverter()
  AppInternalIdentifier? get typeApp => throw _privateConstructorUsedError;

  /// Indicates the color of the workspace
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  /// Is the icon URI of the workspace
  @IconOrNullConverter()
  IconData? get icon => throw _privateConstructorUsedError;

  /// Background image URI of the workspace
  String? get background => throw _privateConstructorUsedError;

  /// Indicates if the workspace is tagged as favorite
  bool? get isFavorite => throw _privateConstructorUsedError;

  /// Indicates the main view of the workspace
  @WorkspaceMainViewOrNullConverter()
  WorkspaceMainView? get mainView => throw _privateConstructorUsedError;

  /// Is the list of [assets] and their ids [assetsIds]
  List<Asset>? get assets => throw _privateConstructorUsedError;
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  /// The fields [casesEnabled], [triggers], [triggersIds], [checkpointsEnabled], [checkpoints], [checkpointsIds],
  /// [mapEnabled], [geofences], [geofencesIds], [mapCardCustomization], [mapCenterCoordinates], [mapCenterMode],
  /// [analyticsEnabled], [charts], [chartsIds], [chartStructure], [gridEnabled], [gridStructure]
  /// are used only when [typeApp] = [AppInternalIdentifier.one]
  /// Is the list of [triggers] and their ids [triggersIds]. And [casesEnabled] indicates
  /// if the cases monitor is enabled
  /// Also, [casesMonitorConfig] indicates the configuration of the cases monitor
  bool? get casesEnabled => throw _privateConstructorUsedError;
  List<Trigger>? get triggers => throw _privateConstructorUsedError;
  List<String>? get triggersIds => throw _privateConstructorUsedError;
  List<CaseMonitorCard?>? get casesMonitorConfig =>
      throw _privateConstructorUsedError;

  /// Is the list of [checkpoints] and their ids [checkpointsIds]. And [checkpointsEnabled] indicates
  /// if the checkpoints monitor is enabled
  bool? get checkpointsEnabled => throw _privateConstructorUsedError;
  List<Checkpoint>? get checkpoints => throw _privateConstructorUsedError;
  List<String>? get checkpointsIds => throw _privateConstructorUsedError;

  /// Is the list of [geofences] and their ids [geofencesIds]. And [mapEnabled] indicates
  /// if the map monitor is enabled
  /// Also, [mapCardCustomization] indicates the customization of the map card
  /// [mapCenterCoordinates] indicates the center coordinates of the map
  /// [mapCenterMode] indicates the center mode of the map
  bool? get mapEnabled => throw _privateConstructorUsedError;
  List<Geofence>? get geofences => throw _privateConstructorUsedError;
  List<String>? get geofencesIds => throw _privateConstructorUsedError;
  List<MapCardSensors> get mapCardCustomization =>
      throw _privateConstructorUsedError;
  GeoPoint? get mapCenterCoordinates => throw _privateConstructorUsedError;
  @MapCenterModeOrNullConverter()
  MapCenterMode? get mapCenterMode => throw _privateConstructorUsedError;

  /// Is the list of [charts] and their ids [chartsIds]. And [analyticsEnabled] indicates
  /// if the analytics monitor is enabled.
  /// Also, [analyticsGridStructure] indicates the visual structure of the charts
  bool? get analyticsEnabled => throw _privateConstructorUsedError;
  List<LayrzChart>? get charts => throw _privateConstructorUsedError;
  List<String>? get chartsIds => throw _privateConstructorUsedError;
  List<AnalyticsGridItem> get analyticsGridStructure =>
      throw _privateConstructorUsedError;

  /// [sensorsEnabled] indicates if the sensors sensors monitor is enabled
  /// Also, [sensorsGridStructure] indicates the visual structure of the sensors
  bool? get sensorsEnabled => throw _privateConstructorUsedError;
  List<SensorGridItem> get sensorsGridStructure =>
      throw _privateConstructorUsedError;

  /// Metric system of the workspace
  @MetricSystemOrNullConverter()
  MetricSystem? get metricSystem => throw _privateConstructorUsedError;
  Timezone? get timezone => throw _privateConstructorUsedError;

  /// [access] indicates the access of the workspace
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WorkspaceCopyWith<Workspace> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkspaceCopyWith<$Res> {
  factory $WorkspaceCopyWith(Workspace value, $Res Function(Workspace) then) =
      _$WorkspaceCopyWithImpl<$Res, Workspace>;
  @useResult
  $Res call(
      {String id,
      String name,
      @AppInternalIdentifierOrNullConverter() AppInternalIdentifier? typeApp,
      @ColorOrNullConverter() Color? color,
      @IconOrNullConverter() IconData? icon,
      String? background,
      bool? isFavorite,
      @WorkspaceMainViewOrNullConverter() WorkspaceMainView? mainView,
      List<Asset>? assets,
      List<String>? assetsIds,
      bool? casesEnabled,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      List<CaseMonitorCard?>? casesMonitorConfig,
      bool? checkpointsEnabled,
      List<Checkpoint>? checkpoints,
      List<String>? checkpointsIds,
      bool? mapEnabled,
      List<Geofence>? geofences,
      List<String>? geofencesIds,
      List<MapCardSensors> mapCardCustomization,
      GeoPoint? mapCenterCoordinates,
      @MapCenterModeOrNullConverter() MapCenterMode? mapCenterMode,
      bool? analyticsEnabled,
      List<LayrzChart>? charts,
      List<String>? chartsIds,
      List<AnalyticsGridItem> analyticsGridStructure,
      bool? sensorsEnabled,
      List<SensorGridItem> sensorsGridStructure,
      @MetricSystemOrNullConverter() MetricSystem? metricSystem,
      Timezone? timezone,
      List<Access>? access});

  $GeoPointCopyWith<$Res>? get mapCenterCoordinates;
  $TimezoneCopyWith<$Res>? get timezone;
}

/// @nodoc
class _$WorkspaceCopyWithImpl<$Res, $Val extends Workspace>
    implements $WorkspaceCopyWith<$Res> {
  _$WorkspaceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? typeApp = freezed,
    Object? color = freezed,
    Object? icon = freezed,
    Object? background = freezed,
    Object? isFavorite = freezed,
    Object? mainView = freezed,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? casesEnabled = freezed,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? casesMonitorConfig = freezed,
    Object? checkpointsEnabled = freezed,
    Object? checkpoints = freezed,
    Object? checkpointsIds = freezed,
    Object? mapEnabled = freezed,
    Object? geofences = freezed,
    Object? geofencesIds = freezed,
    Object? mapCardCustomization = null,
    Object? mapCenterCoordinates = freezed,
    Object? mapCenterMode = freezed,
    Object? analyticsEnabled = freezed,
    Object? charts = freezed,
    Object? chartsIds = freezed,
    Object? analyticsGridStructure = null,
    Object? sensorsEnabled = freezed,
    Object? sensorsGridStructure = null,
    Object? metricSystem = freezed,
    Object? timezone = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      typeApp: freezed == typeApp
          ? _value.typeApp
          : typeApp // ignore: cast_nullable_to_non_nullable
              as AppInternalIdentifier?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      background: freezed == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as String?,
      isFavorite: freezed == isFavorite
          ? _value.isFavorite
          : isFavorite // ignore: cast_nullable_to_non_nullable
              as bool?,
      mainView: freezed == mainView
          ? _value.mainView
          : mainView // ignore: cast_nullable_to_non_nullable
              as WorkspaceMainView?,
      assets: freezed == assets
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      casesEnabled: freezed == casesEnabled
          ? _value.casesEnabled
          : casesEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      triggers: freezed == triggers
          ? _value.triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value.triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      casesMonitorConfig: freezed == casesMonitorConfig
          ? _value.casesMonitorConfig
          : casesMonitorConfig // ignore: cast_nullable_to_non_nullable
              as List<CaseMonitorCard?>?,
      checkpointsEnabled: freezed == checkpointsEnabled
          ? _value.checkpointsEnabled
          : checkpointsEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      checkpoints: freezed == checkpoints
          ? _value.checkpoints
          : checkpoints // ignore: cast_nullable_to_non_nullable
              as List<Checkpoint>?,
      checkpointsIds: freezed == checkpointsIds
          ? _value.checkpointsIds
          : checkpointsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      mapEnabled: freezed == mapEnabled
          ? _value.mapEnabled
          : mapEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      geofences: freezed == geofences
          ? _value.geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      geofencesIds: freezed == geofencesIds
          ? _value.geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      mapCardCustomization: null == mapCardCustomization
          ? _value.mapCardCustomization
          : mapCardCustomization // ignore: cast_nullable_to_non_nullable
              as List<MapCardSensors>,
      mapCenterCoordinates: freezed == mapCenterCoordinates
          ? _value.mapCenterCoordinates
          : mapCenterCoordinates // ignore: cast_nullable_to_non_nullable
              as GeoPoint?,
      mapCenterMode: freezed == mapCenterMode
          ? _value.mapCenterMode
          : mapCenterMode // ignore: cast_nullable_to_non_nullable
              as MapCenterMode?,
      analyticsEnabled: freezed == analyticsEnabled
          ? _value.analyticsEnabled
          : analyticsEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      charts: freezed == charts
          ? _value.charts
          : charts // ignore: cast_nullable_to_non_nullable
              as List<LayrzChart>?,
      chartsIds: freezed == chartsIds
          ? _value.chartsIds
          : chartsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      analyticsGridStructure: null == analyticsGridStructure
          ? _value.analyticsGridStructure
          : analyticsGridStructure // ignore: cast_nullable_to_non_nullable
              as List<AnalyticsGridItem>,
      sensorsEnabled: freezed == sensorsEnabled
          ? _value.sensorsEnabled
          : sensorsEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      sensorsGridStructure: null == sensorsGridStructure
          ? _value.sensorsGridStructure
          : sensorsGridStructure // ignore: cast_nullable_to_non_nullable
              as List<SensorGridItem>,
      metricSystem: freezed == metricSystem
          ? _value.metricSystem
          : metricSystem // ignore: cast_nullable_to_non_nullable
              as MetricSystem?,
      timezone: freezed == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as Timezone?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GeoPointCopyWith<$Res>? get mapCenterCoordinates {
    if (_value.mapCenterCoordinates == null) {
      return null;
    }

    return $GeoPointCopyWith<$Res>(_value.mapCenterCoordinates!, (value) {
      return _then(_value.copyWith(mapCenterCoordinates: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TimezoneCopyWith<$Res>? get timezone {
    if (_value.timezone == null) {
      return null;
    }

    return $TimezoneCopyWith<$Res>(_value.timezone!, (value) {
      return _then(_value.copyWith(timezone: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_WorkspaceCopyWith<$Res> implements $WorkspaceCopyWith<$Res> {
  factory _$$_WorkspaceCopyWith(
          _$_Workspace value, $Res Function(_$_Workspace) then) =
      __$$_WorkspaceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @AppInternalIdentifierOrNullConverter() AppInternalIdentifier? typeApp,
      @ColorOrNullConverter() Color? color,
      @IconOrNullConverter() IconData? icon,
      String? background,
      bool? isFavorite,
      @WorkspaceMainViewOrNullConverter() WorkspaceMainView? mainView,
      List<Asset>? assets,
      List<String>? assetsIds,
      bool? casesEnabled,
      List<Trigger>? triggers,
      List<String>? triggersIds,
      List<CaseMonitorCard?>? casesMonitorConfig,
      bool? checkpointsEnabled,
      List<Checkpoint>? checkpoints,
      List<String>? checkpointsIds,
      bool? mapEnabled,
      List<Geofence>? geofences,
      List<String>? geofencesIds,
      List<MapCardSensors> mapCardCustomization,
      GeoPoint? mapCenterCoordinates,
      @MapCenterModeOrNullConverter() MapCenterMode? mapCenterMode,
      bool? analyticsEnabled,
      List<LayrzChart>? charts,
      List<String>? chartsIds,
      List<AnalyticsGridItem> analyticsGridStructure,
      bool? sensorsEnabled,
      List<SensorGridItem> sensorsGridStructure,
      @MetricSystemOrNullConverter() MetricSystem? metricSystem,
      Timezone? timezone,
      List<Access>? access});

  @override
  $GeoPointCopyWith<$Res>? get mapCenterCoordinates;
  @override
  $TimezoneCopyWith<$Res>? get timezone;
}

/// @nodoc
class __$$_WorkspaceCopyWithImpl<$Res>
    extends _$WorkspaceCopyWithImpl<$Res, _$_Workspace>
    implements _$$_WorkspaceCopyWith<$Res> {
  __$$_WorkspaceCopyWithImpl(
      _$_Workspace _value, $Res Function(_$_Workspace) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? typeApp = freezed,
    Object? color = freezed,
    Object? icon = freezed,
    Object? background = freezed,
    Object? isFavorite = freezed,
    Object? mainView = freezed,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? casesEnabled = freezed,
    Object? triggers = freezed,
    Object? triggersIds = freezed,
    Object? casesMonitorConfig = freezed,
    Object? checkpointsEnabled = freezed,
    Object? checkpoints = freezed,
    Object? checkpointsIds = freezed,
    Object? mapEnabled = freezed,
    Object? geofences = freezed,
    Object? geofencesIds = freezed,
    Object? mapCardCustomization = null,
    Object? mapCenterCoordinates = freezed,
    Object? mapCenterMode = freezed,
    Object? analyticsEnabled = freezed,
    Object? charts = freezed,
    Object? chartsIds = freezed,
    Object? analyticsGridStructure = null,
    Object? sensorsEnabled = freezed,
    Object? sensorsGridStructure = null,
    Object? metricSystem = freezed,
    Object? timezone = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_Workspace(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      typeApp: freezed == typeApp
          ? _value.typeApp
          : typeApp // ignore: cast_nullable_to_non_nullable
              as AppInternalIdentifier?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      icon: freezed == icon
          ? _value.icon
          : icon // ignore: cast_nullable_to_non_nullable
              as IconData?,
      background: freezed == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as String?,
      isFavorite: freezed == isFavorite
          ? _value.isFavorite
          : isFavorite // ignore: cast_nullable_to_non_nullable
              as bool?,
      mainView: freezed == mainView
          ? _value.mainView
          : mainView // ignore: cast_nullable_to_non_nullable
              as WorkspaceMainView?,
      assets: freezed == assets
          ? _value._assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      casesEnabled: freezed == casesEnabled
          ? _value.casesEnabled
          : casesEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      triggers: freezed == triggers
          ? _value._triggers
          : triggers // ignore: cast_nullable_to_non_nullable
              as List<Trigger>?,
      triggersIds: freezed == triggersIds
          ? _value._triggersIds
          : triggersIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      casesMonitorConfig: freezed == casesMonitorConfig
          ? _value._casesMonitorConfig
          : casesMonitorConfig // ignore: cast_nullable_to_non_nullable
              as List<CaseMonitorCard?>?,
      checkpointsEnabled: freezed == checkpointsEnabled
          ? _value.checkpointsEnabled
          : checkpointsEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      checkpoints: freezed == checkpoints
          ? _value._checkpoints
          : checkpoints // ignore: cast_nullable_to_non_nullable
              as List<Checkpoint>?,
      checkpointsIds: freezed == checkpointsIds
          ? _value._checkpointsIds
          : checkpointsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      mapEnabled: freezed == mapEnabled
          ? _value.mapEnabled
          : mapEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      geofences: freezed == geofences
          ? _value._geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      geofencesIds: freezed == geofencesIds
          ? _value._geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      mapCardCustomization: null == mapCardCustomization
          ? _value._mapCardCustomization
          : mapCardCustomization // ignore: cast_nullable_to_non_nullable
              as List<MapCardSensors>,
      mapCenterCoordinates: freezed == mapCenterCoordinates
          ? _value.mapCenterCoordinates
          : mapCenterCoordinates // ignore: cast_nullable_to_non_nullable
              as GeoPoint?,
      mapCenterMode: freezed == mapCenterMode
          ? _value.mapCenterMode
          : mapCenterMode // ignore: cast_nullable_to_non_nullable
              as MapCenterMode?,
      analyticsEnabled: freezed == analyticsEnabled
          ? _value.analyticsEnabled
          : analyticsEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      charts: freezed == charts
          ? _value._charts
          : charts // ignore: cast_nullable_to_non_nullable
              as List<LayrzChart>?,
      chartsIds: freezed == chartsIds
          ? _value._chartsIds
          : chartsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      analyticsGridStructure: null == analyticsGridStructure
          ? _value._analyticsGridStructure
          : analyticsGridStructure // ignore: cast_nullable_to_non_nullable
              as List<AnalyticsGridItem>,
      sensorsEnabled: freezed == sensorsEnabled
          ? _value.sensorsEnabled
          : sensorsEnabled // ignore: cast_nullable_to_non_nullable
              as bool?,
      sensorsGridStructure: null == sensorsGridStructure
          ? _value._sensorsGridStructure
          : sensorsGridStructure // ignore: cast_nullable_to_non_nullable
              as List<SensorGridItem>,
      metricSystem: freezed == metricSystem
          ? _value.metricSystem
          : metricSystem // ignore: cast_nullable_to_non_nullable
              as MetricSystem?,
      timezone: freezed == timezone
          ? _value.timezone
          : timezone // ignore: cast_nullable_to_non_nullable
              as Timezone?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Workspace implements _Workspace {
  const _$_Workspace(
      {required this.id,
      required this.name,
      @AppInternalIdentifierOrNullConverter() this.typeApp,
      @ColorOrNullConverter() this.color,
      @IconOrNullConverter() this.icon,
      this.background,
      this.isFavorite,
      @WorkspaceMainViewOrNullConverter() this.mainView,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      this.casesEnabled,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      final List<CaseMonitorCard?>? casesMonitorConfig,
      this.checkpointsEnabled,
      final List<Checkpoint>? checkpoints,
      final List<String>? checkpointsIds,
      this.mapEnabled,
      final List<Geofence>? geofences,
      final List<String>? geofencesIds,
      final List<MapCardSensors> mapCardCustomization = const [],
      this.mapCenterCoordinates,
      @MapCenterModeOrNullConverter() this.mapCenterMode,
      this.analyticsEnabled,
      final List<LayrzChart>? charts,
      final List<String>? chartsIds,
      final List<AnalyticsGridItem> analyticsGridStructure = const [],
      this.sensorsEnabled,
      final List<SensorGridItem> sensorsGridStructure = const [],
      @MetricSystemOrNullConverter() this.metricSystem,
      this.timezone,
      final List<Access>? access})
      : _assets = assets,
        _assetsIds = assetsIds,
        _triggers = triggers,
        _triggersIds = triggersIds,
        _casesMonitorConfig = casesMonitorConfig,
        _checkpoints = checkpoints,
        _checkpointsIds = checkpointsIds,
        _geofences = geofences,
        _geofencesIds = geofencesIds,
        _mapCardCustomization = mapCardCustomization,
        _charts = charts,
        _chartsIds = chartsIds,
        _analyticsGridStructure = analyticsGridStructure,
        _sensorsGridStructure = sensorsGridStructure,
        _access = access;

  factory _$_Workspace.fromJson(Map<String, dynamic> json) =>
      _$$_WorkspaceFromJson(json);

  /// Is the ID
  @override
  final String id;

  /// Is the name
  @override
  final String name;

  /// Is the type of the App
  @override
  @AppInternalIdentifierOrNullConverter()
  final AppInternalIdentifier? typeApp;

  /// Indicates the color of the workspace
  @override
  @ColorOrNullConverter()
  final Color? color;

  /// Is the icon URI of the workspace
  @override
  @IconOrNullConverter()
  final IconData? icon;

  /// Background image URI of the workspace
  @override
  final String? background;

  /// Indicates if the workspace is tagged as favorite
  @override
  final bool? isFavorite;

  /// Indicates the main view of the workspace
  @override
  @WorkspaceMainViewOrNullConverter()
  final WorkspaceMainView? mainView;

  /// Is the list of [assets] and their ids [assetsIds]
  final List<Asset>? _assets;

  /// Is the list of [assets] and their ids [assetsIds]
  @override
  List<Asset>? get assets {
    final value = _assets;
    if (value == null) return null;
    if (_assets is EqualUnmodifiableListView) return _assets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _assetsIds;
  @override
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// The fields [casesEnabled], [triggers], [triggersIds], [checkpointsEnabled], [checkpoints], [checkpointsIds],
  /// [mapEnabled], [geofences], [geofencesIds], [mapCardCustomization], [mapCenterCoordinates], [mapCenterMode],
  /// [analyticsEnabled], [charts], [chartsIds], [chartStructure], [gridEnabled], [gridStructure]
  /// are used only when [typeApp] = [AppInternalIdentifier.one]
  /// Is the list of [triggers] and their ids [triggersIds]. And [casesEnabled] indicates
  /// if the cases monitor is enabled
  /// Also, [casesMonitorConfig] indicates the configuration of the cases monitor
  @override
  final bool? casesEnabled;
  final List<Trigger>? _triggers;
  @override
  List<Trigger>? get triggers {
    final value = _triggers;
    if (value == null) return null;
    if (_triggers is EqualUnmodifiableListView) return _triggers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _triggersIds;
  @override
  List<String>? get triggersIds {
    final value = _triggersIds;
    if (value == null) return null;
    if (_triggersIds is EqualUnmodifiableListView) return _triggersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<CaseMonitorCard?>? _casesMonitorConfig;
  @override
  List<CaseMonitorCard?>? get casesMonitorConfig {
    final value = _casesMonitorConfig;
    if (value == null) return null;
    if (_casesMonitorConfig is EqualUnmodifiableListView)
      return _casesMonitorConfig;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [checkpoints] and their ids [checkpointsIds]. And [checkpointsEnabled] indicates
  /// if the checkpoints monitor is enabled
  @override
  final bool? checkpointsEnabled;
  final List<Checkpoint>? _checkpoints;
  @override
  List<Checkpoint>? get checkpoints {
    final value = _checkpoints;
    if (value == null) return null;
    if (_checkpoints is EqualUnmodifiableListView) return _checkpoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _checkpointsIds;
  @override
  List<String>? get checkpointsIds {
    final value = _checkpointsIds;
    if (value == null) return null;
    if (_checkpointsIds is EqualUnmodifiableListView) return _checkpointsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Is the list of [geofences] and their ids [geofencesIds]. And [mapEnabled] indicates
  /// if the map monitor is enabled
  /// Also, [mapCardCustomization] indicates the customization of the map card
  /// [mapCenterCoordinates] indicates the center coordinates of the map
  /// [mapCenterMode] indicates the center mode of the map
  @override
  final bool? mapEnabled;
  final List<Geofence>? _geofences;
  @override
  List<Geofence>? get geofences {
    final value = _geofences;
    if (value == null) return null;
    if (_geofences is EqualUnmodifiableListView) return _geofences;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _geofencesIds;
  @override
  List<String>? get geofencesIds {
    final value = _geofencesIds;
    if (value == null) return null;
    if (_geofencesIds is EqualUnmodifiableListView) return _geofencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<MapCardSensors> _mapCardCustomization;
  @override
  @JsonKey()
  List<MapCardSensors> get mapCardCustomization {
    if (_mapCardCustomization is EqualUnmodifiableListView)
      return _mapCardCustomization;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_mapCardCustomization);
  }

  @override
  final GeoPoint? mapCenterCoordinates;
  @override
  @MapCenterModeOrNullConverter()
  final MapCenterMode? mapCenterMode;

  /// Is the list of [charts] and their ids [chartsIds]. And [analyticsEnabled] indicates
  /// if the analytics monitor is enabled.
  /// Also, [analyticsGridStructure] indicates the visual structure of the charts
  @override
  final bool? analyticsEnabled;
  final List<LayrzChart>? _charts;
  @override
  List<LayrzChart>? get charts {
    final value = _charts;
    if (value == null) return null;
    if (_charts is EqualUnmodifiableListView) return _charts;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _chartsIds;
  @override
  List<String>? get chartsIds {
    final value = _chartsIds;
    if (value == null) return null;
    if (_chartsIds is EqualUnmodifiableListView) return _chartsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<AnalyticsGridItem> _analyticsGridStructure;
  @override
  @JsonKey()
  List<AnalyticsGridItem> get analyticsGridStructure {
    if (_analyticsGridStructure is EqualUnmodifiableListView)
      return _analyticsGridStructure;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_analyticsGridStructure);
  }

  /// [sensorsEnabled] indicates if the sensors sensors monitor is enabled
  /// Also, [sensorsGridStructure] indicates the visual structure of the sensors
  @override
  final bool? sensorsEnabled;
  final List<SensorGridItem> _sensorsGridStructure;
  @override
  @JsonKey()
  List<SensorGridItem> get sensorsGridStructure {
    if (_sensorsGridStructure is EqualUnmodifiableListView)
      return _sensorsGridStructure;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sensorsGridStructure);
  }

  /// Metric system of the workspace
  @override
  @MetricSystemOrNullConverter()
  final MetricSystem? metricSystem;
  @override
  final Timezone? timezone;

  /// [access] indicates the access of the workspace
  final List<Access>? _access;

  /// [access] indicates the access of the workspace
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'Workspace(id: $id, name: $name, typeApp: $typeApp, color: $color, icon: $icon, background: $background, isFavorite: $isFavorite, mainView: $mainView, assets: $assets, assetsIds: $assetsIds, casesEnabled: $casesEnabled, triggers: $triggers, triggersIds: $triggersIds, casesMonitorConfig: $casesMonitorConfig, checkpointsEnabled: $checkpointsEnabled, checkpoints: $checkpoints, checkpointsIds: $checkpointsIds, mapEnabled: $mapEnabled, geofences: $geofences, geofencesIds: $geofencesIds, mapCardCustomization: $mapCardCustomization, mapCenterCoordinates: $mapCenterCoordinates, mapCenterMode: $mapCenterMode, analyticsEnabled: $analyticsEnabled, charts: $charts, chartsIds: $chartsIds, analyticsGridStructure: $analyticsGridStructure, sensorsEnabled: $sensorsEnabled, sensorsGridStructure: $sensorsGridStructure, metricSystem: $metricSystem, timezone: $timezone, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Workspace &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.typeApp, typeApp) || other.typeApp == typeApp) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.icon, icon) || other.icon == icon) &&
            (identical(other.background, background) ||
                other.background == background) &&
            (identical(other.isFavorite, isFavorite) ||
                other.isFavorite == isFavorite) &&
            (identical(other.mainView, mainView) ||
                other.mainView == mainView) &&
            const DeepCollectionEquality().equals(other._assets, _assets) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds) &&
            (identical(other.casesEnabled, casesEnabled) ||
                other.casesEnabled == casesEnabled) &&
            const DeepCollectionEquality().equals(other._triggers, _triggers) &&
            const DeepCollectionEquality()
                .equals(other._triggersIds, _triggersIds) &&
            const DeepCollectionEquality()
                .equals(other._casesMonitorConfig, _casesMonitorConfig) &&
            (identical(other.checkpointsEnabled, checkpointsEnabled) ||
                other.checkpointsEnabled == checkpointsEnabled) &&
            const DeepCollectionEquality()
                .equals(other._checkpoints, _checkpoints) &&
            const DeepCollectionEquality()
                .equals(other._checkpointsIds, _checkpointsIds) &&
            (identical(other.mapEnabled, mapEnabled) ||
                other.mapEnabled == mapEnabled) &&
            const DeepCollectionEquality()
                .equals(other._geofences, _geofences) &&
            const DeepCollectionEquality()
                .equals(other._geofencesIds, _geofencesIds) &&
            const DeepCollectionEquality()
                .equals(other._mapCardCustomization, _mapCardCustomization) &&
            (identical(other.mapCenterCoordinates, mapCenterCoordinates) ||
                other.mapCenterCoordinates == mapCenterCoordinates) &&
            (identical(other.mapCenterMode, mapCenterMode) ||
                other.mapCenterMode == mapCenterMode) &&
            (identical(other.analyticsEnabled, analyticsEnabled) ||
                other.analyticsEnabled == analyticsEnabled) &&
            const DeepCollectionEquality().equals(other._charts, _charts) &&
            const DeepCollectionEquality()
                .equals(other._chartsIds, _chartsIds) &&
            const DeepCollectionEquality().equals(
                other._analyticsGridStructure, _analyticsGridStructure) &&
            (identical(other.sensorsEnabled, sensorsEnabled) ||
                other.sensorsEnabled == sensorsEnabled) &&
            const DeepCollectionEquality()
                .equals(other._sensorsGridStructure, _sensorsGridStructure) &&
            (identical(other.metricSystem, metricSystem) ||
                other.metricSystem == metricSystem) &&
            (identical(other.timezone, timezone) ||
                other.timezone == timezone) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        typeApp,
        color,
        icon,
        background,
        isFavorite,
        mainView,
        const DeepCollectionEquality().hash(_assets),
        const DeepCollectionEquality().hash(_assetsIds),
        casesEnabled,
        const DeepCollectionEquality().hash(_triggers),
        const DeepCollectionEquality().hash(_triggersIds),
        const DeepCollectionEquality().hash(_casesMonitorConfig),
        checkpointsEnabled,
        const DeepCollectionEquality().hash(_checkpoints),
        const DeepCollectionEquality().hash(_checkpointsIds),
        mapEnabled,
        const DeepCollectionEquality().hash(_geofences),
        const DeepCollectionEquality().hash(_geofencesIds),
        const DeepCollectionEquality().hash(_mapCardCustomization),
        mapCenterCoordinates,
        mapCenterMode,
        analyticsEnabled,
        const DeepCollectionEquality().hash(_charts),
        const DeepCollectionEquality().hash(_chartsIds),
        const DeepCollectionEquality().hash(_analyticsGridStructure),
        sensorsEnabled,
        const DeepCollectionEquality().hash(_sensorsGridStructure),
        metricSystem,
        timezone,
        const DeepCollectionEquality().hash(_access)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WorkspaceCopyWith<_$_Workspace> get copyWith =>
      __$$_WorkspaceCopyWithImpl<_$_Workspace>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WorkspaceToJson(
      this,
    );
  }
}

abstract class _Workspace implements Workspace {
  const factory _Workspace(
      {required final String id,
      required final String name,
      @AppInternalIdentifierOrNullConverter()
      final AppInternalIdentifier? typeApp,
      @ColorOrNullConverter() final Color? color,
      @IconOrNullConverter() final IconData? icon,
      final String? background,
      final bool? isFavorite,
      @WorkspaceMainViewOrNullConverter() final WorkspaceMainView? mainView,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      final bool? casesEnabled,
      final List<Trigger>? triggers,
      final List<String>? triggersIds,
      final List<CaseMonitorCard?>? casesMonitorConfig,
      final bool? checkpointsEnabled,
      final List<Checkpoint>? checkpoints,
      final List<String>? checkpointsIds,
      final bool? mapEnabled,
      final List<Geofence>? geofences,
      final List<String>? geofencesIds,
      final List<MapCardSensors> mapCardCustomization,
      final GeoPoint? mapCenterCoordinates,
      @MapCenterModeOrNullConverter() final MapCenterMode? mapCenterMode,
      final bool? analyticsEnabled,
      final List<LayrzChart>? charts,
      final List<String>? chartsIds,
      final List<AnalyticsGridItem> analyticsGridStructure,
      final bool? sensorsEnabled,
      final List<SensorGridItem> sensorsGridStructure,
      @MetricSystemOrNullConverter() final MetricSystem? metricSystem,
      final Timezone? timezone,
      final List<Access>? access}) = _$_Workspace;

  factory _Workspace.fromJson(Map<String, dynamic> json) =
      _$_Workspace.fromJson;

  @override

  /// Is the ID
  String get id;
  @override

  /// Is the name
  String get name;
  @override

  /// Is the type of the App
  @AppInternalIdentifierOrNullConverter()
  AppInternalIdentifier? get typeApp;
  @override

  /// Indicates the color of the workspace
  @ColorOrNullConverter()
  Color? get color;
  @override

  /// Is the icon URI of the workspace
  @IconOrNullConverter()
  IconData? get icon;
  @override

  /// Background image URI of the workspace
  String? get background;
  @override

  /// Indicates if the workspace is tagged as favorite
  bool? get isFavorite;
  @override

  /// Indicates the main view of the workspace
  @WorkspaceMainViewOrNullConverter()
  WorkspaceMainView? get mainView;
  @override

  /// Is the list of [assets] and their ids [assetsIds]
  List<Asset>? get assets;
  @override
  List<String>? get assetsIds;
  @override

  /// The fields [casesEnabled], [triggers], [triggersIds], [checkpointsEnabled], [checkpoints], [checkpointsIds],
  /// [mapEnabled], [geofences], [geofencesIds], [mapCardCustomization], [mapCenterCoordinates], [mapCenterMode],
  /// [analyticsEnabled], [charts], [chartsIds], [chartStructure], [gridEnabled], [gridStructure]
  /// are used only when [typeApp] = [AppInternalIdentifier.one]
  /// Is the list of [triggers] and their ids [triggersIds]. And [casesEnabled] indicates
  /// if the cases monitor is enabled
  /// Also, [casesMonitorConfig] indicates the configuration of the cases monitor
  bool? get casesEnabled;
  @override
  List<Trigger>? get triggers;
  @override
  List<String>? get triggersIds;
  @override
  List<CaseMonitorCard?>? get casesMonitorConfig;
  @override

  /// Is the list of [checkpoints] and their ids [checkpointsIds]. And [checkpointsEnabled] indicates
  /// if the checkpoints monitor is enabled
  bool? get checkpointsEnabled;
  @override
  List<Checkpoint>? get checkpoints;
  @override
  List<String>? get checkpointsIds;
  @override

  /// Is the list of [geofences] and their ids [geofencesIds]. And [mapEnabled] indicates
  /// if the map monitor is enabled
  /// Also, [mapCardCustomization] indicates the customization of the map card
  /// [mapCenterCoordinates] indicates the center coordinates of the map
  /// [mapCenterMode] indicates the center mode of the map
  bool? get mapEnabled;
  @override
  List<Geofence>? get geofences;
  @override
  List<String>? get geofencesIds;
  @override
  List<MapCardSensors> get mapCardCustomization;
  @override
  GeoPoint? get mapCenterCoordinates;
  @override
  @MapCenterModeOrNullConverter()
  MapCenterMode? get mapCenterMode;
  @override

  /// Is the list of [charts] and their ids [chartsIds]. And [analyticsEnabled] indicates
  /// if the analytics monitor is enabled.
  /// Also, [analyticsGridStructure] indicates the visual structure of the charts
  bool? get analyticsEnabled;
  @override
  List<LayrzChart>? get charts;
  @override
  List<String>? get chartsIds;
  @override
  List<AnalyticsGridItem> get analyticsGridStructure;
  @override

  /// [sensorsEnabled] indicates if the sensors sensors monitor is enabled
  /// Also, [sensorsGridStructure] indicates the visual structure of the sensors
  bool? get sensorsEnabled;
  @override
  List<SensorGridItem> get sensorsGridStructure;
  @override

  /// Metric system of the workspace
  @MetricSystemOrNullConverter()
  MetricSystem? get metricSystem;
  @override
  Timezone? get timezone;
  @override

  /// [access] indicates the access of the workspace
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_WorkspaceCopyWith<_$_Workspace> get copyWith =>
      throw _privateConstructorUsedError;
}

AnalyticsGridItem _$AnalyticsGridItemFromJson(Map<String, dynamic> json) {
  return _AnalyticsGridItem.fromJson(json);
}

/// @nodoc
mixin _$AnalyticsGridItem {
  /// Is the Chart ID
  String? get chartId => throw _privateConstructorUsedError;

  /// [dimensions] Represents the dimension of the sensor
  GridDimension get dimensions => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AnalyticsGridItemCopyWith<AnalyticsGridItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyticsGridItemCopyWith<$Res> {
  factory $AnalyticsGridItemCopyWith(
          AnalyticsGridItem value, $Res Function(AnalyticsGridItem) then) =
      _$AnalyticsGridItemCopyWithImpl<$Res, AnalyticsGridItem>;
  @useResult
  $Res call({String? chartId, GridDimension dimensions});

  $GridDimensionCopyWith<$Res> get dimensions;
}

/// @nodoc
class _$AnalyticsGridItemCopyWithImpl<$Res, $Val extends AnalyticsGridItem>
    implements $AnalyticsGridItemCopyWith<$Res> {
  _$AnalyticsGridItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chartId = freezed,
    Object? dimensions = null,
  }) {
    return _then(_value.copyWith(
      chartId: freezed == chartId
          ? _value.chartId
          : chartId // ignore: cast_nullable_to_non_nullable
              as String?,
      dimensions: null == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as GridDimension,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GridDimensionCopyWith<$Res> get dimensions {
    return $GridDimensionCopyWith<$Res>(_value.dimensions, (value) {
      return _then(_value.copyWith(dimensions: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AnalyticsGridItemCopyWith<$Res>
    implements $AnalyticsGridItemCopyWith<$Res> {
  factory _$$_AnalyticsGridItemCopyWith(_$_AnalyticsGridItem value,
          $Res Function(_$_AnalyticsGridItem) then) =
      __$$_AnalyticsGridItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? chartId, GridDimension dimensions});

  @override
  $GridDimensionCopyWith<$Res> get dimensions;
}

/// @nodoc
class __$$_AnalyticsGridItemCopyWithImpl<$Res>
    extends _$AnalyticsGridItemCopyWithImpl<$Res, _$_AnalyticsGridItem>
    implements _$$_AnalyticsGridItemCopyWith<$Res> {
  __$$_AnalyticsGridItemCopyWithImpl(
      _$_AnalyticsGridItem _value, $Res Function(_$_AnalyticsGridItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chartId = freezed,
    Object? dimensions = null,
  }) {
    return _then(_$_AnalyticsGridItem(
      chartId: freezed == chartId
          ? _value.chartId
          : chartId // ignore: cast_nullable_to_non_nullable
              as String?,
      dimensions: null == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as GridDimension,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AnalyticsGridItem implements _AnalyticsGridItem {
  const _$_AnalyticsGridItem({this.chartId, required this.dimensions});

  factory _$_AnalyticsGridItem.fromJson(Map<String, dynamic> json) =>
      _$$_AnalyticsGridItemFromJson(json);

  /// Is the Chart ID
  @override
  final String? chartId;

  /// [dimensions] Represents the dimension of the sensor
  @override
  final GridDimension dimensions;

  @override
  String toString() {
    return 'AnalyticsGridItem(chartId: $chartId, dimensions: $dimensions)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AnalyticsGridItem &&
            (identical(other.chartId, chartId) || other.chartId == chartId) &&
            (identical(other.dimensions, dimensions) ||
                other.dimensions == dimensions));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, chartId, dimensions);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AnalyticsGridItemCopyWith<_$_AnalyticsGridItem> get copyWith =>
      __$$_AnalyticsGridItemCopyWithImpl<_$_AnalyticsGridItem>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AnalyticsGridItemToJson(
      this,
    );
  }
}

abstract class _AnalyticsGridItem implements AnalyticsGridItem {
  const factory _AnalyticsGridItem(
      {final String? chartId,
      required final GridDimension dimensions}) = _$_AnalyticsGridItem;

  factory _AnalyticsGridItem.fromJson(Map<String, dynamic> json) =
      _$_AnalyticsGridItem.fromJson;

  @override

  /// Is the Chart ID
  String? get chartId;
  @override

  /// [dimensions] Represents the dimension of the sensor
  GridDimension get dimensions;
  @override
  @JsonKey(ignore: true)
  _$$_AnalyticsGridItemCopyWith<_$_AnalyticsGridItem> get copyWith =>
      throw _privateConstructorUsedError;
}

MapCardAlertConfiguration _$MapCardAlertConfigurationFromJson(
    Map<String, dynamic> json) {
  return _MapCardAlertConfiguration.fromJson(json);
}

/// @nodoc
mixin _$MapCardAlertConfiguration {
  /// Represents the range of search results to be displayed on the map.
  @MapCardModeConverter()
  MapCardMode get range => throw _privateConstructorUsedError;

  /// Display the count of alerts in the map card.
  bool get count => throw _privateConstructorUsedError;

  /// Indicates if the alert segment is enabled.
  bool get enabled => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MapCardAlertConfigurationCopyWith<MapCardAlertConfiguration> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapCardAlertConfigurationCopyWith<$Res> {
  factory $MapCardAlertConfigurationCopyWith(MapCardAlertConfiguration value,
          $Res Function(MapCardAlertConfiguration) then) =
      _$MapCardAlertConfigurationCopyWithImpl<$Res, MapCardAlertConfiguration>;
  @useResult
  $Res call(
      {@MapCardModeConverter() MapCardMode range, bool count, bool enabled});
}

/// @nodoc
class _$MapCardAlertConfigurationCopyWithImpl<$Res,
        $Val extends MapCardAlertConfiguration>
    implements $MapCardAlertConfigurationCopyWith<$Res> {
  _$MapCardAlertConfigurationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? range = null,
    Object? count = null,
    Object? enabled = null,
  }) {
    return _then(_value.copyWith(
      range: null == range
          ? _value.range
          : range // ignore: cast_nullable_to_non_nullable
              as MapCardMode,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as bool,
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MapCardAlertConfigurationCopyWith<$Res>
    implements $MapCardAlertConfigurationCopyWith<$Res> {
  factory _$$_MapCardAlertConfigurationCopyWith(
          _$_MapCardAlertConfiguration value,
          $Res Function(_$_MapCardAlertConfiguration) then) =
      __$$_MapCardAlertConfigurationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@MapCardModeConverter() MapCardMode range, bool count, bool enabled});
}

/// @nodoc
class __$$_MapCardAlertConfigurationCopyWithImpl<$Res>
    extends _$MapCardAlertConfigurationCopyWithImpl<$Res,
        _$_MapCardAlertConfiguration>
    implements _$$_MapCardAlertConfigurationCopyWith<$Res> {
  __$$_MapCardAlertConfigurationCopyWithImpl(
      _$_MapCardAlertConfiguration _value,
      $Res Function(_$_MapCardAlertConfiguration) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? range = null,
    Object? count = null,
    Object? enabled = null,
  }) {
    return _then(_$_MapCardAlertConfiguration(
      range: null == range
          ? _value.range
          : range // ignore: cast_nullable_to_non_nullable
              as MapCardMode,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as bool,
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MapCardAlertConfiguration implements _MapCardAlertConfiguration {
  const _$_MapCardAlertConfiguration(
      {@MapCardModeConverter() this.range = MapCardMode.lastDay,
      this.count = false,
      this.enabled = true});

  factory _$_MapCardAlertConfiguration.fromJson(Map<String, dynamic> json) =>
      _$$_MapCardAlertConfigurationFromJson(json);

  /// Represents the range of search results to be displayed on the map.
  @override
  @JsonKey()
  @MapCardModeConverter()
  final MapCardMode range;

  /// Display the count of alerts in the map card.
  @override
  @JsonKey()
  final bool count;

  /// Indicates if the alert segment is enabled.
  @override
  @JsonKey()
  final bool enabled;

  @override
  String toString() {
    return 'MapCardAlertConfiguration(range: $range, count: $count, enabled: $enabled)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MapCardAlertConfiguration &&
            (identical(other.range, range) || other.range == range) &&
            (identical(other.count, count) || other.count == count) &&
            (identical(other.enabled, enabled) || other.enabled == enabled));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, range, count, enabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MapCardAlertConfigurationCopyWith<_$_MapCardAlertConfiguration>
      get copyWith => __$$_MapCardAlertConfigurationCopyWithImpl<
          _$_MapCardAlertConfiguration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MapCardAlertConfigurationToJson(
      this,
    );
  }
}

abstract class _MapCardAlertConfiguration implements MapCardAlertConfiguration {
  const factory _MapCardAlertConfiguration(
      {@MapCardModeConverter() final MapCardMode range,
      final bool count,
      final bool enabled}) = _$_MapCardAlertConfiguration;

  factory _MapCardAlertConfiguration.fromJson(Map<String, dynamic> json) =
      _$_MapCardAlertConfiguration.fromJson;

  @override

  /// Represents the range of search results to be displayed on the map.
  @MapCardModeConverter()
  MapCardMode get range;
  @override

  /// Display the count of alerts in the map card.
  bool get count;
  @override

  /// Indicates if the alert segment is enabled.
  bool get enabled;
  @override
  @JsonKey(ignore: true)
  _$$_MapCardAlertConfigurationCopyWith<_$_MapCardAlertConfiguration>
      get copyWith => throw _privateConstructorUsedError;
}

MapCardConnectionConfiguration _$MapCardConnectionConfigurationFromJson(
    Map<String, dynamic> json) {
  return _MapCardConnectionConfiguration.fromJson(json);
}

/// @nodoc
mixin _$MapCardConnectionConfiguration {
  /// Indicates if the connection indicatpr segment is enabled.
  bool get indicator => throw _privateConstructorUsedError;

  /// Indicates if the address segment is enabled.
  bool get address => throw _privateConstructorUsedError;

  /// Indicates if the time segment is enabled.
  bool get time => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MapCardConnectionConfigurationCopyWith<MapCardConnectionConfiguration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapCardConnectionConfigurationCopyWith<$Res> {
  factory $MapCardConnectionConfigurationCopyWith(
          MapCardConnectionConfiguration value,
          $Res Function(MapCardConnectionConfiguration) then) =
      _$MapCardConnectionConfigurationCopyWithImpl<$Res,
          MapCardConnectionConfiguration>;
  @useResult
  $Res call({bool indicator, bool address, bool time});
}

/// @nodoc
class _$MapCardConnectionConfigurationCopyWithImpl<$Res,
        $Val extends MapCardConnectionConfiguration>
    implements $MapCardConnectionConfigurationCopyWith<$Res> {
  _$MapCardConnectionConfigurationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? indicator = null,
    Object? address = null,
    Object? time = null,
  }) {
    return _then(_value.copyWith(
      indicator: null == indicator
          ? _value.indicator
          : indicator // ignore: cast_nullable_to_non_nullable
              as bool,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as bool,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MapCardConnectionConfigurationCopyWith<$Res>
    implements $MapCardConnectionConfigurationCopyWith<$Res> {
  factory _$$_MapCardConnectionConfigurationCopyWith(
          _$_MapCardConnectionConfiguration value,
          $Res Function(_$_MapCardConnectionConfiguration) then) =
      __$$_MapCardConnectionConfigurationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool indicator, bool address, bool time});
}

/// @nodoc
class __$$_MapCardConnectionConfigurationCopyWithImpl<$Res>
    extends _$MapCardConnectionConfigurationCopyWithImpl<$Res,
        _$_MapCardConnectionConfiguration>
    implements _$$_MapCardConnectionConfigurationCopyWith<$Res> {
  __$$_MapCardConnectionConfigurationCopyWithImpl(
      _$_MapCardConnectionConfiguration _value,
      $Res Function(_$_MapCardConnectionConfiguration) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? indicator = null,
    Object? address = null,
    Object? time = null,
  }) {
    return _then(_$_MapCardConnectionConfiguration(
      indicator: null == indicator
          ? _value.indicator
          : indicator // ignore: cast_nullable_to_non_nullable
              as bool,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as bool,
      time: null == time
          ? _value.time
          : time // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MapCardConnectionConfiguration
    implements _MapCardConnectionConfiguration {
  const _$_MapCardConnectionConfiguration(
      {this.indicator = true, this.address = false, this.time = false});

  factory _$_MapCardConnectionConfiguration.fromJson(
          Map<String, dynamic> json) =>
      _$$_MapCardConnectionConfigurationFromJson(json);

  /// Indicates if the connection indicatpr segment is enabled.
  @override
  @JsonKey()
  final bool indicator;

  /// Indicates if the address segment is enabled.
  @override
  @JsonKey()
  final bool address;

  /// Indicates if the time segment is enabled.
  @override
  @JsonKey()
  final bool time;

  @override
  String toString() {
    return 'MapCardConnectionConfiguration(indicator: $indicator, address: $address, time: $time)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MapCardConnectionConfiguration &&
            (identical(other.indicator, indicator) ||
                other.indicator == indicator) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.time, time) || other.time == time));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, indicator, address, time);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MapCardConnectionConfigurationCopyWith<_$_MapCardConnectionConfiguration>
      get copyWith => __$$_MapCardConnectionConfigurationCopyWithImpl<
          _$_MapCardConnectionConfiguration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MapCardConnectionConfigurationToJson(
      this,
    );
  }
}

abstract class _MapCardConnectionConfiguration
    implements MapCardConnectionConfiguration {
  const factory _MapCardConnectionConfiguration(
      {final bool indicator,
      final bool address,
      final bool time}) = _$_MapCardConnectionConfiguration;

  factory _MapCardConnectionConfiguration.fromJson(Map<String, dynamic> json) =
      _$_MapCardConnectionConfiguration.fromJson;

  @override

  /// Indicates if the connection indicatpr segment is enabled.
  bool get indicator;
  @override

  /// Indicates if the address segment is enabled.
  bool get address;
  @override

  /// Indicates if the time segment is enabled.
  bool get time;
  @override
  @JsonKey(ignore: true)
  _$$_MapCardConnectionConfigurationCopyWith<_$_MapCardConnectionConfiguration>
      get copyWith => throw _privateConstructorUsedError;
}

MapCardSensorsConfiguration _$MapCardSensorsConfigurationFromJson(
    Map<String, dynamic> json) {
  return _MapCardSensorsConfiguration.fromJson(json);
}

/// @nodoc
mixin _$MapCardSensorsConfiguration {
  /// Indicates if the sensor segment is enabled.
  bool get enabled => throw _privateConstructorUsedError;

  /// Represents the format of the sensor list.
  @MapSensorModeConverter()
  MapSensorMode get mode => throw _privateConstructorUsedError;

  /// Indicates the sensors assigned
  List<String> get values => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MapCardSensorsConfigurationCopyWith<MapCardSensorsConfiguration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapCardSensorsConfigurationCopyWith<$Res> {
  factory $MapCardSensorsConfigurationCopyWith(
          MapCardSensorsConfiguration value,
          $Res Function(MapCardSensorsConfiguration) then) =
      _$MapCardSensorsConfigurationCopyWithImpl<$Res,
          MapCardSensorsConfiguration>;
  @useResult
  $Res call(
      {bool enabled,
      @MapSensorModeConverter() MapSensorMode mode,
      List<String> values});
}

/// @nodoc
class _$MapCardSensorsConfigurationCopyWithImpl<$Res,
        $Val extends MapCardSensorsConfiguration>
    implements $MapCardSensorsConfigurationCopyWith<$Res> {
  _$MapCardSensorsConfigurationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? mode = null,
    Object? values = null,
  }) {
    return _then(_value.copyWith(
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as MapSensorMode,
      values: null == values
          ? _value.values
          : values // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MapCardSensorsConfigurationCopyWith<$Res>
    implements $MapCardSensorsConfigurationCopyWith<$Res> {
  factory _$$_MapCardSensorsConfigurationCopyWith(
          _$_MapCardSensorsConfiguration value,
          $Res Function(_$_MapCardSensorsConfiguration) then) =
      __$$_MapCardSensorsConfigurationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool enabled,
      @MapSensorModeConverter() MapSensorMode mode,
      List<String> values});
}

/// @nodoc
class __$$_MapCardSensorsConfigurationCopyWithImpl<$Res>
    extends _$MapCardSensorsConfigurationCopyWithImpl<$Res,
        _$_MapCardSensorsConfiguration>
    implements _$$_MapCardSensorsConfigurationCopyWith<$Res> {
  __$$_MapCardSensorsConfigurationCopyWithImpl(
      _$_MapCardSensorsConfiguration _value,
      $Res Function(_$_MapCardSensorsConfiguration) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? mode = null,
    Object? values = null,
  }) {
    return _then(_$_MapCardSensorsConfiguration(
      enabled: null == enabled
          ? _value.enabled
          : enabled // ignore: cast_nullable_to_non_nullable
              as bool,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as MapSensorMode,
      values: null == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MapCardSensorsConfiguration implements _MapCardSensorsConfiguration {
  const _$_MapCardSensorsConfiguration(
      {this.enabled = true,
      @MapSensorModeConverter() this.mode = MapSensorMode.grid,
      final List<String> values = const []})
      : _values = values;

  factory _$_MapCardSensorsConfiguration.fromJson(Map<String, dynamic> json) =>
      _$$_MapCardSensorsConfigurationFromJson(json);

  /// Indicates if the sensor segment is enabled.
  @override
  @JsonKey()
  final bool enabled;

  /// Represents the format of the sensor list.
  @override
  @JsonKey()
  @MapSensorModeConverter()
  final MapSensorMode mode;

  /// Indicates the sensors assigned
  final List<String> _values;

  /// Indicates the sensors assigned
  @override
  @JsonKey()
  List<String> get values {
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_values);
  }

  @override
  String toString() {
    return 'MapCardSensorsConfiguration(enabled: $enabled, mode: $mode, values: $values)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MapCardSensorsConfiguration &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            const DeepCollectionEquality().equals(other._values, _values));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, enabled, mode, const DeepCollectionEquality().hash(_values));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MapCardSensorsConfigurationCopyWith<_$_MapCardSensorsConfiguration>
      get copyWith => __$$_MapCardSensorsConfigurationCopyWithImpl<
          _$_MapCardSensorsConfiguration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MapCardSensorsConfigurationToJson(
      this,
    );
  }
}

abstract class _MapCardSensorsConfiguration
    implements MapCardSensorsConfiguration {
  const factory _MapCardSensorsConfiguration(
      {final bool enabled,
      @MapSensorModeConverter() final MapSensorMode mode,
      final List<String> values}) = _$_MapCardSensorsConfiguration;

  factory _MapCardSensorsConfiguration.fromJson(Map<String, dynamic> json) =
      _$_MapCardSensorsConfiguration.fromJson;

  @override

  /// Indicates if the sensor segment is enabled.
  bool get enabled;
  @override

  /// Represents the format of the sensor list.
  @MapSensorModeConverter()
  MapSensorMode get mode;
  @override

  /// Indicates the sensors assigned
  List<String> get values;
  @override
  @JsonKey(ignore: true)
  _$$_MapCardSensorsConfigurationCopyWith<_$_MapCardSensorsConfiguration>
      get copyWith => throw _privateConstructorUsedError;
}

MapCardSensors _$MapCardSensorsFromJson(Map<String, dynamic> json) {
  return _MapCardSensors.fromJson(json);
}

/// @nodoc
mixin _$MapCardSensors {
  /// Represents the ID of the asset
  String get assetId => throw _privateConstructorUsedError;

  /// Represents the alerts configuration
  MapCardAlertConfiguration get alerts => throw _privateConstructorUsedError;

  /// Represents the connection configuration
  MapCardConnectionConfiguration get connection =>
      throw _privateConstructorUsedError;

  /// Represetns the sensors configuration
  MapCardSensorsConfiguration get sensors => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MapCardSensorsCopyWith<MapCardSensors> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapCardSensorsCopyWith<$Res> {
  factory $MapCardSensorsCopyWith(
          MapCardSensors value, $Res Function(MapCardSensors) then) =
      _$MapCardSensorsCopyWithImpl<$Res, MapCardSensors>;
  @useResult
  $Res call(
      {String assetId,
      MapCardAlertConfiguration alerts,
      MapCardConnectionConfiguration connection,
      MapCardSensorsConfiguration sensors});

  $MapCardAlertConfigurationCopyWith<$Res> get alerts;
  $MapCardConnectionConfigurationCopyWith<$Res> get connection;
  $MapCardSensorsConfigurationCopyWith<$Res> get sensors;
}

/// @nodoc
class _$MapCardSensorsCopyWithImpl<$Res, $Val extends MapCardSensors>
    implements $MapCardSensorsCopyWith<$Res> {
  _$MapCardSensorsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = null,
    Object? alerts = null,
    Object? connection = null,
    Object? sensors = null,
  }) {
    return _then(_value.copyWith(
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      alerts: null == alerts
          ? _value.alerts
          : alerts // ignore: cast_nullable_to_non_nullable
              as MapCardAlertConfiguration,
      connection: null == connection
          ? _value.connection
          : connection // ignore: cast_nullable_to_non_nullable
              as MapCardConnectionConfiguration,
      sensors: null == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as MapCardSensorsConfiguration,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MapCardAlertConfigurationCopyWith<$Res> get alerts {
    return $MapCardAlertConfigurationCopyWith<$Res>(_value.alerts, (value) {
      return _then(_value.copyWith(alerts: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MapCardConnectionConfigurationCopyWith<$Res> get connection {
    return $MapCardConnectionConfigurationCopyWith<$Res>(_value.connection,
        (value) {
      return _then(_value.copyWith(connection: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $MapCardSensorsConfigurationCopyWith<$Res> get sensors {
    return $MapCardSensorsConfigurationCopyWith<$Res>(_value.sensors, (value) {
      return _then(_value.copyWith(sensors: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MapCardSensorsCopyWith<$Res>
    implements $MapCardSensorsCopyWith<$Res> {
  factory _$$_MapCardSensorsCopyWith(
          _$_MapCardSensors value, $Res Function(_$_MapCardSensors) then) =
      __$$_MapCardSensorsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String assetId,
      MapCardAlertConfiguration alerts,
      MapCardConnectionConfiguration connection,
      MapCardSensorsConfiguration sensors});

  @override
  $MapCardAlertConfigurationCopyWith<$Res> get alerts;
  @override
  $MapCardConnectionConfigurationCopyWith<$Res> get connection;
  @override
  $MapCardSensorsConfigurationCopyWith<$Res> get sensors;
}

/// @nodoc
class __$$_MapCardSensorsCopyWithImpl<$Res>
    extends _$MapCardSensorsCopyWithImpl<$Res, _$_MapCardSensors>
    implements _$$_MapCardSensorsCopyWith<$Res> {
  __$$_MapCardSensorsCopyWithImpl(
      _$_MapCardSensors _value, $Res Function(_$_MapCardSensors) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = null,
    Object? alerts = null,
    Object? connection = null,
    Object? sensors = null,
  }) {
    return _then(_$_MapCardSensors(
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      alerts: null == alerts
          ? _value.alerts
          : alerts // ignore: cast_nullable_to_non_nullable
              as MapCardAlertConfiguration,
      connection: null == connection
          ? _value.connection
          : connection // ignore: cast_nullable_to_non_nullable
              as MapCardConnectionConfiguration,
      sensors: null == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as MapCardSensorsConfiguration,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MapCardSensors implements _MapCardSensors {
  const _$_MapCardSensors(
      {required this.assetId,
      required this.alerts,
      required this.connection,
      required this.sensors});

  factory _$_MapCardSensors.fromJson(Map<String, dynamic> json) =>
      _$$_MapCardSensorsFromJson(json);

  /// Represents the ID of the asset
  @override
  final String assetId;

  /// Represents the alerts configuration
  @override
  final MapCardAlertConfiguration alerts;

  /// Represents the connection configuration
  @override
  final MapCardConnectionConfiguration connection;

  /// Represetns the sensors configuration
  @override
  final MapCardSensorsConfiguration sensors;

  @override
  String toString() {
    return 'MapCardSensors(assetId: $assetId, alerts: $alerts, connection: $connection, sensors: $sensors)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MapCardSensors &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.alerts, alerts) || other.alerts == alerts) &&
            (identical(other.connection, connection) ||
                other.connection == connection) &&
            (identical(other.sensors, sensors) || other.sensors == sensors));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, assetId, alerts, connection, sensors);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MapCardSensorsCopyWith<_$_MapCardSensors> get copyWith =>
      __$$_MapCardSensorsCopyWithImpl<_$_MapCardSensors>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MapCardSensorsToJson(
      this,
    );
  }
}

abstract class _MapCardSensors implements MapCardSensors {
  const factory _MapCardSensors(
      {required final String assetId,
      required final MapCardAlertConfiguration alerts,
      required final MapCardConnectionConfiguration connection,
      required final MapCardSensorsConfiguration sensors}) = _$_MapCardSensors;

  factory _MapCardSensors.fromJson(Map<String, dynamic> json) =
      _$_MapCardSensors.fromJson;

  @override

  /// Represents the ID of the asset
  String get assetId;
  @override

  /// Represents the alerts configuration
  MapCardAlertConfiguration get alerts;
  @override

  /// Represents the connection configuration
  MapCardConnectionConfiguration get connection;
  @override

  /// Represetns the sensors configuration
  MapCardSensorsConfiguration get sensors;
  @override
  @JsonKey(ignore: true)
  _$$_MapCardSensorsCopyWith<_$_MapCardSensors> get copyWith =>
      throw _privateConstructorUsedError;
}

GridDimension _$GridDimensionFromJson(Map<String, dynamic> json) {
  return _GridDimension.fromJson(json);
}

/// @nodoc
mixin _$GridDimension {
  /// [width] Represents the number of columns to be expanded
  int get width => throw _privateConstructorUsedError;

  /// [height] Represents the number of rows to be expanded
  int get height => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GridDimensionCopyWith<GridDimension> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GridDimensionCopyWith<$Res> {
  factory $GridDimensionCopyWith(
          GridDimension value, $Res Function(GridDimension) then) =
      _$GridDimensionCopyWithImpl<$Res, GridDimension>;
  @useResult
  $Res call({int width, int height});
}

/// @nodoc
class _$GridDimensionCopyWithImpl<$Res, $Val extends GridDimension>
    implements $GridDimensionCopyWith<$Res> {
  _$GridDimensionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = null,
    Object? height = null,
  }) {
    return _then(_value.copyWith(
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_GridDimensionCopyWith<$Res>
    implements $GridDimensionCopyWith<$Res> {
  factory _$$_GridDimensionCopyWith(
          _$_GridDimension value, $Res Function(_$_GridDimension) then) =
      __$$_GridDimensionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int width, int height});
}

/// @nodoc
class __$$_GridDimensionCopyWithImpl<$Res>
    extends _$GridDimensionCopyWithImpl<$Res, _$_GridDimension>
    implements _$$_GridDimensionCopyWith<$Res> {
  __$$_GridDimensionCopyWithImpl(
      _$_GridDimension _value, $Res Function(_$_GridDimension) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = null,
    Object? height = null,
  }) {
    return _then(_$_GridDimension(
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GridDimension implements _GridDimension {
  const _$_GridDimension({required this.width, required this.height});

  factory _$_GridDimension.fromJson(Map<String, dynamic> json) =>
      _$$_GridDimensionFromJson(json);

  /// [width] Represents the number of columns to be expanded
  @override
  final int width;

  /// [height] Represents the number of rows to be expanded
  @override
  final int height;

  @override
  String toString() {
    return 'GridDimension(width: $width, height: $height)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GridDimension &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, width, height);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GridDimensionCopyWith<_$_GridDimension> get copyWith =>
      __$$_GridDimensionCopyWithImpl<_$_GridDimension>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GridDimensionToJson(
      this,
    );
  }
}

abstract class _GridDimension implements GridDimension {
  const factory _GridDimension(
      {required final int width, required final int height}) = _$_GridDimension;

  factory _GridDimension.fromJson(Map<String, dynamic> json) =
      _$_GridDimension.fromJson;

  @override

  /// [width] Represents the number of columns to be expanded
  int get width;
  @override

  /// [height] Represents the number of rows to be expanded
  int get height;
  @override
  @JsonKey(ignore: true)
  _$$_GridDimensionCopyWith<_$_GridDimension> get copyWith =>
      throw _privateConstructorUsedError;
}

SensorGridContent _$SensorGridContentFromJson(Map<String, dynamic> json) {
  return _SensorGridContent.fromJson(json);
}

/// @nodoc
mixin _$SensorGridContent {
  /// Represents the sensor ID
  String? get sensorId => throw _privateConstructorUsedError;

  /// [dimensions] Represents the dimension of the sensor
  GridDimension get dimensions => throw _privateConstructorUsedError;

  /// Indicates if the sensor content has enabled the mask
  bool get maskEnabled => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SensorGridContentCopyWith<SensorGridContent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SensorGridContentCopyWith<$Res> {
  factory $SensorGridContentCopyWith(
          SensorGridContent value, $Res Function(SensorGridContent) then) =
      _$SensorGridContentCopyWithImpl<$Res, SensorGridContent>;
  @useResult
  $Res call({String? sensorId, GridDimension dimensions, bool maskEnabled});

  $GridDimensionCopyWith<$Res> get dimensions;
}

/// @nodoc
class _$SensorGridContentCopyWithImpl<$Res, $Val extends SensorGridContent>
    implements $SensorGridContentCopyWith<$Res> {
  _$SensorGridContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sensorId = freezed,
    Object? dimensions = null,
    Object? maskEnabled = null,
  }) {
    return _then(_value.copyWith(
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      dimensions: null == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as GridDimension,
      maskEnabled: null == maskEnabled
          ? _value.maskEnabled
          : maskEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GridDimensionCopyWith<$Res> get dimensions {
    return $GridDimensionCopyWith<$Res>(_value.dimensions, (value) {
      return _then(_value.copyWith(dimensions: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SensorGridContentCopyWith<$Res>
    implements $SensorGridContentCopyWith<$Res> {
  factory _$$_SensorGridContentCopyWith(_$_SensorGridContent value,
          $Res Function(_$_SensorGridContent) then) =
      __$$_SensorGridContentCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? sensorId, GridDimension dimensions, bool maskEnabled});

  @override
  $GridDimensionCopyWith<$Res> get dimensions;
}

/// @nodoc
class __$$_SensorGridContentCopyWithImpl<$Res>
    extends _$SensorGridContentCopyWithImpl<$Res, _$_SensorGridContent>
    implements _$$_SensorGridContentCopyWith<$Res> {
  __$$_SensorGridContentCopyWithImpl(
      _$_SensorGridContent _value, $Res Function(_$_SensorGridContent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sensorId = freezed,
    Object? dimensions = null,
    Object? maskEnabled = null,
  }) {
    return _then(_$_SensorGridContent(
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      dimensions: null == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as GridDimension,
      maskEnabled: null == maskEnabled
          ? _value.maskEnabled
          : maskEnabled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SensorGridContent implements _SensorGridContent {
  const _$_SensorGridContent(
      {this.sensorId, required this.dimensions, this.maskEnabled = true});

  factory _$_SensorGridContent.fromJson(Map<String, dynamic> json) =>
      _$$_SensorGridContentFromJson(json);

  /// Represents the sensor ID
  @override
  final String? sensorId;

  /// [dimensions] Represents the dimension of the sensor
  @override
  final GridDimension dimensions;

  /// Indicates if the sensor content has enabled the mask
  @override
  @JsonKey()
  final bool maskEnabled;

  @override
  String toString() {
    return 'SensorGridContent(sensorId: $sensorId, dimensions: $dimensions, maskEnabled: $maskEnabled)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SensorGridContent &&
            (identical(other.sensorId, sensorId) ||
                other.sensorId == sensorId) &&
            (identical(other.dimensions, dimensions) ||
                other.dimensions == dimensions) &&
            (identical(other.maskEnabled, maskEnabled) ||
                other.maskEnabled == maskEnabled));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, sensorId, dimensions, maskEnabled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SensorGridContentCopyWith<_$_SensorGridContent> get copyWith =>
      __$$_SensorGridContentCopyWithImpl<_$_SensorGridContent>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SensorGridContentToJson(
      this,
    );
  }
}

abstract class _SensorGridContent implements SensorGridContent {
  const factory _SensorGridContent(
      {final String? sensorId,
      required final GridDimension dimensions,
      final bool maskEnabled}) = _$_SensorGridContent;

  factory _SensorGridContent.fromJson(Map<String, dynamic> json) =
      _$_SensorGridContent.fromJson;

  @override

  /// Represents the sensor ID
  String? get sensorId;
  @override

  /// [dimensions] Represents the dimension of the sensor
  GridDimension get dimensions;
  @override

  /// Indicates if the sensor content has enabled the mask
  bool get maskEnabled;
  @override
  @JsonKey(ignore: true)
  _$$_SensorGridContentCopyWith<_$_SensorGridContent> get copyWith =>
      throw _privateConstructorUsedError;
}

SensorGridItem _$SensorGridItemFromJson(Map<String, dynamic> json) {
  return _SensorGridItem.fromJson(json);
}

/// @nodoc
mixin _$SensorGridItem {
  /// Represents the Asset ID
  String? get assetId => throw _privateConstructorUsedError;

  /// [dimensions] Represents the dimension of the sensor
  GridDimension get dimensions => throw _privateConstructorUsedError;

  /// Represents the color of the card
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;

  /// Represents the sensors of the card
  List<SensorGridContent> get sensors => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SensorGridItemCopyWith<SensorGridItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SensorGridItemCopyWith<$Res> {
  factory $SensorGridItemCopyWith(
          SensorGridItem value, $Res Function(SensorGridItem) then) =
      _$SensorGridItemCopyWithImpl<$Res, SensorGridItem>;
  @useResult
  $Res call(
      {String? assetId,
      GridDimension dimensions,
      @ColorConverter() Color color,
      List<SensorGridContent> sensors});

  $GridDimensionCopyWith<$Res> get dimensions;
}

/// @nodoc
class _$SensorGridItemCopyWithImpl<$Res, $Val extends SensorGridItem>
    implements $SensorGridItemCopyWith<$Res> {
  _$SensorGridItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = freezed,
    Object? dimensions = null,
    Object? color = null,
    Object? sensors = null,
  }) {
    return _then(_value.copyWith(
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      dimensions: null == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as GridDimension,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      sensors: null == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<SensorGridContent>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GridDimensionCopyWith<$Res> get dimensions {
    return $GridDimensionCopyWith<$Res>(_value.dimensions, (value) {
      return _then(_value.copyWith(dimensions: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_SensorGridItemCopyWith<$Res>
    implements $SensorGridItemCopyWith<$Res> {
  factory _$$_SensorGridItemCopyWith(
          _$_SensorGridItem value, $Res Function(_$_SensorGridItem) then) =
      __$$_SensorGridItemCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? assetId,
      GridDimension dimensions,
      @ColorConverter() Color color,
      List<SensorGridContent> sensors});

  @override
  $GridDimensionCopyWith<$Res> get dimensions;
}

/// @nodoc
class __$$_SensorGridItemCopyWithImpl<$Res>
    extends _$SensorGridItemCopyWithImpl<$Res, _$_SensorGridItem>
    implements _$$_SensorGridItemCopyWith<$Res> {
  __$$_SensorGridItemCopyWithImpl(
      _$_SensorGridItem _value, $Res Function(_$_SensorGridItem) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = freezed,
    Object? dimensions = null,
    Object? color = null,
    Object? sensors = null,
  }) {
    return _then(_$_SensorGridItem(
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      dimensions: null == dimensions
          ? _value.dimensions
          : dimensions // ignore: cast_nullable_to_non_nullable
              as GridDimension,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
      sensors: null == sensors
          ? _value._sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<SensorGridContent>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_SensorGridItem implements _SensorGridItem {
  const _$_SensorGridItem(
      {this.assetId,
      required this.dimensions,
      @ColorConverter() this.color = Colors.white,
      required final List<SensorGridContent> sensors})
      : _sensors = sensors;

  factory _$_SensorGridItem.fromJson(Map<String, dynamic> json) =>
      _$$_SensorGridItemFromJson(json);

  /// Represents the Asset ID
  @override
  final String? assetId;

  /// [dimensions] Represents the dimension of the sensor
  @override
  final GridDimension dimensions;

  /// Represents the color of the card
  @override
  @JsonKey()
  @ColorConverter()
  final Color color;

  /// Represents the sensors of the card
  final List<SensorGridContent> _sensors;

  /// Represents the sensors of the card
  @override
  List<SensorGridContent> get sensors {
    if (_sensors is EqualUnmodifiableListView) return _sensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sensors);
  }

  @override
  String toString() {
    return 'SensorGridItem(assetId: $assetId, dimensions: $dimensions, color: $color, sensors: $sensors)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SensorGridItem &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.dimensions, dimensions) ||
                other.dimensions == dimensions) &&
            (identical(other.color, color) || other.color == color) &&
            const DeepCollectionEquality().equals(other._sensors, _sensors));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, assetId, dimensions, color,
      const DeepCollectionEquality().hash(_sensors));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SensorGridItemCopyWith<_$_SensorGridItem> get copyWith =>
      __$$_SensorGridItemCopyWithImpl<_$_SensorGridItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_SensorGridItemToJson(
      this,
    );
  }
}

abstract class _SensorGridItem implements SensorGridItem {
  const factory _SensorGridItem(
      {final String? assetId,
      required final GridDimension dimensions,
      @ColorConverter() final Color color,
      required final List<SensorGridContent> sensors}) = _$_SensorGridItem;

  factory _SensorGridItem.fromJson(Map<String, dynamic> json) =
      _$_SensorGridItem.fromJson;

  @override

  /// Represents the Asset ID
  String? get assetId;
  @override

  /// [dimensions] Represents the dimension of the sensor
  GridDimension get dimensions;
  @override

  /// Represents the color of the card
  @ColorConverter()
  Color get color;
  @override

  /// Represents the sensors of the card
  List<SensorGridContent> get sensors;
  @override
  @JsonKey(ignore: true)
  _$$_SensorGridItemCopyWith<_$_SensorGridItem> get copyWith =>
      throw _privateConstructorUsedError;
}

WorkspaceAlert _$WorkspaceAlertFromJson(Map<String, dynamic> json) {
  return _WorkspaceAlert.fromJson(json);
}

/// @nodoc
mixin _$WorkspaceAlert {
  @TimestampConverter()
  DateTime get at => throw _privateConstructorUsedError;
  String get assetId => throw _privateConstructorUsedError;
  TelemetryPosition get position => throw _privateConstructorUsedError;
  Trigger get trigger => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WorkspaceAlertCopyWith<WorkspaceAlert> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkspaceAlertCopyWith<$Res> {
  factory $WorkspaceAlertCopyWith(
          WorkspaceAlert value, $Res Function(WorkspaceAlert) then) =
      _$WorkspaceAlertCopyWithImpl<$Res, WorkspaceAlert>;
  @useResult
  $Res call(
      {@TimestampConverter() DateTime at,
      String assetId,
      TelemetryPosition position,
      Trigger trigger});

  $TelemetryPositionCopyWith<$Res> get position;
  $TriggerCopyWith<$Res> get trigger;
}

/// @nodoc
class _$WorkspaceAlertCopyWithImpl<$Res, $Val extends WorkspaceAlert>
    implements $WorkspaceAlertCopyWith<$Res> {
  _$WorkspaceAlertCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? at = null,
    Object? assetId = null,
    Object? position = null,
    Object? trigger = null,
  }) {
    return _then(_value.copyWith(
      at: null == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime,
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition,
      trigger: null == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TelemetryPositionCopyWith<$Res> get position {
    return $TelemetryPositionCopyWith<$Res>(_value.position, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TriggerCopyWith<$Res> get trigger {
    return $TriggerCopyWith<$Res>(_value.trigger, (value) {
      return _then(_value.copyWith(trigger: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_WorkspaceAlertCopyWith<$Res>
    implements $WorkspaceAlertCopyWith<$Res> {
  factory _$$_WorkspaceAlertCopyWith(
          _$_WorkspaceAlert value, $Res Function(_$_WorkspaceAlert) then) =
      __$$_WorkspaceAlertCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@TimestampConverter() DateTime at,
      String assetId,
      TelemetryPosition position,
      Trigger trigger});

  @override
  $TelemetryPositionCopyWith<$Res> get position;
  @override
  $TriggerCopyWith<$Res> get trigger;
}

/// @nodoc
class __$$_WorkspaceAlertCopyWithImpl<$Res>
    extends _$WorkspaceAlertCopyWithImpl<$Res, _$_WorkspaceAlert>
    implements _$$_WorkspaceAlertCopyWith<$Res> {
  __$$_WorkspaceAlertCopyWithImpl(
      _$_WorkspaceAlert _value, $Res Function(_$_WorkspaceAlert) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? at = null,
    Object? assetId = null,
    Object? position = null,
    Object? trigger = null,
  }) {
    return _then(_$_WorkspaceAlert(
      at: null == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime,
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition,
      trigger: null == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_WorkspaceAlert implements _WorkspaceAlert {
  const _$_WorkspaceAlert(
      {@TimestampConverter() required this.at,
      required this.assetId,
      required this.position,
      required this.trigger});

  factory _$_WorkspaceAlert.fromJson(Map<String, dynamic> json) =>
      _$$_WorkspaceAlertFromJson(json);

  @override
  @TimestampConverter()
  final DateTime at;
  @override
  final String assetId;
  @override
  final TelemetryPosition position;
  @override
  final Trigger trigger;

  @override
  String toString() {
    return 'WorkspaceAlert(at: $at, assetId: $assetId, position: $position, trigger: $trigger)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WorkspaceAlert &&
            (identical(other.at, at) || other.at == at) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.trigger, trigger) || other.trigger == trigger));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, at, assetId, position, trigger);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WorkspaceAlertCopyWith<_$_WorkspaceAlert> get copyWith =>
      __$$_WorkspaceAlertCopyWithImpl<_$_WorkspaceAlert>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WorkspaceAlertToJson(
      this,
    );
  }
}

abstract class _WorkspaceAlert implements WorkspaceAlert {
  const factory _WorkspaceAlert(
      {@TimestampConverter() required final DateTime at,
      required final String assetId,
      required final TelemetryPosition position,
      required final Trigger trigger}) = _$_WorkspaceAlert;

  factory _WorkspaceAlert.fromJson(Map<String, dynamic> json) =
      _$_WorkspaceAlert.fromJson;

  @override
  @TimestampConverter()
  DateTime get at;
  @override
  String get assetId;
  @override
  TelemetryPosition get position;
  @override
  Trigger get trigger;
  @override
  @JsonKey(ignore: true)
  _$$_WorkspaceAlertCopyWith<_$_WorkspaceAlert> get copyWith =>
      throw _privateConstructorUsedError;
}

WorkspaceTripPoint _$WorkspaceTripPointFromJson(Map<String, dynamic> json) {
  return _WorkspaceTripPoint.fromJson(json);
}

/// @nodoc
mixin _$WorkspaceTripPoint {
  double? get latitude => throw _privateConstructorUsedError;
  double? get longitude => throw _privateConstructorUsedError;
  double? get speed => throw _privateConstructorUsedError;
  String? get triggerName => throw _privateConstructorUsedError;
  String? get triggerId => throw _privateConstructorUsedError;
  @TimestampConverter()
  DateTime get receivedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WorkspaceTripPointCopyWith<WorkspaceTripPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkspaceTripPointCopyWith<$Res> {
  factory $WorkspaceTripPointCopyWith(
          WorkspaceTripPoint value, $Res Function(WorkspaceTripPoint) then) =
      _$WorkspaceTripPointCopyWithImpl<$Res, WorkspaceTripPoint>;
  @useResult
  $Res call(
      {double? latitude,
      double? longitude,
      double? speed,
      String? triggerName,
      String? triggerId,
      @TimestampConverter() DateTime receivedAt});
}

/// @nodoc
class _$WorkspaceTripPointCopyWithImpl<$Res, $Val extends WorkspaceTripPoint>
    implements $WorkspaceTripPointCopyWith<$Res> {
  _$WorkspaceTripPointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? speed = freezed,
    Object? triggerName = freezed,
    Object? triggerId = freezed,
    Object? receivedAt = null,
  }) {
    return _then(_value.copyWith(
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
      speed: freezed == speed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as double?,
      triggerName: freezed == triggerName
          ? _value.triggerName
          : triggerName // ignore: cast_nullable_to_non_nullable
              as String?,
      triggerId: freezed == triggerId
          ? _value.triggerId
          : triggerId // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_WorkspaceTripPointCopyWith<$Res>
    implements $WorkspaceTripPointCopyWith<$Res> {
  factory _$$_WorkspaceTripPointCopyWith(_$_WorkspaceTripPoint value,
          $Res Function(_$_WorkspaceTripPoint) then) =
      __$$_WorkspaceTripPointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? latitude,
      double? longitude,
      double? speed,
      String? triggerName,
      String? triggerId,
      @TimestampConverter() DateTime receivedAt});
}

/// @nodoc
class __$$_WorkspaceTripPointCopyWithImpl<$Res>
    extends _$WorkspaceTripPointCopyWithImpl<$Res, _$_WorkspaceTripPoint>
    implements _$$_WorkspaceTripPointCopyWith<$Res> {
  __$$_WorkspaceTripPointCopyWithImpl(
      _$_WorkspaceTripPoint _value, $Res Function(_$_WorkspaceTripPoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? latitude = freezed,
    Object? longitude = freezed,
    Object? speed = freezed,
    Object? triggerName = freezed,
    Object? triggerId = freezed,
    Object? receivedAt = null,
  }) {
    return _then(_$_WorkspaceTripPoint(
      latitude: freezed == latitude
          ? _value.latitude
          : latitude // ignore: cast_nullable_to_non_nullable
              as double?,
      longitude: freezed == longitude
          ? _value.longitude
          : longitude // ignore: cast_nullable_to_non_nullable
              as double?,
      speed: freezed == speed
          ? _value.speed
          : speed // ignore: cast_nullable_to_non_nullable
              as double?,
      triggerName: freezed == triggerName
          ? _value.triggerName
          : triggerName // ignore: cast_nullable_to_non_nullable
              as String?,
      triggerId: freezed == triggerId
          ? _value.triggerId
          : triggerId // ignore: cast_nullable_to_non_nullable
              as String?,
      receivedAt: null == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_WorkspaceTripPoint implements _WorkspaceTripPoint {
  const _$_WorkspaceTripPoint(
      {this.latitude,
      this.longitude,
      this.speed,
      this.triggerName,
      this.triggerId,
      @TimestampConverter() required this.receivedAt});

  factory _$_WorkspaceTripPoint.fromJson(Map<String, dynamic> json) =>
      _$$_WorkspaceTripPointFromJson(json);

  @override
  final double? latitude;
  @override
  final double? longitude;
  @override
  final double? speed;
  @override
  final String? triggerName;
  @override
  final String? triggerId;
  @override
  @TimestampConverter()
  final DateTime receivedAt;

  @override
  String toString() {
    return 'WorkspaceTripPoint(latitude: $latitude, longitude: $longitude, speed: $speed, triggerName: $triggerName, triggerId: $triggerId, receivedAt: $receivedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WorkspaceTripPoint &&
            (identical(other.latitude, latitude) ||
                other.latitude == latitude) &&
            (identical(other.longitude, longitude) ||
                other.longitude == longitude) &&
            (identical(other.speed, speed) || other.speed == speed) &&
            (identical(other.triggerName, triggerName) ||
                other.triggerName == triggerName) &&
            (identical(other.triggerId, triggerId) ||
                other.triggerId == triggerId) &&
            (identical(other.receivedAt, receivedAt) ||
                other.receivedAt == receivedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, latitude, longitude, speed,
      triggerName, triggerId, receivedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WorkspaceTripPointCopyWith<_$_WorkspaceTripPoint> get copyWith =>
      __$$_WorkspaceTripPointCopyWithImpl<_$_WorkspaceTripPoint>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WorkspaceTripPointToJson(
      this,
    );
  }
}

abstract class _WorkspaceTripPoint implements WorkspaceTripPoint {
  const factory _WorkspaceTripPoint(
          {final double? latitude,
          final double? longitude,
          final double? speed,
          final String? triggerName,
          final String? triggerId,
          @TimestampConverter() required final DateTime receivedAt}) =
      _$_WorkspaceTripPoint;

  factory _WorkspaceTripPoint.fromJson(Map<String, dynamic> json) =
      _$_WorkspaceTripPoint.fromJson;

  @override
  double? get latitude;
  @override
  double? get longitude;
  @override
  double? get speed;
  @override
  String? get triggerName;
  @override
  String? get triggerId;
  @override
  @TimestampConverter()
  DateTime get receivedAt;
  @override
  @JsonKey(ignore: true)
  _$$_WorkspaceTripPointCopyWith<_$_WorkspaceTripPoint> get copyWith =>
      throw _privateConstructorUsedError;
}

WorkspaceTrip _$WorkspaceTripFromJson(Map<String, dynamic> json) {
  return _WorkspaceTrip.fromJson(json);
}

/// @nodoc
mixin _$WorkspaceTrip {
  String get assetId => throw _privateConstructorUsedError;
  String get assetName => throw _privateConstructorUsedError;
  List<WorkspaceTripPoint> get points => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WorkspaceTripCopyWith<WorkspaceTrip> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkspaceTripCopyWith<$Res> {
  factory $WorkspaceTripCopyWith(
          WorkspaceTrip value, $Res Function(WorkspaceTrip) then) =
      _$WorkspaceTripCopyWithImpl<$Res, WorkspaceTrip>;
  @useResult
  $Res call(
      {String assetId, String assetName, List<WorkspaceTripPoint> points});
}

/// @nodoc
class _$WorkspaceTripCopyWithImpl<$Res, $Val extends WorkspaceTrip>
    implements $WorkspaceTripCopyWith<$Res> {
  _$WorkspaceTripCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = null,
    Object? assetName = null,
    Object? points = null,
  }) {
    return _then(_value.copyWith(
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      assetName: null == assetName
          ? _value.assetName
          : assetName // ignore: cast_nullable_to_non_nullable
              as String,
      points: null == points
          ? _value.points
          : points // ignore: cast_nullable_to_non_nullable
              as List<WorkspaceTripPoint>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_WorkspaceTripCopyWith<$Res>
    implements $WorkspaceTripCopyWith<$Res> {
  factory _$$_WorkspaceTripCopyWith(
          _$_WorkspaceTrip value, $Res Function(_$_WorkspaceTrip) then) =
      __$$_WorkspaceTripCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String assetId, String assetName, List<WorkspaceTripPoint> points});
}

/// @nodoc
class __$$_WorkspaceTripCopyWithImpl<$Res>
    extends _$WorkspaceTripCopyWithImpl<$Res, _$_WorkspaceTrip>
    implements _$$_WorkspaceTripCopyWith<$Res> {
  __$$_WorkspaceTripCopyWithImpl(
      _$_WorkspaceTrip _value, $Res Function(_$_WorkspaceTrip) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetId = null,
    Object? assetName = null,
    Object? points = null,
  }) {
    return _then(_$_WorkspaceTrip(
      assetId: null == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String,
      assetName: null == assetName
          ? _value.assetName
          : assetName // ignore: cast_nullable_to_non_nullable
              as String,
      points: null == points
          ? _value._points
          : points // ignore: cast_nullable_to_non_nullable
              as List<WorkspaceTripPoint>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_WorkspaceTrip implements _WorkspaceTrip {
  const _$_WorkspaceTrip(
      {required this.assetId,
      required this.assetName,
      final List<WorkspaceTripPoint> points = const []})
      : _points = points;

  factory _$_WorkspaceTrip.fromJson(Map<String, dynamic> json) =>
      _$$_WorkspaceTripFromJson(json);

  @override
  final String assetId;
  @override
  final String assetName;
  final List<WorkspaceTripPoint> _points;
  @override
  @JsonKey()
  List<WorkspaceTripPoint> get points {
    if (_points is EqualUnmodifiableListView) return _points;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_points);
  }

  @override
  String toString() {
    return 'WorkspaceTrip(assetId: $assetId, assetName: $assetName, points: $points)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_WorkspaceTrip &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.assetName, assetName) ||
                other.assetName == assetName) &&
            const DeepCollectionEquality().equals(other._points, _points));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, assetId, assetName,
      const DeepCollectionEquality().hash(_points));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_WorkspaceTripCopyWith<_$_WorkspaceTrip> get copyWith =>
      __$$_WorkspaceTripCopyWithImpl<_$_WorkspaceTrip>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_WorkspaceTripToJson(
      this,
    );
  }
}

abstract class _WorkspaceTrip implements WorkspaceTrip {
  const factory _WorkspaceTrip(
      {required final String assetId,
      required final String assetName,
      final List<WorkspaceTripPoint> points}) = _$_WorkspaceTrip;

  factory _WorkspaceTrip.fromJson(Map<String, dynamic> json) =
      _$_WorkspaceTrip.fromJson;

  @override
  String get assetId;
  @override
  String get assetName;
  @override
  List<WorkspaceTripPoint> get points;
  @override
  @JsonKey(ignore: true)
  _$$_WorkspaceTripCopyWith<_$_WorkspaceTrip> get copyWith =>
      throw _privateConstructorUsedError;
}

CaseMonitorCard _$CaseMonitorCardFromJson(Map<String, dynamic> json) {
  return _CaseMonitorCard.fromJson(json);
}

/// @nodoc
mixin _$CaseMonitorCard {
  /// Represents the type of the block
  @CaseMonitorCardTypeConverter()
  CaseMonitorCardType get type => throw _privateConstructorUsedError;

  /// When [type] is [CaseMonitorCardType.specificAsset], will use [assetId] to apply the filter.
  String? get assetId => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CaseMonitorCardCopyWith<CaseMonitorCard> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CaseMonitorCardCopyWith<$Res> {
  factory $CaseMonitorCardCopyWith(
          CaseMonitorCard value, $Res Function(CaseMonitorCard) then) =
      _$CaseMonitorCardCopyWithImpl<$Res, CaseMonitorCard>;
  @useResult
  $Res call(
      {@CaseMonitorCardTypeConverter() CaseMonitorCardType type,
      String? assetId});
}

/// @nodoc
class _$CaseMonitorCardCopyWithImpl<$Res, $Val extends CaseMonitorCard>
    implements $CaseMonitorCardCopyWith<$Res> {
  _$CaseMonitorCardCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? assetId = freezed,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CaseMonitorCardType,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CaseMonitorCardCopyWith<$Res>
    implements $CaseMonitorCardCopyWith<$Res> {
  factory _$$_CaseMonitorCardCopyWith(
          _$_CaseMonitorCard value, $Res Function(_$_CaseMonitorCard) then) =
      __$$_CaseMonitorCardCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@CaseMonitorCardTypeConverter() CaseMonitorCardType type,
      String? assetId});
}

/// @nodoc
class __$$_CaseMonitorCardCopyWithImpl<$Res>
    extends _$CaseMonitorCardCopyWithImpl<$Res, _$_CaseMonitorCard>
    implements _$$_CaseMonitorCardCopyWith<$Res> {
  __$$_CaseMonitorCardCopyWithImpl(
      _$_CaseMonitorCard _value, $Res Function(_$_CaseMonitorCard) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? assetId = freezed,
  }) {
    return _then(_$_CaseMonitorCard(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as CaseMonitorCardType,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_CaseMonitorCard implements _CaseMonitorCard {
  const _$_CaseMonitorCard(
      {@CaseMonitorCardTypeConverter() required this.type, this.assetId});

  factory _$_CaseMonitorCard.fromJson(Map<String, dynamic> json) =>
      _$$_CaseMonitorCardFromJson(json);

  /// Represents the type of the block
  @override
  @CaseMonitorCardTypeConverter()
  final CaseMonitorCardType type;

  /// When [type] is [CaseMonitorCardType.specificAsset], will use [assetId] to apply the filter.
  @override
  final String? assetId;

  @override
  String toString() {
    return 'CaseMonitorCard(type: $type, assetId: $assetId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CaseMonitorCard &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.assetId, assetId) || other.assetId == assetId));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, type, assetId);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CaseMonitorCardCopyWith<_$_CaseMonitorCard> get copyWith =>
      __$$_CaseMonitorCardCopyWithImpl<_$_CaseMonitorCard>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CaseMonitorCardToJson(
      this,
    );
  }
}

abstract class _CaseMonitorCard implements CaseMonitorCard {
  const factory _CaseMonitorCard(
      {@CaseMonitorCardTypeConverter() required final CaseMonitorCardType type,
      final String? assetId}) = _$_CaseMonitorCard;

  factory _CaseMonitorCard.fromJson(Map<String, dynamic> json) =
      _$_CaseMonitorCard.fromJson;

  @override

  /// Represents the type of the block
  @CaseMonitorCardTypeConverter()
  CaseMonitorCardType get type;
  @override

  /// When [type] is [CaseMonitorCardType.specificAsset], will use [assetId] to apply the filter.
  String? get assetId;
  @override
  @JsonKey(ignore: true)
  _$$_CaseMonitorCardCopyWith<_$_CaseMonitorCard> get copyWith =>
      throw _privateConstructorUsedError;
}

VisionProfile _$VisionProfileFromJson(Map<String, dynamic> json) {
  return _VisionProfile.fromJson(json);
}

/// @nodoc
mixin _$VisionProfile {
  /// [id] is the unique identifier of the profile.
  String get id => throw _privateConstructorUsedError;

  /// [name] is the name of the profile.
  String get name => throw _privateConstructorUsedError;

  /// [variant] is the variant of the profile.
  @VisionProfileVariantConverter()
  VisionProfileVariant get variant => throw _privateConstructorUsedError;

  /// [gaugeModel], [gaugeShape], [maskRadius], [threshold], [maxThValue], [minLineLength], [maxLineGap], [maxValue], [minValue], [maxAngle],
  /// [minAngle], [precision], [minRRatio], [maxRRatio] only will comes when [variant] is [VisionProfileVariant.gauge]
  double? get maskRadius => throw _privateConstructorUsedError;
  int? get threshold => throw _privateConstructorUsedError;
  int? get maxThValue => throw _privateConstructorUsedError;
  int? get minLineLength => throw _privateConstructorUsedError;
  int? get maxLineGap => throw _privateConstructorUsedError;
  double? get maxValue => throw _privateConstructorUsedError;
  double? get minValue => throw _privateConstructorUsedError;
  double? get maxAngle => throw _privateConstructorUsedError;
  double? get minAngle => throw _privateConstructorUsedError;
  double? get precision => throw _privateConstructorUsedError;
  double? get minRRatio => throw _privateConstructorUsedError;
  double? get maxRRatio => throw _privateConstructorUsedError;
  double? get centerDisplacement => throw _privateConstructorUsedError;
  int? get decimals => throw _privateConstructorUsedError;
  @VisionProfileGaugeShapeOrNullConverter()
  VisionProfileGaugeShape? get gaugeShape => throw _privateConstructorUsedError;
  @VisionProfileGaugeModelOrNullConverter()
  VisionProfileGaugeModel? get gaugeModel => throw _privateConstructorUsedError;

  /// [access] is the list of grant access to the vision profile.
  List<Access>? get access => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $VisionProfileCopyWith<VisionProfile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $VisionProfileCopyWith<$Res> {
  factory $VisionProfileCopyWith(
          VisionProfile value, $Res Function(VisionProfile) then) =
      _$VisionProfileCopyWithImpl<$Res, VisionProfile>;
  @useResult
  $Res call(
      {String id,
      String name,
      @VisionProfileVariantConverter() VisionProfileVariant variant,
      double? maskRadius,
      int? threshold,
      int? maxThValue,
      int? minLineLength,
      int? maxLineGap,
      double? maxValue,
      double? minValue,
      double? maxAngle,
      double? minAngle,
      double? precision,
      double? minRRatio,
      double? maxRRatio,
      double? centerDisplacement,
      int? decimals,
      @VisionProfileGaugeShapeOrNullConverter()
      VisionProfileGaugeShape? gaugeShape,
      @VisionProfileGaugeModelOrNullConverter()
      VisionProfileGaugeModel? gaugeModel,
      List<Access>? access});
}

/// @nodoc
class _$VisionProfileCopyWithImpl<$Res, $Val extends VisionProfile>
    implements $VisionProfileCopyWith<$Res> {
  _$VisionProfileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? variant = null,
    Object? maskRadius = freezed,
    Object? threshold = freezed,
    Object? maxThValue = freezed,
    Object? minLineLength = freezed,
    Object? maxLineGap = freezed,
    Object? maxValue = freezed,
    Object? minValue = freezed,
    Object? maxAngle = freezed,
    Object? minAngle = freezed,
    Object? precision = freezed,
    Object? minRRatio = freezed,
    Object? maxRRatio = freezed,
    Object? centerDisplacement = freezed,
    Object? decimals = freezed,
    Object? gaugeShape = freezed,
    Object? gaugeModel = freezed,
    Object? access = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      variant: null == variant
          ? _value.variant
          : variant // ignore: cast_nullable_to_non_nullable
              as VisionProfileVariant,
      maskRadius: freezed == maskRadius
          ? _value.maskRadius
          : maskRadius // ignore: cast_nullable_to_non_nullable
              as double?,
      threshold: freezed == threshold
          ? _value.threshold
          : threshold // ignore: cast_nullable_to_non_nullable
              as int?,
      maxThValue: freezed == maxThValue
          ? _value.maxThValue
          : maxThValue // ignore: cast_nullable_to_non_nullable
              as int?,
      minLineLength: freezed == minLineLength
          ? _value.minLineLength
          : minLineLength // ignore: cast_nullable_to_non_nullable
              as int?,
      maxLineGap: freezed == maxLineGap
          ? _value.maxLineGap
          : maxLineGap // ignore: cast_nullable_to_non_nullable
              as int?,
      maxValue: freezed == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      minValue: freezed == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxAngle: freezed == maxAngle
          ? _value.maxAngle
          : maxAngle // ignore: cast_nullable_to_non_nullable
              as double?,
      minAngle: freezed == minAngle
          ? _value.minAngle
          : minAngle // ignore: cast_nullable_to_non_nullable
              as double?,
      precision: freezed == precision
          ? _value.precision
          : precision // ignore: cast_nullable_to_non_nullable
              as double?,
      minRRatio: freezed == minRRatio
          ? _value.minRRatio
          : minRRatio // ignore: cast_nullable_to_non_nullable
              as double?,
      maxRRatio: freezed == maxRRatio
          ? _value.maxRRatio
          : maxRRatio // ignore: cast_nullable_to_non_nullable
              as double?,
      centerDisplacement: freezed == centerDisplacement
          ? _value.centerDisplacement
          : centerDisplacement // ignore: cast_nullable_to_non_nullable
              as double?,
      decimals: freezed == decimals
          ? _value.decimals
          : decimals // ignore: cast_nullable_to_non_nullable
              as int?,
      gaugeShape: freezed == gaugeShape
          ? _value.gaugeShape
          : gaugeShape // ignore: cast_nullable_to_non_nullable
              as VisionProfileGaugeShape?,
      gaugeModel: freezed == gaugeModel
          ? _value.gaugeModel
          : gaugeModel // ignore: cast_nullable_to_non_nullable
              as VisionProfileGaugeModel?,
      access: freezed == access
          ? _value.access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_VisionProfileCopyWith<$Res>
    implements $VisionProfileCopyWith<$Res> {
  factory _$$_VisionProfileCopyWith(
          _$_VisionProfile value, $Res Function(_$_VisionProfile) then) =
      __$$_VisionProfileCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @VisionProfileVariantConverter() VisionProfileVariant variant,
      double? maskRadius,
      int? threshold,
      int? maxThValue,
      int? minLineLength,
      int? maxLineGap,
      double? maxValue,
      double? minValue,
      double? maxAngle,
      double? minAngle,
      double? precision,
      double? minRRatio,
      double? maxRRatio,
      double? centerDisplacement,
      int? decimals,
      @VisionProfileGaugeShapeOrNullConverter()
      VisionProfileGaugeShape? gaugeShape,
      @VisionProfileGaugeModelOrNullConverter()
      VisionProfileGaugeModel? gaugeModel,
      List<Access>? access});
}

/// @nodoc
class __$$_VisionProfileCopyWithImpl<$Res>
    extends _$VisionProfileCopyWithImpl<$Res, _$_VisionProfile>
    implements _$$_VisionProfileCopyWith<$Res> {
  __$$_VisionProfileCopyWithImpl(
      _$_VisionProfile _value, $Res Function(_$_VisionProfile) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? variant = null,
    Object? maskRadius = freezed,
    Object? threshold = freezed,
    Object? maxThValue = freezed,
    Object? minLineLength = freezed,
    Object? maxLineGap = freezed,
    Object? maxValue = freezed,
    Object? minValue = freezed,
    Object? maxAngle = freezed,
    Object? minAngle = freezed,
    Object? precision = freezed,
    Object? minRRatio = freezed,
    Object? maxRRatio = freezed,
    Object? centerDisplacement = freezed,
    Object? decimals = freezed,
    Object? gaugeShape = freezed,
    Object? gaugeModel = freezed,
    Object? access = freezed,
  }) {
    return _then(_$_VisionProfile(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      variant: null == variant
          ? _value.variant
          : variant // ignore: cast_nullable_to_non_nullable
              as VisionProfileVariant,
      maskRadius: freezed == maskRadius
          ? _value.maskRadius
          : maskRadius // ignore: cast_nullable_to_non_nullable
              as double?,
      threshold: freezed == threshold
          ? _value.threshold
          : threshold // ignore: cast_nullable_to_non_nullable
              as int?,
      maxThValue: freezed == maxThValue
          ? _value.maxThValue
          : maxThValue // ignore: cast_nullable_to_non_nullable
              as int?,
      minLineLength: freezed == minLineLength
          ? _value.minLineLength
          : minLineLength // ignore: cast_nullable_to_non_nullable
              as int?,
      maxLineGap: freezed == maxLineGap
          ? _value.maxLineGap
          : maxLineGap // ignore: cast_nullable_to_non_nullable
              as int?,
      maxValue: freezed == maxValue
          ? _value.maxValue
          : maxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      minValue: freezed == minValue
          ? _value.minValue
          : minValue // ignore: cast_nullable_to_non_nullable
              as double?,
      maxAngle: freezed == maxAngle
          ? _value.maxAngle
          : maxAngle // ignore: cast_nullable_to_non_nullable
              as double?,
      minAngle: freezed == minAngle
          ? _value.minAngle
          : minAngle // ignore: cast_nullable_to_non_nullable
              as double?,
      precision: freezed == precision
          ? _value.precision
          : precision // ignore: cast_nullable_to_non_nullable
              as double?,
      minRRatio: freezed == minRRatio
          ? _value.minRRatio
          : minRRatio // ignore: cast_nullable_to_non_nullable
              as double?,
      maxRRatio: freezed == maxRRatio
          ? _value.maxRRatio
          : maxRRatio // ignore: cast_nullable_to_non_nullable
              as double?,
      centerDisplacement: freezed == centerDisplacement
          ? _value.centerDisplacement
          : centerDisplacement // ignore: cast_nullable_to_non_nullable
              as double?,
      decimals: freezed == decimals
          ? _value.decimals
          : decimals // ignore: cast_nullable_to_non_nullable
              as int?,
      gaugeShape: freezed == gaugeShape
          ? _value.gaugeShape
          : gaugeShape // ignore: cast_nullable_to_non_nullable
              as VisionProfileGaugeShape?,
      gaugeModel: freezed == gaugeModel
          ? _value.gaugeModel
          : gaugeModel // ignore: cast_nullable_to_non_nullable
              as VisionProfileGaugeModel?,
      access: freezed == access
          ? _value._access
          : access // ignore: cast_nullable_to_non_nullable
              as List<Access>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_VisionProfile implements _VisionProfile {
  const _$_VisionProfile(
      {required this.id,
      required this.name,
      @VisionProfileVariantConverter() required this.variant,
      this.maskRadius,
      this.threshold,
      this.maxThValue,
      this.minLineLength,
      this.maxLineGap,
      this.maxValue,
      this.minValue,
      this.maxAngle,
      this.minAngle,
      this.precision,
      this.minRRatio,
      this.maxRRatio,
      this.centerDisplacement,
      this.decimals,
      @VisionProfileGaugeShapeOrNullConverter() this.gaugeShape,
      @VisionProfileGaugeModelOrNullConverter() this.gaugeModel,
      final List<Access>? access})
      : _access = access;

  factory _$_VisionProfile.fromJson(Map<String, dynamic> json) =>
      _$$_VisionProfileFromJson(json);

  /// [id] is the unique identifier of the profile.
  @override
  final String id;

  /// [name] is the name of the profile.
  @override
  final String name;

  /// [variant] is the variant of the profile.
  @override
  @VisionProfileVariantConverter()
  final VisionProfileVariant variant;

  /// [gaugeModel], [gaugeShape], [maskRadius], [threshold], [maxThValue], [minLineLength], [maxLineGap], [maxValue], [minValue], [maxAngle],
  /// [minAngle], [precision], [minRRatio], [maxRRatio] only will comes when [variant] is [VisionProfileVariant.gauge]
  @override
  final double? maskRadius;
  @override
  final int? threshold;
  @override
  final int? maxThValue;
  @override
  final int? minLineLength;
  @override
  final int? maxLineGap;
  @override
  final double? maxValue;
  @override
  final double? minValue;
  @override
  final double? maxAngle;
  @override
  final double? minAngle;
  @override
  final double? precision;
  @override
  final double? minRRatio;
  @override
  final double? maxRRatio;
  @override
  final double? centerDisplacement;
  @override
  final int? decimals;
  @override
  @VisionProfileGaugeShapeOrNullConverter()
  final VisionProfileGaugeShape? gaugeShape;
  @override
  @VisionProfileGaugeModelOrNullConverter()
  final VisionProfileGaugeModel? gaugeModel;

  /// [access] is the list of grant access to the vision profile.
  final List<Access>? _access;

  /// [access] is the list of grant access to the vision profile.
  @override
  List<Access>? get access {
    final value = _access;
    if (value == null) return null;
    if (_access is EqualUnmodifiableListView) return _access;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'VisionProfile(id: $id, name: $name, variant: $variant, maskRadius: $maskRadius, threshold: $threshold, maxThValue: $maxThValue, minLineLength: $minLineLength, maxLineGap: $maxLineGap, maxValue: $maxValue, minValue: $minValue, maxAngle: $maxAngle, minAngle: $minAngle, precision: $precision, minRRatio: $minRRatio, maxRRatio: $maxRRatio, centerDisplacement: $centerDisplacement, decimals: $decimals, gaugeShape: $gaugeShape, gaugeModel: $gaugeModel, access: $access)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_VisionProfile &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.variant, variant) || other.variant == variant) &&
            (identical(other.maskRadius, maskRadius) ||
                other.maskRadius == maskRadius) &&
            (identical(other.threshold, threshold) ||
                other.threshold == threshold) &&
            (identical(other.maxThValue, maxThValue) ||
                other.maxThValue == maxThValue) &&
            (identical(other.minLineLength, minLineLength) ||
                other.minLineLength == minLineLength) &&
            (identical(other.maxLineGap, maxLineGap) ||
                other.maxLineGap == maxLineGap) &&
            (identical(other.maxValue, maxValue) ||
                other.maxValue == maxValue) &&
            (identical(other.minValue, minValue) ||
                other.minValue == minValue) &&
            (identical(other.maxAngle, maxAngle) ||
                other.maxAngle == maxAngle) &&
            (identical(other.minAngle, minAngle) ||
                other.minAngle == minAngle) &&
            (identical(other.precision, precision) ||
                other.precision == precision) &&
            (identical(other.minRRatio, minRRatio) ||
                other.minRRatio == minRRatio) &&
            (identical(other.maxRRatio, maxRRatio) ||
                other.maxRRatio == maxRRatio) &&
            (identical(other.centerDisplacement, centerDisplacement) ||
                other.centerDisplacement == centerDisplacement) &&
            (identical(other.decimals, decimals) ||
                other.decimals == decimals) &&
            (identical(other.gaugeShape, gaugeShape) ||
                other.gaugeShape == gaugeShape) &&
            (identical(other.gaugeModel, gaugeModel) ||
                other.gaugeModel == gaugeModel) &&
            const DeepCollectionEquality().equals(other._access, _access));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        variant,
        maskRadius,
        threshold,
        maxThValue,
        minLineLength,
        maxLineGap,
        maxValue,
        minValue,
        maxAngle,
        minAngle,
        precision,
        minRRatio,
        maxRRatio,
        centerDisplacement,
        decimals,
        gaugeShape,
        gaugeModel,
        const DeepCollectionEquality().hash(_access)
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_VisionProfileCopyWith<_$_VisionProfile> get copyWith =>
      __$$_VisionProfileCopyWithImpl<_$_VisionProfile>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_VisionProfileToJson(
      this,
    );
  }
}

abstract class _VisionProfile implements VisionProfile {
  const factory _VisionProfile(
      {required final String id,
      required final String name,
      @VisionProfileVariantConverter()
      required final VisionProfileVariant variant,
      final double? maskRadius,
      final int? threshold,
      final int? maxThValue,
      final int? minLineLength,
      final int? maxLineGap,
      final double? maxValue,
      final double? minValue,
      final double? maxAngle,
      final double? minAngle,
      final double? precision,
      final double? minRRatio,
      final double? maxRRatio,
      final double? centerDisplacement,
      final int? decimals,
      @VisionProfileGaugeShapeOrNullConverter()
      final VisionProfileGaugeShape? gaugeShape,
      @VisionProfileGaugeModelOrNullConverter()
      final VisionProfileGaugeModel? gaugeModel,
      final List<Access>? access}) = _$_VisionProfile;

  factory _VisionProfile.fromJson(Map<String, dynamic> json) =
      _$_VisionProfile.fromJson;

  @override

  /// [id] is the unique identifier of the profile.
  String get id;
  @override

  /// [name] is the name of the profile.
  String get name;
  @override

  /// [variant] is the variant of the profile.
  @VisionProfileVariantConverter()
  VisionProfileVariant get variant;
  @override

  /// [gaugeModel], [gaugeShape], [maskRadius], [threshold], [maxThValue], [minLineLength], [maxLineGap], [maxValue], [minValue], [maxAngle],
  /// [minAngle], [precision], [minRRatio], [maxRRatio] only will comes when [variant] is [VisionProfileVariant.gauge]
  double? get maskRadius;
  @override
  int? get threshold;
  @override
  int? get maxThValue;
  @override
  int? get minLineLength;
  @override
  int? get maxLineGap;
  @override
  double? get maxValue;
  @override
  double? get minValue;
  @override
  double? get maxAngle;
  @override
  double? get minAngle;
  @override
  double? get precision;
  @override
  double? get minRRatio;
  @override
  double? get maxRRatio;
  @override
  double? get centerDisplacement;
  @override
  int? get decimals;
  @override
  @VisionProfileGaugeShapeOrNullConverter()
  VisionProfileGaugeShape? get gaugeShape;
  @override
  @VisionProfileGaugeModelOrNullConverter()
  VisionProfileGaugeModel? get gaugeModel;
  @override

  /// [access] is the list of grant access to the vision profile.
  List<Access>? get access;
  @override
  @JsonKey(ignore: true)
  _$$_VisionProfileCopyWith<_$_VisionProfile> get copyWith =>
      throw _privateConstructorUsedError;
}

AppAccessibility _$AppAccessibilityFromJson(Map<String, dynamic> json) {
  return _AppAccessibility.fromJson(json);
}

/// @nodoc
mixin _$AppAccessibility {
  String get host => throw _privateConstructorUsedError;
  bool get isDeployed => throw _privateConstructorUsedError;
  bool get isSuspended => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppAccessibilityCopyWith<AppAccessibility> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppAccessibilityCopyWith<$Res> {
  factory $AppAccessibilityCopyWith(
          AppAccessibility value, $Res Function(AppAccessibility) then) =
      _$AppAccessibilityCopyWithImpl<$Res, AppAccessibility>;
  @useResult
  $Res call({String host, bool isDeployed, bool isSuspended});
}

/// @nodoc
class _$AppAccessibilityCopyWithImpl<$Res, $Val extends AppAccessibility>
    implements $AppAccessibilityCopyWith<$Res> {
  _$AppAccessibilityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? host = null,
    Object? isDeployed = null,
    Object? isSuspended = null,
  }) {
    return _then(_value.copyWith(
      host: null == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String,
      isDeployed: null == isDeployed
          ? _value.isDeployed
          : isDeployed // ignore: cast_nullable_to_non_nullable
              as bool,
      isSuspended: null == isSuspended
          ? _value.isSuspended
          : isSuspended // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppAccessibilityCopyWith<$Res>
    implements $AppAccessibilityCopyWith<$Res> {
  factory _$$_AppAccessibilityCopyWith(
          _$_AppAccessibility value, $Res Function(_$_AppAccessibility) then) =
      __$$_AppAccessibilityCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String host, bool isDeployed, bool isSuspended});
}

/// @nodoc
class __$$_AppAccessibilityCopyWithImpl<$Res>
    extends _$AppAccessibilityCopyWithImpl<$Res, _$_AppAccessibility>
    implements _$$_AppAccessibilityCopyWith<$Res> {
  __$$_AppAccessibilityCopyWithImpl(
      _$_AppAccessibility _value, $Res Function(_$_AppAccessibility) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? host = null,
    Object? isDeployed = null,
    Object? isSuspended = null,
  }) {
    return _then(_$_AppAccessibility(
      host: null == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String,
      isDeployed: null == isDeployed
          ? _value.isDeployed
          : isDeployed // ignore: cast_nullable_to_non_nullable
              as bool,
      isSuspended: null == isSuspended
          ? _value.isSuspended
          : isSuspended // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppAccessibility implements _AppAccessibility {
  const _$_AppAccessibility(
      {required this.host,
      required this.isDeployed,
      required this.isSuspended});

  factory _$_AppAccessibility.fromJson(Map<String, dynamic> json) =>
      _$$_AppAccessibilityFromJson(json);

  @override
  final String host;
  @override
  final bool isDeployed;
  @override
  final bool isSuspended;

  @override
  String toString() {
    return 'AppAccessibility(host: $host, isDeployed: $isDeployed, isSuspended: $isSuspended)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppAccessibility &&
            (identical(other.host, host) || other.host == host) &&
            (identical(other.isDeployed, isDeployed) ||
                other.isDeployed == isDeployed) &&
            (identical(other.isSuspended, isSuspended) ||
                other.isSuspended == isSuspended));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, host, isDeployed, isSuspended);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppAccessibilityCopyWith<_$_AppAccessibility> get copyWith =>
      __$$_AppAccessibilityCopyWithImpl<_$_AppAccessibility>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppAccessibilityToJson(
      this,
    );
  }
}

abstract class _AppAccessibility implements AppAccessibility {
  const factory _AppAccessibility(
      {required final String host,
      required final bool isDeployed,
      required final bool isSuspended}) = _$_AppAccessibility;

  factory _AppAccessibility.fromJson(Map<String, dynamic> json) =
      _$_AppAccessibility.fromJson;

  @override
  String get host;
  @override
  bool get isDeployed;
  @override
  bool get isSuspended;
  @override
  @JsonKey(ignore: true)
  _$$_AppAccessibilityCopyWith<_$_AppAccessibility> get copyWith =>
      throw _privateConstructorUsedError;
}

AvailableApp _$AvailableAppFromJson(Map<String, dynamic> json) {
  return _AvailableApp.fromJson(json);
}

/// @nodoc
mixin _$AvailableApp {
  /// [id] is the unique identifier of the app.
  String get id => throw _privateConstructorUsedError;

  /// [name] is the name of the app. It's a fixed name, not a translation key
  String get name => throw _privateConstructorUsedError;

  /// [appId] is the unique identifier of the app, like "com.layrz.launchpad".
  String get appId => throw _privateConstructorUsedError;

  /// [appType] is the type of the app.
  @AppTypeConverter()
  AppType get appType => throw _privateConstructorUsedError;

  /// [technology] is the technology of the app.
  @AppTechnologyConverter()
  AppTechnology get technology => throw _privateConstructorUsedError;

  /// [legalInformation] is the legal information of the app.
  AppLegal? get legalInformation => throw _privateConstructorUsedError;

  /// [designInformation] is the design information of the app.
  AppDesign? get designInformation => throw _privateConstructorUsedError;

  /// [supportedPlatforms] is the list of supported platforms of the App, depends of the technology.
  @AppPlatformConverter()
  List<AppPlatform>? get supportedPlatforms =>
      throw _privateConstructorUsedError;

  /// [onlyCustomized] is true if the app only can be register with customization.
  bool get onlyCustomized => throw _privateConstructorUsedError;

  ///[hasImport] is true if the app has import feature.
  bool? get hasImport => throw _privateConstructorUsedError;

  /// [hasKeychain] is true if the app has keychain feature.
  bool? get hasKeychain => throw _privateConstructorUsedError;

  /// [serverFolder] is the server folder of the app.
  String? get serverFolder => throw _privateConstructorUsedError;

  /// [s3Folder] is the s3 folder of the app.
  String? get s3Folder => throw _privateConstructorUsedError;

  /// [canMapLayers] is true if the app can have more than the default map layer.
  bool? get canMapLayers => throw _privateConstructorUsedError;

  /// [versions] is the list of versions of the app.
  List<AppVersion>? get versions => throw _privateConstructorUsedError;

  /// [implementations] is the list of implementations of the app.
  List<RegisteredApp>? get implementations =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AvailableAppCopyWith<AvailableApp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AvailableAppCopyWith<$Res> {
  factory $AvailableAppCopyWith(
          AvailableApp value, $Res Function(AvailableApp) then) =
      _$AvailableAppCopyWithImpl<$Res, AvailableApp>;
  @useResult
  $Res call(
      {String id,
      String name,
      String appId,
      @AppTypeConverter() AppType appType,
      @AppTechnologyConverter() AppTechnology technology,
      AppLegal? legalInformation,
      AppDesign? designInformation,
      @AppPlatformConverter() List<AppPlatform>? supportedPlatforms,
      bool onlyCustomized,
      bool? hasImport,
      bool? hasKeychain,
      String? serverFolder,
      String? s3Folder,
      bool? canMapLayers,
      List<AppVersion>? versions,
      List<RegisteredApp>? implementations});

  $AppLegalCopyWith<$Res>? get legalInformation;
  $AppDesignCopyWith<$Res>? get designInformation;
}

/// @nodoc
class _$AvailableAppCopyWithImpl<$Res, $Val extends AvailableApp>
    implements $AvailableAppCopyWith<$Res> {
  _$AvailableAppCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? appId = null,
    Object? appType = null,
    Object? technology = null,
    Object? legalInformation = freezed,
    Object? designInformation = freezed,
    Object? supportedPlatforms = freezed,
    Object? onlyCustomized = null,
    Object? hasImport = freezed,
    Object? hasKeychain = freezed,
    Object? serverFolder = freezed,
    Object? s3Folder = freezed,
    Object? canMapLayers = freezed,
    Object? versions = freezed,
    Object? implementations = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      appId: null == appId
          ? _value.appId
          : appId // ignore: cast_nullable_to_non_nullable
              as String,
      appType: null == appType
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as AppType,
      technology: null == technology
          ? _value.technology
          : technology // ignore: cast_nullable_to_non_nullable
              as AppTechnology,
      legalInformation: freezed == legalInformation
          ? _value.legalInformation
          : legalInformation // ignore: cast_nullable_to_non_nullable
              as AppLegal?,
      designInformation: freezed == designInformation
          ? _value.designInformation
          : designInformation // ignore: cast_nullable_to_non_nullable
              as AppDesign?,
      supportedPlatforms: freezed == supportedPlatforms
          ? _value.supportedPlatforms
          : supportedPlatforms // ignore: cast_nullable_to_non_nullable
              as List<AppPlatform>?,
      onlyCustomized: null == onlyCustomized
          ? _value.onlyCustomized
          : onlyCustomized // ignore: cast_nullable_to_non_nullable
              as bool,
      hasImport: freezed == hasImport
          ? _value.hasImport
          : hasImport // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasKeychain: freezed == hasKeychain
          ? _value.hasKeychain
          : hasKeychain // ignore: cast_nullable_to_non_nullable
              as bool?,
      serverFolder: freezed == serverFolder
          ? _value.serverFolder
          : serverFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      s3Folder: freezed == s3Folder
          ? _value.s3Folder
          : s3Folder // ignore: cast_nullable_to_non_nullable
              as String?,
      canMapLayers: freezed == canMapLayers
          ? _value.canMapLayers
          : canMapLayers // ignore: cast_nullable_to_non_nullable
              as bool?,
      versions: freezed == versions
          ? _value.versions
          : versions // ignore: cast_nullable_to_non_nullable
              as List<AppVersion>?,
      implementations: freezed == implementations
          ? _value.implementations
          : implementations // ignore: cast_nullable_to_non_nullable
              as List<RegisteredApp>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AppLegalCopyWith<$Res>? get legalInformation {
    if (_value.legalInformation == null) {
      return null;
    }

    return $AppLegalCopyWith<$Res>(_value.legalInformation!, (value) {
      return _then(_value.copyWith(legalInformation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppDesignCopyWith<$Res>? get designInformation {
    if (_value.designInformation == null) {
      return null;
    }

    return $AppDesignCopyWith<$Res>(_value.designInformation!, (value) {
      return _then(_value.copyWith(designInformation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AvailableAppCopyWith<$Res>
    implements $AvailableAppCopyWith<$Res> {
  factory _$$_AvailableAppCopyWith(
          _$_AvailableApp value, $Res Function(_$_AvailableApp) then) =
      __$$_AvailableAppCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String appId,
      @AppTypeConverter() AppType appType,
      @AppTechnologyConverter() AppTechnology technology,
      AppLegal? legalInformation,
      AppDesign? designInformation,
      @AppPlatformConverter() List<AppPlatform>? supportedPlatforms,
      bool onlyCustomized,
      bool? hasImport,
      bool? hasKeychain,
      String? serverFolder,
      String? s3Folder,
      bool? canMapLayers,
      List<AppVersion>? versions,
      List<RegisteredApp>? implementations});

  @override
  $AppLegalCopyWith<$Res>? get legalInformation;
  @override
  $AppDesignCopyWith<$Res>? get designInformation;
}

/// @nodoc
class __$$_AvailableAppCopyWithImpl<$Res>
    extends _$AvailableAppCopyWithImpl<$Res, _$_AvailableApp>
    implements _$$_AvailableAppCopyWith<$Res> {
  __$$_AvailableAppCopyWithImpl(
      _$_AvailableApp _value, $Res Function(_$_AvailableApp) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? appId = null,
    Object? appType = null,
    Object? technology = null,
    Object? legalInformation = freezed,
    Object? designInformation = freezed,
    Object? supportedPlatforms = freezed,
    Object? onlyCustomized = null,
    Object? hasImport = freezed,
    Object? hasKeychain = freezed,
    Object? serverFolder = freezed,
    Object? s3Folder = freezed,
    Object? canMapLayers = freezed,
    Object? versions = freezed,
    Object? implementations = freezed,
  }) {
    return _then(_$_AvailableApp(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      appId: null == appId
          ? _value.appId
          : appId // ignore: cast_nullable_to_non_nullable
              as String,
      appType: null == appType
          ? _value.appType
          : appType // ignore: cast_nullable_to_non_nullable
              as AppType,
      technology: null == technology
          ? _value.technology
          : technology // ignore: cast_nullable_to_non_nullable
              as AppTechnology,
      legalInformation: freezed == legalInformation
          ? _value.legalInformation
          : legalInformation // ignore: cast_nullable_to_non_nullable
              as AppLegal?,
      designInformation: freezed == designInformation
          ? _value.designInformation
          : designInformation // ignore: cast_nullable_to_non_nullable
              as AppDesign?,
      supportedPlatforms: freezed == supportedPlatforms
          ? _value._supportedPlatforms
          : supportedPlatforms // ignore: cast_nullable_to_non_nullable
              as List<AppPlatform>?,
      onlyCustomized: null == onlyCustomized
          ? _value.onlyCustomized
          : onlyCustomized // ignore: cast_nullable_to_non_nullable
              as bool,
      hasImport: freezed == hasImport
          ? _value.hasImport
          : hasImport // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasKeychain: freezed == hasKeychain
          ? _value.hasKeychain
          : hasKeychain // ignore: cast_nullable_to_non_nullable
              as bool?,
      serverFolder: freezed == serverFolder
          ? _value.serverFolder
          : serverFolder // ignore: cast_nullable_to_non_nullable
              as String?,
      s3Folder: freezed == s3Folder
          ? _value.s3Folder
          : s3Folder // ignore: cast_nullable_to_non_nullable
              as String?,
      canMapLayers: freezed == canMapLayers
          ? _value.canMapLayers
          : canMapLayers // ignore: cast_nullable_to_non_nullable
              as bool?,
      versions: freezed == versions
          ? _value._versions
          : versions // ignore: cast_nullable_to_non_nullable
              as List<AppVersion>?,
      implementations: freezed == implementations
          ? _value._implementations
          : implementations // ignore: cast_nullable_to_non_nullable
              as List<RegisteredApp>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AvailableApp implements _AvailableApp {
  const _$_AvailableApp(
      {required this.id,
      required this.name,
      required this.appId,
      @AppTypeConverter() required this.appType,
      @AppTechnologyConverter() required this.technology,
      this.legalInformation,
      this.designInformation,
      @AppPlatformConverter() final List<AppPlatform>? supportedPlatforms,
      required this.onlyCustomized,
      this.hasImport,
      this.hasKeychain,
      this.serverFolder,
      this.s3Folder,
      this.canMapLayers,
      final List<AppVersion>? versions,
      final List<RegisteredApp>? implementations})
      : _supportedPlatforms = supportedPlatforms,
        _versions = versions,
        _implementations = implementations;

  factory _$_AvailableApp.fromJson(Map<String, dynamic> json) =>
      _$$_AvailableAppFromJson(json);

  /// [id] is the unique identifier of the app.
  @override
  final String id;

  /// [name] is the name of the app. It's a fixed name, not a translation key
  @override
  final String name;

  /// [appId] is the unique identifier of the app, like "com.layrz.launchpad".
  @override
  final String appId;

  /// [appType] is the type of the app.
  @override
  @AppTypeConverter()
  final AppType appType;

  /// [technology] is the technology of the app.
  @override
  @AppTechnologyConverter()
  final AppTechnology technology;

  /// [legalInformation] is the legal information of the app.
  @override
  final AppLegal? legalInformation;

  /// [designInformation] is the design information of the app.
  @override
  final AppDesign? designInformation;

  /// [supportedPlatforms] is the list of supported platforms of the App, depends of the technology.
  final List<AppPlatform>? _supportedPlatforms;

  /// [supportedPlatforms] is the list of supported platforms of the App, depends of the technology.
  @override
  @AppPlatformConverter()
  List<AppPlatform>? get supportedPlatforms {
    final value = _supportedPlatforms;
    if (value == null) return null;
    if (_supportedPlatforms is EqualUnmodifiableListView)
      return _supportedPlatforms;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [onlyCustomized] is true if the app only can be register with customization.
  @override
  final bool onlyCustomized;

  ///[hasImport] is true if the app has import feature.
  @override
  final bool? hasImport;

  /// [hasKeychain] is true if the app has keychain feature.
  @override
  final bool? hasKeychain;

  /// [serverFolder] is the server folder of the app.
  @override
  final String? serverFolder;

  /// [s3Folder] is the s3 folder of the app.
  @override
  final String? s3Folder;

  /// [canMapLayers] is true if the app can have more than the default map layer.
  @override
  final bool? canMapLayers;

  /// [versions] is the list of versions of the app.
  final List<AppVersion>? _versions;

  /// [versions] is the list of versions of the app.
  @override
  List<AppVersion>? get versions {
    final value = _versions;
    if (value == null) return null;
    if (_versions is EqualUnmodifiableListView) return _versions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [implementations] is the list of implementations of the app.
  final List<RegisteredApp>? _implementations;

  /// [implementations] is the list of implementations of the app.
  @override
  List<RegisteredApp>? get implementations {
    final value = _implementations;
    if (value == null) return null;
    if (_implementations is EqualUnmodifiableListView) return _implementations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AvailableApp(id: $id, name: $name, appId: $appId, appType: $appType, technology: $technology, legalInformation: $legalInformation, designInformation: $designInformation, supportedPlatforms: $supportedPlatforms, onlyCustomized: $onlyCustomized, hasImport: $hasImport, hasKeychain: $hasKeychain, serverFolder: $serverFolder, s3Folder: $s3Folder, canMapLayers: $canMapLayers, versions: $versions, implementations: $implementations)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AvailableApp &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.appId, appId) || other.appId == appId) &&
            (identical(other.appType, appType) || other.appType == appType) &&
            (identical(other.technology, technology) ||
                other.technology == technology) &&
            (identical(other.legalInformation, legalInformation) ||
                other.legalInformation == legalInformation) &&
            (identical(other.designInformation, designInformation) ||
                other.designInformation == designInformation) &&
            const DeepCollectionEquality()
                .equals(other._supportedPlatforms, _supportedPlatforms) &&
            (identical(other.onlyCustomized, onlyCustomized) ||
                other.onlyCustomized == onlyCustomized) &&
            (identical(other.hasImport, hasImport) ||
                other.hasImport == hasImport) &&
            (identical(other.hasKeychain, hasKeychain) ||
                other.hasKeychain == hasKeychain) &&
            (identical(other.serverFolder, serverFolder) ||
                other.serverFolder == serverFolder) &&
            (identical(other.s3Folder, s3Folder) ||
                other.s3Folder == s3Folder) &&
            (identical(other.canMapLayers, canMapLayers) ||
                other.canMapLayers == canMapLayers) &&
            const DeepCollectionEquality().equals(other._versions, _versions) &&
            const DeepCollectionEquality()
                .equals(other._implementations, _implementations));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      appId,
      appType,
      technology,
      legalInformation,
      designInformation,
      const DeepCollectionEquality().hash(_supportedPlatforms),
      onlyCustomized,
      hasImport,
      hasKeychain,
      serverFolder,
      s3Folder,
      canMapLayers,
      const DeepCollectionEquality().hash(_versions),
      const DeepCollectionEquality().hash(_implementations));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AvailableAppCopyWith<_$_AvailableApp> get copyWith =>
      __$$_AvailableAppCopyWithImpl<_$_AvailableApp>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AvailableAppToJson(
      this,
    );
  }
}

abstract class _AvailableApp implements AvailableApp {
  const factory _AvailableApp(
      {required final String id,
      required final String name,
      required final String appId,
      @AppTypeConverter() required final AppType appType,
      @AppTechnologyConverter() required final AppTechnology technology,
      final AppLegal? legalInformation,
      final AppDesign? designInformation,
      @AppPlatformConverter() final List<AppPlatform>? supportedPlatforms,
      required final bool onlyCustomized,
      final bool? hasImport,
      final bool? hasKeychain,
      final String? serverFolder,
      final String? s3Folder,
      final bool? canMapLayers,
      final List<AppVersion>? versions,
      final List<RegisteredApp>? implementations}) = _$_AvailableApp;

  factory _AvailableApp.fromJson(Map<String, dynamic> json) =
      _$_AvailableApp.fromJson;

  @override

  /// [id] is the unique identifier of the app.
  String get id;
  @override

  /// [name] is the name of the app. It's a fixed name, not a translation key
  String get name;
  @override

  /// [appId] is the unique identifier of the app, like "com.layrz.launchpad".
  String get appId;
  @override

  /// [appType] is the type of the app.
  @AppTypeConverter()
  AppType get appType;
  @override

  /// [technology] is the technology of the app.
  @AppTechnologyConverter()
  AppTechnology get technology;
  @override

  /// [legalInformation] is the legal information of the app.
  AppLegal? get legalInformation;
  @override

  /// [designInformation] is the design information of the app.
  AppDesign? get designInformation;
  @override

  /// [supportedPlatforms] is the list of supported platforms of the App, depends of the technology.
  @AppPlatformConverter()
  List<AppPlatform>? get supportedPlatforms;
  @override

  /// [onlyCustomized] is true if the app only can be register with customization.
  bool get onlyCustomized;
  @override

  ///[hasImport] is true if the app has import feature.
  bool? get hasImport;
  @override

  /// [hasKeychain] is true if the app has keychain feature.
  bool? get hasKeychain;
  @override

  /// [serverFolder] is the server folder of the app.
  String? get serverFolder;
  @override

  /// [s3Folder] is the s3 folder of the app.
  String? get s3Folder;
  @override

  /// [canMapLayers] is true if the app can have more than the default map layer.
  bool? get canMapLayers;
  @override

  /// [versions] is the list of versions of the app.
  List<AppVersion>? get versions;
  @override

  /// [implementations] is the list of implementations of the app.
  List<RegisteredApp>? get implementations;
  @override
  @JsonKey(ignore: true)
  _$$_AvailableAppCopyWith<_$_AvailableApp> get copyWith =>
      throw _privateConstructorUsedError;
}

RegisteredApp _$RegisteredAppFromJson(Map<String, dynamic> json) {
  return _RegisteredApp.fromJson(json);
}

/// @nodoc
mixin _$RegisteredApp {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get nickname => throw _privateConstructorUsedError;
  @AppTechnologyConverter()
  AppTechnology get technology => throw _privateConstructorUsedError;
  AppLegal? get legalInformation => throw _privateConstructorUsedError;
  AppDesign? get designInformation => throw _privateConstructorUsedError;
  bool? get isCustomized => throw _privateConstructorUsedError;
  List<AppInstance>? get instances => throw _privateConstructorUsedError;
  List<Asset>? get importedAssets => throw _privateConstructorUsedError;
  List<Device>? get importedDevices => throw _privateConstructorUsedError;
  List<User>? get importedUsers => throw _privateConstructorUsedError;
  List<User>? get keychain => throw _privateConstructorUsedError;
  String get sourceId => throw _privateConstructorUsedError;

  /// [mapLayers] is the list of map layers of the app.
  List<MapLayer> get mapLayers => throw _privateConstructorUsedError;

  /// [owner] is the owner of the app.
  /// !Important: This field is only available when the query is from `/goldenm/graphql`
  User? get owner => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RegisteredAppCopyWith<RegisteredApp> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegisteredAppCopyWith<$Res> {
  factory $RegisteredAppCopyWith(
          RegisteredApp value, $Res Function(RegisteredApp) then) =
      _$RegisteredAppCopyWithImpl<$Res, RegisteredApp>;
  @useResult
  $Res call(
      {String id,
      String name,
      String nickname,
      @AppTechnologyConverter() AppTechnology technology,
      AppLegal? legalInformation,
      AppDesign? designInformation,
      bool? isCustomized,
      List<AppInstance>? instances,
      List<Asset>? importedAssets,
      List<Device>? importedDevices,
      List<User>? importedUsers,
      List<User>? keychain,
      String sourceId,
      List<MapLayer> mapLayers,
      User? owner});

  $AppLegalCopyWith<$Res>? get legalInformation;
  $AppDesignCopyWith<$Res>? get designInformation;
  $UserCopyWith<$Res>? get owner;
}

/// @nodoc
class _$RegisteredAppCopyWithImpl<$Res, $Val extends RegisteredApp>
    implements $RegisteredAppCopyWith<$Res> {
  _$RegisteredAppCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? nickname = null,
    Object? technology = null,
    Object? legalInformation = freezed,
    Object? designInformation = freezed,
    Object? isCustomized = freezed,
    Object? instances = freezed,
    Object? importedAssets = freezed,
    Object? importedDevices = freezed,
    Object? importedUsers = freezed,
    Object? keychain = freezed,
    Object? sourceId = null,
    Object? mapLayers = null,
    Object? owner = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      nickname: null == nickname
          ? _value.nickname
          : nickname // ignore: cast_nullable_to_non_nullable
              as String,
      technology: null == technology
          ? _value.technology
          : technology // ignore: cast_nullable_to_non_nullable
              as AppTechnology,
      legalInformation: freezed == legalInformation
          ? _value.legalInformation
          : legalInformation // ignore: cast_nullable_to_non_nullable
              as AppLegal?,
      designInformation: freezed == designInformation
          ? _value.designInformation
          : designInformation // ignore: cast_nullable_to_non_nullable
              as AppDesign?,
      isCustomized: freezed == isCustomized
          ? _value.isCustomized
          : isCustomized // ignore: cast_nullable_to_non_nullable
              as bool?,
      instances: freezed == instances
          ? _value.instances
          : instances // ignore: cast_nullable_to_non_nullable
              as List<AppInstance>?,
      importedAssets: freezed == importedAssets
          ? _value.importedAssets
          : importedAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      importedDevices: freezed == importedDevices
          ? _value.importedDevices
          : importedDevices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
      importedUsers: freezed == importedUsers
          ? _value.importedUsers
          : importedUsers // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      keychain: freezed == keychain
          ? _value.keychain
          : keychain // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      sourceId: null == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as String,
      mapLayers: null == mapLayers
          ? _value.mapLayers
          : mapLayers // ignore: cast_nullable_to_non_nullable
              as List<MapLayer>,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as User?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AppLegalCopyWith<$Res>? get legalInformation {
    if (_value.legalInformation == null) {
      return null;
    }

    return $AppLegalCopyWith<$Res>(_value.legalInformation!, (value) {
      return _then(_value.copyWith(legalInformation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppDesignCopyWith<$Res>? get designInformation {
    if (_value.designInformation == null) {
      return null;
    }

    return $AppDesignCopyWith<$Res>(_value.designInformation!, (value) {
      return _then(_value.copyWith(designInformation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get owner {
    if (_value.owner == null) {
      return null;
    }

    return $UserCopyWith<$Res>(_value.owner!, (value) {
      return _then(_value.copyWith(owner: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_RegisteredAppCopyWith<$Res>
    implements $RegisteredAppCopyWith<$Res> {
  factory _$$_RegisteredAppCopyWith(
          _$_RegisteredApp value, $Res Function(_$_RegisteredApp) then) =
      __$$_RegisteredAppCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String nickname,
      @AppTechnologyConverter() AppTechnology technology,
      AppLegal? legalInformation,
      AppDesign? designInformation,
      bool? isCustomized,
      List<AppInstance>? instances,
      List<Asset>? importedAssets,
      List<Device>? importedDevices,
      List<User>? importedUsers,
      List<User>? keychain,
      String sourceId,
      List<MapLayer> mapLayers,
      User? owner});

  @override
  $AppLegalCopyWith<$Res>? get legalInformation;
  @override
  $AppDesignCopyWith<$Res>? get designInformation;
  @override
  $UserCopyWith<$Res>? get owner;
}

/// @nodoc
class __$$_RegisteredAppCopyWithImpl<$Res>
    extends _$RegisteredAppCopyWithImpl<$Res, _$_RegisteredApp>
    implements _$$_RegisteredAppCopyWith<$Res> {
  __$$_RegisteredAppCopyWithImpl(
      _$_RegisteredApp _value, $Res Function(_$_RegisteredApp) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? nickname = null,
    Object? technology = null,
    Object? legalInformation = freezed,
    Object? designInformation = freezed,
    Object? isCustomized = freezed,
    Object? instances = freezed,
    Object? importedAssets = freezed,
    Object? importedDevices = freezed,
    Object? importedUsers = freezed,
    Object? keychain = freezed,
    Object? sourceId = null,
    Object? mapLayers = null,
    Object? owner = freezed,
  }) {
    return _then(_$_RegisteredApp(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      nickname: null == nickname
          ? _value.nickname
          : nickname // ignore: cast_nullable_to_non_nullable
              as String,
      technology: null == technology
          ? _value.technology
          : technology // ignore: cast_nullable_to_non_nullable
              as AppTechnology,
      legalInformation: freezed == legalInformation
          ? _value.legalInformation
          : legalInformation // ignore: cast_nullable_to_non_nullable
              as AppLegal?,
      designInformation: freezed == designInformation
          ? _value.designInformation
          : designInformation // ignore: cast_nullable_to_non_nullable
              as AppDesign?,
      isCustomized: freezed == isCustomized
          ? _value.isCustomized
          : isCustomized // ignore: cast_nullable_to_non_nullable
              as bool?,
      instances: freezed == instances
          ? _value._instances
          : instances // ignore: cast_nullable_to_non_nullable
              as List<AppInstance>?,
      importedAssets: freezed == importedAssets
          ? _value._importedAssets
          : importedAssets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      importedDevices: freezed == importedDevices
          ? _value._importedDevices
          : importedDevices // ignore: cast_nullable_to_non_nullable
              as List<Device>?,
      importedUsers: freezed == importedUsers
          ? _value._importedUsers
          : importedUsers // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      keychain: freezed == keychain
          ? _value._keychain
          : keychain // ignore: cast_nullable_to_non_nullable
              as List<User>?,
      sourceId: null == sourceId
          ? _value.sourceId
          : sourceId // ignore: cast_nullable_to_non_nullable
              as String,
      mapLayers: null == mapLayers
          ? _value._mapLayers
          : mapLayers // ignore: cast_nullable_to_non_nullable
              as List<MapLayer>,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as User?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_RegisteredApp implements _RegisteredApp {
  const _$_RegisteredApp(
      {required this.id,
      required this.name,
      required this.nickname,
      @AppTechnologyConverter() required this.technology,
      this.legalInformation,
      this.designInformation,
      this.isCustomized,
      final List<AppInstance>? instances,
      final List<Asset>? importedAssets,
      final List<Device>? importedDevices,
      final List<User>? importedUsers,
      final List<User>? keychain,
      required this.sourceId,
      final List<MapLayer> mapLayers = const [],
      this.owner})
      : _instances = instances,
        _importedAssets = importedAssets,
        _importedDevices = importedDevices,
        _importedUsers = importedUsers,
        _keychain = keychain,
        _mapLayers = mapLayers;

  factory _$_RegisteredApp.fromJson(Map<String, dynamic> json) =>
      _$$_RegisteredAppFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String nickname;
  @override
  @AppTechnologyConverter()
  final AppTechnology technology;
  @override
  final AppLegal? legalInformation;
  @override
  final AppDesign? designInformation;
  @override
  final bool? isCustomized;
  final List<AppInstance>? _instances;
  @override
  List<AppInstance>? get instances {
    final value = _instances;
    if (value == null) return null;
    if (_instances is EqualUnmodifiableListView) return _instances;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Asset>? _importedAssets;
  @override
  List<Asset>? get importedAssets {
    final value = _importedAssets;
    if (value == null) return null;
    if (_importedAssets is EqualUnmodifiableListView) return _importedAssets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<Device>? _importedDevices;
  @override
  List<Device>? get importedDevices {
    final value = _importedDevices;
    if (value == null) return null;
    if (_importedDevices is EqualUnmodifiableListView) return _importedDevices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<User>? _importedUsers;
  @override
  List<User>? get importedUsers {
    final value = _importedUsers;
    if (value == null) return null;
    if (_importedUsers is EqualUnmodifiableListView) return _importedUsers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<User>? _keychain;
  @override
  List<User>? get keychain {
    final value = _keychain;
    if (value == null) return null;
    if (_keychain is EqualUnmodifiableListView) return _keychain;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final String sourceId;

  /// [mapLayers] is the list of map layers of the app.
  final List<MapLayer> _mapLayers;

  /// [mapLayers] is the list of map layers of the app.
  @override
  @JsonKey()
  List<MapLayer> get mapLayers {
    if (_mapLayers is EqualUnmodifiableListView) return _mapLayers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_mapLayers);
  }

  /// [owner] is the owner of the app.
  /// !Important: This field is only available when the query is from `/goldenm/graphql`
  @override
  final User? owner;

  @override
  String toString() {
    return 'RegisteredApp(id: $id, name: $name, nickname: $nickname, technology: $technology, legalInformation: $legalInformation, designInformation: $designInformation, isCustomized: $isCustomized, instances: $instances, importedAssets: $importedAssets, importedDevices: $importedDevices, importedUsers: $importedUsers, keychain: $keychain, sourceId: $sourceId, mapLayers: $mapLayers, owner: $owner)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RegisteredApp &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.nickname, nickname) ||
                other.nickname == nickname) &&
            (identical(other.technology, technology) ||
                other.technology == technology) &&
            (identical(other.legalInformation, legalInformation) ||
                other.legalInformation == legalInformation) &&
            (identical(other.designInformation, designInformation) ||
                other.designInformation == designInformation) &&
            (identical(other.isCustomized, isCustomized) ||
                other.isCustomized == isCustomized) &&
            const DeepCollectionEquality()
                .equals(other._instances, _instances) &&
            const DeepCollectionEquality()
                .equals(other._importedAssets, _importedAssets) &&
            const DeepCollectionEquality()
                .equals(other._importedDevices, _importedDevices) &&
            const DeepCollectionEquality()
                .equals(other._importedUsers, _importedUsers) &&
            const DeepCollectionEquality().equals(other._keychain, _keychain) &&
            (identical(other.sourceId, sourceId) ||
                other.sourceId == sourceId) &&
            const DeepCollectionEquality()
                .equals(other._mapLayers, _mapLayers) &&
            (identical(other.owner, owner) || other.owner == owner));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      nickname,
      technology,
      legalInformation,
      designInformation,
      isCustomized,
      const DeepCollectionEquality().hash(_instances),
      const DeepCollectionEquality().hash(_importedAssets),
      const DeepCollectionEquality().hash(_importedDevices),
      const DeepCollectionEquality().hash(_importedUsers),
      const DeepCollectionEquality().hash(_keychain),
      sourceId,
      const DeepCollectionEquality().hash(_mapLayers),
      owner);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RegisteredAppCopyWith<_$_RegisteredApp> get copyWith =>
      __$$_RegisteredAppCopyWithImpl<_$_RegisteredApp>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RegisteredAppToJson(
      this,
    );
  }
}

abstract class _RegisteredApp implements RegisteredApp {
  const factory _RegisteredApp(
      {required final String id,
      required final String name,
      required final String nickname,
      @AppTechnologyConverter() required final AppTechnology technology,
      final AppLegal? legalInformation,
      final AppDesign? designInformation,
      final bool? isCustomized,
      final List<AppInstance>? instances,
      final List<Asset>? importedAssets,
      final List<Device>? importedDevices,
      final List<User>? importedUsers,
      final List<User>? keychain,
      required final String sourceId,
      final List<MapLayer> mapLayers,
      final User? owner}) = _$_RegisteredApp;

  factory _RegisteredApp.fromJson(Map<String, dynamic> json) =
      _$_RegisteredApp.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get nickname;
  @override
  @AppTechnologyConverter()
  AppTechnology get technology;
  @override
  AppLegal? get legalInformation;
  @override
  AppDesign? get designInformation;
  @override
  bool? get isCustomized;
  @override
  List<AppInstance>? get instances;
  @override
  List<Asset>? get importedAssets;
  @override
  List<Device>? get importedDevices;
  @override
  List<User>? get importedUsers;
  @override
  List<User>? get keychain;
  @override
  String get sourceId;
  @override

  /// [mapLayers] is the list of map layers of the app.
  List<MapLayer> get mapLayers;
  @override

  /// [owner] is the owner of the app.
  /// !Important: This field is only available when the query is from `/goldenm/graphql`
  User? get owner;
  @override
  @JsonKey(ignore: true)
  _$$_RegisteredAppCopyWith<_$_RegisteredApp> get copyWith =>
      throw _privateConstructorUsedError;
}

AppThemedAsset _$AppThemedAssetFromJson(Map<String, dynamic> json) {
  return _AppThemedAsset.fromJson(json);
}

/// @nodoc
mixin _$AppThemedAsset {
  String get normal => throw _privateConstructorUsedError;
  String get white => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppThemedAssetCopyWith<AppThemedAsset> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppThemedAssetCopyWith<$Res> {
  factory $AppThemedAssetCopyWith(
          AppThemedAsset value, $Res Function(AppThemedAsset) then) =
      _$AppThemedAssetCopyWithImpl<$Res, AppThemedAsset>;
  @useResult
  $Res call({String normal, String white});
}

/// @nodoc
class _$AppThemedAssetCopyWithImpl<$Res, $Val extends AppThemedAsset>
    implements $AppThemedAssetCopyWith<$Res> {
  _$AppThemedAssetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? normal = null,
    Object? white = null,
  }) {
    return _then(_value.copyWith(
      normal: null == normal
          ? _value.normal
          : normal // ignore: cast_nullable_to_non_nullable
              as String,
      white: null == white
          ? _value.white
          : white // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppThemedAssetCopyWith<$Res>
    implements $AppThemedAssetCopyWith<$Res> {
  factory _$$_AppThemedAssetCopyWith(
          _$_AppThemedAsset value, $Res Function(_$_AppThemedAsset) then) =
      __$$_AppThemedAssetCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String normal, String white});
}

/// @nodoc
class __$$_AppThemedAssetCopyWithImpl<$Res>
    extends _$AppThemedAssetCopyWithImpl<$Res, _$_AppThemedAsset>
    implements _$$_AppThemedAssetCopyWith<$Res> {
  __$$_AppThemedAssetCopyWithImpl(
      _$_AppThemedAsset _value, $Res Function(_$_AppThemedAsset) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? normal = null,
    Object? white = null,
  }) {
    return _then(_$_AppThemedAsset(
      normal: null == normal
          ? _value.normal
          : normal // ignore: cast_nullable_to_non_nullable
              as String,
      white: null == white
          ? _value.white
          : white // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppThemedAsset implements _AppThemedAsset {
  const _$_AppThemedAsset({required this.normal, required this.white});

  factory _$_AppThemedAsset.fromJson(Map<String, dynamic> json) =>
      _$$_AppThemedAssetFromJson(json);

  @override
  final String normal;
  @override
  final String white;

  @override
  String toString() {
    return 'AppThemedAsset(normal: $normal, white: $white)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppThemedAsset &&
            (identical(other.normal, normal) || other.normal == normal) &&
            (identical(other.white, white) || other.white == white));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, normal, white);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppThemedAssetCopyWith<_$_AppThemedAsset> get copyWith =>
      __$$_AppThemedAssetCopyWithImpl<_$_AppThemedAsset>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppThemedAssetToJson(
      this,
    );
  }
}

abstract class _AppThemedAsset implements AppThemedAsset {
  const factory _AppThemedAsset(
      {required final String normal,
      required final String white}) = _$_AppThemedAsset;

  factory _AppThemedAsset.fromJson(Map<String, dynamic> json) =
      _$_AppThemedAsset.fromJson;

  @override
  String get normal;
  @override
  String get white;
  @override
  @JsonKey(ignore: true)
  _$$_AppThemedAssetCopyWith<_$_AppThemedAsset> get copyWith =>
      throw _privateConstructorUsedError;
}

AppBackgroundDesign _$AppBackgroundDesignFromJson(Map<String, dynamic> json) {
  return _AppBackgroundDesign.fromJson(json);
}

/// @nodoc
mixin _$AppBackgroundDesign {
  String? get image => throw _privateConstructorUsedError;
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;
  @BackgroundModeConverter()
  BackgroundMode get mode => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppBackgroundDesignCopyWith<AppBackgroundDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppBackgroundDesignCopyWith<$Res> {
  factory $AppBackgroundDesignCopyWith(
          AppBackgroundDesign value, $Res Function(AppBackgroundDesign) then) =
      _$AppBackgroundDesignCopyWithImpl<$Res, AppBackgroundDesign>;
  @useResult
  $Res call(
      {String? image,
      @ColorOrNullConverter() Color? color,
      @BackgroundModeConverter() BackgroundMode mode});
}

/// @nodoc
class _$AppBackgroundDesignCopyWithImpl<$Res, $Val extends AppBackgroundDesign>
    implements $AppBackgroundDesignCopyWith<$Res> {
  _$AppBackgroundDesignCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = freezed,
    Object? color = freezed,
    Object? mode = null,
  }) {
    return _then(_value.copyWith(
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as BackgroundMode,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppBackgroundDesignCopyWith<$Res>
    implements $AppBackgroundDesignCopyWith<$Res> {
  factory _$$_AppBackgroundDesignCopyWith(_$_AppBackgroundDesign value,
          $Res Function(_$_AppBackgroundDesign) then) =
      __$$_AppBackgroundDesignCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? image,
      @ColorOrNullConverter() Color? color,
      @BackgroundModeConverter() BackgroundMode mode});
}

/// @nodoc
class __$$_AppBackgroundDesignCopyWithImpl<$Res>
    extends _$AppBackgroundDesignCopyWithImpl<$Res, _$_AppBackgroundDesign>
    implements _$$_AppBackgroundDesignCopyWith<$Res> {
  __$$_AppBackgroundDesignCopyWithImpl(_$_AppBackgroundDesign _value,
      $Res Function(_$_AppBackgroundDesign) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = freezed,
    Object? color = freezed,
    Object? mode = null,
  }) {
    return _then(_$_AppBackgroundDesign(
      image: freezed == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as BackgroundMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppBackgroundDesign implements _AppBackgroundDesign {
  const _$_AppBackgroundDesign(
      {this.image,
      @ColorOrNullConverter() this.color,
      @BackgroundModeConverter() required this.mode});

  factory _$_AppBackgroundDesign.fromJson(Map<String, dynamic> json) =>
      _$$_AppBackgroundDesignFromJson(json);

  @override
  final String? image;
  @override
  @ColorOrNullConverter()
  final Color? color;
  @override
  @BackgroundModeConverter()
  final BackgroundMode mode;

  @override
  String toString() {
    return 'AppBackgroundDesign(image: $image, color: $color, mode: $mode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppBackgroundDesign &&
            (identical(other.image, image) || other.image == image) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.mode, mode) || other.mode == mode));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, image, color, mode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppBackgroundDesignCopyWith<_$_AppBackgroundDesign> get copyWith =>
      __$$_AppBackgroundDesignCopyWithImpl<_$_AppBackgroundDesign>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppBackgroundDesignToJson(
      this,
    );
  }
}

abstract class _AppBackgroundDesign implements AppBackgroundDesign {
  const factory _AppBackgroundDesign(
          {final String? image,
          @ColorOrNullConverter() final Color? color,
          @BackgroundModeConverter() required final BackgroundMode mode}) =
      _$_AppBackgroundDesign;

  factory _AppBackgroundDesign.fromJson(Map<String, dynamic> json) =
      _$_AppBackgroundDesign.fromJson;

  @override
  String? get image;
  @override
  @ColorOrNullConverter()
  Color? get color;
  @override
  @BackgroundModeConverter()
  BackgroundMode get mode;
  @override
  @JsonKey(ignore: true)
  _$$_AppBackgroundDesignCopyWith<_$_AppBackgroundDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

AppBuild _$AppBuildFromJson(Map<String, dynamic> json) {
  return _AppBuild.fromJson(json);
}

/// @nodoc
mixin _$AppBuild {
  String get id => throw _privateConstructorUsedError;
  String get buildName => throw _privateConstructorUsedError;
  int get buildNumber => throw _privateConstructorUsedError;
  String? get fileUri => throw _privateConstructorUsedError;
  String? get comments => throw _privateConstructorUsedError;
  @AppBuildStatusConverter()
  AppBuildStatus get status => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get startAt => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get endAt => throw _privateConstructorUsedError;
  bool? get isNext => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppBuildCopyWith<AppBuild> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppBuildCopyWith<$Res> {
  factory $AppBuildCopyWith(AppBuild value, $Res Function(AppBuild) then) =
      _$AppBuildCopyWithImpl<$Res, AppBuild>;
  @useResult
  $Res call(
      {String id,
      String buildName,
      int buildNumber,
      String? fileUri,
      String? comments,
      @AppBuildStatusConverter() AppBuildStatus status,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      bool? isNext});
}

/// @nodoc
class _$AppBuildCopyWithImpl<$Res, $Val extends AppBuild>
    implements $AppBuildCopyWith<$Res> {
  _$AppBuildCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? buildName = null,
    Object? buildNumber = null,
    Object? fileUri = freezed,
    Object? comments = freezed,
    Object? status = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? isNext = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      buildName: null == buildName
          ? _value.buildName
          : buildName // ignore: cast_nullable_to_non_nullable
              as String,
      buildNumber: null == buildNumber
          ? _value.buildNumber
          : buildNumber // ignore: cast_nullable_to_non_nullable
              as int,
      fileUri: freezed == fileUri
          ? _value.fileUri
          : fileUri // ignore: cast_nullable_to_non_nullable
              as String?,
      comments: freezed == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as AppBuildStatus,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isNext: freezed == isNext
          ? _value.isNext
          : isNext // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppBuildCopyWith<$Res> implements $AppBuildCopyWith<$Res> {
  factory _$$_AppBuildCopyWith(
          _$_AppBuild value, $Res Function(_$_AppBuild) then) =
      __$$_AppBuildCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String buildName,
      int buildNumber,
      String? fileUri,
      String? comments,
      @AppBuildStatusConverter() AppBuildStatus status,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      bool? isNext});
}

/// @nodoc
class __$$_AppBuildCopyWithImpl<$Res>
    extends _$AppBuildCopyWithImpl<$Res, _$_AppBuild>
    implements _$$_AppBuildCopyWith<$Res> {
  __$$_AppBuildCopyWithImpl(
      _$_AppBuild _value, $Res Function(_$_AppBuild) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? buildName = null,
    Object? buildNumber = null,
    Object? fileUri = freezed,
    Object? comments = freezed,
    Object? status = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? isNext = freezed,
  }) {
    return _then(_$_AppBuild(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      buildName: null == buildName
          ? _value.buildName
          : buildName // ignore: cast_nullable_to_non_nullable
              as String,
      buildNumber: null == buildNumber
          ? _value.buildNumber
          : buildNumber // ignore: cast_nullable_to_non_nullable
              as int,
      fileUri: freezed == fileUri
          ? _value.fileUri
          : fileUri // ignore: cast_nullable_to_non_nullable
              as String?,
      comments: freezed == comments
          ? _value.comments
          : comments // ignore: cast_nullable_to_non_nullable
              as String?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as AppBuildStatus,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isNext: freezed == isNext
          ? _value.isNext
          : isNext // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppBuild implements _AppBuild {
  const _$_AppBuild(
      {required this.id,
      required this.buildName,
      required this.buildNumber,
      this.fileUri,
      this.comments,
      @AppBuildStatusConverter() required this.status,
      @TimestampOrNullConverter() this.startAt,
      @TimestampOrNullConverter() this.endAt,
      this.isNext});

  factory _$_AppBuild.fromJson(Map<String, dynamic> json) =>
      _$$_AppBuildFromJson(json);

  @override
  final String id;
  @override
  final String buildName;
  @override
  final int buildNumber;
  @override
  final String? fileUri;
  @override
  final String? comments;
  @override
  @AppBuildStatusConverter()
  final AppBuildStatus status;
  @override
  @TimestampOrNullConverter()
  final DateTime? startAt;
  @override
  @TimestampOrNullConverter()
  final DateTime? endAt;
  @override
  final bool? isNext;

  @override
  String toString() {
    return 'AppBuild(id: $id, buildName: $buildName, buildNumber: $buildNumber, fileUri: $fileUri, comments: $comments, status: $status, startAt: $startAt, endAt: $endAt, isNext: $isNext)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppBuild &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.buildName, buildName) ||
                other.buildName == buildName) &&
            (identical(other.buildNumber, buildNumber) ||
                other.buildNumber == buildNumber) &&
            (identical(other.fileUri, fileUri) || other.fileUri == fileUri) &&
            (identical(other.comments, comments) ||
                other.comments == comments) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.startAt, startAt) || other.startAt == startAt) &&
            (identical(other.endAt, endAt) || other.endAt == endAt) &&
            (identical(other.isNext, isNext) || other.isNext == isNext));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, buildName, buildNumber,
      fileUri, comments, status, startAt, endAt, isNext);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppBuildCopyWith<_$_AppBuild> get copyWith =>
      __$$_AppBuildCopyWithImpl<_$_AppBuild>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppBuildToJson(
      this,
    );
  }
}

abstract class _AppBuild implements AppBuild {
  const factory _AppBuild(
      {required final String id,
      required final String buildName,
      required final int buildNumber,
      final String? fileUri,
      final String? comments,
      @AppBuildStatusConverter() required final AppBuildStatus status,
      @TimestampOrNullConverter() final DateTime? startAt,
      @TimestampOrNullConverter() final DateTime? endAt,
      final bool? isNext}) = _$_AppBuild;

  factory _AppBuild.fromJson(Map<String, dynamic> json) = _$_AppBuild.fromJson;

  @override
  String get id;
  @override
  String get buildName;
  @override
  int get buildNumber;
  @override
  String? get fileUri;
  @override
  String? get comments;
  @override
  @AppBuildStatusConverter()
  AppBuildStatus get status;
  @override
  @TimestampOrNullConverter()
  DateTime? get startAt;
  @override
  @TimestampOrNullConverter()
  DateTime? get endAt;
  @override
  bool? get isNext;
  @override
  @JsonKey(ignore: true)
  _$$_AppBuildCopyWith<_$_AppBuild> get copyWith =>
      throw _privateConstructorUsedError;
}

AppThemedColors _$AppThemedColorsFromJson(Map<String, dynamic> json) {
  return _AppThemedColors.fromJson(json);
}

/// @nodoc
mixin _$AppThemedColors {
  @AppThemeOrNullConverter()
  AppTheme? get theme => throw _privateConstructorUsedError;
  @ColorOrNullConverter()
  Color? get mainColor => throw _privateConstructorUsedError;
  @ColorOrNullConverter()
  Color? get primary => throw _privateConstructorUsedError;
  @ColorOrNullConverter()
  Color? get secondary => throw _privateConstructorUsedError;
  @ColorOrNullConverter()
  Color? get accent => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppThemedColorsCopyWith<AppThemedColors> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppThemedColorsCopyWith<$Res> {
  factory $AppThemedColorsCopyWith(
          AppThemedColors value, $Res Function(AppThemedColors) then) =
      _$AppThemedColorsCopyWithImpl<$Res, AppThemedColors>;
  @useResult
  $Res call(
      {@AppThemeOrNullConverter() AppTheme? theme,
      @ColorOrNullConverter() Color? mainColor,
      @ColorOrNullConverter() Color? primary,
      @ColorOrNullConverter() Color? secondary,
      @ColorOrNullConverter() Color? accent});
}

/// @nodoc
class _$AppThemedColorsCopyWithImpl<$Res, $Val extends AppThemedColors>
    implements $AppThemedColorsCopyWith<$Res> {
  _$AppThemedColorsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? theme = freezed,
    Object? mainColor = freezed,
    Object? primary = freezed,
    Object? secondary = freezed,
    Object? accent = freezed,
  }) {
    return _then(_value.copyWith(
      theme: freezed == theme
          ? _value.theme
          : theme // ignore: cast_nullable_to_non_nullable
              as AppTheme?,
      mainColor: freezed == mainColor
          ? _value.mainColor
          : mainColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      primary: freezed == primary
          ? _value.primary
          : primary // ignore: cast_nullable_to_non_nullable
              as Color?,
      secondary: freezed == secondary
          ? _value.secondary
          : secondary // ignore: cast_nullable_to_non_nullable
              as Color?,
      accent: freezed == accent
          ? _value.accent
          : accent // ignore: cast_nullable_to_non_nullable
              as Color?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppThemedColorsCopyWith<$Res>
    implements $AppThemedColorsCopyWith<$Res> {
  factory _$$_AppThemedColorsCopyWith(
          _$_AppThemedColors value, $Res Function(_$_AppThemedColors) then) =
      __$$_AppThemedColorsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@AppThemeOrNullConverter() AppTheme? theme,
      @ColorOrNullConverter() Color? mainColor,
      @ColorOrNullConverter() Color? primary,
      @ColorOrNullConverter() Color? secondary,
      @ColorOrNullConverter() Color? accent});
}

/// @nodoc
class __$$_AppThemedColorsCopyWithImpl<$Res>
    extends _$AppThemedColorsCopyWithImpl<$Res, _$_AppThemedColors>
    implements _$$_AppThemedColorsCopyWith<$Res> {
  __$$_AppThemedColorsCopyWithImpl(
      _$_AppThemedColors _value, $Res Function(_$_AppThemedColors) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? theme = freezed,
    Object? mainColor = freezed,
    Object? primary = freezed,
    Object? secondary = freezed,
    Object? accent = freezed,
  }) {
    return _then(_$_AppThemedColors(
      theme: freezed == theme
          ? _value.theme
          : theme // ignore: cast_nullable_to_non_nullable
              as AppTheme?,
      mainColor: freezed == mainColor
          ? _value.mainColor
          : mainColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      primary: freezed == primary
          ? _value.primary
          : primary // ignore: cast_nullable_to_non_nullable
              as Color?,
      secondary: freezed == secondary
          ? _value.secondary
          : secondary // ignore: cast_nullable_to_non_nullable
              as Color?,
      accent: freezed == accent
          ? _value.accent
          : accent // ignore: cast_nullable_to_non_nullable
              as Color?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppThemedColors implements _AppThemedColors {
  const _$_AppThemedColors(
      {@AppThemeOrNullConverter() this.theme,
      @ColorOrNullConverter() this.mainColor,
      @ColorOrNullConverter() this.primary,
      @ColorOrNullConverter() this.secondary,
      @ColorOrNullConverter() this.accent});

  factory _$_AppThemedColors.fromJson(Map<String, dynamic> json) =>
      _$$_AppThemedColorsFromJson(json);

  @override
  @AppThemeOrNullConverter()
  final AppTheme? theme;
  @override
  @ColorOrNullConverter()
  final Color? mainColor;
  @override
  @ColorOrNullConverter()
  final Color? primary;
  @override
  @ColorOrNullConverter()
  final Color? secondary;
  @override
  @ColorOrNullConverter()
  final Color? accent;

  @override
  String toString() {
    return 'AppThemedColors(theme: $theme, mainColor: $mainColor, primary: $primary, secondary: $secondary, accent: $accent)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppThemedColors &&
            (identical(other.theme, theme) || other.theme == theme) &&
            (identical(other.mainColor, mainColor) ||
                other.mainColor == mainColor) &&
            (identical(other.primary, primary) || other.primary == primary) &&
            (identical(other.secondary, secondary) ||
                other.secondary == secondary) &&
            (identical(other.accent, accent) || other.accent == accent));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, theme, mainColor, primary, secondary, accent);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppThemedColorsCopyWith<_$_AppThemedColors> get copyWith =>
      __$$_AppThemedColorsCopyWithImpl<_$_AppThemedColors>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppThemedColorsToJson(
      this,
    );
  }
}

abstract class _AppThemedColors implements AppThemedColors {
  const factory _AppThemedColors(
      {@AppThemeOrNullConverter() final AppTheme? theme,
      @ColorOrNullConverter() final Color? mainColor,
      @ColorOrNullConverter() final Color? primary,
      @ColorOrNullConverter() final Color? secondary,
      @ColorOrNullConverter() final Color? accent}) = _$_AppThemedColors;

  factory _AppThemedColors.fromJson(Map<String, dynamic> json) =
      _$_AppThemedColors.fromJson;

  @override
  @AppThemeOrNullConverter()
  AppTheme? get theme;
  @override
  @ColorOrNullConverter()
  Color? get mainColor;
  @override
  @ColorOrNullConverter()
  Color? get primary;
  @override
  @ColorOrNullConverter()
  Color? get secondary;
  @override
  @ColorOrNullConverter()
  Color? get accent;
  @override
  @JsonKey(ignore: true)
  _$$_AppThemedColorsCopyWith<_$_AppThemedColors> get copyWith =>
      throw _privateConstructorUsedError;
}

LegacyAppDesign _$LegacyAppDesignFromJson(Map<String, dynamic> json) {
  return _LegacyAppDesign.fromJson(json);
}

/// @nodoc
mixin _$LegacyAppDesign {
  AppThemedColors get colors => throw _privateConstructorUsedError;
  AppThemedAsset get favicons => throw _privateConstructorUsedError;
  AppThemedAsset get logos => throw _privateConstructorUsedError;
  String get appicon => throw _privateConstructorUsedError;
  AppBackgroundDesign get background => throw _privateConstructorUsedError;
  LegacyAppLoginDesign? get login => throw _privateConstructorUsedError;
  AppTitleMode? get title => throw _privateConstructorUsedError;
  AppFooter? get footer => throw _privateConstructorUsedError;
  @FooterFormatOrNullConverter()
  FooterFormat? get footerFormat => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LegacyAppDesignCopyWith<LegacyAppDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LegacyAppDesignCopyWith<$Res> {
  factory $LegacyAppDesignCopyWith(
          LegacyAppDesign value, $Res Function(LegacyAppDesign) then) =
      _$LegacyAppDesignCopyWithImpl<$Res, LegacyAppDesign>;
  @useResult
  $Res call(
      {AppThemedColors colors,
      AppThemedAsset favicons,
      AppThemedAsset logos,
      String appicon,
      AppBackgroundDesign background,
      LegacyAppLoginDesign? login,
      AppTitleMode? title,
      AppFooter? footer,
      @FooterFormatOrNullConverter() FooterFormat? footerFormat});

  $AppThemedColorsCopyWith<$Res> get colors;
  $AppThemedAssetCopyWith<$Res> get favicons;
  $AppThemedAssetCopyWith<$Res> get logos;
  $AppBackgroundDesignCopyWith<$Res> get background;
  $LegacyAppLoginDesignCopyWith<$Res>? get login;
  $AppTitleModeCopyWith<$Res>? get title;
  $AppFooterCopyWith<$Res>? get footer;
}

/// @nodoc
class _$LegacyAppDesignCopyWithImpl<$Res, $Val extends LegacyAppDesign>
    implements $LegacyAppDesignCopyWith<$Res> {
  _$LegacyAppDesignCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? colors = null,
    Object? favicons = null,
    Object? logos = null,
    Object? appicon = null,
    Object? background = null,
    Object? login = freezed,
    Object? title = freezed,
    Object? footer = freezed,
    Object? footerFormat = freezed,
  }) {
    return _then(_value.copyWith(
      colors: null == colors
          ? _value.colors
          : colors // ignore: cast_nullable_to_non_nullable
              as AppThemedColors,
      favicons: null == favicons
          ? _value.favicons
          : favicons // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      logos: null == logos
          ? _value.logos
          : logos // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      appicon: null == appicon
          ? _value.appicon
          : appicon // ignore: cast_nullable_to_non_nullable
              as String,
      background: null == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as AppBackgroundDesign,
      login: freezed == login
          ? _value.login
          : login // ignore: cast_nullable_to_non_nullable
              as LegacyAppLoginDesign?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as AppTitleMode?,
      footer: freezed == footer
          ? _value.footer
          : footer // ignore: cast_nullable_to_non_nullable
              as AppFooter?,
      footerFormat: freezed == footerFormat
          ? _value.footerFormat
          : footerFormat // ignore: cast_nullable_to_non_nullable
              as FooterFormat?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AppThemedColorsCopyWith<$Res> get colors {
    return $AppThemedColorsCopyWith<$Res>(_value.colors, (value) {
      return _then(_value.copyWith(colors: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppThemedAssetCopyWith<$Res> get favicons {
    return $AppThemedAssetCopyWith<$Res>(_value.favicons, (value) {
      return _then(_value.copyWith(favicons: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppThemedAssetCopyWith<$Res> get logos {
    return $AppThemedAssetCopyWith<$Res>(_value.logos, (value) {
      return _then(_value.copyWith(logos: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppBackgroundDesignCopyWith<$Res> get background {
    return $AppBackgroundDesignCopyWith<$Res>(_value.background, (value) {
      return _then(_value.copyWith(background: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $LegacyAppLoginDesignCopyWith<$Res>? get login {
    if (_value.login == null) {
      return null;
    }

    return $LegacyAppLoginDesignCopyWith<$Res>(_value.login!, (value) {
      return _then(_value.copyWith(login: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppTitleModeCopyWith<$Res>? get title {
    if (_value.title == null) {
      return null;
    }

    return $AppTitleModeCopyWith<$Res>(_value.title!, (value) {
      return _then(_value.copyWith(title: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppFooterCopyWith<$Res>? get footer {
    if (_value.footer == null) {
      return null;
    }

    return $AppFooterCopyWith<$Res>(_value.footer!, (value) {
      return _then(_value.copyWith(footer: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_LegacyAppDesignCopyWith<$Res>
    implements $LegacyAppDesignCopyWith<$Res> {
  factory _$$_LegacyAppDesignCopyWith(
          _$_LegacyAppDesign value, $Res Function(_$_LegacyAppDesign) then) =
      __$$_LegacyAppDesignCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {AppThemedColors colors,
      AppThemedAsset favicons,
      AppThemedAsset logos,
      String appicon,
      AppBackgroundDesign background,
      LegacyAppLoginDesign? login,
      AppTitleMode? title,
      AppFooter? footer,
      @FooterFormatOrNullConverter() FooterFormat? footerFormat});

  @override
  $AppThemedColorsCopyWith<$Res> get colors;
  @override
  $AppThemedAssetCopyWith<$Res> get favicons;
  @override
  $AppThemedAssetCopyWith<$Res> get logos;
  @override
  $AppBackgroundDesignCopyWith<$Res> get background;
  @override
  $LegacyAppLoginDesignCopyWith<$Res>? get login;
  @override
  $AppTitleModeCopyWith<$Res>? get title;
  @override
  $AppFooterCopyWith<$Res>? get footer;
}

/// @nodoc
class __$$_LegacyAppDesignCopyWithImpl<$Res>
    extends _$LegacyAppDesignCopyWithImpl<$Res, _$_LegacyAppDesign>
    implements _$$_LegacyAppDesignCopyWith<$Res> {
  __$$_LegacyAppDesignCopyWithImpl(
      _$_LegacyAppDesign _value, $Res Function(_$_LegacyAppDesign) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? colors = null,
    Object? favicons = null,
    Object? logos = null,
    Object? appicon = null,
    Object? background = null,
    Object? login = freezed,
    Object? title = freezed,
    Object? footer = freezed,
    Object? footerFormat = freezed,
  }) {
    return _then(_$_LegacyAppDesign(
      colors: null == colors
          ? _value.colors
          : colors // ignore: cast_nullable_to_non_nullable
              as AppThemedColors,
      favicons: null == favicons
          ? _value.favicons
          : favicons // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      logos: null == logos
          ? _value.logos
          : logos // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      appicon: null == appicon
          ? _value.appicon
          : appicon // ignore: cast_nullable_to_non_nullable
              as String,
      background: null == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as AppBackgroundDesign,
      login: freezed == login
          ? _value.login
          : login // ignore: cast_nullable_to_non_nullable
              as LegacyAppLoginDesign?,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as AppTitleMode?,
      footer: freezed == footer
          ? _value.footer
          : footer // ignore: cast_nullable_to_non_nullable
              as AppFooter?,
      footerFormat: freezed == footerFormat
          ? _value.footerFormat
          : footerFormat // ignore: cast_nullable_to_non_nullable
              as FooterFormat?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LegacyAppDesign implements _LegacyAppDesign {
  const _$_LegacyAppDesign(
      {required this.colors,
      required this.favicons,
      required this.logos,
      required this.appicon,
      required this.background,
      this.login,
      this.title,
      this.footer,
      @FooterFormatOrNullConverter() this.footerFormat});

  factory _$_LegacyAppDesign.fromJson(Map<String, dynamic> json) =>
      _$$_LegacyAppDesignFromJson(json);

  @override
  final AppThemedColors colors;
  @override
  final AppThemedAsset favicons;
  @override
  final AppThemedAsset logos;
  @override
  final String appicon;
  @override
  final AppBackgroundDesign background;
  @override
  final LegacyAppLoginDesign? login;
  @override
  final AppTitleMode? title;
  @override
  final AppFooter? footer;
  @override
  @FooterFormatOrNullConverter()
  final FooterFormat? footerFormat;

  @override
  String toString() {
    return 'LegacyAppDesign(colors: $colors, favicons: $favicons, logos: $logos, appicon: $appicon, background: $background, login: $login, title: $title, footer: $footer, footerFormat: $footerFormat)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LegacyAppDesign &&
            (identical(other.colors, colors) || other.colors == colors) &&
            (identical(other.favicons, favicons) ||
                other.favicons == favicons) &&
            (identical(other.logos, logos) || other.logos == logos) &&
            (identical(other.appicon, appicon) || other.appicon == appicon) &&
            (identical(other.background, background) ||
                other.background == background) &&
            (identical(other.login, login) || other.login == login) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.footer, footer) || other.footer == footer) &&
            (identical(other.footerFormat, footerFormat) ||
                other.footerFormat == footerFormat));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, colors, favicons, logos, appicon,
      background, login, title, footer, footerFormat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LegacyAppDesignCopyWith<_$_LegacyAppDesign> get copyWith =>
      __$$_LegacyAppDesignCopyWithImpl<_$_LegacyAppDesign>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LegacyAppDesignToJson(
      this,
    );
  }
}

abstract class _LegacyAppDesign implements LegacyAppDesign {
  const factory _LegacyAppDesign(
          {required final AppThemedColors colors,
          required final AppThemedAsset favicons,
          required final AppThemedAsset logos,
          required final String appicon,
          required final AppBackgroundDesign background,
          final LegacyAppLoginDesign? login,
          final AppTitleMode? title,
          final AppFooter? footer,
          @FooterFormatOrNullConverter() final FooterFormat? footerFormat}) =
      _$_LegacyAppDesign;

  factory _LegacyAppDesign.fromJson(Map<String, dynamic> json) =
      _$_LegacyAppDesign.fromJson;

  @override
  AppThemedColors get colors;
  @override
  AppThemedAsset get favicons;
  @override
  AppThemedAsset get logos;
  @override
  String get appicon;
  @override
  AppBackgroundDesign get background;
  @override
  LegacyAppLoginDesign? get login;
  @override
  AppTitleMode? get title;
  @override
  AppFooter? get footer;
  @override
  @FooterFormatOrNullConverter()
  FooterFormat? get footerFormat;
  @override
  @JsonKey(ignore: true)
  _$$_LegacyAppDesignCopyWith<_$_LegacyAppDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

AppDesign _$AppDesignFromJson(Map<String, dynamic> json) {
  return _AppDesign.fromJson(json);
}

/// @nodoc
mixin _$AppDesign {
  AppThemedColors get colors => throw _privateConstructorUsedError;
  AppThemedAsset get favicons => throw _privateConstructorUsedError;
  AppThemedAsset get logos => throw _privateConstructorUsedError;
  String get appicon => throw _privateConstructorUsedError;
  AppLoginDesign? get login => throw _privateConstructorUsedError;
  @FooterFormatOrNullConverter()
  FooterFormat? get footerFormat => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppDesignCopyWith<AppDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppDesignCopyWith<$Res> {
  factory $AppDesignCopyWith(AppDesign value, $Res Function(AppDesign) then) =
      _$AppDesignCopyWithImpl<$Res, AppDesign>;
  @useResult
  $Res call(
      {AppThemedColors colors,
      AppThemedAsset favicons,
      AppThemedAsset logos,
      String appicon,
      AppLoginDesign? login,
      @FooterFormatOrNullConverter() FooterFormat? footerFormat});

  $AppThemedColorsCopyWith<$Res> get colors;
  $AppThemedAssetCopyWith<$Res> get favicons;
  $AppThemedAssetCopyWith<$Res> get logos;
  $AppLoginDesignCopyWith<$Res>? get login;
}

/// @nodoc
class _$AppDesignCopyWithImpl<$Res, $Val extends AppDesign>
    implements $AppDesignCopyWith<$Res> {
  _$AppDesignCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? colors = null,
    Object? favicons = null,
    Object? logos = null,
    Object? appicon = null,
    Object? login = freezed,
    Object? footerFormat = freezed,
  }) {
    return _then(_value.copyWith(
      colors: null == colors
          ? _value.colors
          : colors // ignore: cast_nullable_to_non_nullable
              as AppThemedColors,
      favicons: null == favicons
          ? _value.favicons
          : favicons // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      logos: null == logos
          ? _value.logos
          : logos // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      appicon: null == appicon
          ? _value.appicon
          : appicon // ignore: cast_nullable_to_non_nullable
              as String,
      login: freezed == login
          ? _value.login
          : login // ignore: cast_nullable_to_non_nullable
              as AppLoginDesign?,
      footerFormat: freezed == footerFormat
          ? _value.footerFormat
          : footerFormat // ignore: cast_nullable_to_non_nullable
              as FooterFormat?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AppThemedColorsCopyWith<$Res> get colors {
    return $AppThemedColorsCopyWith<$Res>(_value.colors, (value) {
      return _then(_value.copyWith(colors: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppThemedAssetCopyWith<$Res> get favicons {
    return $AppThemedAssetCopyWith<$Res>(_value.favicons, (value) {
      return _then(_value.copyWith(favicons: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppThemedAssetCopyWith<$Res> get logos {
    return $AppThemedAssetCopyWith<$Res>(_value.logos, (value) {
      return _then(_value.copyWith(logos: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AppLoginDesignCopyWith<$Res>? get login {
    if (_value.login == null) {
      return null;
    }

    return $AppLoginDesignCopyWith<$Res>(_value.login!, (value) {
      return _then(_value.copyWith(login: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AppDesignCopyWith<$Res> implements $AppDesignCopyWith<$Res> {
  factory _$$_AppDesignCopyWith(
          _$_AppDesign value, $Res Function(_$_AppDesign) then) =
      __$$_AppDesignCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {AppThemedColors colors,
      AppThemedAsset favicons,
      AppThemedAsset logos,
      String appicon,
      AppLoginDesign? login,
      @FooterFormatOrNullConverter() FooterFormat? footerFormat});

  @override
  $AppThemedColorsCopyWith<$Res> get colors;
  @override
  $AppThemedAssetCopyWith<$Res> get favicons;
  @override
  $AppThemedAssetCopyWith<$Res> get logos;
  @override
  $AppLoginDesignCopyWith<$Res>? get login;
}

/// @nodoc
class __$$_AppDesignCopyWithImpl<$Res>
    extends _$AppDesignCopyWithImpl<$Res, _$_AppDesign>
    implements _$$_AppDesignCopyWith<$Res> {
  __$$_AppDesignCopyWithImpl(
      _$_AppDesign _value, $Res Function(_$_AppDesign) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? colors = null,
    Object? favicons = null,
    Object? logos = null,
    Object? appicon = null,
    Object? login = freezed,
    Object? footerFormat = freezed,
  }) {
    return _then(_$_AppDesign(
      colors: null == colors
          ? _value.colors
          : colors // ignore: cast_nullable_to_non_nullable
              as AppThemedColors,
      favicons: null == favicons
          ? _value.favicons
          : favicons // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      logos: null == logos
          ? _value.logos
          : logos // ignore: cast_nullable_to_non_nullable
              as AppThemedAsset,
      appicon: null == appicon
          ? _value.appicon
          : appicon // ignore: cast_nullable_to_non_nullable
              as String,
      login: freezed == login
          ? _value.login
          : login // ignore: cast_nullable_to_non_nullable
              as AppLoginDesign?,
      footerFormat: freezed == footerFormat
          ? _value.footerFormat
          : footerFormat // ignore: cast_nullable_to_non_nullable
              as FooterFormat?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppDesign implements _AppDesign {
  const _$_AppDesign(
      {required this.colors,
      required this.favicons,
      required this.logos,
      required this.appicon,
      this.login,
      @FooterFormatOrNullConverter() this.footerFormat});

  factory _$_AppDesign.fromJson(Map<String, dynamic> json) =>
      _$$_AppDesignFromJson(json);

  @override
  final AppThemedColors colors;
  @override
  final AppThemedAsset favicons;
  @override
  final AppThemedAsset logos;
  @override
  final String appicon;
  @override
  final AppLoginDesign? login;
  @override
  @FooterFormatOrNullConverter()
  final FooterFormat? footerFormat;

  @override
  String toString() {
    return 'AppDesign(colors: $colors, favicons: $favicons, logos: $logos, appicon: $appicon, login: $login, footerFormat: $footerFormat)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppDesign &&
            (identical(other.colors, colors) || other.colors == colors) &&
            (identical(other.favicons, favicons) ||
                other.favicons == favicons) &&
            (identical(other.logos, logos) || other.logos == logos) &&
            (identical(other.appicon, appicon) || other.appicon == appicon) &&
            (identical(other.login, login) || other.login == login) &&
            (identical(other.footerFormat, footerFormat) ||
                other.footerFormat == footerFormat));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, colors, favicons, logos, appicon, login, footerFormat);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppDesignCopyWith<_$_AppDesign> get copyWith =>
      __$$_AppDesignCopyWithImpl<_$_AppDesign>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppDesignToJson(
      this,
    );
  }
}

abstract class _AppDesign implements AppDesign {
  const factory _AppDesign(
          {required final AppThemedColors colors,
          required final AppThemedAsset favicons,
          required final AppThemedAsset logos,
          required final String appicon,
          final AppLoginDesign? login,
          @FooterFormatOrNullConverter() final FooterFormat? footerFormat}) =
      _$_AppDesign;

  factory _AppDesign.fromJson(Map<String, dynamic> json) =
      _$_AppDesign.fromJson;

  @override
  AppThemedColors get colors;
  @override
  AppThemedAsset get favicons;
  @override
  AppThemedAsset get logos;
  @override
  String get appicon;
  @override
  AppLoginDesign? get login;
  @override
  @FooterFormatOrNullConverter()
  FooterFormat? get footerFormat;
  @override
  @JsonKey(ignore: true)
  _$$_AppDesignCopyWith<_$_AppDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

AppFooter _$AppFooterFromJson(Map<String, dynamic> json) {
  return _AppFooter.fromJson(json);
}

/// @nodoc
mixin _$AppFooter {
  @FooterFormatConverter()
  FooterFormat get mode => throw _privateConstructorUsedError;
  String? get custom => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppFooterCopyWith<AppFooter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppFooterCopyWith<$Res> {
  factory $AppFooterCopyWith(AppFooter value, $Res Function(AppFooter) then) =
      _$AppFooterCopyWithImpl<$Res, AppFooter>;
  @useResult
  $Res call({@FooterFormatConverter() FooterFormat mode, String? custom});
}

/// @nodoc
class _$AppFooterCopyWithImpl<$Res, $Val extends AppFooter>
    implements $AppFooterCopyWith<$Res> {
  _$AppFooterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
    Object? custom = freezed,
  }) {
    return _then(_value.copyWith(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FooterFormat,
      custom: freezed == custom
          ? _value.custom
          : custom // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppFooterCopyWith<$Res> implements $AppFooterCopyWith<$Res> {
  factory _$$_AppFooterCopyWith(
          _$_AppFooter value, $Res Function(_$_AppFooter) then) =
      __$$_AppFooterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@FooterFormatConverter() FooterFormat mode, String? custom});
}

/// @nodoc
class __$$_AppFooterCopyWithImpl<$Res>
    extends _$AppFooterCopyWithImpl<$Res, _$_AppFooter>
    implements _$$_AppFooterCopyWith<$Res> {
  __$$_AppFooterCopyWithImpl(
      _$_AppFooter _value, $Res Function(_$_AppFooter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
    Object? custom = freezed,
  }) {
    return _then(_$_AppFooter(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as FooterFormat,
      custom: freezed == custom
          ? _value.custom
          : custom // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppFooter implements _AppFooter {
  const _$_AppFooter(
      {@FooterFormatConverter() required this.mode, this.custom});

  factory _$_AppFooter.fromJson(Map<String, dynamic> json) =>
      _$$_AppFooterFromJson(json);

  @override
  @FooterFormatConverter()
  final FooterFormat mode;
  @override
  final String? custom;

  @override
  String toString() {
    return 'AppFooter(mode: $mode, custom: $custom)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppFooter &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.custom, custom) || other.custom == custom));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, mode, custom);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppFooterCopyWith<_$_AppFooter> get copyWith =>
      __$$_AppFooterCopyWithImpl<_$_AppFooter>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppFooterToJson(
      this,
    );
  }
}

abstract class _AppFooter implements AppFooter {
  const factory _AppFooter(
      {@FooterFormatConverter() required final FooterFormat mode,
      final String? custom}) = _$_AppFooter;

  factory _AppFooter.fromJson(Map<String, dynamic> json) =
      _$_AppFooter.fromJson;

  @override
  @FooterFormatConverter()
  FooterFormat get mode;
  @override
  String? get custom;
  @override
  @JsonKey(ignore: true)
  _$$_AppFooterCopyWith<_$_AppFooter> get copyWith =>
      throw _privateConstructorUsedError;
}

AppInstance _$AppInstanceFromJson(Map<String, dynamic> json) {
  return _AppInstance.fromJson(json);
}

/// @nodoc
mixin _$AppInstance {
  String get id => throw _privateConstructorUsedError;
  String get appId => throw _privateConstructorUsedError;
  @AppPlatformConverter()
  AppPlatform get platform => throw _privateConstructorUsedError;
  String? get host => throw _privateConstructorUsedError;
  bool? get isDeployed => throw _privateConstructorUsedError;
  String? get appIdentifier => throw _privateConstructorUsedError;
  String? get developerName => throw _privateConstructorUsedError;
  String? get developerIdentifier => throw _privateConstructorUsedError;
  List<AppBuild> get builds => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppInstanceCopyWith<AppInstance> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppInstanceCopyWith<$Res> {
  factory $AppInstanceCopyWith(
          AppInstance value, $Res Function(AppInstance) then) =
      _$AppInstanceCopyWithImpl<$Res, AppInstance>;
  @useResult
  $Res call(
      {String id,
      String appId,
      @AppPlatformConverter() AppPlatform platform,
      String? host,
      bool? isDeployed,
      String? appIdentifier,
      String? developerName,
      String? developerIdentifier,
      List<AppBuild> builds});
}

/// @nodoc
class _$AppInstanceCopyWithImpl<$Res, $Val extends AppInstance>
    implements $AppInstanceCopyWith<$Res> {
  _$AppInstanceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? appId = null,
    Object? platform = null,
    Object? host = freezed,
    Object? isDeployed = freezed,
    Object? appIdentifier = freezed,
    Object? developerName = freezed,
    Object? developerIdentifier = freezed,
    Object? builds = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      appId: null == appId
          ? _value.appId
          : appId // ignore: cast_nullable_to_non_nullable
              as String,
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as AppPlatform,
      host: freezed == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeployed: freezed == isDeployed
          ? _value.isDeployed
          : isDeployed // ignore: cast_nullable_to_non_nullable
              as bool?,
      appIdentifier: freezed == appIdentifier
          ? _value.appIdentifier
          : appIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      developerName: freezed == developerName
          ? _value.developerName
          : developerName // ignore: cast_nullable_to_non_nullable
              as String?,
      developerIdentifier: freezed == developerIdentifier
          ? _value.developerIdentifier
          : developerIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      builds: null == builds
          ? _value.builds
          : builds // ignore: cast_nullable_to_non_nullable
              as List<AppBuild>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppInstanceCopyWith<$Res>
    implements $AppInstanceCopyWith<$Res> {
  factory _$$_AppInstanceCopyWith(
          _$_AppInstance value, $Res Function(_$_AppInstance) then) =
      __$$_AppInstanceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String appId,
      @AppPlatformConverter() AppPlatform platform,
      String? host,
      bool? isDeployed,
      String? appIdentifier,
      String? developerName,
      String? developerIdentifier,
      List<AppBuild> builds});
}

/// @nodoc
class __$$_AppInstanceCopyWithImpl<$Res>
    extends _$AppInstanceCopyWithImpl<$Res, _$_AppInstance>
    implements _$$_AppInstanceCopyWith<$Res> {
  __$$_AppInstanceCopyWithImpl(
      _$_AppInstance _value, $Res Function(_$_AppInstance) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? appId = null,
    Object? platform = null,
    Object? host = freezed,
    Object? isDeployed = freezed,
    Object? appIdentifier = freezed,
    Object? developerName = freezed,
    Object? developerIdentifier = freezed,
    Object? builds = null,
  }) {
    return _then(_$_AppInstance(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      appId: null == appId
          ? _value.appId
          : appId // ignore: cast_nullable_to_non_nullable
              as String,
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as AppPlatform,
      host: freezed == host
          ? _value.host
          : host // ignore: cast_nullable_to_non_nullable
              as String?,
      isDeployed: freezed == isDeployed
          ? _value.isDeployed
          : isDeployed // ignore: cast_nullable_to_non_nullable
              as bool?,
      appIdentifier: freezed == appIdentifier
          ? _value.appIdentifier
          : appIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      developerName: freezed == developerName
          ? _value.developerName
          : developerName // ignore: cast_nullable_to_non_nullable
              as String?,
      developerIdentifier: freezed == developerIdentifier
          ? _value.developerIdentifier
          : developerIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      builds: null == builds
          ? _value._builds
          : builds // ignore: cast_nullable_to_non_nullable
              as List<AppBuild>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppInstance implements _AppInstance {
  const _$_AppInstance(
      {required this.id,
      required this.appId,
      @AppPlatformConverter() required this.platform,
      this.host,
      this.isDeployed,
      this.appIdentifier,
      this.developerName,
      this.developerIdentifier,
      final List<AppBuild> builds = const []})
      : _builds = builds;

  factory _$_AppInstance.fromJson(Map<String, dynamic> json) =>
      _$$_AppInstanceFromJson(json);

  @override
  final String id;
  @override
  final String appId;
  @override
  @AppPlatformConverter()
  final AppPlatform platform;
  @override
  final String? host;
  @override
  final bool? isDeployed;
  @override
  final String? appIdentifier;
  @override
  final String? developerName;
  @override
  final String? developerIdentifier;
  final List<AppBuild> _builds;
  @override
  @JsonKey()
  List<AppBuild> get builds {
    if (_builds is EqualUnmodifiableListView) return _builds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_builds);
  }

  @override
  String toString() {
    return 'AppInstance(id: $id, appId: $appId, platform: $platform, host: $host, isDeployed: $isDeployed, appIdentifier: $appIdentifier, developerName: $developerName, developerIdentifier: $developerIdentifier, builds: $builds)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppInstance &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.appId, appId) || other.appId == appId) &&
            (identical(other.platform, platform) ||
                other.platform == platform) &&
            (identical(other.host, host) || other.host == host) &&
            (identical(other.isDeployed, isDeployed) ||
                other.isDeployed == isDeployed) &&
            (identical(other.appIdentifier, appIdentifier) ||
                other.appIdentifier == appIdentifier) &&
            (identical(other.developerName, developerName) ||
                other.developerName == developerName) &&
            (identical(other.developerIdentifier, developerIdentifier) ||
                other.developerIdentifier == developerIdentifier) &&
            const DeepCollectionEquality().equals(other._builds, _builds));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      appId,
      platform,
      host,
      isDeployed,
      appIdentifier,
      developerName,
      developerIdentifier,
      const DeepCollectionEquality().hash(_builds));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppInstanceCopyWith<_$_AppInstance> get copyWith =>
      __$$_AppInstanceCopyWithImpl<_$_AppInstance>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppInstanceToJson(
      this,
    );
  }
}

abstract class _AppInstance implements AppInstance {
  const factory _AppInstance(
      {required final String id,
      required final String appId,
      @AppPlatformConverter() required final AppPlatform platform,
      final String? host,
      final bool? isDeployed,
      final String? appIdentifier,
      final String? developerName,
      final String? developerIdentifier,
      final List<AppBuild> builds}) = _$_AppInstance;

  factory _AppInstance.fromJson(Map<String, dynamic> json) =
      _$_AppInstance.fromJson;

  @override
  String get id;
  @override
  String get appId;
  @override
  @AppPlatformConverter()
  AppPlatform get platform;
  @override
  String? get host;
  @override
  bool? get isDeployed;
  @override
  String? get appIdentifier;
  @override
  String? get developerName;
  @override
  String? get developerIdentifier;
  @override
  List<AppBuild> get builds;
  @override
  @JsonKey(ignore: true)
  _$$_AppInstanceCopyWith<_$_AppInstance> get copyWith =>
      throw _privateConstructorUsedError;
}

AppLegal _$AppLegalFromJson(Map<String, dynamic> json) {
  return _AppLegal.fromJson(json);
}

/// @nodoc
mixin _$AppLegal {
  String get companyName => throw _privateConstructorUsedError;
  String get companyUrl => throw _privateConstructorUsedError;
  String get privacyPolicy => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppLegalCopyWith<AppLegal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppLegalCopyWith<$Res> {
  factory $AppLegalCopyWith(AppLegal value, $Res Function(AppLegal) then) =
      _$AppLegalCopyWithImpl<$Res, AppLegal>;
  @useResult
  $Res call({String companyName, String companyUrl, String privacyPolicy});
}

/// @nodoc
class _$AppLegalCopyWithImpl<$Res, $Val extends AppLegal>
    implements $AppLegalCopyWith<$Res> {
  _$AppLegalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? companyName = null,
    Object? companyUrl = null,
    Object? privacyPolicy = null,
  }) {
    return _then(_value.copyWith(
      companyName: null == companyName
          ? _value.companyName
          : companyName // ignore: cast_nullable_to_non_nullable
              as String,
      companyUrl: null == companyUrl
          ? _value.companyUrl
          : companyUrl // ignore: cast_nullable_to_non_nullable
              as String,
      privacyPolicy: null == privacyPolicy
          ? _value.privacyPolicy
          : privacyPolicy // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppLegalCopyWith<$Res> implements $AppLegalCopyWith<$Res> {
  factory _$$_AppLegalCopyWith(
          _$_AppLegal value, $Res Function(_$_AppLegal) then) =
      __$$_AppLegalCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String companyName, String companyUrl, String privacyPolicy});
}

/// @nodoc
class __$$_AppLegalCopyWithImpl<$Res>
    extends _$AppLegalCopyWithImpl<$Res, _$_AppLegal>
    implements _$$_AppLegalCopyWith<$Res> {
  __$$_AppLegalCopyWithImpl(
      _$_AppLegal _value, $Res Function(_$_AppLegal) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? companyName = null,
    Object? companyUrl = null,
    Object? privacyPolicy = null,
  }) {
    return _then(_$_AppLegal(
      companyName: null == companyName
          ? _value.companyName
          : companyName // ignore: cast_nullable_to_non_nullable
              as String,
      companyUrl: null == companyUrl
          ? _value.companyUrl
          : companyUrl // ignore: cast_nullable_to_non_nullable
              as String,
      privacyPolicy: null == privacyPolicy
          ? _value.privacyPolicy
          : privacyPolicy // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppLegal implements _AppLegal {
  const _$_AppLegal(
      {required this.companyName,
      required this.companyUrl,
      required this.privacyPolicy});

  factory _$_AppLegal.fromJson(Map<String, dynamic> json) =>
      _$$_AppLegalFromJson(json);

  @override
  final String companyName;
  @override
  final String companyUrl;
  @override
  final String privacyPolicy;

  @override
  String toString() {
    return 'AppLegal(companyName: $companyName, companyUrl: $companyUrl, privacyPolicy: $privacyPolicy)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppLegal &&
            (identical(other.companyName, companyName) ||
                other.companyName == companyName) &&
            (identical(other.companyUrl, companyUrl) ||
                other.companyUrl == companyUrl) &&
            (identical(other.privacyPolicy, privacyPolicy) ||
                other.privacyPolicy == privacyPolicy));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, companyName, companyUrl, privacyPolicy);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppLegalCopyWith<_$_AppLegal> get copyWith =>
      __$$_AppLegalCopyWithImpl<_$_AppLegal>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppLegalToJson(
      this,
    );
  }
}

abstract class _AppLegal implements AppLegal {
  const factory _AppLegal(
      {required final String companyName,
      required final String companyUrl,
      required final String privacyPolicy}) = _$_AppLegal;

  factory _AppLegal.fromJson(Map<String, dynamic> json) = _$_AppLegal.fromJson;

  @override
  String get companyName;
  @override
  String get companyUrl;
  @override
  String get privacyPolicy;
  @override
  @JsonKey(ignore: true)
  _$$_AppLegalCopyWith<_$_AppLegal> get copyWith =>
      throw _privateConstructorUsedError;
}

AppLoginDesign _$AppLoginDesignFromJson(Map<String, dynamic> json) {
  return _AppLoginDesign.fromJson(json);
}

/// @nodoc
mixin _$AppLoginDesign {
  @LoginLayoutModeConverter()
  LoginLayoutMode get layout => throw _privateConstructorUsedError;
  @TitleModeConverter()
  TitleMode get title => throw _privateConstructorUsedError;
  AppBackgroundDesign get background => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppLoginDesignCopyWith<AppLoginDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppLoginDesignCopyWith<$Res> {
  factory $AppLoginDesignCopyWith(
          AppLoginDesign value, $Res Function(AppLoginDesign) then) =
      _$AppLoginDesignCopyWithImpl<$Res, AppLoginDesign>;
  @useResult
  $Res call(
      {@LoginLayoutModeConverter() LoginLayoutMode layout,
      @TitleModeConverter() TitleMode title,
      AppBackgroundDesign background});

  $AppBackgroundDesignCopyWith<$Res> get background;
}

/// @nodoc
class _$AppLoginDesignCopyWithImpl<$Res, $Val extends AppLoginDesign>
    implements $AppLoginDesignCopyWith<$Res> {
  _$AppLoginDesignCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? layout = null,
    Object? title = null,
    Object? background = null,
  }) {
    return _then(_value.copyWith(
      layout: null == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as LoginLayoutMode,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as TitleMode,
      background: null == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as AppBackgroundDesign,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AppBackgroundDesignCopyWith<$Res> get background {
    return $AppBackgroundDesignCopyWith<$Res>(_value.background, (value) {
      return _then(_value.copyWith(background: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AppLoginDesignCopyWith<$Res>
    implements $AppLoginDesignCopyWith<$Res> {
  factory _$$_AppLoginDesignCopyWith(
          _$_AppLoginDesign value, $Res Function(_$_AppLoginDesign) then) =
      __$$_AppLoginDesignCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@LoginLayoutModeConverter() LoginLayoutMode layout,
      @TitleModeConverter() TitleMode title,
      AppBackgroundDesign background});

  @override
  $AppBackgroundDesignCopyWith<$Res> get background;
}

/// @nodoc
class __$$_AppLoginDesignCopyWithImpl<$Res>
    extends _$AppLoginDesignCopyWithImpl<$Res, _$_AppLoginDesign>
    implements _$$_AppLoginDesignCopyWith<$Res> {
  __$$_AppLoginDesignCopyWithImpl(
      _$_AppLoginDesign _value, $Res Function(_$_AppLoginDesign) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? layout = null,
    Object? title = null,
    Object? background = null,
  }) {
    return _then(_$_AppLoginDesign(
      layout: null == layout
          ? _value.layout
          : layout // ignore: cast_nullable_to_non_nullable
              as LoginLayoutMode,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as TitleMode,
      background: null == background
          ? _value.background
          : background // ignore: cast_nullable_to_non_nullable
              as AppBackgroundDesign,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppLoginDesign implements _AppLoginDesign {
  const _$_AppLoginDesign(
      {@LoginLayoutModeConverter() required this.layout,
      @TitleModeConverter() required this.title,
      required this.background});

  factory _$_AppLoginDesign.fromJson(Map<String, dynamic> json) =>
      _$$_AppLoginDesignFromJson(json);

  @override
  @LoginLayoutModeConverter()
  final LoginLayoutMode layout;
  @override
  @TitleModeConverter()
  final TitleMode title;
  @override
  final AppBackgroundDesign background;

  @override
  String toString() {
    return 'AppLoginDesign(layout: $layout, title: $title, background: $background)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppLoginDesign &&
            (identical(other.layout, layout) || other.layout == layout) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.background, background) ||
                other.background == background));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, layout, title, background);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppLoginDesignCopyWith<_$_AppLoginDesign> get copyWith =>
      __$$_AppLoginDesignCopyWithImpl<_$_AppLoginDesign>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppLoginDesignToJson(
      this,
    );
  }
}

abstract class _AppLoginDesign implements AppLoginDesign {
  const factory _AppLoginDesign(
      {@LoginLayoutModeConverter() required final LoginLayoutMode layout,
      @TitleModeConverter() required final TitleMode title,
      required final AppBackgroundDesign background}) = _$_AppLoginDesign;

  factory _AppLoginDesign.fromJson(Map<String, dynamic> json) =
      _$_AppLoginDesign.fromJson;

  @override
  @LoginLayoutModeConverter()
  LoginLayoutMode get layout;
  @override
  @TitleModeConverter()
  TitleMode get title;
  @override
  AppBackgroundDesign get background;
  @override
  @JsonKey(ignore: true)
  _$$_AppLoginDesignCopyWith<_$_AppLoginDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

LegacyAppLoginDesign _$LegacyAppLoginDesignFromJson(Map<String, dynamic> json) {
  return _LegacyAppLoginDesign.fromJson(json);
}

/// @nodoc
mixin _$LegacyAppLoginDesign {
  @LoginLayoutModeConverter()
  LoginLayoutMode get mode => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LegacyAppLoginDesignCopyWith<LegacyAppLoginDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LegacyAppLoginDesignCopyWith<$Res> {
  factory $LegacyAppLoginDesignCopyWith(LegacyAppLoginDesign value,
          $Res Function(LegacyAppLoginDesign) then) =
      _$LegacyAppLoginDesignCopyWithImpl<$Res, LegacyAppLoginDesign>;
  @useResult
  $Res call({@LoginLayoutModeConverter() LoginLayoutMode mode});
}

/// @nodoc
class _$LegacyAppLoginDesignCopyWithImpl<$Res,
        $Val extends LegacyAppLoginDesign>
    implements $LegacyAppLoginDesignCopyWith<$Res> {
  _$LegacyAppLoginDesignCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
  }) {
    return _then(_value.copyWith(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as LoginLayoutMode,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LegacyAppLoginDesignCopyWith<$Res>
    implements $LegacyAppLoginDesignCopyWith<$Res> {
  factory _$$_LegacyAppLoginDesignCopyWith(_$_LegacyAppLoginDesign value,
          $Res Function(_$_LegacyAppLoginDesign) then) =
      __$$_LegacyAppLoginDesignCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@LoginLayoutModeConverter() LoginLayoutMode mode});
}

/// @nodoc
class __$$_LegacyAppLoginDesignCopyWithImpl<$Res>
    extends _$LegacyAppLoginDesignCopyWithImpl<$Res, _$_LegacyAppLoginDesign>
    implements _$$_LegacyAppLoginDesignCopyWith<$Res> {
  __$$_LegacyAppLoginDesignCopyWithImpl(_$_LegacyAppLoginDesign _value,
      $Res Function(_$_LegacyAppLoginDesign) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
  }) {
    return _then(_$_LegacyAppLoginDesign(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as LoginLayoutMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_LegacyAppLoginDesign implements _LegacyAppLoginDesign {
  const _$_LegacyAppLoginDesign(
      {@LoginLayoutModeConverter() required this.mode});

  factory _$_LegacyAppLoginDesign.fromJson(Map<String, dynamic> json) =>
      _$$_LegacyAppLoginDesignFromJson(json);

  @override
  @LoginLayoutModeConverter()
  final LoginLayoutMode mode;

  @override
  String toString() {
    return 'LegacyAppLoginDesign(mode: $mode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LegacyAppLoginDesign &&
            (identical(other.mode, mode) || other.mode == mode));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, mode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LegacyAppLoginDesignCopyWith<_$_LegacyAppLoginDesign> get copyWith =>
      __$$_LegacyAppLoginDesignCopyWithImpl<_$_LegacyAppLoginDesign>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LegacyAppLoginDesignToJson(
      this,
    );
  }
}

abstract class _LegacyAppLoginDesign implements LegacyAppLoginDesign {
  const factory _LegacyAppLoginDesign(
          {@LoginLayoutModeConverter() required final LoginLayoutMode mode}) =
      _$_LegacyAppLoginDesign;

  factory _LegacyAppLoginDesign.fromJson(Map<String, dynamic> json) =
      _$_LegacyAppLoginDesign.fromJson;

  @override
  @LoginLayoutModeConverter()
  LoginLayoutMode get mode;
  @override
  @JsonKey(ignore: true)
  _$$_LegacyAppLoginDesignCopyWith<_$_LegacyAppLoginDesign> get copyWith =>
      throw _privateConstructorUsedError;
}

AppTitleMode _$AppTitleModeFromJson(Map<String, dynamic> json) {
  return _AppTitleMode.fromJson(json);
}

/// @nodoc
mixin _$AppTitleMode {
  @TitleModeConverter()
  TitleMode get mode => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppTitleModeCopyWith<AppTitleMode> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppTitleModeCopyWith<$Res> {
  factory $AppTitleModeCopyWith(
          AppTitleMode value, $Res Function(AppTitleMode) then) =
      _$AppTitleModeCopyWithImpl<$Res, AppTitleMode>;
  @useResult
  $Res call({@TitleModeConverter() TitleMode mode});
}

/// @nodoc
class _$AppTitleModeCopyWithImpl<$Res, $Val extends AppTitleMode>
    implements $AppTitleModeCopyWith<$Res> {
  _$AppTitleModeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
  }) {
    return _then(_value.copyWith(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as TitleMode,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppTitleModeCopyWith<$Res>
    implements $AppTitleModeCopyWith<$Res> {
  factory _$$_AppTitleModeCopyWith(
          _$_AppTitleMode value, $Res Function(_$_AppTitleMode) then) =
      __$$_AppTitleModeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@TitleModeConverter() TitleMode mode});
}

/// @nodoc
class __$$_AppTitleModeCopyWithImpl<$Res>
    extends _$AppTitleModeCopyWithImpl<$Res, _$_AppTitleMode>
    implements _$$_AppTitleModeCopyWith<$Res> {
  __$$_AppTitleModeCopyWithImpl(
      _$_AppTitleMode _value, $Res Function(_$_AppTitleMode) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mode = null,
  }) {
    return _then(_$_AppTitleMode(
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as TitleMode,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppTitleMode implements _AppTitleMode {
  const _$_AppTitleMode({@TitleModeConverter() required this.mode});

  factory _$_AppTitleMode.fromJson(Map<String, dynamic> json) =>
      _$$_AppTitleModeFromJson(json);

  @override
  @TitleModeConverter()
  final TitleMode mode;

  @override
  String toString() {
    return 'AppTitleMode(mode: $mode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppTitleMode &&
            (identical(other.mode, mode) || other.mode == mode));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, mode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppTitleModeCopyWith<_$_AppTitleMode> get copyWith =>
      __$$_AppTitleModeCopyWithImpl<_$_AppTitleMode>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppTitleModeToJson(
      this,
    );
  }
}

abstract class _AppTitleMode implements AppTitleMode {
  const factory _AppTitleMode(
      {@TitleModeConverter() required final TitleMode mode}) = _$_AppTitleMode;

  factory _AppTitleMode.fromJson(Map<String, dynamic> json) =
      _$_AppTitleMode.fromJson;

  @override
  @TitleModeConverter()
  TitleMode get mode;
  @override
  @JsonKey(ignore: true)
  _$$_AppTitleModeCopyWith<_$_AppTitleMode> get copyWith =>
      throw _privateConstructorUsedError;
}

AppVersion _$AppVersionFromJson(Map<String, dynamic> json) {
  return _AppVersion.fromJson(json);
}

/// @nodoc
mixin _$AppVersion {
  String get id => throw _privateConstructorUsedError;
  @AppInternalIdentifierConverter()
  AppInternalIdentifier get app => throw _privateConstructorUsedError;
  @AppPlatformConverter()
  AppPlatform get platform => throw _privateConstructorUsedError;
  String? get fileUri => throw _privateConstructorUsedError;
  int get buildNumber => throw _privateConstructorUsedError;
  String get buildName => throw _privateConstructorUsedError;
  @TimestampConverter()
  DateTime get releasedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppVersionCopyWith<AppVersion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppVersionCopyWith<$Res> {
  factory $AppVersionCopyWith(
          AppVersion value, $Res Function(AppVersion) then) =
      _$AppVersionCopyWithImpl<$Res, AppVersion>;
  @useResult
  $Res call(
      {String id,
      @AppInternalIdentifierConverter() AppInternalIdentifier app,
      @AppPlatformConverter() AppPlatform platform,
      String? fileUri,
      int buildNumber,
      String buildName,
      @TimestampConverter() DateTime releasedAt});
}

/// @nodoc
class _$AppVersionCopyWithImpl<$Res, $Val extends AppVersion>
    implements $AppVersionCopyWith<$Res> {
  _$AppVersionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? app = null,
    Object? platform = null,
    Object? fileUri = freezed,
    Object? buildNumber = null,
    Object? buildName = null,
    Object? releasedAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      app: null == app
          ? _value.app
          : app // ignore: cast_nullable_to_non_nullable
              as AppInternalIdentifier,
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as AppPlatform,
      fileUri: freezed == fileUri
          ? _value.fileUri
          : fileUri // ignore: cast_nullable_to_non_nullable
              as String?,
      buildNumber: null == buildNumber
          ? _value.buildNumber
          : buildNumber // ignore: cast_nullable_to_non_nullable
              as int,
      buildName: null == buildName
          ? _value.buildName
          : buildName // ignore: cast_nullable_to_non_nullable
              as String,
      releasedAt: null == releasedAt
          ? _value.releasedAt
          : releasedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AppVersionCopyWith<$Res>
    implements $AppVersionCopyWith<$Res> {
  factory _$$_AppVersionCopyWith(
          _$_AppVersion value, $Res Function(_$_AppVersion) then) =
      __$$_AppVersionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @AppInternalIdentifierConverter() AppInternalIdentifier app,
      @AppPlatformConverter() AppPlatform platform,
      String? fileUri,
      int buildNumber,
      String buildName,
      @TimestampConverter() DateTime releasedAt});
}

/// @nodoc
class __$$_AppVersionCopyWithImpl<$Res>
    extends _$AppVersionCopyWithImpl<$Res, _$_AppVersion>
    implements _$$_AppVersionCopyWith<$Res> {
  __$$_AppVersionCopyWithImpl(
      _$_AppVersion _value, $Res Function(_$_AppVersion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? app = null,
    Object? platform = null,
    Object? fileUri = freezed,
    Object? buildNumber = null,
    Object? buildName = null,
    Object? releasedAt = null,
  }) {
    return _then(_$_AppVersion(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      app: null == app
          ? _value.app
          : app // ignore: cast_nullable_to_non_nullable
              as AppInternalIdentifier,
      platform: null == platform
          ? _value.platform
          : platform // ignore: cast_nullable_to_non_nullable
              as AppPlatform,
      fileUri: freezed == fileUri
          ? _value.fileUri
          : fileUri // ignore: cast_nullable_to_non_nullable
              as String?,
      buildNumber: null == buildNumber
          ? _value.buildNumber
          : buildNumber // ignore: cast_nullable_to_non_nullable
              as int,
      buildName: null == buildName
          ? _value.buildName
          : buildName // ignore: cast_nullable_to_non_nullable
              as String,
      releasedAt: null == releasedAt
          ? _value.releasedAt
          : releasedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AppVersion implements _AppVersion {
  const _$_AppVersion(
      {required this.id,
      @AppInternalIdentifierConverter() required this.app,
      @AppPlatformConverter() required this.platform,
      this.fileUri,
      required this.buildNumber,
      required this.buildName,
      @TimestampConverter() required this.releasedAt});

  factory _$_AppVersion.fromJson(Map<String, dynamic> json) =>
      _$$_AppVersionFromJson(json);

  @override
  final String id;
  @override
  @AppInternalIdentifierConverter()
  final AppInternalIdentifier app;
  @override
  @AppPlatformConverter()
  final AppPlatform platform;
  @override
  final String? fileUri;
  @override
  final int buildNumber;
  @override
  final String buildName;
  @override
  @TimestampConverter()
  final DateTime releasedAt;

  @override
  String toString() {
    return 'AppVersion(id: $id, app: $app, platform: $platform, fileUri: $fileUri, buildNumber: $buildNumber, buildName: $buildName, releasedAt: $releasedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AppVersion &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.app, app) || other.app == app) &&
            (identical(other.platform, platform) ||
                other.platform == platform) &&
            (identical(other.fileUri, fileUri) || other.fileUri == fileUri) &&
            (identical(other.buildNumber, buildNumber) ||
                other.buildNumber == buildNumber) &&
            (identical(other.buildName, buildName) ||
                other.buildName == buildName) &&
            (identical(other.releasedAt, releasedAt) ||
                other.releasedAt == releasedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, app, platform, fileUri,
      buildNumber, buildName, releasedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AppVersionCopyWith<_$_AppVersion> get copyWith =>
      __$$_AppVersionCopyWithImpl<_$_AppVersion>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AppVersionToJson(
      this,
    );
  }
}

abstract class _AppVersion implements AppVersion {
  const factory _AppVersion(
          {required final String id,
          @AppInternalIdentifierConverter()
          required final AppInternalIdentifier app,
          @AppPlatformConverter() required final AppPlatform platform,
          final String? fileUri,
          required final int buildNumber,
          required final String buildName,
          @TimestampConverter() required final DateTime releasedAt}) =
      _$_AppVersion;

  factory _AppVersion.fromJson(Map<String, dynamic> json) =
      _$_AppVersion.fromJson;

  @override
  String get id;
  @override
  @AppInternalIdentifierConverter()
  AppInternalIdentifier get app;
  @override
  @AppPlatformConverter()
  AppPlatform get platform;
  @override
  String? get fileUri;
  @override
  int get buildNumber;
  @override
  String get buildName;
  @override
  @TimestampConverter()
  DateTime get releasedAt;
  @override
  @JsonKey(ignore: true)
  _$$_AppVersionCopyWith<_$_AppVersion> get copyWith =>
      throw _privateConstructorUsedError;
}

MapLayer _$MapLayerFromJson(Map<String, dynamic> json) {
  return _MapLayer.fromJson(json);
}

/// @nodoc
mixin _$MapLayer {
  /// [id] is the unique identifier for the layer.
  String get id => throw _privateConstructorUsedError;

  /// [name] is the name of the layer.
  String get name => throw _privateConstructorUsedError;

  /// [server] is the server that hosts the layer.
  /// Should be a valid URL with `{x}`, `{y}`, and `{z}` placeholders.
  String get server => throw _privateConstructorUsedError;

  /// [serverDark] is the server that hosts the layer for dark mode.
  /// Should be a valid URL with `{x}`, `{y}`, and `{z}` placeholders.
  /// If it is null, the [server] will be used.
  String? get serverDark => throw _privateConstructorUsedError;

  /// [type] is the type of the layer.
  /// It can be [MapLayerType.raster] or [MapLayerType.vector].
  /// By default, it is [MapLayerType.raster].
  @MapLayerTypeConverter()
  MapLayerType get type => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MapLayerCopyWith<MapLayer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapLayerCopyWith<$Res> {
  factory $MapLayerCopyWith(MapLayer value, $Res Function(MapLayer) then) =
      _$MapLayerCopyWithImpl<$Res, MapLayer>;
  @useResult
  $Res call(
      {String id,
      String name,
      String server,
      String? serverDark,
      @MapLayerTypeConverter() MapLayerType type});
}

/// @nodoc
class _$MapLayerCopyWithImpl<$Res, $Val extends MapLayer>
    implements $MapLayerCopyWith<$Res> {
  _$MapLayerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? server = null,
    Object? serverDark = freezed,
    Object? type = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      server: null == server
          ? _value.server
          : server // ignore: cast_nullable_to_non_nullable
              as String,
      serverDark: freezed == serverDark
          ? _value.serverDark
          : serverDark // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MapLayerType,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MapLayerCopyWith<$Res> implements $MapLayerCopyWith<$Res> {
  factory _$$_MapLayerCopyWith(
          _$_MapLayer value, $Res Function(_$_MapLayer) then) =
      __$$_MapLayerCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String server,
      String? serverDark,
      @MapLayerTypeConverter() MapLayerType type});
}

/// @nodoc
class __$$_MapLayerCopyWithImpl<$Res>
    extends _$MapLayerCopyWithImpl<$Res, _$_MapLayer>
    implements _$$_MapLayerCopyWith<$Res> {
  __$$_MapLayerCopyWithImpl(
      _$_MapLayer _value, $Res Function(_$_MapLayer) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? server = null,
    Object? serverDark = freezed,
    Object? type = null,
  }) {
    return _then(_$_MapLayer(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      server: null == server
          ? _value.server
          : server // ignore: cast_nullable_to_non_nullable
              as String,
      serverDark: freezed == serverDark
          ? _value.serverDark
          : serverDark // ignore: cast_nullable_to_non_nullable
              as String?,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as MapLayerType,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MapLayer implements _MapLayer {
  const _$_MapLayer(
      {required this.id,
      required this.name,
      required this.server,
      this.serverDark,
      @MapLayerTypeConverter() this.type = MapLayerType.raster});

  factory _$_MapLayer.fromJson(Map<String, dynamic> json) =>
      _$$_MapLayerFromJson(json);

  /// [id] is the unique identifier for the layer.
  @override
  final String id;

  /// [name] is the name of the layer.
  @override
  final String name;

  /// [server] is the server that hosts the layer.
  /// Should be a valid URL with `{x}`, `{y}`, and `{z}` placeholders.
  @override
  final String server;

  /// [serverDark] is the server that hosts the layer for dark mode.
  /// Should be a valid URL with `{x}`, `{y}`, and `{z}` placeholders.
  /// If it is null, the [server] will be used.
  @override
  final String? serverDark;

  /// [type] is the type of the layer.
  /// It can be [MapLayerType.raster] or [MapLayerType.vector].
  /// By default, it is [MapLayerType.raster].
  @override
  @JsonKey()
  @MapLayerTypeConverter()
  final MapLayerType type;

  @override
  String toString() {
    return 'MapLayer(id: $id, name: $name, server: $server, serverDark: $serverDark, type: $type)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MapLayer &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.server, server) || other.server == server) &&
            (identical(other.serverDark, serverDark) ||
                other.serverDark == serverDark) &&
            (identical(other.type, type) || other.type == type));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, name, server, serverDark, type);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MapLayerCopyWith<_$_MapLayer> get copyWith =>
      __$$_MapLayerCopyWithImpl<_$_MapLayer>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MapLayerToJson(
      this,
    );
  }
}

abstract class _MapLayer implements MapLayer {
  const factory _MapLayer(
      {required final String id,
      required final String name,
      required final String server,
      final String? serverDark,
      @MapLayerTypeConverter() final MapLayerType type}) = _$_MapLayer;

  factory _MapLayer.fromJson(Map<String, dynamic> json) = _$_MapLayer.fromJson;

  @override

  /// [id] is the unique identifier for the layer.
  String get id;
  @override

  /// [name] is the name of the layer.
  String get name;
  @override

  /// [server] is the server that hosts the layer.
  /// Should be a valid URL with `{x}`, `{y}`, and `{z}` placeholders.
  String get server;
  @override

  /// [serverDark] is the server that hosts the layer for dark mode.
  /// Should be a valid URL with `{x}`, `{y}`, and `{z}` placeholders.
  /// If it is null, the [server] will be used.
  String? get serverDark;
  @override

  /// [type] is the type of the layer.
  /// It can be [MapLayerType.raster] or [MapLayerType.vector].
  /// By default, it is [MapLayerType.raster].
  @MapLayerTypeConverter()
  MapLayerType get type;
  @override
  @JsonKey(ignore: true)
  _$$_MapLayerCopyWith<_$_MapLayer> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsEntry _$AtsEntryFromJson(Map<String, dynamic> json) {
  return _AtsEntry.fromJson(json);
}

/// @nodoc
mixin _$AtsEntry {
  /// ID of the volume. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// ID of the Asset
  String? get assetId => throw _privateConstructorUsedError;

  /// Asset linked to entry.
  Asset? get asset => throw _privateConstructorUsedError;

  /// Tank level at start of entry
  double? get oldTankLevel => throw _privateConstructorUsedError;

  /// Tank level at the end of the entry.
  double? get newTankLevel => throw _privateConstructorUsedError;

  /// Start entry date
  @TimestampOrNullConverter()
  DateTime? get startAt => throw _privateConstructorUsedError;

  /// End entry date
  @TimestampOrNullConverter()
  DateTime? get endAt => throw _privateConstructorUsedError;

  /// Represents error percent between reception and sensor entry.
  double? get errorPercent => throw _privateConstructorUsedError;

  /// Reception linked to entry.
  AtsReception? get reception => throw _privateConstructorUsedError;

  /// List of receptions linked to the entry. Please read the documentation for Reception for more details about the fields.
  List<AtsReception>? get receptions => throw _privateConstructorUsedError;

  /// True if the entry is linked to a purchase order.
  bool? get isLinked => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsEntryCopyWith<AtsEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsEntryCopyWith<$Res> {
  factory $AtsEntryCopyWith(AtsEntry value, $Res Function(AtsEntry) then) =
      _$AtsEntryCopyWithImpl<$Res, AtsEntry>;
  @useResult
  $Res call(
      {String id,
      String? assetId,
      Asset? asset,
      double? oldTankLevel,
      double? newTankLevel,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      double? errorPercent,
      AtsReception? reception,
      List<AtsReception>? receptions,
      bool? isLinked});

  $AssetCopyWith<$Res>? get asset;
  $AtsReceptionCopyWith<$Res>? get reception;
}

/// @nodoc
class _$AtsEntryCopyWithImpl<$Res, $Val extends AtsEntry>
    implements $AtsEntryCopyWith<$Res> {
  _$AtsEntryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? assetId = freezed,
    Object? asset = freezed,
    Object? oldTankLevel = freezed,
    Object? newTankLevel = freezed,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? errorPercent = freezed,
    Object? reception = freezed,
    Object? receptions = freezed,
    Object? isLinked = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      oldTankLevel: freezed == oldTankLevel
          ? _value.oldTankLevel
          : oldTankLevel // ignore: cast_nullable_to_non_nullable
              as double?,
      newTankLevel: freezed == newTankLevel
          ? _value.newTankLevel
          : newTankLevel // ignore: cast_nullable_to_non_nullable
              as double?,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      errorPercent: freezed == errorPercent
          ? _value.errorPercent
          : errorPercent // ignore: cast_nullable_to_non_nullable
              as double?,
      reception: freezed == reception
          ? _value.reception
          : reception // ignore: cast_nullable_to_non_nullable
              as AtsReception?,
      receptions: freezed == receptions
          ? _value.receptions
          : receptions // ignore: cast_nullable_to_non_nullable
              as List<AtsReception>?,
      isLinked: freezed == isLinked
          ? _value.isLinked
          : isLinked // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get asset {
    if (_value.asset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.asset!, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsReceptionCopyWith<$Res>? get reception {
    if (_value.reception == null) {
      return null;
    }

    return $AtsReceptionCopyWith<$Res>(_value.reception!, (value) {
      return _then(_value.copyWith(reception: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsEntryCopyWith<$Res> implements $AtsEntryCopyWith<$Res> {
  factory _$$_AtsEntryCopyWith(
          _$_AtsEntry value, $Res Function(_$_AtsEntry) then) =
      __$$_AtsEntryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String? assetId,
      Asset? asset,
      double? oldTankLevel,
      double? newTankLevel,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      double? errorPercent,
      AtsReception? reception,
      List<AtsReception>? receptions,
      bool? isLinked});

  @override
  $AssetCopyWith<$Res>? get asset;
  @override
  $AtsReceptionCopyWith<$Res>? get reception;
}

/// @nodoc
class __$$_AtsEntryCopyWithImpl<$Res>
    extends _$AtsEntryCopyWithImpl<$Res, _$_AtsEntry>
    implements _$$_AtsEntryCopyWith<$Res> {
  __$$_AtsEntryCopyWithImpl(
      _$_AtsEntry _value, $Res Function(_$_AtsEntry) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? assetId = freezed,
    Object? asset = freezed,
    Object? oldTankLevel = freezed,
    Object? newTankLevel = freezed,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? errorPercent = freezed,
    Object? reception = freezed,
    Object? receptions = freezed,
    Object? isLinked = freezed,
  }) {
    return _then(_$_AtsEntry(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      oldTankLevel: freezed == oldTankLevel
          ? _value.oldTankLevel
          : oldTankLevel // ignore: cast_nullable_to_non_nullable
              as double?,
      newTankLevel: freezed == newTankLevel
          ? _value.newTankLevel
          : newTankLevel // ignore: cast_nullable_to_non_nullable
              as double?,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      errorPercent: freezed == errorPercent
          ? _value.errorPercent
          : errorPercent // ignore: cast_nullable_to_non_nullable
              as double?,
      reception: freezed == reception
          ? _value.reception
          : reception // ignore: cast_nullable_to_non_nullable
              as AtsReception?,
      receptions: freezed == receptions
          ? _value._receptions
          : receptions // ignore: cast_nullable_to_non_nullable
              as List<AtsReception>?,
      isLinked: freezed == isLinked
          ? _value.isLinked
          : isLinked // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsEntry implements _AtsEntry {
  const _$_AtsEntry(
      {required this.id,
      this.assetId,
      this.asset,
      this.oldTankLevel,
      this.newTankLevel,
      @TimestampOrNullConverter() this.startAt,
      @TimestampOrNullConverter() this.endAt,
      this.errorPercent,
      this.reception,
      final List<AtsReception>? receptions,
      this.isLinked})
      : _receptions = receptions;

  factory _$_AtsEntry.fromJson(Map<String, dynamic> json) =>
      _$$_AtsEntryFromJson(json);

  /// ID of the volume. This ID is unique.
  @override
  final String id;

  /// ID of the Asset
  @override
  final String? assetId;

  /// Asset linked to entry.
  @override
  final Asset? asset;

  /// Tank level at start of entry
  @override
  final double? oldTankLevel;

  /// Tank level at the end of the entry.
  @override
  final double? newTankLevel;

  /// Start entry date
  @override
  @TimestampOrNullConverter()
  final DateTime? startAt;

  /// End entry date
  @override
  @TimestampOrNullConverter()
  final DateTime? endAt;

  /// Represents error percent between reception and sensor entry.
  @override
  final double? errorPercent;

  /// Reception linked to entry.
  @override
  final AtsReception? reception;

  /// List of receptions linked to the entry. Please read the documentation for Reception for more details about the fields.
  final List<AtsReception>? _receptions;

  /// List of receptions linked to the entry. Please read the documentation for Reception for more details about the fields.
  @override
  List<AtsReception>? get receptions {
    final value = _receptions;
    if (value == null) return null;
    if (_receptions is EqualUnmodifiableListView) return _receptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// True if the entry is linked to a purchase order.
  @override
  final bool? isLinked;

  @override
  String toString() {
    return 'AtsEntry(id: $id, assetId: $assetId, asset: $asset, oldTankLevel: $oldTankLevel, newTankLevel: $newTankLevel, startAt: $startAt, endAt: $endAt, errorPercent: $errorPercent, reception: $reception, receptions: $receptions, isLinked: $isLinked)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsEntry &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.oldTankLevel, oldTankLevel) ||
                other.oldTankLevel == oldTankLevel) &&
            (identical(other.newTankLevel, newTankLevel) ||
                other.newTankLevel == newTankLevel) &&
            (identical(other.startAt, startAt) || other.startAt == startAt) &&
            (identical(other.endAt, endAt) || other.endAt == endAt) &&
            (identical(other.errorPercent, errorPercent) ||
                other.errorPercent == errorPercent) &&
            (identical(other.reception, reception) ||
                other.reception == reception) &&
            const DeepCollectionEquality()
                .equals(other._receptions, _receptions) &&
            (identical(other.isLinked, isLinked) ||
                other.isLinked == isLinked));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      assetId,
      asset,
      oldTankLevel,
      newTankLevel,
      startAt,
      endAt,
      errorPercent,
      reception,
      const DeepCollectionEquality().hash(_receptions),
      isLinked);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsEntryCopyWith<_$_AtsEntry> get copyWith =>
      __$$_AtsEntryCopyWithImpl<_$_AtsEntry>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsEntryToJson(
      this,
    );
  }
}

abstract class _AtsEntry implements AtsEntry {
  const factory _AtsEntry(
      {required final String id,
      final String? assetId,
      final Asset? asset,
      final double? oldTankLevel,
      final double? newTankLevel,
      @TimestampOrNullConverter() final DateTime? startAt,
      @TimestampOrNullConverter() final DateTime? endAt,
      final double? errorPercent,
      final AtsReception? reception,
      final List<AtsReception>? receptions,
      final bool? isLinked}) = _$_AtsEntry;

  factory _AtsEntry.fromJson(Map<String, dynamic> json) = _$_AtsEntry.fromJson;

  @override

  /// ID of the volume. This ID is unique.
  String get id;
  @override

  /// ID of the Asset
  String? get assetId;
  @override

  /// Asset linked to entry.
  Asset? get asset;
  @override

  /// Tank level at start of entry
  double? get oldTankLevel;
  @override

  /// Tank level at the end of the entry.
  double? get newTankLevel;
  @override

  /// Start entry date
  @TimestampOrNullConverter()
  DateTime? get startAt;
  @override

  /// End entry date
  @TimestampOrNullConverter()
  DateTime? get endAt;
  @override

  /// Represents error percent between reception and sensor entry.
  double? get errorPercent;
  @override

  /// Reception linked to entry.
  AtsReception? get reception;
  @override

  /// List of receptions linked to the entry. Please read the documentation for Reception for more details about the fields.
  List<AtsReception>? get receptions;
  @override

  /// True if the entry is linked to a purchase order.
  bool? get isLinked;
  @override
  @JsonKey(ignore: true)
  _$$_AtsEntryCopyWith<_$_AtsEntry> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsReceptionProduct _$AtsReceptionProductFromJson(Map<String, dynamic> json) {
  return _AtsReceptionProduct.fromJson(json);
}

/// @nodoc
mixin _$AtsReceptionProduct {
  /// ID of the reception product. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the asset.
  String? get assetId => throw _privateConstructorUsedError;

  /// Fuel type enum. Check its possible values in the enum documentation.
  @AtsFuelTypeOrNullConverter()
  AtsFuelType? get fuelType => throw _privateConstructorUsedError;

  /// Volume received in purchased order (Expressed in Litters).
  double? get volumeBought => throw _privateConstructorUsedError;

  /// Total volume received, based on fuel type, density and temperature.
  double? get realVolume => throw _privateConstructorUsedError;

  /// Reception date and time expressed in unix timestamp.
  @TimestampOrNullConverter()
  DateTime? get receivedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsReceptionProductCopyWith<AtsReceptionProduct> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsReceptionProductCopyWith<$Res> {
  factory $AtsReceptionProductCopyWith(
          AtsReceptionProduct value, $Res Function(AtsReceptionProduct) then) =
      _$AtsReceptionProductCopyWithImpl<$Res, AtsReceptionProduct>;
  @useResult
  $Res call(
      {String? id,
      String? assetId,
      @AtsFuelTypeOrNullConverter() AtsFuelType? fuelType,
      double? volumeBought,
      double? realVolume,
      @TimestampOrNullConverter() DateTime? receivedAt});
}

/// @nodoc
class _$AtsReceptionProductCopyWithImpl<$Res, $Val extends AtsReceptionProduct>
    implements $AtsReceptionProductCopyWith<$Res> {
  _$AtsReceptionProductCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? assetId = freezed,
    Object? fuelType = freezed,
    Object? volumeBought = freezed,
    Object? realVolume = freezed,
    Object? receivedAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      fuelType: freezed == fuelType
          ? _value.fuelType
          : fuelType // ignore: cast_nullable_to_non_nullable
              as AtsFuelType?,
      volumeBought: freezed == volumeBought
          ? _value.volumeBought
          : volumeBought // ignore: cast_nullable_to_non_nullable
              as double?,
      realVolume: freezed == realVolume
          ? _value.realVolume
          : realVolume // ignore: cast_nullable_to_non_nullable
              as double?,
      receivedAt: freezed == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsReceptionProductCopyWith<$Res>
    implements $AtsReceptionProductCopyWith<$Res> {
  factory _$$_AtsReceptionProductCopyWith(_$_AtsReceptionProduct value,
          $Res Function(_$_AtsReceptionProduct) then) =
      __$$_AtsReceptionProductCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? assetId,
      @AtsFuelTypeOrNullConverter() AtsFuelType? fuelType,
      double? volumeBought,
      double? realVolume,
      @TimestampOrNullConverter() DateTime? receivedAt});
}

/// @nodoc
class __$$_AtsReceptionProductCopyWithImpl<$Res>
    extends _$AtsReceptionProductCopyWithImpl<$Res, _$_AtsReceptionProduct>
    implements _$$_AtsReceptionProductCopyWith<$Res> {
  __$$_AtsReceptionProductCopyWithImpl(_$_AtsReceptionProduct _value,
      $Res Function(_$_AtsReceptionProduct) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? assetId = freezed,
    Object? fuelType = freezed,
    Object? volumeBought = freezed,
    Object? realVolume = freezed,
    Object? receivedAt = freezed,
  }) {
    return _then(_$_AtsReceptionProduct(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      fuelType: freezed == fuelType
          ? _value.fuelType
          : fuelType // ignore: cast_nullable_to_non_nullable
              as AtsFuelType?,
      volumeBought: freezed == volumeBought
          ? _value.volumeBought
          : volumeBought // ignore: cast_nullable_to_non_nullable
              as double?,
      realVolume: freezed == realVolume
          ? _value.realVolume
          : realVolume // ignore: cast_nullable_to_non_nullable
              as double?,
      receivedAt: freezed == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsReceptionProduct implements _AtsReceptionProduct {
  const _$_AtsReceptionProduct(
      {this.id,
      this.assetId,
      @AtsFuelTypeOrNullConverter() this.fuelType,
      this.volumeBought,
      this.realVolume,
      @TimestampOrNullConverter() this.receivedAt});

  factory _$_AtsReceptionProduct.fromJson(Map<String, dynamic> json) =>
      _$$_AtsReceptionProductFromJson(json);

  /// ID of the reception product. This ID is unique.
  @override
  final String? id;

  /// ID of the asset.
  @override
  final String? assetId;

  /// Fuel type enum. Check its possible values in the enum documentation.
  @override
  @AtsFuelTypeOrNullConverter()
  final AtsFuelType? fuelType;

  /// Volume received in purchased order (Expressed in Litters).
  @override
  final double? volumeBought;

  /// Total volume received, based on fuel type, density and temperature.
  @override
  final double? realVolume;

  /// Reception date and time expressed in unix timestamp.
  @override
  @TimestampOrNullConverter()
  final DateTime? receivedAt;

  @override
  String toString() {
    return 'AtsReceptionProduct(id: $id, assetId: $assetId, fuelType: $fuelType, volumeBought: $volumeBought, realVolume: $realVolume, receivedAt: $receivedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsReceptionProduct &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.fuelType, fuelType) ||
                other.fuelType == fuelType) &&
            (identical(other.volumeBought, volumeBought) ||
                other.volumeBought == volumeBought) &&
            (identical(other.realVolume, realVolume) ||
                other.realVolume == realVolume) &&
            (identical(other.receivedAt, receivedAt) ||
                other.receivedAt == receivedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, assetId, fuelType, volumeBought, realVolume, receivedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsReceptionProductCopyWith<_$_AtsReceptionProduct> get copyWith =>
      __$$_AtsReceptionProductCopyWithImpl<_$_AtsReceptionProduct>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsReceptionProductToJson(
      this,
    );
  }
}

abstract class _AtsReceptionProduct implements AtsReceptionProduct {
  const factory _AtsReceptionProduct(
          {final String? id,
          final String? assetId,
          @AtsFuelTypeOrNullConverter() final AtsFuelType? fuelType,
          final double? volumeBought,
          final double? realVolume,
          @TimestampOrNullConverter() final DateTime? receivedAt}) =
      _$_AtsReceptionProduct;

  factory _AtsReceptionProduct.fromJson(Map<String, dynamic> json) =
      _$_AtsReceptionProduct.fromJson;

  @override

  /// ID of the reception product. This ID is unique.
  String? get id;
  @override

  /// ID of the asset.
  String? get assetId;
  @override

  /// Fuel type enum. Check its possible values in the enum documentation.
  @AtsFuelTypeOrNullConverter()
  AtsFuelType? get fuelType;
  @override

  /// Volume received in purchased order (Expressed in Litters).
  double? get volumeBought;
  @override

  /// Total volume received, based on fuel type, density and temperature.
  double? get realVolume;
  @override

  /// Reception date and time expressed in unix timestamp.
  @TimestampOrNullConverter()
  DateTime? get receivedAt;
  @override
  @JsonKey(ignore: true)
  _$$_AtsReceptionProductCopyWith<_$_AtsReceptionProduct> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsReceptionProductInput _$AtsReceptionProductInputFromJson(
    Map<String, dynamic> json) {
  return _AtsReceptionProductInput.fromJson(json);
}

/// @nodoc
mixin _$AtsReceptionProductInput {
  /// Fuel ANP category code
  String? get fuelAnp => throw _privateConstructorUsedError;

  /// Fuel ANP category code
  set fuelAnp(String? value) => throw _privateConstructorUsedError;

  /// List of tank photos
  List<String>? get tanksImages => throw _privateConstructorUsedError;

  /// List of tank photos
  set tanksImages(List<String>? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsReceptionProductInputCopyWith<AtsReceptionProductInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsReceptionProductInputCopyWith<$Res> {
  factory $AtsReceptionProductInputCopyWith(AtsReceptionProductInput value,
          $Res Function(AtsReceptionProductInput) then) =
      _$AtsReceptionProductInputCopyWithImpl<$Res, AtsReceptionProductInput>;
  @useResult
  $Res call({String? fuelAnp, List<String>? tanksImages});
}

/// @nodoc
class _$AtsReceptionProductInputCopyWithImpl<$Res,
        $Val extends AtsReceptionProductInput>
    implements $AtsReceptionProductInputCopyWith<$Res> {
  _$AtsReceptionProductInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fuelAnp = freezed,
    Object? tanksImages = freezed,
  }) {
    return _then(_value.copyWith(
      fuelAnp: freezed == fuelAnp
          ? _value.fuelAnp
          : fuelAnp // ignore: cast_nullable_to_non_nullable
              as String?,
      tanksImages: freezed == tanksImages
          ? _value.tanksImages
          : tanksImages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsReceptionProductInputCopyWith<$Res>
    implements $AtsReceptionProductInputCopyWith<$Res> {
  factory _$$_AtsReceptionProductInputCopyWith(
          _$_AtsReceptionProductInput value,
          $Res Function(_$_AtsReceptionProductInput) then) =
      __$$_AtsReceptionProductInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? fuelAnp, List<String>? tanksImages});
}

/// @nodoc
class __$$_AtsReceptionProductInputCopyWithImpl<$Res>
    extends _$AtsReceptionProductInputCopyWithImpl<$Res,
        _$_AtsReceptionProductInput>
    implements _$$_AtsReceptionProductInputCopyWith<$Res> {
  __$$_AtsReceptionProductInputCopyWithImpl(_$_AtsReceptionProductInput _value,
      $Res Function(_$_AtsReceptionProductInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fuelAnp = freezed,
    Object? tanksImages = freezed,
  }) {
    return _then(_$_AtsReceptionProductInput(
      fuelAnp: freezed == fuelAnp
          ? _value.fuelAnp
          : fuelAnp // ignore: cast_nullable_to_non_nullable
              as String?,
      tanksImages: freezed == tanksImages
          ? _value.tanksImages
          : tanksImages // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsReceptionProductInput implements _AtsReceptionProductInput {
  _$_AtsReceptionProductInput({this.fuelAnp, this.tanksImages});

  factory _$_AtsReceptionProductInput.fromJson(Map<String, dynamic> json) =>
      _$$_AtsReceptionProductInputFromJson(json);

  /// Fuel ANP category code
  @override
  String? fuelAnp;

  /// List of tank photos
  @override
  List<String>? tanksImages;

  @override
  String toString() {
    return 'AtsReceptionProductInput(fuelAnp: $fuelAnp, tanksImages: $tanksImages)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsReceptionProductInputCopyWith<_$_AtsReceptionProductInput>
      get copyWith => __$$_AtsReceptionProductInputCopyWithImpl<
          _$_AtsReceptionProductInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsReceptionProductInputToJson(
      this,
    );
  }
}

abstract class _AtsReceptionProductInput implements AtsReceptionProductInput {
  factory _AtsReceptionProductInput(
      {String? fuelAnp,
      List<String>? tanksImages}) = _$_AtsReceptionProductInput;

  factory _AtsReceptionProductInput.fromJson(Map<String, dynamic> json) =
      _$_AtsReceptionProductInput.fromJson;

  @override

  /// Fuel ANP category code
  String? get fuelAnp;

  /// Fuel ANP category code
  set fuelAnp(String? value);
  @override

  /// List of tank photos
  List<String>? get tanksImages;

  /// List of tank photos
  set tanksImages(List<String>? value);
  @override
  @JsonKey(ignore: true)
  _$$_AtsReceptionProductInputCopyWith<_$_AtsReceptionProductInput>
      get copyWith => throw _privateConstructorUsedError;
}

AtsReceptionInput _$AtsReceptionInputFromJson(Map<String, dynamic> json) {
  return _AtsReceptionInput.fromJson(json);
}

/// @nodoc
mixin _$AtsReceptionInput {
  ///ID of the [AtsReception]. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  ///ID of the [AtsReception]. This ID is unique.
  set id(String? value) => throw _privateConstructorUsedError;

  /// ID of the purchase order.
  int? get orderId => throw _privateConstructorUsedError;

  /// ID of the purchase order.
  set orderId(int? value) => throw _privateConstructorUsedError;

  /// Diferent [AtsReceptionProductInput] obtained of the [AtsPurchaseOrder]
  List<AtsReceptionProductInput>? get products =>
      throw _privateConstructorUsedError;

  /// Diferent [AtsReceptionProductInput] obtained of the [AtsPurchaseOrder]
  set products(List<AtsReceptionProductInput>? value) =>
      throw _privateConstructorUsedError;

  /// ID of the [Asset] supply point
  String? get assetId => throw _privateConstructorUsedError;

  /// ID of the [Asset] supply point
  set assetId(String? value) => throw _privateConstructorUsedError;

  /// [AtsReception] operation time
  @DurationOrNullConverter()
  Duration? get operationTime => throw _privateConstructorUsedError;

  /// [AtsReception] operation time
  @DurationOrNullConverter()
  set operationTime(Duration? value) => throw _privateConstructorUsedError;

  /// App used to create the [AtsReception].
  @AtsFromAppOrNullConverter()
  AtsFromApp? get app => throw _privateConstructorUsedError;

  /// App used to create the [AtsReception].
  @AtsFromAppOrNullConverter()
  set app(AtsFromApp? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsReceptionInputCopyWith<AtsReceptionInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsReceptionInputCopyWith<$Res> {
  factory $AtsReceptionInputCopyWith(
          AtsReceptionInput value, $Res Function(AtsReceptionInput) then) =
      _$AtsReceptionInputCopyWithImpl<$Res, AtsReceptionInput>;
  @useResult
  $Res call(
      {String? id,
      int? orderId,
      List<AtsReceptionProductInput>? products,
      String? assetId,
      @DurationOrNullConverter() Duration? operationTime,
      @AtsFromAppOrNullConverter() AtsFromApp? app});
}

/// @nodoc
class _$AtsReceptionInputCopyWithImpl<$Res, $Val extends AtsReceptionInput>
    implements $AtsReceptionInputCopyWith<$Res> {
  _$AtsReceptionInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? orderId = freezed,
    Object? products = freezed,
    Object? assetId = freezed,
    Object? operationTime = freezed,
    Object? app = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as int?,
      products: freezed == products
          ? _value.products
          : products // ignore: cast_nullable_to_non_nullable
              as List<AtsReceptionProductInput>?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      operationTime: freezed == operationTime
          ? _value.operationTime
          : operationTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      app: freezed == app
          ? _value.app
          : app // ignore: cast_nullable_to_non_nullable
              as AtsFromApp?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsReceptionInputCopyWith<$Res>
    implements $AtsReceptionInputCopyWith<$Res> {
  factory _$$_AtsReceptionInputCopyWith(_$_AtsReceptionInput value,
          $Res Function(_$_AtsReceptionInput) then) =
      __$$_AtsReceptionInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      int? orderId,
      List<AtsReceptionProductInput>? products,
      String? assetId,
      @DurationOrNullConverter() Duration? operationTime,
      @AtsFromAppOrNullConverter() AtsFromApp? app});
}

/// @nodoc
class __$$_AtsReceptionInputCopyWithImpl<$Res>
    extends _$AtsReceptionInputCopyWithImpl<$Res, _$_AtsReceptionInput>
    implements _$$_AtsReceptionInputCopyWith<$Res> {
  __$$_AtsReceptionInputCopyWithImpl(
      _$_AtsReceptionInput _value, $Res Function(_$_AtsReceptionInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? orderId = freezed,
    Object? products = freezed,
    Object? assetId = freezed,
    Object? operationTime = freezed,
    Object? app = freezed,
  }) {
    return _then(_$_AtsReceptionInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as int?,
      products: freezed == products
          ? _value.products
          : products // ignore: cast_nullable_to_non_nullable
              as List<AtsReceptionProductInput>?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      operationTime: freezed == operationTime
          ? _value.operationTime
          : operationTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      app: freezed == app
          ? _value.app
          : app // ignore: cast_nullable_to_non_nullable
              as AtsFromApp?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsReceptionInput implements _AtsReceptionInput {
  _$_AtsReceptionInput(
      {this.id,
      this.orderId,
      this.products,
      this.assetId,
      @DurationOrNullConverter() this.operationTime,
      @AtsFromAppOrNullConverter() this.app});

  factory _$_AtsReceptionInput.fromJson(Map<String, dynamic> json) =>
      _$$_AtsReceptionInputFromJson(json);

  ///ID of the [AtsReception]. This ID is unique.
  @override
  String? id;

  /// ID of the purchase order.
  @override
  int? orderId;

  /// Diferent [AtsReceptionProductInput] obtained of the [AtsPurchaseOrder]
  @override
  List<AtsReceptionProductInput>? products;

  /// ID of the [Asset] supply point
  @override
  String? assetId;

  /// [AtsReception] operation time
  @override
  @DurationOrNullConverter()
  Duration? operationTime;

  /// App used to create the [AtsReception].
  @override
  @AtsFromAppOrNullConverter()
  AtsFromApp? app;

  @override
  String toString() {
    return 'AtsReceptionInput(id: $id, orderId: $orderId, products: $products, assetId: $assetId, operationTime: $operationTime, app: $app)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsReceptionInputCopyWith<_$_AtsReceptionInput> get copyWith =>
      __$$_AtsReceptionInputCopyWithImpl<_$_AtsReceptionInput>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsReceptionInputToJson(
      this,
    );
  }
}

abstract class _AtsReceptionInput implements AtsReceptionInput {
  factory _AtsReceptionInput(
      {String? id,
      int? orderId,
      List<AtsReceptionProductInput>? products,
      String? assetId,
      @DurationOrNullConverter() Duration? operationTime,
      @AtsFromAppOrNullConverter() AtsFromApp? app}) = _$_AtsReceptionInput;

  factory _AtsReceptionInput.fromJson(Map<String, dynamic> json) =
      _$_AtsReceptionInput.fromJson;

  @override

  ///ID of the [AtsReception]. This ID is unique.
  String? get id;

  ///ID of the [AtsReception]. This ID is unique.
  set id(String? value);
  @override

  /// ID of the purchase order.
  int? get orderId;

  /// ID of the purchase order.
  set orderId(int? value);
  @override

  /// Diferent [AtsReceptionProductInput] obtained of the [AtsPurchaseOrder]
  List<AtsReceptionProductInput>? get products;

  /// Diferent [AtsReceptionProductInput] obtained of the [AtsPurchaseOrder]
  set products(List<AtsReceptionProductInput>? value);
  @override

  /// ID of the [Asset] supply point
  String? get assetId;

  /// ID of the [Asset] supply point
  set assetId(String? value);
  @override

  /// [AtsReception] operation time
  @DurationOrNullConverter()
  Duration? get operationTime;

  /// [AtsReception] operation time
  @DurationOrNullConverter()
  set operationTime(Duration? value);
  @override

  /// App used to create the [AtsReception].
  @AtsFromAppOrNullConverter()
  AtsFromApp? get app;

  /// App used to create the [AtsReception].
  @AtsFromAppOrNullConverter()
  set app(AtsFromApp? value);
  @override
  @JsonKey(ignore: true)
  _$$_AtsReceptionInputCopyWith<_$_AtsReceptionInput> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsAuthenticationIdentifier _$AtsAuthenticationIdentifierFromJson(
    Map<String, dynamic> json) {
  return _AtsAuthenticationIdentifier.fromJson(json);
}

/// @nodoc
mixin _$AtsAuthenticationIdentifier {
  /// ID of the [AtsAuthenticationIdentifier]. This ID is unique'
  String? get id => throw _privateConstructorUsedError;

  /// [AtsAuthenticationIdentifier] identifier category, It is a Enum from [AtsAuthenticationCategory]
  @AtsAuthenticationCategoryOrNullConverter()
  AtsAuthenticationCategory? get category => throw _privateConstructorUsedError;

  /// [AtsAuthenticationIdentifier] card ID
  String? get cardId => throw _privateConstructorUsedError;

  /// [AtsAuthenticationCard] linked to this identifier. See AuthenticationCard for more information
  AtsAuthenticationCard? get card => throw _privateConstructorUsedError;

  /// Authentication identifier NFC identifier
  String? get nfcIdentifier => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsAuthenticationIdentifierCopyWith<AtsAuthenticationIdentifier>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsAuthenticationIdentifierCopyWith<$Res> {
  factory $AtsAuthenticationIdentifierCopyWith(
          AtsAuthenticationIdentifier value,
          $Res Function(AtsAuthenticationIdentifier) then) =
      _$AtsAuthenticationIdentifierCopyWithImpl<$Res,
          AtsAuthenticationIdentifier>;
  @useResult
  $Res call(
      {String? id,
      @AtsAuthenticationCategoryOrNullConverter()
      AtsAuthenticationCategory? category,
      String? cardId,
      AtsAuthenticationCard? card,
      String? nfcIdentifier});

  $AtsAuthenticationCardCopyWith<$Res>? get card;
}

/// @nodoc
class _$AtsAuthenticationIdentifierCopyWithImpl<$Res,
        $Val extends AtsAuthenticationIdentifier>
    implements $AtsAuthenticationIdentifierCopyWith<$Res> {
  _$AtsAuthenticationIdentifierCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? category = freezed,
    Object? cardId = freezed,
    Object? card = freezed,
    Object? nfcIdentifier = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as AtsAuthenticationCategory?,
      cardId: freezed == cardId
          ? _value.cardId
          : cardId // ignore: cast_nullable_to_non_nullable
              as String?,
      card: freezed == card
          ? _value.card
          : card // ignore: cast_nullable_to_non_nullable
              as AtsAuthenticationCard?,
      nfcIdentifier: freezed == nfcIdentifier
          ? _value.nfcIdentifier
          : nfcIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsAuthenticationCardCopyWith<$Res>? get card {
    if (_value.card == null) {
      return null;
    }

    return $AtsAuthenticationCardCopyWith<$Res>(_value.card!, (value) {
      return _then(_value.copyWith(card: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsAuthenticationIdentifierCopyWith<$Res>
    implements $AtsAuthenticationIdentifierCopyWith<$Res> {
  factory _$$_AtsAuthenticationIdentifierCopyWith(
          _$_AtsAuthenticationIdentifier value,
          $Res Function(_$_AtsAuthenticationIdentifier) then) =
      __$$_AtsAuthenticationIdentifierCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      @AtsAuthenticationCategoryOrNullConverter()
      AtsAuthenticationCategory? category,
      String? cardId,
      AtsAuthenticationCard? card,
      String? nfcIdentifier});

  @override
  $AtsAuthenticationCardCopyWith<$Res>? get card;
}

/// @nodoc
class __$$_AtsAuthenticationIdentifierCopyWithImpl<$Res>
    extends _$AtsAuthenticationIdentifierCopyWithImpl<$Res,
        _$_AtsAuthenticationIdentifier>
    implements _$$_AtsAuthenticationIdentifierCopyWith<$Res> {
  __$$_AtsAuthenticationIdentifierCopyWithImpl(
      _$_AtsAuthenticationIdentifier _value,
      $Res Function(_$_AtsAuthenticationIdentifier) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? category = freezed,
    Object? cardId = freezed,
    Object? card = freezed,
    Object? nfcIdentifier = freezed,
  }) {
    return _then(_$_AtsAuthenticationIdentifier(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as AtsAuthenticationCategory?,
      cardId: freezed == cardId
          ? _value.cardId
          : cardId // ignore: cast_nullable_to_non_nullable
              as String?,
      card: freezed == card
          ? _value.card
          : card // ignore: cast_nullable_to_non_nullable
              as AtsAuthenticationCard?,
      nfcIdentifier: freezed == nfcIdentifier
          ? _value.nfcIdentifier
          : nfcIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsAuthenticationIdentifier implements _AtsAuthenticationIdentifier {
  const _$_AtsAuthenticationIdentifier(
      {this.id,
      @AtsAuthenticationCategoryOrNullConverter() this.category,
      this.cardId,
      this.card,
      this.nfcIdentifier});

  factory _$_AtsAuthenticationIdentifier.fromJson(Map<String, dynamic> json) =>
      _$$_AtsAuthenticationIdentifierFromJson(json);

  /// ID of the [AtsAuthenticationIdentifier]. This ID is unique'
  @override
  final String? id;

  /// [AtsAuthenticationIdentifier] identifier category, It is a Enum from [AtsAuthenticationCategory]
  @override
  @AtsAuthenticationCategoryOrNullConverter()
  final AtsAuthenticationCategory? category;

  /// [AtsAuthenticationIdentifier] card ID
  @override
  final String? cardId;

  /// [AtsAuthenticationCard] linked to this identifier. See AuthenticationCard for more information
  @override
  final AtsAuthenticationCard? card;

  /// Authentication identifier NFC identifier
  @override
  final String? nfcIdentifier;

  @override
  String toString() {
    return 'AtsAuthenticationIdentifier(id: $id, category: $category, cardId: $cardId, card: $card, nfcIdentifier: $nfcIdentifier)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsAuthenticationIdentifier &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.cardId, cardId) || other.cardId == cardId) &&
            (identical(other.card, card) || other.card == card) &&
            (identical(other.nfcIdentifier, nfcIdentifier) ||
                other.nfcIdentifier == nfcIdentifier));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, category, cardId, card, nfcIdentifier);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsAuthenticationIdentifierCopyWith<_$_AtsAuthenticationIdentifier>
      get copyWith => __$$_AtsAuthenticationIdentifierCopyWithImpl<
          _$_AtsAuthenticationIdentifier>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsAuthenticationIdentifierToJson(
      this,
    );
  }
}

abstract class _AtsAuthenticationIdentifier
    implements AtsAuthenticationIdentifier {
  const factory _AtsAuthenticationIdentifier(
      {final String? id,
      @AtsAuthenticationCategoryOrNullConverter()
      final AtsAuthenticationCategory? category,
      final String? cardId,
      final AtsAuthenticationCard? card,
      final String? nfcIdentifier}) = _$_AtsAuthenticationIdentifier;

  factory _AtsAuthenticationIdentifier.fromJson(Map<String, dynamic> json) =
      _$_AtsAuthenticationIdentifier.fromJson;

  @override

  /// ID of the [AtsAuthenticationIdentifier]. This ID is unique'
  String? get id;
  @override

  /// [AtsAuthenticationIdentifier] identifier category, It is a Enum from [AtsAuthenticationCategory]
  @AtsAuthenticationCategoryOrNullConverter()
  AtsAuthenticationCategory? get category;
  @override

  /// [AtsAuthenticationIdentifier] card ID
  String? get cardId;
  @override

  /// [AtsAuthenticationCard] linked to this identifier. See AuthenticationCard for more information
  AtsAuthenticationCard? get card;
  @override

  /// Authentication identifier NFC identifier
  String? get nfcIdentifier;
  @override
  @JsonKey(ignore: true)
  _$$_AtsAuthenticationIdentifierCopyWith<_$_AtsAuthenticationIdentifier>
      get copyWith => throw _privateConstructorUsedError;
}

AtsAuthenticationCard _$AtsAuthenticationCardFromJson(
    Map<String, dynamic> json) {
  return _AtsAuthenticationCard.fromJson(json);
}

/// @nodoc
mixin _$AtsAuthenticationCard {
  /// [id] represents the unique identifier of the card.
  String get id => throw _privateConstructorUsedError;

  /// [number] represents the number printed in the card
  int get number => throw _privateConstructorUsedError;

  /// [externalIdentifier] is the external identifier of the card. Defined in decimal format.
  int get externalIdentifier => throw _privateConstructorUsedError;

  /// [externalIdentifierHex] is the external identifier of the card. Defined in hexadecimal format.
  String get externalIdentifierHex => throw _privateConstructorUsedError;

  /// [asset] is the linked asset to this card.
  Asset? get asset => throw _privateConstructorUsedError;

  /// [owner] is the owner of this card.
  User? get owner => throw _privateConstructorUsedError;

  /// [isSuspended] is true if the card is suspended.
  bool? get isSuspended => throw _privateConstructorUsedError;

  /// [history] is the history of this card.
  List<AtsHistoryAuthenticationCard>? get history =>
      throw _privateConstructorUsedError;

  /// [createdAt] is the date when the card was created.
  @TimestampOrNullConverter()
  DateTime? get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsAuthenticationCardCopyWith<AtsAuthenticationCard> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsAuthenticationCardCopyWith<$Res> {
  factory $AtsAuthenticationCardCopyWith(AtsAuthenticationCard value,
          $Res Function(AtsAuthenticationCard) then) =
      _$AtsAuthenticationCardCopyWithImpl<$Res, AtsAuthenticationCard>;
  @useResult
  $Res call(
      {String id,
      int number,
      int externalIdentifier,
      String externalIdentifierHex,
      Asset? asset,
      User? owner,
      bool? isSuspended,
      List<AtsHistoryAuthenticationCard>? history,
      @TimestampOrNullConverter() DateTime? createdAt});

  $AssetCopyWith<$Res>? get asset;
  $UserCopyWith<$Res>? get owner;
}

/// @nodoc
class _$AtsAuthenticationCardCopyWithImpl<$Res,
        $Val extends AtsAuthenticationCard>
    implements $AtsAuthenticationCardCopyWith<$Res> {
  _$AtsAuthenticationCardCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? number = null,
    Object? externalIdentifier = null,
    Object? externalIdentifierHex = null,
    Object? asset = freezed,
    Object? owner = freezed,
    Object? isSuspended = freezed,
    Object? history = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      number: null == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int,
      externalIdentifier: null == externalIdentifier
          ? _value.externalIdentifier
          : externalIdentifier // ignore: cast_nullable_to_non_nullable
              as int,
      externalIdentifierHex: null == externalIdentifierHex
          ? _value.externalIdentifierHex
          : externalIdentifierHex // ignore: cast_nullable_to_non_nullable
              as String,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as User?,
      isSuspended: freezed == isSuspended
          ? _value.isSuspended
          : isSuspended // ignore: cast_nullable_to_non_nullable
              as bool?,
      history: freezed == history
          ? _value.history
          : history // ignore: cast_nullable_to_non_nullable
              as List<AtsHistoryAuthenticationCard>?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get asset {
    if (_value.asset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.asset!, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get owner {
    if (_value.owner == null) {
      return null;
    }

    return $UserCopyWith<$Res>(_value.owner!, (value) {
      return _then(_value.copyWith(owner: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsAuthenticationCardCopyWith<$Res>
    implements $AtsAuthenticationCardCopyWith<$Res> {
  factory _$$_AtsAuthenticationCardCopyWith(_$_AtsAuthenticationCard value,
          $Res Function(_$_AtsAuthenticationCard) then) =
      __$$_AtsAuthenticationCardCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      int number,
      int externalIdentifier,
      String externalIdentifierHex,
      Asset? asset,
      User? owner,
      bool? isSuspended,
      List<AtsHistoryAuthenticationCard>? history,
      @TimestampOrNullConverter() DateTime? createdAt});

  @override
  $AssetCopyWith<$Res>? get asset;
  @override
  $UserCopyWith<$Res>? get owner;
}

/// @nodoc
class __$$_AtsAuthenticationCardCopyWithImpl<$Res>
    extends _$AtsAuthenticationCardCopyWithImpl<$Res, _$_AtsAuthenticationCard>
    implements _$$_AtsAuthenticationCardCopyWith<$Res> {
  __$$_AtsAuthenticationCardCopyWithImpl(_$_AtsAuthenticationCard _value,
      $Res Function(_$_AtsAuthenticationCard) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? number = null,
    Object? externalIdentifier = null,
    Object? externalIdentifierHex = null,
    Object? asset = freezed,
    Object? owner = freezed,
    Object? isSuspended = freezed,
    Object? history = freezed,
    Object? createdAt = freezed,
  }) {
    return _then(_$_AtsAuthenticationCard(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      number: null == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as int,
      externalIdentifier: null == externalIdentifier
          ? _value.externalIdentifier
          : externalIdentifier // ignore: cast_nullable_to_non_nullable
              as int,
      externalIdentifierHex: null == externalIdentifierHex
          ? _value.externalIdentifierHex
          : externalIdentifierHex // ignore: cast_nullable_to_non_nullable
              as String,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as User?,
      isSuspended: freezed == isSuspended
          ? _value.isSuspended
          : isSuspended // ignore: cast_nullable_to_non_nullable
              as bool?,
      history: freezed == history
          ? _value._history
          : history // ignore: cast_nullable_to_non_nullable
              as List<AtsHistoryAuthenticationCard>?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsAuthenticationCard implements _AtsAuthenticationCard {
  const _$_AtsAuthenticationCard(
      {required this.id,
      required this.number,
      required this.externalIdentifier,
      required this.externalIdentifierHex,
      this.asset,
      this.owner,
      this.isSuspended,
      final List<AtsHistoryAuthenticationCard>? history,
      @TimestampOrNullConverter() this.createdAt})
      : _history = history;

  factory _$_AtsAuthenticationCard.fromJson(Map<String, dynamic> json) =>
      _$$_AtsAuthenticationCardFromJson(json);

  /// [id] represents the unique identifier of the card.
  @override
  final String id;

  /// [number] represents the number printed in the card
  @override
  final int number;

  /// [externalIdentifier] is the external identifier of the card. Defined in decimal format.
  @override
  final int externalIdentifier;

  /// [externalIdentifierHex] is the external identifier of the card. Defined in hexadecimal format.
  @override
  final String externalIdentifierHex;

  /// [asset] is the linked asset to this card.
  @override
  final Asset? asset;

  /// [owner] is the owner of this card.
  @override
  final User? owner;

  /// [isSuspended] is true if the card is suspended.
  @override
  final bool? isSuspended;

  /// [history] is the history of this card.
  final List<AtsHistoryAuthenticationCard>? _history;

  /// [history] is the history of this card.
  @override
  List<AtsHistoryAuthenticationCard>? get history {
    final value = _history;
    if (value == null) return null;
    if (_history is EqualUnmodifiableListView) return _history;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [createdAt] is the date when the card was created.
  @override
  @TimestampOrNullConverter()
  final DateTime? createdAt;

  @override
  String toString() {
    return 'AtsAuthenticationCard(id: $id, number: $number, externalIdentifier: $externalIdentifier, externalIdentifierHex: $externalIdentifierHex, asset: $asset, owner: $owner, isSuspended: $isSuspended, history: $history, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsAuthenticationCard &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.externalIdentifier, externalIdentifier) ||
                other.externalIdentifier == externalIdentifier) &&
            (identical(other.externalIdentifierHex, externalIdentifierHex) ||
                other.externalIdentifierHex == externalIdentifierHex) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.owner, owner) || other.owner == owner) &&
            (identical(other.isSuspended, isSuspended) ||
                other.isSuspended == isSuspended) &&
            const DeepCollectionEquality().equals(other._history, _history) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      number,
      externalIdentifier,
      externalIdentifierHex,
      asset,
      owner,
      isSuspended,
      const DeepCollectionEquality().hash(_history),
      createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsAuthenticationCardCopyWith<_$_AtsAuthenticationCard> get copyWith =>
      __$$_AtsAuthenticationCardCopyWithImpl<_$_AtsAuthenticationCard>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsAuthenticationCardToJson(
      this,
    );
  }
}

abstract class _AtsAuthenticationCard implements AtsAuthenticationCard {
  const factory _AtsAuthenticationCard(
          {required final String id,
          required final int number,
          required final int externalIdentifier,
          required final String externalIdentifierHex,
          final Asset? asset,
          final User? owner,
          final bool? isSuspended,
          final List<AtsHistoryAuthenticationCard>? history,
          @TimestampOrNullConverter() final DateTime? createdAt}) =
      _$_AtsAuthenticationCard;

  factory _AtsAuthenticationCard.fromJson(Map<String, dynamic> json) =
      _$_AtsAuthenticationCard.fromJson;

  @override

  /// [id] represents the unique identifier of the card.
  String get id;
  @override

  /// [number] represents the number printed in the card
  int get number;
  @override

  /// [externalIdentifier] is the external identifier of the card. Defined in decimal format.
  int get externalIdentifier;
  @override

  /// [externalIdentifierHex] is the external identifier of the card. Defined in hexadecimal format.
  String get externalIdentifierHex;
  @override

  /// [asset] is the linked asset to this card.
  Asset? get asset;
  @override

  /// [owner] is the owner of this card.
  User? get owner;
  @override

  /// [isSuspended] is true if the card is suspended.
  bool? get isSuspended;
  @override

  /// [history] is the history of this card.
  List<AtsHistoryAuthenticationCard>? get history;
  @override

  /// [createdAt] is the date when the card was created.
  @TimestampOrNullConverter()
  DateTime? get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_AtsAuthenticationCardCopyWith<_$_AtsAuthenticationCard> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsHistoryAuthenticationCard _$AtsHistoryAuthenticationCardFromJson(
    Map<String, dynamic> json) {
  return _AtsHistoryAuthenticationCard.fromJson(json);
}

/// @nodoc
mixin _$AtsHistoryAuthenticationCard {
  /// [id] represents the unique identifier of the history operation of the card.
  String get id => throw _privateConstructorUsedError;

  /// [operation] represents the operation performed in the card.
  @AtsHistoryAuthenticationCardOperationConverter()
  AtsHistoryAuthenticationCardOperation get operation =>
      throw _privateConstructorUsedError;

  /// [asset] is the linked asset to this card.
  Asset? get asset => throw _privateConstructorUsedError;

  /// [owner] is the owner of this card.
  User? get owner => throw _privateConstructorUsedError;

  /// [createdBy] is the user who performed the operation.
  User get createdBy => throw _privateConstructorUsedError;

  /// [createdAt] is the date when the card was created.
  @TimestampConverter()
  DateTime get createdAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsHistoryAuthenticationCardCopyWith<AtsHistoryAuthenticationCard>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsHistoryAuthenticationCardCopyWith<$Res> {
  factory $AtsHistoryAuthenticationCardCopyWith(
          AtsHistoryAuthenticationCard value,
          $Res Function(AtsHistoryAuthenticationCard) then) =
      _$AtsHistoryAuthenticationCardCopyWithImpl<$Res,
          AtsHistoryAuthenticationCard>;
  @useResult
  $Res call(
      {String id,
      @AtsHistoryAuthenticationCardOperationConverter()
      AtsHistoryAuthenticationCardOperation operation,
      Asset? asset,
      User? owner,
      User createdBy,
      @TimestampConverter() DateTime createdAt});

  $AssetCopyWith<$Res>? get asset;
  $UserCopyWith<$Res>? get owner;
  $UserCopyWith<$Res> get createdBy;
}

/// @nodoc
class _$AtsHistoryAuthenticationCardCopyWithImpl<$Res,
        $Val extends AtsHistoryAuthenticationCard>
    implements $AtsHistoryAuthenticationCardCopyWith<$Res> {
  _$AtsHistoryAuthenticationCardCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? operation = null,
    Object? asset = freezed,
    Object? owner = freezed,
    Object? createdBy = null,
    Object? createdAt = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      operation: null == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as AtsHistoryAuthenticationCardOperation,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as User?,
      createdBy: null == createdBy
          ? _value.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as User,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get asset {
    if (_value.asset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.asset!, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get owner {
    if (_value.owner == null) {
      return null;
    }

    return $UserCopyWith<$Res>(_value.owner!, (value) {
      return _then(_value.copyWith(owner: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res> get createdBy {
    return $UserCopyWith<$Res>(_value.createdBy, (value) {
      return _then(_value.copyWith(createdBy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsHistoryAuthenticationCardCopyWith<$Res>
    implements $AtsHistoryAuthenticationCardCopyWith<$Res> {
  factory _$$_AtsHistoryAuthenticationCardCopyWith(
          _$_AtsHistoryAuthenticationCard value,
          $Res Function(_$_AtsHistoryAuthenticationCard) then) =
      __$$_AtsHistoryAuthenticationCardCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @AtsHistoryAuthenticationCardOperationConverter()
      AtsHistoryAuthenticationCardOperation operation,
      Asset? asset,
      User? owner,
      User createdBy,
      @TimestampConverter() DateTime createdAt});

  @override
  $AssetCopyWith<$Res>? get asset;
  @override
  $UserCopyWith<$Res>? get owner;
  @override
  $UserCopyWith<$Res> get createdBy;
}

/// @nodoc
class __$$_AtsHistoryAuthenticationCardCopyWithImpl<$Res>
    extends _$AtsHistoryAuthenticationCardCopyWithImpl<$Res,
        _$_AtsHistoryAuthenticationCard>
    implements _$$_AtsHistoryAuthenticationCardCopyWith<$Res> {
  __$$_AtsHistoryAuthenticationCardCopyWithImpl(
      _$_AtsHistoryAuthenticationCard _value,
      $Res Function(_$_AtsHistoryAuthenticationCard) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? operation = null,
    Object? asset = freezed,
    Object? owner = freezed,
    Object? createdBy = null,
    Object? createdAt = null,
  }) {
    return _then(_$_AtsHistoryAuthenticationCard(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      operation: null == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as AtsHistoryAuthenticationCardOperation,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      owner: freezed == owner
          ? _value.owner
          : owner // ignore: cast_nullable_to_non_nullable
              as User?,
      createdBy: null == createdBy
          ? _value.createdBy
          : createdBy // ignore: cast_nullable_to_non_nullable
              as User,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsHistoryAuthenticationCard implements _AtsHistoryAuthenticationCard {
  const _$_AtsHistoryAuthenticationCard(
      {required this.id,
      @AtsHistoryAuthenticationCardOperationConverter() required this.operation,
      this.asset,
      this.owner,
      required this.createdBy,
      @TimestampConverter() required this.createdAt});

  factory _$_AtsHistoryAuthenticationCard.fromJson(Map<String, dynamic> json) =>
      _$$_AtsHistoryAuthenticationCardFromJson(json);

  /// [id] represents the unique identifier of the history operation of the card.
  @override
  final String id;

  /// [operation] represents the operation performed in the card.
  @override
  @AtsHistoryAuthenticationCardOperationConverter()
  final AtsHistoryAuthenticationCardOperation operation;

  /// [asset] is the linked asset to this card.
  @override
  final Asset? asset;

  /// [owner] is the owner of this card.
  @override
  final User? owner;

  /// [createdBy] is the user who performed the operation.
  @override
  final User createdBy;

  /// [createdAt] is the date when the card was created.
  @override
  @TimestampConverter()
  final DateTime createdAt;

  @override
  String toString() {
    return 'AtsHistoryAuthenticationCard(id: $id, operation: $operation, asset: $asset, owner: $owner, createdBy: $createdBy, createdAt: $createdAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsHistoryAuthenticationCard &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.operation, operation) ||
                other.operation == operation) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.owner, owner) || other.owner == owner) &&
            (identical(other.createdBy, createdBy) ||
                other.createdBy == createdBy) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, operation, asset, owner, createdBy, createdAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsHistoryAuthenticationCardCopyWith<_$_AtsHistoryAuthenticationCard>
      get copyWith => __$$_AtsHistoryAuthenticationCardCopyWithImpl<
          _$_AtsHistoryAuthenticationCard>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsHistoryAuthenticationCardToJson(
      this,
    );
  }
}

abstract class _AtsHistoryAuthenticationCard
    implements AtsHistoryAuthenticationCard {
  const factory _AtsHistoryAuthenticationCard(
          {required final String id,
          @AtsHistoryAuthenticationCardOperationConverter()
          required final AtsHistoryAuthenticationCardOperation operation,
          final Asset? asset,
          final User? owner,
          required final User createdBy,
          @TimestampConverter() required final DateTime createdAt}) =
      _$_AtsHistoryAuthenticationCard;

  factory _AtsHistoryAuthenticationCard.fromJson(Map<String, dynamic> json) =
      _$_AtsHistoryAuthenticationCard.fromJson;

  @override

  /// [id] represents the unique identifier of the history operation of the card.
  String get id;
  @override

  /// [operation] represents the operation performed in the card.
  @AtsHistoryAuthenticationCardOperationConverter()
  AtsHistoryAuthenticationCardOperation get operation;
  @override

  /// [asset] is the linked asset to this card.
  Asset? get asset;
  @override

  /// [owner] is the owner of this card.
  User? get owner;
  @override

  /// [createdBy] is the user who performed the operation.
  User get createdBy;
  @override

  /// [createdAt] is the date when the card was created.
  @TimestampConverter()
  DateTime get createdAt;
  @override
  @JsonKey(ignore: true)
  _$$_AtsHistoryAuthenticationCardCopyWith<_$_AtsHistoryAuthenticationCard>
      get copyWith => throw _privateConstructorUsedError;
}

AtsFeedbackMessege _$AtsFeedbackMessegeFromJson(Map<String, dynamic> json) {
  return _AtsFeedbackMessege.fromJson(json);
}

/// @nodoc
mixin _$AtsFeedbackMessege {
  /// [id] of the asset entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// [content] sent from the [User].
  String? get content => throw _privateConstructorUsedError;

  /// [creator] Owner or submitter.
  User? get creator => throw _privateConstructorUsedError;

  /// [at] Date of creation in UNIX Timestamp.
  @TimestampOrNullConverter()
  DateTime? get at => throw _privateConstructorUsedError;

  /// [app] object from comming feedback message, only will return when FeedbackMessage.source = FeedbackSource.APP
  RegisteredApp? get app => throw _privateConstructorUsedError;

  /// [source] Source of the feedback message.
  @FeedbackSourceOrNullConverter()
  FeedbackSource? get source => throw _privateConstructorUsedError;

  /// [isRead] Is read indicator.
  bool? get isRead => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsFeedbackMessegeCopyWith<AtsFeedbackMessege> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsFeedbackMessegeCopyWith<$Res> {
  factory $AtsFeedbackMessegeCopyWith(
          AtsFeedbackMessege value, $Res Function(AtsFeedbackMessege) then) =
      _$AtsFeedbackMessegeCopyWithImpl<$Res, AtsFeedbackMessege>;
  @useResult
  $Res call(
      {String? id,
      String? content,
      User? creator,
      @TimestampOrNullConverter() DateTime? at,
      RegisteredApp? app,
      @FeedbackSourceOrNullConverter() FeedbackSource? source,
      bool? isRead});

  $UserCopyWith<$Res>? get creator;
  $RegisteredAppCopyWith<$Res>? get app;
}

/// @nodoc
class _$AtsFeedbackMessegeCopyWithImpl<$Res, $Val extends AtsFeedbackMessege>
    implements $AtsFeedbackMessegeCopyWith<$Res> {
  _$AtsFeedbackMessegeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? creator = freezed,
    Object? at = freezed,
    Object? app = freezed,
    Object? source = freezed,
    Object? isRead = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      creator: freezed == creator
          ? _value.creator
          : creator // ignore: cast_nullable_to_non_nullable
              as User?,
      at: freezed == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      app: freezed == app
          ? _value.app
          : app // ignore: cast_nullable_to_non_nullable
              as RegisteredApp?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as FeedbackSource?,
      isRead: freezed == isRead
          ? _value.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res>? get creator {
    if (_value.creator == null) {
      return null;
    }

    return $UserCopyWith<$Res>(_value.creator!, (value) {
      return _then(_value.copyWith(creator: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RegisteredAppCopyWith<$Res>? get app {
    if (_value.app == null) {
      return null;
    }

    return $RegisteredAppCopyWith<$Res>(_value.app!, (value) {
      return _then(_value.copyWith(app: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsFeedbackMessegeCopyWith<$Res>
    implements $AtsFeedbackMessegeCopyWith<$Res> {
  factory _$$_AtsFeedbackMessegeCopyWith(_$_AtsFeedbackMessege value,
          $Res Function(_$_AtsFeedbackMessege) then) =
      __$$_AtsFeedbackMessegeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? content,
      User? creator,
      @TimestampOrNullConverter() DateTime? at,
      RegisteredApp? app,
      @FeedbackSourceOrNullConverter() FeedbackSource? source,
      bool? isRead});

  @override
  $UserCopyWith<$Res>? get creator;
  @override
  $RegisteredAppCopyWith<$Res>? get app;
}

/// @nodoc
class __$$_AtsFeedbackMessegeCopyWithImpl<$Res>
    extends _$AtsFeedbackMessegeCopyWithImpl<$Res, _$_AtsFeedbackMessege>
    implements _$$_AtsFeedbackMessegeCopyWith<$Res> {
  __$$_AtsFeedbackMessegeCopyWithImpl(
      _$_AtsFeedbackMessege _value, $Res Function(_$_AtsFeedbackMessege) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? content = freezed,
    Object? creator = freezed,
    Object? at = freezed,
    Object? app = freezed,
    Object? source = freezed,
    Object? isRead = freezed,
  }) {
    return _then(_$_AtsFeedbackMessege(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      content: freezed == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String?,
      creator: freezed == creator
          ? _value.creator
          : creator // ignore: cast_nullable_to_non_nullable
              as User?,
      at: freezed == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      app: freezed == app
          ? _value.app
          : app // ignore: cast_nullable_to_non_nullable
              as RegisteredApp?,
      source: freezed == source
          ? _value.source
          : source // ignore: cast_nullable_to_non_nullable
              as FeedbackSource?,
      isRead: freezed == isRead
          ? _value.isRead
          : isRead // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsFeedbackMessege implements _AtsFeedbackMessege {
  const _$_AtsFeedbackMessege(
      {this.id,
      this.content,
      this.creator,
      @TimestampOrNullConverter() this.at,
      this.app,
      @FeedbackSourceOrNullConverter() this.source,
      this.isRead});

  factory _$_AtsFeedbackMessege.fromJson(Map<String, dynamic> json) =>
      _$$_AtsFeedbackMessegeFromJson(json);

  /// [id] of the asset entity. This ID is unique.
  @override
  final String? id;

  /// [content] sent from the [User].
  @override
  final String? content;

  /// [creator] Owner or submitter.
  @override
  final User? creator;

  /// [at] Date of creation in UNIX Timestamp.
  @override
  @TimestampOrNullConverter()
  final DateTime? at;

  /// [app] object from comming feedback message, only will return when FeedbackMessage.source = FeedbackSource.APP
  @override
  final RegisteredApp? app;

  /// [source] Source of the feedback message.
  @override
  @FeedbackSourceOrNullConverter()
  final FeedbackSource? source;

  /// [isRead] Is read indicator.
  @override
  final bool? isRead;

  @override
  String toString() {
    return 'AtsFeedbackMessege(id: $id, content: $content, creator: $creator, at: $at, app: $app, source: $source, isRead: $isRead)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsFeedbackMessege &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.creator, creator) || other.creator == creator) &&
            (identical(other.at, at) || other.at == at) &&
            (identical(other.app, app) || other.app == app) &&
            (identical(other.source, source) || other.source == source) &&
            (identical(other.isRead, isRead) || other.isRead == isRead));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, content, creator, at, app, source, isRead);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsFeedbackMessegeCopyWith<_$_AtsFeedbackMessege> get copyWith =>
      __$$_AtsFeedbackMessegeCopyWithImpl<_$_AtsFeedbackMessege>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsFeedbackMessegeToJson(
      this,
    );
  }
}

abstract class _AtsFeedbackMessege implements AtsFeedbackMessege {
  const factory _AtsFeedbackMessege(
      {final String? id,
      final String? content,
      final User? creator,
      @TimestampOrNullConverter() final DateTime? at,
      final RegisteredApp? app,
      @FeedbackSourceOrNullConverter() final FeedbackSource? source,
      final bool? isRead}) = _$_AtsFeedbackMessege;

  factory _AtsFeedbackMessege.fromJson(Map<String, dynamic> json) =
      _$_AtsFeedbackMessege.fromJson;

  @override

  /// [id] of the asset entity. This ID is unique.
  String? get id;
  @override

  /// [content] sent from the [User].
  String? get content;
  @override

  /// [creator] Owner or submitter.
  User? get creator;
  @override

  /// [at] Date of creation in UNIX Timestamp.
  @TimestampOrNullConverter()
  DateTime? get at;
  @override

  /// [app] object from comming feedback message, only will return when FeedbackMessage.source = FeedbackSource.APP
  RegisteredApp? get app;
  @override

  /// [source] Source of the feedback message.
  @FeedbackSourceOrNullConverter()
  FeedbackSource? get source;
  @override

  /// [isRead] Is read indicator.
  bool? get isRead;
  @override
  @JsonKey(ignore: true)
  _$$_AtsFeedbackMessegeCopyWith<_$_AtsFeedbackMessege> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsEvent _$AtsEventFromJson(Map<String, dynamic> json) {
  return _AtsEvent.fromJson(json);
}

/// @nodoc
mixin _$AtsEvent {
  /// [id] of the asset entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// [operation] Operation linked to the [AtsEvent].
  Operation? get operation => throw _privateConstructorUsedError;

  /// [operationId] Operation linked to the [AtsEvent].
  String? get operationId => throw _privateConstructorUsedError;

  /// [trigger] Trigger linked to the [AtsEvent].
  Trigger? get trigger => throw _privateConstructorUsedError;

  /// [triggerId] Trigger linked to the [AtsEvent].
  String? get triggerId =>
      throw _privateConstructorUsedError; // /// [function] Pitagoras function linked to the [AtsEvent].
// Function? function,
  /// [functionId] Pitagoras function ID linked to the [AtsEvent].
  String? get functionId => throw _privateConstructorUsedError;

  /// [asset] Asset linked to the [AtsEvent].
  Asset? get asset => throw _privateConstructorUsedError;

  /// [assetId] Asset ID linked to the [AtsEvent].
  String? get assetId => throw _privateConstructorUsedError;

  /// [position] linked to the [AtsEvent].
  TelemetryPosition? get position => throw _privateConstructorUsedError;

  /// [payload] Raw received payload values list of the message.
  List<TelemetrySensor>? get payload => throw _privateConstructorUsedError;

  /// [sensors] values list of the message.
  List<Sensor>? get sensors => throw _privateConstructorUsedError;

  /// [at] Unix timestamp representing the date of the event.
  @TimestampOrNullConverter()
  DateTime? get at => throw _privateConstructorUsedError;

  /// [isCheck] Flag to identify if the event has been checked.
  bool? get isCheck => throw _privateConstructorUsedError;

  /// [comment] on closing event.
  String? get comment => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsEventCopyWith<AtsEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsEventCopyWith<$Res> {
  factory $AtsEventCopyWith(AtsEvent value, $Res Function(AtsEvent) then) =
      _$AtsEventCopyWithImpl<$Res, AtsEvent>;
  @useResult
  $Res call(
      {String? id,
      Operation? operation,
      String? operationId,
      Trigger? trigger,
      String? triggerId,
      String? functionId,
      Asset? asset,
      String? assetId,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload,
      List<Sensor>? sensors,
      @TimestampOrNullConverter() DateTime? at,
      bool? isCheck,
      String? comment});

  $OperationCopyWith<$Res>? get operation;
  $TriggerCopyWith<$Res>? get trigger;
  $AssetCopyWith<$Res>? get asset;
  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class _$AtsEventCopyWithImpl<$Res, $Val extends AtsEvent>
    implements $AtsEventCopyWith<$Res> {
  _$AtsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? operation = freezed,
    Object? operationId = freezed,
    Object? trigger = freezed,
    Object? triggerId = freezed,
    Object? functionId = freezed,
    Object? asset = freezed,
    Object? assetId = freezed,
    Object? position = freezed,
    Object? payload = freezed,
    Object? sensors = freezed,
    Object? at = freezed,
    Object? isCheck = freezed,
    Object? comment = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      operation: freezed == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as Operation?,
      operationId: freezed == operationId
          ? _value.operationId
          : operationId // ignore: cast_nullable_to_non_nullable
              as String?,
      trigger: freezed == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger?,
      triggerId: freezed == triggerId
          ? _value.triggerId
          : triggerId // ignore: cast_nullable_to_non_nullable
              as String?,
      functionId: freezed == functionId
          ? _value.functionId
          : functionId // ignore: cast_nullable_to_non_nullable
              as String?,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value.payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      sensors: freezed == sensors
          ? _value.sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<Sensor>?,
      at: freezed == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isCheck: freezed == isCheck
          ? _value.isCheck
          : isCheck // ignore: cast_nullable_to_non_nullable
              as bool?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $OperationCopyWith<$Res>? get operation {
    if (_value.operation == null) {
      return null;
    }

    return $OperationCopyWith<$Res>(_value.operation!, (value) {
      return _then(_value.copyWith(operation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TriggerCopyWith<$Res>? get trigger {
    if (_value.trigger == null) {
      return null;
    }

    return $TriggerCopyWith<$Res>(_value.trigger!, (value) {
      return _then(_value.copyWith(trigger: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get asset {
    if (_value.asset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.asset!, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TelemetryPositionCopyWith<$Res>? get position {
    if (_value.position == null) {
      return null;
    }

    return $TelemetryPositionCopyWith<$Res>(_value.position!, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsEventCopyWith<$Res> implements $AtsEventCopyWith<$Res> {
  factory _$$_AtsEventCopyWith(
          _$_AtsEvent value, $Res Function(_$_AtsEvent) then) =
      __$$_AtsEventCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      Operation? operation,
      String? operationId,
      Trigger? trigger,
      String? triggerId,
      String? functionId,
      Asset? asset,
      String? assetId,
      TelemetryPosition? position,
      List<TelemetrySensor>? payload,
      List<Sensor>? sensors,
      @TimestampOrNullConverter() DateTime? at,
      bool? isCheck,
      String? comment});

  @override
  $OperationCopyWith<$Res>? get operation;
  @override
  $TriggerCopyWith<$Res>? get trigger;
  @override
  $AssetCopyWith<$Res>? get asset;
  @override
  $TelemetryPositionCopyWith<$Res>? get position;
}

/// @nodoc
class __$$_AtsEventCopyWithImpl<$Res>
    extends _$AtsEventCopyWithImpl<$Res, _$_AtsEvent>
    implements _$$_AtsEventCopyWith<$Res> {
  __$$_AtsEventCopyWithImpl(
      _$_AtsEvent _value, $Res Function(_$_AtsEvent) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? operation = freezed,
    Object? operationId = freezed,
    Object? trigger = freezed,
    Object? triggerId = freezed,
    Object? functionId = freezed,
    Object? asset = freezed,
    Object? assetId = freezed,
    Object? position = freezed,
    Object? payload = freezed,
    Object? sensors = freezed,
    Object? at = freezed,
    Object? isCheck = freezed,
    Object? comment = freezed,
  }) {
    return _then(_$_AtsEvent(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      operation: freezed == operation
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as Operation?,
      operationId: freezed == operationId
          ? _value.operationId
          : operationId // ignore: cast_nullable_to_non_nullable
              as String?,
      trigger: freezed == trigger
          ? _value.trigger
          : trigger // ignore: cast_nullable_to_non_nullable
              as Trigger?,
      triggerId: freezed == triggerId
          ? _value.triggerId
          : triggerId // ignore: cast_nullable_to_non_nullable
              as String?,
      functionId: freezed == functionId
          ? _value.functionId
          : functionId // ignore: cast_nullable_to_non_nullable
              as String?,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      position: freezed == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as TelemetryPosition?,
      payload: freezed == payload
          ? _value._payload
          : payload // ignore: cast_nullable_to_non_nullable
              as List<TelemetrySensor>?,
      sensors: freezed == sensors
          ? _value._sensors
          : sensors // ignore: cast_nullable_to_non_nullable
              as List<Sensor>?,
      at: freezed == at
          ? _value.at
          : at // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isCheck: freezed == isCheck
          ? _value.isCheck
          : isCheck // ignore: cast_nullable_to_non_nullable
              as bool?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsEvent implements _AtsEvent {
  const _$_AtsEvent(
      {this.id,
      this.operation,
      this.operationId,
      this.trigger,
      this.triggerId,
      this.functionId,
      this.asset,
      this.assetId,
      this.position,
      final List<TelemetrySensor>? payload,
      final List<Sensor>? sensors,
      @TimestampOrNullConverter() this.at,
      this.isCheck,
      this.comment})
      : _payload = payload,
        _sensors = sensors;

  factory _$_AtsEvent.fromJson(Map<String, dynamic> json) =>
      _$$_AtsEventFromJson(json);

  /// [id] of the asset entity. This ID is unique.
  @override
  final String? id;

  /// [operation] Operation linked to the [AtsEvent].
  @override
  final Operation? operation;

  /// [operationId] Operation linked to the [AtsEvent].
  @override
  final String? operationId;

  /// [trigger] Trigger linked to the [AtsEvent].
  @override
  final Trigger? trigger;

  /// [triggerId] Trigger linked to the [AtsEvent].
  @override
  final String? triggerId;
// /// [function] Pitagoras function linked to the [AtsEvent].
// Function? function,
  /// [functionId] Pitagoras function ID linked to the [AtsEvent].
  @override
  final String? functionId;

  /// [asset] Asset linked to the [AtsEvent].
  @override
  final Asset? asset;

  /// [assetId] Asset ID linked to the [AtsEvent].
  @override
  final String? assetId;

  /// [position] linked to the [AtsEvent].
  @override
  final TelemetryPosition? position;

  /// [payload] Raw received payload values list of the message.
  final List<TelemetrySensor>? _payload;

  /// [payload] Raw received payload values list of the message.
  @override
  List<TelemetrySensor>? get payload {
    final value = _payload;
    if (value == null) return null;
    if (_payload is EqualUnmodifiableListView) return _payload;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [sensors] values list of the message.
  final List<Sensor>? _sensors;

  /// [sensors] values list of the message.
  @override
  List<Sensor>? get sensors {
    final value = _sensors;
    if (value == null) return null;
    if (_sensors is EqualUnmodifiableListView) return _sensors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [at] Unix timestamp representing the date of the event.
  @override
  @TimestampOrNullConverter()
  final DateTime? at;

  /// [isCheck] Flag to identify if the event has been checked.
  @override
  final bool? isCheck;

  /// [comment] on closing event.
  @override
  final String? comment;

  @override
  String toString() {
    return 'AtsEvent(id: $id, operation: $operation, operationId: $operationId, trigger: $trigger, triggerId: $triggerId, functionId: $functionId, asset: $asset, assetId: $assetId, position: $position, payload: $payload, sensors: $sensors, at: $at, isCheck: $isCheck, comment: $comment)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsEvent &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.operation, operation) ||
                other.operation == operation) &&
            (identical(other.operationId, operationId) ||
                other.operationId == operationId) &&
            (identical(other.trigger, trigger) || other.trigger == trigger) &&
            (identical(other.triggerId, triggerId) ||
                other.triggerId == triggerId) &&
            (identical(other.functionId, functionId) ||
                other.functionId == functionId) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.position, position) ||
                other.position == position) &&
            const DeepCollectionEquality().equals(other._payload, _payload) &&
            const DeepCollectionEquality().equals(other._sensors, _sensors) &&
            (identical(other.at, at) || other.at == at) &&
            (identical(other.isCheck, isCheck) || other.isCheck == isCheck) &&
            (identical(other.comment, comment) || other.comment == comment));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      operation,
      operationId,
      trigger,
      triggerId,
      functionId,
      asset,
      assetId,
      position,
      const DeepCollectionEquality().hash(_payload),
      const DeepCollectionEquality().hash(_sensors),
      at,
      isCheck,
      comment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsEventCopyWith<_$_AtsEvent> get copyWith =>
      __$$_AtsEventCopyWithImpl<_$_AtsEvent>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsEventToJson(
      this,
    );
  }
}

abstract class _AtsEvent implements AtsEvent {
  const factory _AtsEvent(
      {final String? id,
      final Operation? operation,
      final String? operationId,
      final Trigger? trigger,
      final String? triggerId,
      final String? functionId,
      final Asset? asset,
      final String? assetId,
      final TelemetryPosition? position,
      final List<TelemetrySensor>? payload,
      final List<Sensor>? sensors,
      @TimestampOrNullConverter() final DateTime? at,
      final bool? isCheck,
      final String? comment}) = _$_AtsEvent;

  factory _AtsEvent.fromJson(Map<String, dynamic> json) = _$_AtsEvent.fromJson;

  @override

  /// [id] of the asset entity. This ID is unique.
  String? get id;
  @override

  /// [operation] Operation linked to the [AtsEvent].
  Operation? get operation;
  @override

  /// [operationId] Operation linked to the [AtsEvent].
  String? get operationId;
  @override

  /// [trigger] Trigger linked to the [AtsEvent].
  Trigger? get trigger;
  @override

  /// [triggerId] Trigger linked to the [AtsEvent].
  String? get triggerId;
  @override // /// [function] Pitagoras function linked to the [AtsEvent].
// Function? function,
  /// [functionId] Pitagoras function ID linked to the [AtsEvent].
  String? get functionId;
  @override

  /// [asset] Asset linked to the [AtsEvent].
  Asset? get asset;
  @override

  /// [assetId] Asset ID linked to the [AtsEvent].
  String? get assetId;
  @override

  /// [position] linked to the [AtsEvent].
  TelemetryPosition? get position;
  @override

  /// [payload] Raw received payload values list of the message.
  List<TelemetrySensor>? get payload;
  @override

  /// [sensors] values list of the message.
  List<Sensor>? get sensors;
  @override

  /// [at] Unix timestamp representing the date of the event.
  @TimestampOrNullConverter()
  DateTime? get at;
  @override

  /// [isCheck] Flag to identify if the event has been checked.
  bool? get isCheck;
  @override

  /// [comment] on closing event.
  String? get comment;
  @override
  @JsonKey(ignore: true)
  _$$_AtsEventCopyWith<_$_AtsEvent> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsNsAddress _$AtsNsAddressFromJson(Map<String, dynamic> json) {
  return _AtsNsAddress.fromJson(json);
}

/// @nodoc
mixin _$AtsNsAddress {
  /// [address] represents the address of the address
  String get address => throw _privateConstructorUsedError;

  /// [number] represents the number of the address
  String get number => throw _privateConstructorUsedError;

  /// [district] represents the district of the address
  String get district => throw _privateConstructorUsedError;

  /// [zipCode] represents the zip code of the address
  String get zipCode => throw _privateConstructorUsedError;

  /// [cityCode] represents the city code of the address
  String get cityCode => throw _privateConstructorUsedError;

  /// [cityName] represents the city name of the address
  String get cityName => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsNsAddressCopyWith<AtsNsAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsNsAddressCopyWith<$Res> {
  factory $AtsNsAddressCopyWith(
          AtsNsAddress value, $Res Function(AtsNsAddress) then) =
      _$AtsNsAddressCopyWithImpl<$Res, AtsNsAddress>;
  @useResult
  $Res call(
      {String address,
      String number,
      String district,
      String zipCode,
      String cityCode,
      String cityName});
}

/// @nodoc
class _$AtsNsAddressCopyWithImpl<$Res, $Val extends AtsNsAddress>
    implements $AtsNsAddressCopyWith<$Res> {
  _$AtsNsAddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = null,
    Object? number = null,
    Object? district = null,
    Object? zipCode = null,
    Object? cityCode = null,
    Object? cityName = null,
  }) {
    return _then(_value.copyWith(
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      number: null == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String,
      district: null == district
          ? _value.district
          : district // ignore: cast_nullable_to_non_nullable
              as String,
      zipCode: null == zipCode
          ? _value.zipCode
          : zipCode // ignore: cast_nullable_to_non_nullable
              as String,
      cityCode: null == cityCode
          ? _value.cityCode
          : cityCode // ignore: cast_nullable_to_non_nullable
              as String,
      cityName: null == cityName
          ? _value.cityName
          : cityName // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsNsAddressCopyWith<$Res>
    implements $AtsNsAddressCopyWith<$Res> {
  factory _$$_AtsNsAddressCopyWith(
          _$_AtsNsAddress value, $Res Function(_$_AtsNsAddress) then) =
      __$$_AtsNsAddressCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String address,
      String number,
      String district,
      String zipCode,
      String cityCode,
      String cityName});
}

/// @nodoc
class __$$_AtsNsAddressCopyWithImpl<$Res>
    extends _$AtsNsAddressCopyWithImpl<$Res, _$_AtsNsAddress>
    implements _$$_AtsNsAddressCopyWith<$Res> {
  __$$_AtsNsAddressCopyWithImpl(
      _$_AtsNsAddress _value, $Res Function(_$_AtsNsAddress) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? address = null,
    Object? number = null,
    Object? district = null,
    Object? zipCode = null,
    Object? cityCode = null,
    Object? cityName = null,
  }) {
    return _then(_$_AtsNsAddress(
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
      number: null == number
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String,
      district: null == district
          ? _value.district
          : district // ignore: cast_nullable_to_non_nullable
              as String,
      zipCode: null == zipCode
          ? _value.zipCode
          : zipCode // ignore: cast_nullable_to_non_nullable
              as String,
      cityCode: null == cityCode
          ? _value.cityCode
          : cityCode // ignore: cast_nullable_to_non_nullable
              as String,
      cityName: null == cityName
          ? _value.cityName
          : cityName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsNsAddress implements _AtsNsAddress {
  const _$_AtsNsAddress(
      {required this.address,
      required this.number,
      required this.district,
      required this.zipCode,
      required this.cityCode,
      required this.cityName});

  factory _$_AtsNsAddress.fromJson(Map<String, dynamic> json) =>
      _$$_AtsNsAddressFromJson(json);

  /// [address] represents the address of the address
  @override
  final String address;

  /// [number] represents the number of the address
  @override
  final String number;

  /// [district] represents the district of the address
  @override
  final String district;

  /// [zipCode] represents the zip code of the address
  @override
  final String zipCode;

  /// [cityCode] represents the city code of the address
  @override
  final String cityCode;

  /// [cityName] represents the city name of the address
  @override
  final String cityName;

  @override
  String toString() {
    return 'AtsNsAddress(address: $address, number: $number, district: $district, zipCode: $zipCode, cityCode: $cityCode, cityName: $cityName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsNsAddress &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.number, number) || other.number == number) &&
            (identical(other.district, district) ||
                other.district == district) &&
            (identical(other.zipCode, zipCode) || other.zipCode == zipCode) &&
            (identical(other.cityCode, cityCode) ||
                other.cityCode == cityCode) &&
            (identical(other.cityName, cityName) ||
                other.cityName == cityName));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, address, number, district, zipCode, cityCode, cityName);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsNsAddressCopyWith<_$_AtsNsAddress> get copyWith =>
      __$$_AtsNsAddressCopyWithImpl<_$_AtsNsAddress>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsNsAddressToJson(
      this,
    );
  }
}

abstract class _AtsNsAddress implements AtsNsAddress {
  const factory _AtsNsAddress(
      {required final String address,
      required final String number,
      required final String district,
      required final String zipCode,
      required final String cityCode,
      required final String cityName}) = _$_AtsNsAddress;

  factory _AtsNsAddress.fromJson(Map<String, dynamic> json) =
      _$_AtsNsAddress.fromJson;

  @override

  /// [address] represents the address of the address
  String get address;
  @override

  /// [number] represents the number of the address
  String get number;
  @override

  /// [district] represents the district of the address
  String get district;
  @override

  /// [zipCode] represents the zip code of the address
  String get zipCode;
  @override

  /// [cityCode] represents the city code of the address
  String get cityCode;
  @override

  /// [cityName] represents the city name of the address
  String get cityName;
  @override
  @JsonKey(ignore: true)
  _$$_AtsNsAddressCopyWith<_$_AtsNsAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsNsLicense _$AtsNsLicenseFromJson(Map<String, dynamic> json) {
  return _AtsNsLicense.fromJson(json);
}

/// @nodoc
mixin _$AtsNsLicense {
  /// [id] represents the unique identifier of the license
  String get id => throw _privateConstructorUsedError;

  /// [status] represents the status of the license
  /// `0` means Testing environment
  /// `1` means Production environment
  /// `2` means Blocked license
  @AtsNsStatusConverter()
  AtsNsStatus get status => throw _privateConstructorUsedError;

  /// [receive90Days] represents that the license can receive last 90 days of data.
  /// Also, is only available for [projectId] = `NS DDFe`.
  bool? get receive90Days => throw _privateConstructorUsedError;

  /// [projectId] represents the project id of the license
  @AtsNsProjectIdOrNullConverter()
  AtsNsProjectId? get projectId => throw _privateConstructorUsedError;

  /// [certificate] represents the certificate of the license
  /// Is stored in base64 format
  String? get certificate => throw _privateConstructorUsedError;

  /// [certificatePassword] represents the certificate password of the license
  String? get certificatePassword => throw _privateConstructorUsedError;

  /// [cnpj] represents the CNPJ of the license
  /// CNPJ is equivalent to a Taxpayer Identification Number (TIN) (RIF for Venecos)
  String get cnpj => throw _privateConstructorUsedError;

  /// [inscriptionId] represents the state registration of the license
  String? get inscriptionId => throw _privateConstructorUsedError;

  /// [businessName] represents the business name of the license
  String? get businessName => throw _privateConstructorUsedError;

  /// [companyName] represents the business trademark name of the license
  String? get companyName => throw _privateConstructorUsedError;

  /// [icmsType] represents the ICMS type of the license
  @AtsIcmsTypeOrNullConverter()
  AtsIcmsType? get icmsType => throw _privateConstructorUsedError;

  /// [emails] is a list of `String` that represents the emails of the license
  List<String>? get emails => throw _privateConstructorUsedError;

  /// [phoneNumbers] is a list of `String` that represents the phone numbers of the license
  List<String>? get phoneNumbers => throw _privateConstructorUsedError;

  /// [addresses] is a list of [AtsNsAddress] that represents the addresses of the license
  List<AtsNsAddress>? get addresses => throw _privateConstructorUsedError;

  /// [expirationDate] represents the expiration date of the license
  @JsonKey(name: 'expirationDateUnix')
  @TimestampOrNullConverter()
  DateTime? get expirationDate => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsNsLicenseCopyWith<AtsNsLicense> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsNsLicenseCopyWith<$Res> {
  factory $AtsNsLicenseCopyWith(
          AtsNsLicense value, $Res Function(AtsNsLicense) then) =
      _$AtsNsLicenseCopyWithImpl<$Res, AtsNsLicense>;
  @useResult
  $Res call(
      {String id,
      @AtsNsStatusConverter() AtsNsStatus status,
      bool? receive90Days,
      @AtsNsProjectIdOrNullConverter() AtsNsProjectId? projectId,
      String? certificate,
      String? certificatePassword,
      String cnpj,
      String? inscriptionId,
      String? businessName,
      String? companyName,
      @AtsIcmsTypeOrNullConverter() AtsIcmsType? icmsType,
      List<String>? emails,
      List<String>? phoneNumbers,
      List<AtsNsAddress>? addresses,
      @JsonKey(name: 'expirationDateUnix')
      @TimestampOrNullConverter()
      DateTime? expirationDate});
}

/// @nodoc
class _$AtsNsLicenseCopyWithImpl<$Res, $Val extends AtsNsLicense>
    implements $AtsNsLicenseCopyWith<$Res> {
  _$AtsNsLicenseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? status = null,
    Object? receive90Days = freezed,
    Object? projectId = freezed,
    Object? certificate = freezed,
    Object? certificatePassword = freezed,
    Object? cnpj = null,
    Object? inscriptionId = freezed,
    Object? businessName = freezed,
    Object? companyName = freezed,
    Object? icmsType = freezed,
    Object? emails = freezed,
    Object? phoneNumbers = freezed,
    Object? addresses = freezed,
    Object? expirationDate = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as AtsNsStatus,
      receive90Days: freezed == receive90Days
          ? _value.receive90Days
          : receive90Days // ignore: cast_nullable_to_non_nullable
              as bool?,
      projectId: freezed == projectId
          ? _value.projectId
          : projectId // ignore: cast_nullable_to_non_nullable
              as AtsNsProjectId?,
      certificate: freezed == certificate
          ? _value.certificate
          : certificate // ignore: cast_nullable_to_non_nullable
              as String?,
      certificatePassword: freezed == certificatePassword
          ? _value.certificatePassword
          : certificatePassword // ignore: cast_nullable_to_non_nullable
              as String?,
      cnpj: null == cnpj
          ? _value.cnpj
          : cnpj // ignore: cast_nullable_to_non_nullable
              as String,
      inscriptionId: freezed == inscriptionId
          ? _value.inscriptionId
          : inscriptionId // ignore: cast_nullable_to_non_nullable
              as String?,
      businessName: freezed == businessName
          ? _value.businessName
          : businessName // ignore: cast_nullable_to_non_nullable
              as String?,
      companyName: freezed == companyName
          ? _value.companyName
          : companyName // ignore: cast_nullable_to_non_nullable
              as String?,
      icmsType: freezed == icmsType
          ? _value.icmsType
          : icmsType // ignore: cast_nullable_to_non_nullable
              as AtsIcmsType?,
      emails: freezed == emails
          ? _value.emails
          : emails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      phoneNumbers: freezed == phoneNumbers
          ? _value.phoneNumbers
          : phoneNumbers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      addresses: freezed == addresses
          ? _value.addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<AtsNsAddress>?,
      expirationDate: freezed == expirationDate
          ? _value.expirationDate
          : expirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsNsLicenseCopyWith<$Res>
    implements $AtsNsLicenseCopyWith<$Res> {
  factory _$$_AtsNsLicenseCopyWith(
          _$_AtsNsLicense value, $Res Function(_$_AtsNsLicense) then) =
      __$$_AtsNsLicenseCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @AtsNsStatusConverter() AtsNsStatus status,
      bool? receive90Days,
      @AtsNsProjectIdOrNullConverter() AtsNsProjectId? projectId,
      String? certificate,
      String? certificatePassword,
      String cnpj,
      String? inscriptionId,
      String? businessName,
      String? companyName,
      @AtsIcmsTypeOrNullConverter() AtsIcmsType? icmsType,
      List<String>? emails,
      List<String>? phoneNumbers,
      List<AtsNsAddress>? addresses,
      @JsonKey(name: 'expirationDateUnix')
      @TimestampOrNullConverter()
      DateTime? expirationDate});
}

/// @nodoc
class __$$_AtsNsLicenseCopyWithImpl<$Res>
    extends _$AtsNsLicenseCopyWithImpl<$Res, _$_AtsNsLicense>
    implements _$$_AtsNsLicenseCopyWith<$Res> {
  __$$_AtsNsLicenseCopyWithImpl(
      _$_AtsNsLicense _value, $Res Function(_$_AtsNsLicense) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? status = null,
    Object? receive90Days = freezed,
    Object? projectId = freezed,
    Object? certificate = freezed,
    Object? certificatePassword = freezed,
    Object? cnpj = null,
    Object? inscriptionId = freezed,
    Object? businessName = freezed,
    Object? companyName = freezed,
    Object? icmsType = freezed,
    Object? emails = freezed,
    Object? phoneNumbers = freezed,
    Object? addresses = freezed,
    Object? expirationDate = freezed,
  }) {
    return _then(_$_AtsNsLicense(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as AtsNsStatus,
      receive90Days: freezed == receive90Days
          ? _value.receive90Days
          : receive90Days // ignore: cast_nullable_to_non_nullable
              as bool?,
      projectId: freezed == projectId
          ? _value.projectId
          : projectId // ignore: cast_nullable_to_non_nullable
              as AtsNsProjectId?,
      certificate: freezed == certificate
          ? _value.certificate
          : certificate // ignore: cast_nullable_to_non_nullable
              as String?,
      certificatePassword: freezed == certificatePassword
          ? _value.certificatePassword
          : certificatePassword // ignore: cast_nullable_to_non_nullable
              as String?,
      cnpj: null == cnpj
          ? _value.cnpj
          : cnpj // ignore: cast_nullable_to_non_nullable
              as String,
      inscriptionId: freezed == inscriptionId
          ? _value.inscriptionId
          : inscriptionId // ignore: cast_nullable_to_non_nullable
              as String?,
      businessName: freezed == businessName
          ? _value.businessName
          : businessName // ignore: cast_nullable_to_non_nullable
              as String?,
      companyName: freezed == companyName
          ? _value.companyName
          : companyName // ignore: cast_nullable_to_non_nullable
              as String?,
      icmsType: freezed == icmsType
          ? _value.icmsType
          : icmsType // ignore: cast_nullable_to_non_nullable
              as AtsIcmsType?,
      emails: freezed == emails
          ? _value._emails
          : emails // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      phoneNumbers: freezed == phoneNumbers
          ? _value._phoneNumbers
          : phoneNumbers // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      addresses: freezed == addresses
          ? _value._addresses
          : addresses // ignore: cast_nullable_to_non_nullable
              as List<AtsNsAddress>?,
      expirationDate: freezed == expirationDate
          ? _value.expirationDate
          : expirationDate // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsNsLicense implements _AtsNsLicense {
  const _$_AtsNsLicense(
      {required this.id,
      @AtsNsStatusConverter() required this.status,
      this.receive90Days,
      @AtsNsProjectIdOrNullConverter() this.projectId,
      this.certificate,
      this.certificatePassword,
      required this.cnpj,
      this.inscriptionId,
      this.businessName,
      this.companyName,
      @AtsIcmsTypeOrNullConverter() this.icmsType,
      final List<String>? emails,
      final List<String>? phoneNumbers,
      final List<AtsNsAddress>? addresses,
      @JsonKey(name: 'expirationDateUnix')
      @TimestampOrNullConverter()
      this.expirationDate})
      : _emails = emails,
        _phoneNumbers = phoneNumbers,
        _addresses = addresses;

  factory _$_AtsNsLicense.fromJson(Map<String, dynamic> json) =>
      _$$_AtsNsLicenseFromJson(json);

  /// [id] represents the unique identifier of the license
  @override
  final String id;

  /// [status] represents the status of the license
  /// `0` means Testing environment
  /// `1` means Production environment
  /// `2` means Blocked license
  @override
  @AtsNsStatusConverter()
  final AtsNsStatus status;

  /// [receive90Days] represents that the license can receive last 90 days of data.
  /// Also, is only available for [projectId] = `NS DDFe`.
  @override
  final bool? receive90Days;

  /// [projectId] represents the project id of the license
  @override
  @AtsNsProjectIdOrNullConverter()
  final AtsNsProjectId? projectId;

  /// [certificate] represents the certificate of the license
  /// Is stored in base64 format
  @override
  final String? certificate;

  /// [certificatePassword] represents the certificate password of the license
  @override
  final String? certificatePassword;

  /// [cnpj] represents the CNPJ of the license
  /// CNPJ is equivalent to a Taxpayer Identification Number (TIN) (RIF for Venecos)
  @override
  final String cnpj;

  /// [inscriptionId] represents the state registration of the license
  @override
  final String? inscriptionId;

  /// [businessName] represents the business name of the license
  @override
  final String? businessName;

  /// [companyName] represents the business trademark name of the license
  @override
  final String? companyName;

  /// [icmsType] represents the ICMS type of the license
  @override
  @AtsIcmsTypeOrNullConverter()
  final AtsIcmsType? icmsType;

  /// [emails] is a list of `String` that represents the emails of the license
  final List<String>? _emails;

  /// [emails] is a list of `String` that represents the emails of the license
  @override
  List<String>? get emails {
    final value = _emails;
    if (value == null) return null;
    if (_emails is EqualUnmodifiableListView) return _emails;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [phoneNumbers] is a list of `String` that represents the phone numbers of the license
  final List<String>? _phoneNumbers;

  /// [phoneNumbers] is a list of `String` that represents the phone numbers of the license
  @override
  List<String>? get phoneNumbers {
    final value = _phoneNumbers;
    if (value == null) return null;
    if (_phoneNumbers is EqualUnmodifiableListView) return _phoneNumbers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [addresses] is a list of [AtsNsAddress] that represents the addresses of the license
  final List<AtsNsAddress>? _addresses;

  /// [addresses] is a list of [AtsNsAddress] that represents the addresses of the license
  @override
  List<AtsNsAddress>? get addresses {
    final value = _addresses;
    if (value == null) return null;
    if (_addresses is EqualUnmodifiableListView) return _addresses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [expirationDate] represents the expiration date of the license
  @override
  @JsonKey(name: 'expirationDateUnix')
  @TimestampOrNullConverter()
  final DateTime? expirationDate;

  @override
  String toString() {
    return 'AtsNsLicense(id: $id, status: $status, receive90Days: $receive90Days, projectId: $projectId, certificate: $certificate, certificatePassword: $certificatePassword, cnpj: $cnpj, inscriptionId: $inscriptionId, businessName: $businessName, companyName: $companyName, icmsType: $icmsType, emails: $emails, phoneNumbers: $phoneNumbers, addresses: $addresses, expirationDate: $expirationDate)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsNsLicense &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.receive90Days, receive90Days) ||
                other.receive90Days == receive90Days) &&
            (identical(other.projectId, projectId) ||
                other.projectId == projectId) &&
            (identical(other.certificate, certificate) ||
                other.certificate == certificate) &&
            (identical(other.certificatePassword, certificatePassword) ||
                other.certificatePassword == certificatePassword) &&
            (identical(other.cnpj, cnpj) || other.cnpj == cnpj) &&
            (identical(other.inscriptionId, inscriptionId) ||
                other.inscriptionId == inscriptionId) &&
            (identical(other.businessName, businessName) ||
                other.businessName == businessName) &&
            (identical(other.companyName, companyName) ||
                other.companyName == companyName) &&
            (identical(other.icmsType, icmsType) ||
                other.icmsType == icmsType) &&
            const DeepCollectionEquality().equals(other._emails, _emails) &&
            const DeepCollectionEquality()
                .equals(other._phoneNumbers, _phoneNumbers) &&
            const DeepCollectionEquality()
                .equals(other._addresses, _addresses) &&
            (identical(other.expirationDate, expirationDate) ||
                other.expirationDate == expirationDate));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      status,
      receive90Days,
      projectId,
      certificate,
      certificatePassword,
      cnpj,
      inscriptionId,
      businessName,
      companyName,
      icmsType,
      const DeepCollectionEquality().hash(_emails),
      const DeepCollectionEquality().hash(_phoneNumbers),
      const DeepCollectionEquality().hash(_addresses),
      expirationDate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsNsLicenseCopyWith<_$_AtsNsLicense> get copyWith =>
      __$$_AtsNsLicenseCopyWithImpl<_$_AtsNsLicense>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsNsLicenseToJson(
      this,
    );
  }
}

abstract class _AtsNsLicense implements AtsNsLicense {
  const factory _AtsNsLicense(
      {required final String id,
      @AtsNsStatusConverter() required final AtsNsStatus status,
      final bool? receive90Days,
      @AtsNsProjectIdOrNullConverter() final AtsNsProjectId? projectId,
      final String? certificate,
      final String? certificatePassword,
      required final String cnpj,
      final String? inscriptionId,
      final String? businessName,
      final String? companyName,
      @AtsIcmsTypeOrNullConverter() final AtsIcmsType? icmsType,
      final List<String>? emails,
      final List<String>? phoneNumbers,
      final List<AtsNsAddress>? addresses,
      @JsonKey(name: 'expirationDateUnix')
      @TimestampOrNullConverter()
      final DateTime? expirationDate}) = _$_AtsNsLicense;

  factory _AtsNsLicense.fromJson(Map<String, dynamic> json) =
      _$_AtsNsLicense.fromJson;

  @override

  /// [id] represents the unique identifier of the license
  String get id;
  @override

  /// [status] represents the status of the license
  /// `0` means Testing environment
  /// `1` means Production environment
  /// `2` means Blocked license
  @AtsNsStatusConverter()
  AtsNsStatus get status;
  @override

  /// [receive90Days] represents that the license can receive last 90 days of data.
  /// Also, is only available for [projectId] = `NS DDFe`.
  bool? get receive90Days;
  @override

  /// [projectId] represents the project id of the license
  @AtsNsProjectIdOrNullConverter()
  AtsNsProjectId? get projectId;
  @override

  /// [certificate] represents the certificate of the license
  /// Is stored in base64 format
  String? get certificate;
  @override

  /// [certificatePassword] represents the certificate password of the license
  String? get certificatePassword;
  @override

  /// [cnpj] represents the CNPJ of the license
  /// CNPJ is equivalent to a Taxpayer Identification Number (TIN) (RIF for Venecos)
  String get cnpj;
  @override

  /// [inscriptionId] represents the state registration of the license
  String? get inscriptionId;
  @override

  /// [businessName] represents the business name of the license
  String? get businessName;
  @override

  /// [companyName] represents the business trademark name of the license
  String? get companyName;
  @override

  /// [icmsType] represents the ICMS type of the license
  @AtsIcmsTypeOrNullConverter()
  AtsIcmsType? get icmsType;
  @override

  /// [emails] is a list of `String` that represents the emails of the license
  List<String>? get emails;
  @override

  /// [phoneNumbers] is a list of `String` that represents the phone numbers of the license
  List<String>? get phoneNumbers;
  @override

  /// [addresses] is a list of [AtsNsAddress] that represents the addresses of the license
  List<AtsNsAddress>? get addresses;
  @override

  /// [expirationDate] represents the expiration date of the license
  @JsonKey(name: 'expirationDateUnix')
  @TimestampOrNullConverter()
  DateTime? get expirationDate;
  @override
  @JsonKey(ignore: true)
  _$$_AtsNsLicenseCopyWith<_$_AtsNsLicense> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsTransportInformation _$AtsTransportInformationFromJson(
    Map<String, dynamic> json) {
  return _AtsTransportInformation.fromJson(json);
}

/// @nodoc
mixin _$AtsTransportInformation {
  /// Transport company CNPJ.
  String? get cnpj => throw _privateConstructorUsedError;

  /// Transport name / description.
  String? get name => throw _privateConstructorUsedError;

  /// Transport address.
  String? get address => throw _privateConstructorUsedError;

  /// Transport mun.
  String? get mun => throw _privateConstructorUsedError;

  /// Freight mod.
  String? get freightMod => throw _privateConstructorUsedError;

  /// Federal unit.
  String? get federalUnit => throw _privateConstructorUsedError;

  /// Business number.
  String? get businessNumber => throw _privateConstructorUsedError;

  /// Vehicle plate code.
  String? get vehiclePlate => throw _privateConstructorUsedError;

  /// Vehicle federal unit.
  String? get vehicleUf => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsTransportInformationCopyWith<AtsTransportInformation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsTransportInformationCopyWith<$Res> {
  factory $AtsTransportInformationCopyWith(AtsTransportInformation value,
          $Res Function(AtsTransportInformation) then) =
      _$AtsTransportInformationCopyWithImpl<$Res, AtsTransportInformation>;
  @useResult
  $Res call(
      {String? cnpj,
      String? name,
      String? address,
      String? mun,
      String? freightMod,
      String? federalUnit,
      String? businessNumber,
      String? vehiclePlate,
      String? vehicleUf});
}

/// @nodoc
class _$AtsTransportInformationCopyWithImpl<$Res,
        $Val extends AtsTransportInformation>
    implements $AtsTransportInformationCopyWith<$Res> {
  _$AtsTransportInformationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cnpj = freezed,
    Object? name = freezed,
    Object? address = freezed,
    Object? mun = freezed,
    Object? freightMod = freezed,
    Object? federalUnit = freezed,
    Object? businessNumber = freezed,
    Object? vehiclePlate = freezed,
    Object? vehicleUf = freezed,
  }) {
    return _then(_value.copyWith(
      cnpj: freezed == cnpj
          ? _value.cnpj
          : cnpj // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
      mun: freezed == mun
          ? _value.mun
          : mun // ignore: cast_nullable_to_non_nullable
              as String?,
      freightMod: freezed == freightMod
          ? _value.freightMod
          : freightMod // ignore: cast_nullable_to_non_nullable
              as String?,
      federalUnit: freezed == federalUnit
          ? _value.federalUnit
          : federalUnit // ignore: cast_nullable_to_non_nullable
              as String?,
      businessNumber: freezed == businessNumber
          ? _value.businessNumber
          : businessNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      vehiclePlate: freezed == vehiclePlate
          ? _value.vehiclePlate
          : vehiclePlate // ignore: cast_nullable_to_non_nullable
              as String?,
      vehicleUf: freezed == vehicleUf
          ? _value.vehicleUf
          : vehicleUf // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsTransportInformationCopyWith<$Res>
    implements $AtsTransportInformationCopyWith<$Res> {
  factory _$$_AtsTransportInformationCopyWith(_$_AtsTransportInformation value,
          $Res Function(_$_AtsTransportInformation) then) =
      __$$_AtsTransportInformationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? cnpj,
      String? name,
      String? address,
      String? mun,
      String? freightMod,
      String? federalUnit,
      String? businessNumber,
      String? vehiclePlate,
      String? vehicleUf});
}

/// @nodoc
class __$$_AtsTransportInformationCopyWithImpl<$Res>
    extends _$AtsTransportInformationCopyWithImpl<$Res,
        _$_AtsTransportInformation>
    implements _$$_AtsTransportInformationCopyWith<$Res> {
  __$$_AtsTransportInformationCopyWithImpl(_$_AtsTransportInformation _value,
      $Res Function(_$_AtsTransportInformation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cnpj = freezed,
    Object? name = freezed,
    Object? address = freezed,
    Object? mun = freezed,
    Object? freightMod = freezed,
    Object? federalUnit = freezed,
    Object? businessNumber = freezed,
    Object? vehiclePlate = freezed,
    Object? vehicleUf = freezed,
  }) {
    return _then(_$_AtsTransportInformation(
      cnpj: freezed == cnpj
          ? _value.cnpj
          : cnpj // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
      mun: freezed == mun
          ? _value.mun
          : mun // ignore: cast_nullable_to_non_nullable
              as String?,
      freightMod: freezed == freightMod
          ? _value.freightMod
          : freightMod // ignore: cast_nullable_to_non_nullable
              as String?,
      federalUnit: freezed == federalUnit
          ? _value.federalUnit
          : federalUnit // ignore: cast_nullable_to_non_nullable
              as String?,
      businessNumber: freezed == businessNumber
          ? _value.businessNumber
          : businessNumber // ignore: cast_nullable_to_non_nullable
              as String?,
      vehiclePlate: freezed == vehiclePlate
          ? _value.vehiclePlate
          : vehiclePlate // ignore: cast_nullable_to_non_nullable
              as String?,
      vehicleUf: freezed == vehicleUf
          ? _value.vehicleUf
          : vehicleUf // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsTransportInformation implements _AtsTransportInformation {
  _$_AtsTransportInformation(
      {this.cnpj,
      this.name,
      this.address,
      this.mun,
      this.freightMod,
      this.federalUnit,
      this.businessNumber,
      this.vehiclePlate,
      this.vehicleUf});

  factory _$_AtsTransportInformation.fromJson(Map<String, dynamic> json) =>
      _$$_AtsTransportInformationFromJson(json);

  /// Transport company CNPJ.
  @override
  final String? cnpj;

  /// Transport name / description.
  @override
  final String? name;

  /// Transport address.
  @override
  final String? address;

  /// Transport mun.
  @override
  final String? mun;

  /// Freight mod.
  @override
  final String? freightMod;

  /// Federal unit.
  @override
  final String? federalUnit;

  /// Business number.
  @override
  final String? businessNumber;

  /// Vehicle plate code.
  @override
  final String? vehiclePlate;

  /// Vehicle federal unit.
  @override
  final String? vehicleUf;

  @override
  String toString() {
    return 'AtsTransportInformation(cnpj: $cnpj, name: $name, address: $address, mun: $mun, freightMod: $freightMod, federalUnit: $federalUnit, businessNumber: $businessNumber, vehiclePlate: $vehiclePlate, vehicleUf: $vehicleUf)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsTransportInformation &&
            (identical(other.cnpj, cnpj) || other.cnpj == cnpj) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.mun, mun) || other.mun == mun) &&
            (identical(other.freightMod, freightMod) ||
                other.freightMod == freightMod) &&
            (identical(other.federalUnit, federalUnit) ||
                other.federalUnit == federalUnit) &&
            (identical(other.businessNumber, businessNumber) ||
                other.businessNumber == businessNumber) &&
            (identical(other.vehiclePlate, vehiclePlate) ||
                other.vehiclePlate == vehiclePlate) &&
            (identical(other.vehicleUf, vehicleUf) ||
                other.vehicleUf == vehicleUf));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, cnpj, name, address, mun,
      freightMod, federalUnit, businessNumber, vehiclePlate, vehicleUf);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsTransportInformationCopyWith<_$_AtsTransportInformation>
      get copyWith =>
          __$$_AtsTransportInformationCopyWithImpl<_$_AtsTransportInformation>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsTransportInformationToJson(
      this,
    );
  }
}

abstract class _AtsTransportInformation implements AtsTransportInformation {
  factory _AtsTransportInformation(
      {final String? cnpj,
      final String? name,
      final String? address,
      final String? mun,
      final String? freightMod,
      final String? federalUnit,
      final String? businessNumber,
      final String? vehiclePlate,
      final String? vehicleUf}) = _$_AtsTransportInformation;

  factory _AtsTransportInformation.fromJson(Map<String, dynamic> json) =
      _$_AtsTransportInformation.fromJson;

  @override

  /// Transport company CNPJ.
  String? get cnpj;
  @override

  /// Transport name / description.
  String? get name;
  @override

  /// Transport address.
  String? get address;
  @override

  /// Transport mun.
  String? get mun;
  @override

  /// Freight mod.
  String? get freightMod;
  @override

  /// Federal unit.
  String? get federalUnit;
  @override

  /// Business number.
  String? get businessNumber;
  @override

  /// Vehicle plate code.
  String? get vehiclePlate;
  @override

  /// Vehicle federal unit.
  String? get vehicleUf;
  @override
  @JsonKey(ignore: true)
  _$$_AtsTransportInformationCopyWith<_$_AtsTransportInformation>
      get copyWith => throw _privateConstructorUsedError;
}

AtsCompanyInformation _$AtsCompanyInformationFromJson(
    Map<String, dynamic> json) {
  return _AtsCompanyInformation.fromJson(json);
}

/// @nodoc
mixin _$AtsCompanyInformation {
  /// Your company name, could be the legal name or commercial name. For example, Golden M is the commercial name of Golden M, Inc.
  String? get name => throw _privateConstructorUsedError;

  /// Company National Registry of Legal Entities.
  String? get cnpj => throw _privateConstructorUsedError;

  /// Company Address
  String? get address => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsCompanyInformationCopyWith<AtsCompanyInformation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsCompanyInformationCopyWith<$Res> {
  factory $AtsCompanyInformationCopyWith(AtsCompanyInformation value,
          $Res Function(AtsCompanyInformation) then) =
      _$AtsCompanyInformationCopyWithImpl<$Res, AtsCompanyInformation>;
  @useResult
  $Res call({String? name, String? cnpj, String? address});
}

/// @nodoc
class _$AtsCompanyInformationCopyWithImpl<$Res,
        $Val extends AtsCompanyInformation>
    implements $AtsCompanyInformationCopyWith<$Res> {
  _$AtsCompanyInformationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? cnpj = freezed,
    Object? address = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      cnpj: freezed == cnpj
          ? _value.cnpj
          : cnpj // ignore: cast_nullable_to_non_nullable
              as String?,
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsCompanyInformationCopyWith<$Res>
    implements $AtsCompanyInformationCopyWith<$Res> {
  factory _$$_AtsCompanyInformationCopyWith(_$_AtsCompanyInformation value,
          $Res Function(_$_AtsCompanyInformation) then) =
      __$$_AtsCompanyInformationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, String? cnpj, String? address});
}

/// @nodoc
class __$$_AtsCompanyInformationCopyWithImpl<$Res>
    extends _$AtsCompanyInformationCopyWithImpl<$Res, _$_AtsCompanyInformation>
    implements _$$_AtsCompanyInformationCopyWith<$Res> {
  __$$_AtsCompanyInformationCopyWithImpl(_$_AtsCompanyInformation _value,
      $Res Function(_$_AtsCompanyInformation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? cnpj = freezed,
    Object? address = freezed,
  }) {
    return _then(_$_AtsCompanyInformation(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      cnpj: freezed == cnpj
          ? _value.cnpj
          : cnpj // ignore: cast_nullable_to_non_nullable
              as String?,
      address: freezed == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsCompanyInformation implements _AtsCompanyInformation {
  _$_AtsCompanyInformation({this.name, this.cnpj, this.address});

  factory _$_AtsCompanyInformation.fromJson(Map<String, dynamic> json) =>
      _$$_AtsCompanyInformationFromJson(json);

  /// Your company name, could be the legal name or commercial name. For example, Golden M is the commercial name of Golden M, Inc.
  @override
  final String? name;

  /// Company National Registry of Legal Entities.
  @override
  final String? cnpj;

  /// Company Address
  @override
  final String? address;

  @override
  String toString() {
    return 'AtsCompanyInformation(name: $name, cnpj: $cnpj, address: $address)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsCompanyInformation &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.cnpj, cnpj) || other.cnpj == cnpj) &&
            (identical(other.address, address) || other.address == address));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, name, cnpj, address);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsCompanyInformationCopyWith<_$_AtsCompanyInformation> get copyWith =>
      __$$_AtsCompanyInformationCopyWithImpl<_$_AtsCompanyInformation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsCompanyInformationToJson(
      this,
    );
  }
}

abstract class _AtsCompanyInformation implements AtsCompanyInformation {
  factory _AtsCompanyInformation(
      {final String? name,
      final String? cnpj,
      final String? address}) = _$_AtsCompanyInformation;

  factory _AtsCompanyInformation.fromJson(Map<String, dynamic> json) =
      _$_AtsCompanyInformation.fromJson;

  @override

  /// Your company name, could be the legal name or commercial name. For example, Golden M is the commercial name of Golden M, Inc.
  String? get name;
  @override

  /// Company National Registry of Legal Entities.
  String? get cnpj;
  @override

  /// Company Address
  String? get address;
  @override
  @JsonKey(ignore: true)
  _$$_AtsCompanyInformationCopyWith<_$_AtsCompanyInformation> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsProductInformation _$AtsProductInformationFromJson(
    Map<String, dynamic> json) {
  return _AtsProductInformation.fromJson(json);
}

/// @nodoc
mixin _$AtsProductInformation {
  /// Product code.
  String? get ncm => throw _privateConstructorUsedError;

  /// Product name / description.
  String? get name => throw _privateConstructorUsedError;

  /// Measure unit of the product.
  String? get measureUnit => throw _privateConstructorUsedError;

  /// Quantity of the product it is of [AtsReceptionPructsInput] volumeBought.
  double? get quantity => throw _privateConstructorUsedError;

  /// Unitary value of the product.
  double? get unitValue => throw _privateConstructorUsedError;

  /// Result of quantity + unit_value (From API)
  double? get productValue => throw _privateConstructorUsedError;

  /// Product sub category.
  Map<String, dynamic>? get subcategory => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsProductInformationCopyWith<AtsProductInformation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsProductInformationCopyWith<$Res> {
  factory $AtsProductInformationCopyWith(AtsProductInformation value,
          $Res Function(AtsProductInformation) then) =
      _$AtsProductInformationCopyWithImpl<$Res, AtsProductInformation>;
  @useResult
  $Res call(
      {String? ncm,
      String? name,
      String? measureUnit,
      double? quantity,
      double? unitValue,
      double? productValue,
      Map<String, dynamic>? subcategory});
}

/// @nodoc
class _$AtsProductInformationCopyWithImpl<$Res,
        $Val extends AtsProductInformation>
    implements $AtsProductInformationCopyWith<$Res> {
  _$AtsProductInformationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ncm = freezed,
    Object? name = freezed,
    Object? measureUnit = freezed,
    Object? quantity = freezed,
    Object? unitValue = freezed,
    Object? productValue = freezed,
    Object? subcategory = freezed,
  }) {
    return _then(_value.copyWith(
      ncm: freezed == ncm
          ? _value.ncm
          : ncm // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      measureUnit: freezed == measureUnit
          ? _value.measureUnit
          : measureUnit // ignore: cast_nullable_to_non_nullable
              as String?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as double?,
      unitValue: freezed == unitValue
          ? _value.unitValue
          : unitValue // ignore: cast_nullable_to_non_nullable
              as double?,
      productValue: freezed == productValue
          ? _value.productValue
          : productValue // ignore: cast_nullable_to_non_nullable
              as double?,
      subcategory: freezed == subcategory
          ? _value.subcategory
          : subcategory // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsProductInformationCopyWith<$Res>
    implements $AtsProductInformationCopyWith<$Res> {
  factory _$$_AtsProductInformationCopyWith(_$_AtsProductInformation value,
          $Res Function(_$_AtsProductInformation) then) =
      __$$_AtsProductInformationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? ncm,
      String? name,
      String? measureUnit,
      double? quantity,
      double? unitValue,
      double? productValue,
      Map<String, dynamic>? subcategory});
}

/// @nodoc
class __$$_AtsProductInformationCopyWithImpl<$Res>
    extends _$AtsProductInformationCopyWithImpl<$Res, _$_AtsProductInformation>
    implements _$$_AtsProductInformationCopyWith<$Res> {
  __$$_AtsProductInformationCopyWithImpl(_$_AtsProductInformation _value,
      $Res Function(_$_AtsProductInformation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? ncm = freezed,
    Object? name = freezed,
    Object? measureUnit = freezed,
    Object? quantity = freezed,
    Object? unitValue = freezed,
    Object? productValue = freezed,
    Object? subcategory = freezed,
  }) {
    return _then(_$_AtsProductInformation(
      ncm: freezed == ncm
          ? _value.ncm
          : ncm // ignore: cast_nullable_to_non_nullable
              as String?,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      measureUnit: freezed == measureUnit
          ? _value.measureUnit
          : measureUnit // ignore: cast_nullable_to_non_nullable
              as String?,
      quantity: freezed == quantity
          ? _value.quantity
          : quantity // ignore: cast_nullable_to_non_nullable
              as double?,
      unitValue: freezed == unitValue
          ? _value.unitValue
          : unitValue // ignore: cast_nullable_to_non_nullable
              as double?,
      productValue: freezed == productValue
          ? _value.productValue
          : productValue // ignore: cast_nullable_to_non_nullable
              as double?,
      subcategory: freezed == subcategory
          ? _value._subcategory
          : subcategory // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsProductInformation implements _AtsProductInformation {
  _$_AtsProductInformation(
      {this.ncm,
      this.name,
      this.measureUnit,
      this.quantity,
      this.unitValue,
      this.productValue,
      final Map<String, dynamic>? subcategory})
      : _subcategory = subcategory;

  factory _$_AtsProductInformation.fromJson(Map<String, dynamic> json) =>
      _$$_AtsProductInformationFromJson(json);

  /// Product code.
  @override
  final String? ncm;

  /// Product name / description.
  @override
  final String? name;

  /// Measure unit of the product.
  @override
  final String? measureUnit;

  /// Quantity of the product it is of [AtsReceptionPructsInput] volumeBought.
  @override
  final double? quantity;

  /// Unitary value of the product.
  @override
  final double? unitValue;

  /// Result of quantity + unit_value (From API)
  @override
  final double? productValue;

  /// Product sub category.
  final Map<String, dynamic>? _subcategory;

  /// Product sub category.
  @override
  Map<String, dynamic>? get subcategory {
    final value = _subcategory;
    if (value == null) return null;
    if (_subcategory is EqualUnmodifiableMapView) return _subcategory;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'AtsProductInformation(ncm: $ncm, name: $name, measureUnit: $measureUnit, quantity: $quantity, unitValue: $unitValue, productValue: $productValue, subcategory: $subcategory)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsProductInformation &&
            (identical(other.ncm, ncm) || other.ncm == ncm) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.measureUnit, measureUnit) ||
                other.measureUnit == measureUnit) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.unitValue, unitValue) ||
                other.unitValue == unitValue) &&
            (identical(other.productValue, productValue) ||
                other.productValue == productValue) &&
            const DeepCollectionEquality()
                .equals(other._subcategory, _subcategory));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      ncm,
      name,
      measureUnit,
      quantity,
      unitValue,
      productValue,
      const DeepCollectionEquality().hash(_subcategory));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsProductInformationCopyWith<_$_AtsProductInformation> get copyWith =>
      __$$_AtsProductInformationCopyWithImpl<_$_AtsProductInformation>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsProductInformationToJson(
      this,
    );
  }
}

abstract class _AtsProductInformation implements AtsProductInformation {
  factory _AtsProductInformation(
      {final String? ncm,
      final String? name,
      final String? measureUnit,
      final double? quantity,
      final double? unitValue,
      final double? productValue,
      final Map<String, dynamic>? subcategory}) = _$_AtsProductInformation;

  factory _AtsProductInformation.fromJson(Map<String, dynamic> json) =
      _$_AtsProductInformation.fromJson;

  @override

  /// Product code.
  String? get ncm;
  @override

  /// Product name / description.
  String? get name;
  @override

  /// Measure unit of the product.
  String? get measureUnit;
  @override

  /// Quantity of the product it is of [AtsReceptionPructsInput] volumeBought.
  double? get quantity;
  @override

  /// Unitary value of the product.
  double? get unitValue;
  @override

  /// Result of quantity + unit_value (From API)
  double? get productValue;
  @override

  /// Product sub category.
  Map<String, dynamic>? get subcategory;
  @override
  @JsonKey(ignore: true)
  _$$_AtsProductInformationCopyWith<_$_AtsProductInformation> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsPurchaseOrder _$AtsPurchaseOrderFromJson(Map<String, dynamic> json) {
  return _AtsPurchaseOrder.fromJson(json);
}

/// @nodoc
mixin _$AtsPurchaseOrder {
  /// ID of the [Asset] entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// External API ID
  String? get ownerId => throw _privateConstructorUsedError;

  /// Order or invoice number.
  String? get orderId => throw _privateConstructorUsedError;

  /// ID of the asset.
  String? get assetId => throw _privateConstructorUsedError;

  /// Unix of last [AtsReception] date.
  @TimestampOrNullConverter()
  DateTime? get purchasedAt => throw _privateConstructorUsedError;

  /// Unix of last [AtsReception] date.
  @TimestampOrNullConverter()
  DateTime? get receivedAt => throw _privateConstructorUsedError;

  /// [Asset] linked to the [AtsPurchaseOrder].
  Asset? get asset => throw _privateConstructorUsedError;

  /// Legal information about the seller. Please read the comments of CompanyInformation definition for more information.
  AtsCompanyInformation? get sellerInformation =>
      throw _privateConstructorUsedError;

  /// Legal information about the receiver. Please read the comments of CompanyInformation definition for more information.
  AtsCompanyInformation? get receiverInformation =>
      throw _privateConstructorUsedError;

  /// List of products purchased. Please read the comments of ProductInformation definition for more information.
  List<AtsProductInformation>? get productsInformation =>
      throw _privateConstructorUsedError;

  /// Total information. Please read the comments of Total definition for more information.
  AtsPurchaseTotal? get total => throw _privateConstructorUsedError;

  /// True if the purchase order was received.
  bool? get isReceived => throw _privateConstructorUsedError;

  /// True is the purchase order has a reception
  bool? get hasReception => throw _privateConstructorUsedError;

  /// Legal information about the transport. Please read the comments of TransportInformation definition for more information.
  AtsTransportInformation? get transportInformation =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsPurchaseOrderCopyWith<AtsPurchaseOrder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsPurchaseOrderCopyWith<$Res> {
  factory $AtsPurchaseOrderCopyWith(
          AtsPurchaseOrder value, $Res Function(AtsPurchaseOrder) then) =
      _$AtsPurchaseOrderCopyWithImpl<$Res, AtsPurchaseOrder>;
  @useResult
  $Res call(
      {String? id,
      String? ownerId,
      String? orderId,
      String? assetId,
      @TimestampOrNullConverter() DateTime? purchasedAt,
      @TimestampOrNullConverter() DateTime? receivedAt,
      Asset? asset,
      AtsCompanyInformation? sellerInformation,
      AtsCompanyInformation? receiverInformation,
      List<AtsProductInformation>? productsInformation,
      AtsPurchaseTotal? total,
      bool? isReceived,
      bool? hasReception,
      AtsTransportInformation? transportInformation});

  $AssetCopyWith<$Res>? get asset;
  $AtsCompanyInformationCopyWith<$Res>? get sellerInformation;
  $AtsCompanyInformationCopyWith<$Res>? get receiverInformation;
  $AtsPurchaseTotalCopyWith<$Res>? get total;
  $AtsTransportInformationCopyWith<$Res>? get transportInformation;
}

/// @nodoc
class _$AtsPurchaseOrderCopyWithImpl<$Res, $Val extends AtsPurchaseOrder>
    implements $AtsPurchaseOrderCopyWith<$Res> {
  _$AtsPurchaseOrderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? ownerId = freezed,
    Object? orderId = freezed,
    Object? assetId = freezed,
    Object? purchasedAt = freezed,
    Object? receivedAt = freezed,
    Object? asset = freezed,
    Object? sellerInformation = freezed,
    Object? receiverInformation = freezed,
    Object? productsInformation = freezed,
    Object? total = freezed,
    Object? isReceived = freezed,
    Object? hasReception = freezed,
    Object? transportInformation = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      ownerId: freezed == ownerId
          ? _value.ownerId
          : ownerId // ignore: cast_nullable_to_non_nullable
              as String?,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as String?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      purchasedAt: freezed == purchasedAt
          ? _value.purchasedAt
          : purchasedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      receivedAt: freezed == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      sellerInformation: freezed == sellerInformation
          ? _value.sellerInformation
          : sellerInformation // ignore: cast_nullable_to_non_nullable
              as AtsCompanyInformation?,
      receiverInformation: freezed == receiverInformation
          ? _value.receiverInformation
          : receiverInformation // ignore: cast_nullable_to_non_nullable
              as AtsCompanyInformation?,
      productsInformation: freezed == productsInformation
          ? _value.productsInformation
          : productsInformation // ignore: cast_nullable_to_non_nullable
              as List<AtsProductInformation>?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as AtsPurchaseTotal?,
      isReceived: freezed == isReceived
          ? _value.isReceived
          : isReceived // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasReception: freezed == hasReception
          ? _value.hasReception
          : hasReception // ignore: cast_nullable_to_non_nullable
              as bool?,
      transportInformation: freezed == transportInformation
          ? _value.transportInformation
          : transportInformation // ignore: cast_nullable_to_non_nullable
              as AtsTransportInformation?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get asset {
    if (_value.asset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.asset!, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsCompanyInformationCopyWith<$Res>? get sellerInformation {
    if (_value.sellerInformation == null) {
      return null;
    }

    return $AtsCompanyInformationCopyWith<$Res>(_value.sellerInformation!,
        (value) {
      return _then(_value.copyWith(sellerInformation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsCompanyInformationCopyWith<$Res>? get receiverInformation {
    if (_value.receiverInformation == null) {
      return null;
    }

    return $AtsCompanyInformationCopyWith<$Res>(_value.receiverInformation!,
        (value) {
      return _then(_value.copyWith(receiverInformation: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsPurchaseTotalCopyWith<$Res>? get total {
    if (_value.total == null) {
      return null;
    }

    return $AtsPurchaseTotalCopyWith<$Res>(_value.total!, (value) {
      return _then(_value.copyWith(total: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsTransportInformationCopyWith<$Res>? get transportInformation {
    if (_value.transportInformation == null) {
      return null;
    }

    return $AtsTransportInformationCopyWith<$Res>(_value.transportInformation!,
        (value) {
      return _then(_value.copyWith(transportInformation: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsPurchaseOrderCopyWith<$Res>
    implements $AtsPurchaseOrderCopyWith<$Res> {
  factory _$$_AtsPurchaseOrderCopyWith(
          _$_AtsPurchaseOrder value, $Res Function(_$_AtsPurchaseOrder) then) =
      __$$_AtsPurchaseOrderCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? ownerId,
      String? orderId,
      String? assetId,
      @TimestampOrNullConverter() DateTime? purchasedAt,
      @TimestampOrNullConverter() DateTime? receivedAt,
      Asset? asset,
      AtsCompanyInformation? sellerInformation,
      AtsCompanyInformation? receiverInformation,
      List<AtsProductInformation>? productsInformation,
      AtsPurchaseTotal? total,
      bool? isReceived,
      bool? hasReception,
      AtsTransportInformation? transportInformation});

  @override
  $AssetCopyWith<$Res>? get asset;
  @override
  $AtsCompanyInformationCopyWith<$Res>? get sellerInformation;
  @override
  $AtsCompanyInformationCopyWith<$Res>? get receiverInformation;
  @override
  $AtsPurchaseTotalCopyWith<$Res>? get total;
  @override
  $AtsTransportInformationCopyWith<$Res>? get transportInformation;
}

/// @nodoc
class __$$_AtsPurchaseOrderCopyWithImpl<$Res>
    extends _$AtsPurchaseOrderCopyWithImpl<$Res, _$_AtsPurchaseOrder>
    implements _$$_AtsPurchaseOrderCopyWith<$Res> {
  __$$_AtsPurchaseOrderCopyWithImpl(
      _$_AtsPurchaseOrder _value, $Res Function(_$_AtsPurchaseOrder) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? ownerId = freezed,
    Object? orderId = freezed,
    Object? assetId = freezed,
    Object? purchasedAt = freezed,
    Object? receivedAt = freezed,
    Object? asset = freezed,
    Object? sellerInformation = freezed,
    Object? receiverInformation = freezed,
    Object? productsInformation = freezed,
    Object? total = freezed,
    Object? isReceived = freezed,
    Object? hasReception = freezed,
    Object? transportInformation = freezed,
  }) {
    return _then(_$_AtsPurchaseOrder(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      ownerId: freezed == ownerId
          ? _value.ownerId
          : ownerId // ignore: cast_nullable_to_non_nullable
              as String?,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as String?,
      assetId: freezed == assetId
          ? _value.assetId
          : assetId // ignore: cast_nullable_to_non_nullable
              as String?,
      purchasedAt: freezed == purchasedAt
          ? _value.purchasedAt
          : purchasedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      receivedAt: freezed == receivedAt
          ? _value.receivedAt
          : receivedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      asset: freezed == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      sellerInformation: freezed == sellerInformation
          ? _value.sellerInformation
          : sellerInformation // ignore: cast_nullable_to_non_nullable
              as AtsCompanyInformation?,
      receiverInformation: freezed == receiverInformation
          ? _value.receiverInformation
          : receiverInformation // ignore: cast_nullable_to_non_nullable
              as AtsCompanyInformation?,
      productsInformation: freezed == productsInformation
          ? _value._productsInformation
          : productsInformation // ignore: cast_nullable_to_non_nullable
              as List<AtsProductInformation>?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as AtsPurchaseTotal?,
      isReceived: freezed == isReceived
          ? _value.isReceived
          : isReceived // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasReception: freezed == hasReception
          ? _value.hasReception
          : hasReception // ignore: cast_nullable_to_non_nullable
              as bool?,
      transportInformation: freezed == transportInformation
          ? _value.transportInformation
          : transportInformation // ignore: cast_nullable_to_non_nullable
              as AtsTransportInformation?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsPurchaseOrder implements _AtsPurchaseOrder {
  _$_AtsPurchaseOrder(
      {this.id,
      this.ownerId,
      this.orderId,
      this.assetId,
      @TimestampOrNullConverter() this.purchasedAt,
      @TimestampOrNullConverter() this.receivedAt,
      this.asset,
      this.sellerInformation,
      this.receiverInformation,
      final List<AtsProductInformation>? productsInformation,
      this.total,
      this.isReceived,
      this.hasReception,
      this.transportInformation})
      : _productsInformation = productsInformation;

  factory _$_AtsPurchaseOrder.fromJson(Map<String, dynamic> json) =>
      _$$_AtsPurchaseOrderFromJson(json);

  /// ID of the [Asset] entity. This ID is unique.
  @override
  final String? id;

  /// External API ID
  @override
  final String? ownerId;

  /// Order or invoice number.
  @override
  final String? orderId;

  /// ID of the asset.
  @override
  final String? assetId;

  /// Unix of last [AtsReception] date.
  @override
  @TimestampOrNullConverter()
  final DateTime? purchasedAt;

  /// Unix of last [AtsReception] date.
  @override
  @TimestampOrNullConverter()
  final DateTime? receivedAt;

  /// [Asset] linked to the [AtsPurchaseOrder].
  @override
  final Asset? asset;

  /// Legal information about the seller. Please read the comments of CompanyInformation definition for more information.
  @override
  final AtsCompanyInformation? sellerInformation;

  /// Legal information about the receiver. Please read the comments of CompanyInformation definition for more information.
  @override
  final AtsCompanyInformation? receiverInformation;

  /// List of products purchased. Please read the comments of ProductInformation definition for more information.
  final List<AtsProductInformation>? _productsInformation;

  /// List of products purchased. Please read the comments of ProductInformation definition for more information.
  @override
  List<AtsProductInformation>? get productsInformation {
    final value = _productsInformation;
    if (value == null) return null;
    if (_productsInformation is EqualUnmodifiableListView)
      return _productsInformation;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Total information. Please read the comments of Total definition for more information.
  @override
  final AtsPurchaseTotal? total;

  /// True if the purchase order was received.
  @override
  final bool? isReceived;

  /// True is the purchase order has a reception
  @override
  final bool? hasReception;

  /// Legal information about the transport. Please read the comments of TransportInformation definition for more information.
  @override
  final AtsTransportInformation? transportInformation;

  @override
  String toString() {
    return 'AtsPurchaseOrder(id: $id, ownerId: $ownerId, orderId: $orderId, assetId: $assetId, purchasedAt: $purchasedAt, receivedAt: $receivedAt, asset: $asset, sellerInformation: $sellerInformation, receiverInformation: $receiverInformation, productsInformation: $productsInformation, total: $total, isReceived: $isReceived, hasReception: $hasReception, transportInformation: $transportInformation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsPurchaseOrder &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.ownerId, ownerId) || other.ownerId == ownerId) &&
            (identical(other.orderId, orderId) || other.orderId == orderId) &&
            (identical(other.assetId, assetId) || other.assetId == assetId) &&
            (identical(other.purchasedAt, purchasedAt) ||
                other.purchasedAt == purchasedAt) &&
            (identical(other.receivedAt, receivedAt) ||
                other.receivedAt == receivedAt) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.sellerInformation, sellerInformation) ||
                other.sellerInformation == sellerInformation) &&
            (identical(other.receiverInformation, receiverInformation) ||
                other.receiverInformation == receiverInformation) &&
            const DeepCollectionEquality()
                .equals(other._productsInformation, _productsInformation) &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.isReceived, isReceived) ||
                other.isReceived == isReceived) &&
            (identical(other.hasReception, hasReception) ||
                other.hasReception == hasReception) &&
            (identical(other.transportInformation, transportInformation) ||
                other.transportInformation == transportInformation));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      ownerId,
      orderId,
      assetId,
      purchasedAt,
      receivedAt,
      asset,
      sellerInformation,
      receiverInformation,
      const DeepCollectionEquality().hash(_productsInformation),
      total,
      isReceived,
      hasReception,
      transportInformation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsPurchaseOrderCopyWith<_$_AtsPurchaseOrder> get copyWith =>
      __$$_AtsPurchaseOrderCopyWithImpl<_$_AtsPurchaseOrder>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsPurchaseOrderToJson(
      this,
    );
  }
}

abstract class _AtsPurchaseOrder implements AtsPurchaseOrder {
  factory _AtsPurchaseOrder(
          {final String? id,
          final String? ownerId,
          final String? orderId,
          final String? assetId,
          @TimestampOrNullConverter() final DateTime? purchasedAt,
          @TimestampOrNullConverter() final DateTime? receivedAt,
          final Asset? asset,
          final AtsCompanyInformation? sellerInformation,
          final AtsCompanyInformation? receiverInformation,
          final List<AtsProductInformation>? productsInformation,
          final AtsPurchaseTotal? total,
          final bool? isReceived,
          final bool? hasReception,
          final AtsTransportInformation? transportInformation}) =
      _$_AtsPurchaseOrder;

  factory _AtsPurchaseOrder.fromJson(Map<String, dynamic> json) =
      _$_AtsPurchaseOrder.fromJson;

  @override

  /// ID of the [Asset] entity. This ID is unique.
  String? get id;
  @override

  /// External API ID
  String? get ownerId;
  @override

  /// Order or invoice number.
  String? get orderId;
  @override

  /// ID of the asset.
  String? get assetId;
  @override

  /// Unix of last [AtsReception] date.
  @TimestampOrNullConverter()
  DateTime? get purchasedAt;
  @override

  /// Unix of last [AtsReception] date.
  @TimestampOrNullConverter()
  DateTime? get receivedAt;
  @override

  /// [Asset] linked to the [AtsPurchaseOrder].
  Asset? get asset;
  @override

  /// Legal information about the seller. Please read the comments of CompanyInformation definition for more information.
  AtsCompanyInformation? get sellerInformation;
  @override

  /// Legal information about the receiver. Please read the comments of CompanyInformation definition for more information.
  AtsCompanyInformation? get receiverInformation;
  @override

  /// List of products purchased. Please read the comments of ProductInformation definition for more information.
  List<AtsProductInformation>? get productsInformation;
  @override

  /// Total information. Please read the comments of Total definition for more information.
  AtsPurchaseTotal? get total;
  @override

  /// True if the purchase order was received.
  bool? get isReceived;
  @override

  /// True is the purchase order has a reception
  bool? get hasReception;
  @override

  /// Legal information about the transport. Please read the comments of TransportInformation definition for more information.
  AtsTransportInformation? get transportInformation;
  @override
  @JsonKey(ignore: true)
  _$$_AtsPurchaseOrderCopyWith<_$_AtsPurchaseOrder> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsPurchaseTotal _$AtsPurchaseTotalFromJson(Map<String, dynamic> json) {
  return _AtsPurchaseTotal.fromJson(json);
}

/// @nodoc
mixin _$AtsPurchaseTotal {
  /// Subtotal of the product.
  double? get subtotal => throw _privateConstructorUsedError;

  /// Net discount value (not %)
  double? get discountValue => throw _privateConstructorUsedError;

  /// Total value of the product with discount
  double? get total => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsPurchaseTotalCopyWith<AtsPurchaseTotal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsPurchaseTotalCopyWith<$Res> {
  factory $AtsPurchaseTotalCopyWith(
          AtsPurchaseTotal value, $Res Function(AtsPurchaseTotal) then) =
      _$AtsPurchaseTotalCopyWithImpl<$Res, AtsPurchaseTotal>;
  @useResult
  $Res call({double? subtotal, double? discountValue, double? total});
}

/// @nodoc
class _$AtsPurchaseTotalCopyWithImpl<$Res, $Val extends AtsPurchaseTotal>
    implements $AtsPurchaseTotalCopyWith<$Res> {
  _$AtsPurchaseTotalCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subtotal = freezed,
    Object? discountValue = freezed,
    Object? total = freezed,
  }) {
    return _then(_value.copyWith(
      subtotal: freezed == subtotal
          ? _value.subtotal
          : subtotal // ignore: cast_nullable_to_non_nullable
              as double?,
      discountValue: freezed == discountValue
          ? _value.discountValue
          : discountValue // ignore: cast_nullable_to_non_nullable
              as double?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsPurchaseTotalCopyWith<$Res>
    implements $AtsPurchaseTotalCopyWith<$Res> {
  factory _$$_AtsPurchaseTotalCopyWith(
          _$_AtsPurchaseTotal value, $Res Function(_$_AtsPurchaseTotal) then) =
      __$$_AtsPurchaseTotalCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double? subtotal, double? discountValue, double? total});
}

/// @nodoc
class __$$_AtsPurchaseTotalCopyWithImpl<$Res>
    extends _$AtsPurchaseTotalCopyWithImpl<$Res, _$_AtsPurchaseTotal>
    implements _$$_AtsPurchaseTotalCopyWith<$Res> {
  __$$_AtsPurchaseTotalCopyWithImpl(
      _$_AtsPurchaseTotal _value, $Res Function(_$_AtsPurchaseTotal) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? subtotal = freezed,
    Object? discountValue = freezed,
    Object? total = freezed,
  }) {
    return _then(_$_AtsPurchaseTotal(
      subtotal: freezed == subtotal
          ? _value.subtotal
          : subtotal // ignore: cast_nullable_to_non_nullable
              as double?,
      discountValue: freezed == discountValue
          ? _value.discountValue
          : discountValue // ignore: cast_nullable_to_non_nullable
              as double?,
      total: freezed == total
          ? _value.total
          : total // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsPurchaseTotal implements _AtsPurchaseTotal {
  _$_AtsPurchaseTotal({this.subtotal, this.discountValue, this.total});

  factory _$_AtsPurchaseTotal.fromJson(Map<String, dynamic> json) =>
      _$$_AtsPurchaseTotalFromJson(json);

  /// Subtotal of the product.
  @override
  final double? subtotal;

  /// Net discount value (not %)
  @override
  final double? discountValue;

  /// Total value of the product with discount
  @override
  final double? total;

  @override
  String toString() {
    return 'AtsPurchaseTotal(subtotal: $subtotal, discountValue: $discountValue, total: $total)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsPurchaseTotal &&
            (identical(other.subtotal, subtotal) ||
                other.subtotal == subtotal) &&
            (identical(other.discountValue, discountValue) ||
                other.discountValue == discountValue) &&
            (identical(other.total, total) || other.total == total));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, subtotal, discountValue, total);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsPurchaseTotalCopyWith<_$_AtsPurchaseTotal> get copyWith =>
      __$$_AtsPurchaseTotalCopyWithImpl<_$_AtsPurchaseTotal>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsPurchaseTotalToJson(
      this,
    );
  }
}

abstract class _AtsPurchaseTotal implements AtsPurchaseTotal {
  factory _AtsPurchaseTotal(
      {final double? subtotal,
      final double? discountValue,
      final double? total}) = _$_AtsPurchaseTotal;

  factory _AtsPurchaseTotal.fromJson(Map<String, dynamic> json) =
      _$_AtsPurchaseTotal.fromJson;

  @override

  /// Subtotal of the product.
  double? get subtotal;
  @override

  /// Net discount value (not %)
  double? get discountValue;
  @override

  /// Total value of the product with discount
  double? get total;
  @override
  @JsonKey(ignore: true)
  _$$_AtsPurchaseTotalCopyWith<_$_AtsPurchaseTotal> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsReception _$AtsReceptionFromJson(Map<String, dynamic> json) {
  return _AtsReception.fromJson(json);
}

/// @nodoc
mixin _$AtsReception {
  ///  ID of the [AtsReception]. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// ID of the [AtsPurchaseOrder].
  int? get orderId => throw _privateConstructorUsedError;

  /// [AtsPurchaseOrder] linked to the reception.
  AtsPurchaseOrder? get order => throw _privateConstructorUsedError;

  /// List of [AtsPurchaseOrder] IDs.
  List<int>? get ordersIds => throw _privateConstructorUsedError;

  /// [AtsEntry] linked to the [AtsReception].
  AtsEntry? get entry => throw _privateConstructorUsedError;

  /// List of [AtsReceptionProduct] obtained of the [AtsPurchaseOrder] exactly in [AtsProductsInformation]
  List<AtsReceptionProduct>? get products => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsReceptionCopyWith<AtsReception> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsReceptionCopyWith<$Res> {
  factory $AtsReceptionCopyWith(
          AtsReception value, $Res Function(AtsReception) then) =
      _$AtsReceptionCopyWithImpl<$Res, AtsReception>;
  @useResult
  $Res call(
      {String id,
      int? orderId,
      AtsPurchaseOrder? order,
      List<int>? ordersIds,
      AtsEntry? entry,
      List<AtsReceptionProduct>? products});

  $AtsPurchaseOrderCopyWith<$Res>? get order;
  $AtsEntryCopyWith<$Res>? get entry;
}

/// @nodoc
class _$AtsReceptionCopyWithImpl<$Res, $Val extends AtsReception>
    implements $AtsReceptionCopyWith<$Res> {
  _$AtsReceptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? orderId = freezed,
    Object? order = freezed,
    Object? ordersIds = freezed,
    Object? entry = freezed,
    Object? products = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as int?,
      order: freezed == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as AtsPurchaseOrder?,
      ordersIds: freezed == ordersIds
          ? _value.ordersIds
          : ordersIds // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      entry: freezed == entry
          ? _value.entry
          : entry // ignore: cast_nullable_to_non_nullable
              as AtsEntry?,
      products: freezed == products
          ? _value.products
          : products // ignore: cast_nullable_to_non_nullable
              as List<AtsReceptionProduct>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsPurchaseOrderCopyWith<$Res>? get order {
    if (_value.order == null) {
      return null;
    }

    return $AtsPurchaseOrderCopyWith<$Res>(_value.order!, (value) {
      return _then(_value.copyWith(order: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AtsEntryCopyWith<$Res>? get entry {
    if (_value.entry == null) {
      return null;
    }

    return $AtsEntryCopyWith<$Res>(_value.entry!, (value) {
      return _then(_value.copyWith(entry: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsReceptionCopyWith<$Res>
    implements $AtsReceptionCopyWith<$Res> {
  factory _$$_AtsReceptionCopyWith(
          _$_AtsReception value, $Res Function(_$_AtsReception) then) =
      __$$_AtsReceptionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      int? orderId,
      AtsPurchaseOrder? order,
      List<int>? ordersIds,
      AtsEntry? entry,
      List<AtsReceptionProduct>? products});

  @override
  $AtsPurchaseOrderCopyWith<$Res>? get order;
  @override
  $AtsEntryCopyWith<$Res>? get entry;
}

/// @nodoc
class __$$_AtsReceptionCopyWithImpl<$Res>
    extends _$AtsReceptionCopyWithImpl<$Res, _$_AtsReception>
    implements _$$_AtsReceptionCopyWith<$Res> {
  __$$_AtsReceptionCopyWithImpl(
      _$_AtsReception _value, $Res Function(_$_AtsReception) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? orderId = freezed,
    Object? order = freezed,
    Object? ordersIds = freezed,
    Object? entry = freezed,
    Object? products = freezed,
  }) {
    return _then(_$_AtsReception(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      orderId: freezed == orderId
          ? _value.orderId
          : orderId // ignore: cast_nullable_to_non_nullable
              as int?,
      order: freezed == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as AtsPurchaseOrder?,
      ordersIds: freezed == ordersIds
          ? _value._ordersIds
          : ordersIds // ignore: cast_nullable_to_non_nullable
              as List<int>?,
      entry: freezed == entry
          ? _value.entry
          : entry // ignore: cast_nullable_to_non_nullable
              as AtsEntry?,
      products: freezed == products
          ? _value._products
          : products // ignore: cast_nullable_to_non_nullable
              as List<AtsReceptionProduct>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsReception implements _AtsReception {
  _$_AtsReception(
      {required this.id,
      this.orderId,
      this.order,
      final List<int>? ordersIds,
      this.entry,
      final List<AtsReceptionProduct>? products})
      : _ordersIds = ordersIds,
        _products = products;

  factory _$_AtsReception.fromJson(Map<String, dynamic> json) =>
      _$$_AtsReceptionFromJson(json);

  ///  ID of the [AtsReception]. This ID is unique.
  @override
  final String id;

  /// ID of the [AtsPurchaseOrder].
  @override
  final int? orderId;

  /// [AtsPurchaseOrder] linked to the reception.
  @override
  final AtsPurchaseOrder? order;

  /// List of [AtsPurchaseOrder] IDs.
  final List<int>? _ordersIds;

  /// List of [AtsPurchaseOrder] IDs.
  @override
  List<int>? get ordersIds {
    final value = _ordersIds;
    if (value == null) return null;
    if (_ordersIds is EqualUnmodifiableListView) return _ordersIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [AtsEntry] linked to the [AtsReception].
  @override
  final AtsEntry? entry;

  /// List of [AtsReceptionProduct] obtained of the [AtsPurchaseOrder] exactly in [AtsProductsInformation]
  final List<AtsReceptionProduct>? _products;

  /// List of [AtsReceptionProduct] obtained of the [AtsPurchaseOrder] exactly in [AtsProductsInformation]
  @override
  List<AtsReceptionProduct>? get products {
    final value = _products;
    if (value == null) return null;
    if (_products is EqualUnmodifiableListView) return _products;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'AtsReception(id: $id, orderId: $orderId, order: $order, ordersIds: $ordersIds, entry: $entry, products: $products)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsReception &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.orderId, orderId) || other.orderId == orderId) &&
            (identical(other.order, order) || other.order == order) &&
            const DeepCollectionEquality()
                .equals(other._ordersIds, _ordersIds) &&
            (identical(other.entry, entry) || other.entry == entry) &&
            const DeepCollectionEquality().equals(other._products, _products));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      orderId,
      order,
      const DeepCollectionEquality().hash(_ordersIds),
      entry,
      const DeepCollectionEquality().hash(_products));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsReceptionCopyWith<_$_AtsReception> get copyWith =>
      __$$_AtsReceptionCopyWithImpl<_$_AtsReception>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsReceptionToJson(
      this,
    );
  }
}

abstract class _AtsReception implements AtsReception {
  factory _AtsReception(
      {required final String id,
      final int? orderId,
      final AtsPurchaseOrder? order,
      final List<int>? ordersIds,
      final AtsEntry? entry,
      final List<AtsReceptionProduct>? products}) = _$_AtsReception;

  factory _AtsReception.fromJson(Map<String, dynamic> json) =
      _$_AtsReception.fromJson;

  @override

  ///  ID of the [AtsReception]. This ID is unique.
  String get id;
  @override

  /// ID of the [AtsPurchaseOrder].
  int? get orderId;
  @override

  /// [AtsPurchaseOrder] linked to the reception.
  AtsPurchaseOrder? get order;
  @override

  /// List of [AtsPurchaseOrder] IDs.
  List<int>? get ordersIds;
  @override

  /// [AtsEntry] linked to the [AtsReception].
  AtsEntry? get entry;
  @override

  /// List of [AtsReceptionProduct] obtained of the [AtsPurchaseOrder] exactly in [AtsProductsInformation]
  List<AtsReceptionProduct>? get products;
  @override
  @JsonKey(ignore: true)
  _$$_AtsReceptionCopyWith<_$_AtsReception> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsEntryUnloadInput _$AtsEntryUnloadInputFromJson(Map<String, dynamic> json) {
  return _AtsEntryUnloadInput.fromJson(json);
}

/// @nodoc
mixin _$AtsEntryUnloadInput {
  /// ID of the [AtsEntryUnloadInput], ignore it if you are using "addLicense" mutation.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the [AtsEntryUnloadInput], ignore it if you are using "addLicense" mutation.
  set id(String? value) => throw _privateConstructorUsedError;

  /// ID of the tank [Asset].
  String? get fromAssetId => throw _privateConstructorUsedError;

  /// ID of the tank [Asset].
  set fromAssetId(String? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsEntryUnloadInputCopyWith<AtsEntryUnloadInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsEntryUnloadInputCopyWith<$Res> {
  factory $AtsEntryUnloadInputCopyWith(
          AtsEntryUnloadInput value, $Res Function(AtsEntryUnloadInput) then) =
      _$AtsEntryUnloadInputCopyWithImpl<$Res, AtsEntryUnloadInput>;
  @useResult
  $Res call({String? id, String? fromAssetId});
}

/// @nodoc
class _$AtsEntryUnloadInputCopyWithImpl<$Res, $Val extends AtsEntryUnloadInput>
    implements $AtsEntryUnloadInputCopyWith<$Res> {
  _$AtsEntryUnloadInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? fromAssetId = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAssetId: freezed == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsEntryUnloadInputCopyWith<$Res>
    implements $AtsEntryUnloadInputCopyWith<$Res> {
  factory _$$_AtsEntryUnloadInputCopyWith(_$_AtsEntryUnloadInput value,
          $Res Function(_$_AtsEntryUnloadInput) then) =
      __$$_AtsEntryUnloadInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? id, String? fromAssetId});
}

/// @nodoc
class __$$_AtsEntryUnloadInputCopyWithImpl<$Res>
    extends _$AtsEntryUnloadInputCopyWithImpl<$Res, _$_AtsEntryUnloadInput>
    implements _$$_AtsEntryUnloadInputCopyWith<$Res> {
  __$$_AtsEntryUnloadInputCopyWithImpl(_$_AtsEntryUnloadInput _value,
      $Res Function(_$_AtsEntryUnloadInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? fromAssetId = freezed,
  }) {
    return _then(_$_AtsEntryUnloadInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAssetId: freezed == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsEntryUnloadInput implements _AtsEntryUnloadInput {
  _$_AtsEntryUnloadInput({this.id, this.fromAssetId});

  factory _$_AtsEntryUnloadInput.fromJson(Map<String, dynamic> json) =>
      _$$_AtsEntryUnloadInputFromJson(json);

  /// ID of the [AtsEntryUnloadInput], ignore it if you are using "addLicense" mutation.
  @override
  String? id;

  /// ID of the tank [Asset].
  @override
  String? fromAssetId;

  @override
  String toString() {
    return 'AtsEntryUnloadInput(id: $id, fromAssetId: $fromAssetId)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsEntryUnloadInputCopyWith<_$_AtsEntryUnloadInput> get copyWith =>
      __$$_AtsEntryUnloadInputCopyWithImpl<_$_AtsEntryUnloadInput>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsEntryUnloadInputToJson(
      this,
    );
  }
}

abstract class _AtsEntryUnloadInput implements AtsEntryUnloadInput {
  factory _AtsEntryUnloadInput({String? id, String? fromAssetId}) =
      _$_AtsEntryUnloadInput;

  factory _AtsEntryUnloadInput.fromJson(Map<String, dynamic> json) =
      _$_AtsEntryUnloadInput.fromJson;

  @override

  /// ID of the [AtsEntryUnloadInput], ignore it if you are using "addLicense" mutation.
  String? get id;

  /// ID of the [AtsEntryUnloadInput], ignore it if you are using "addLicense" mutation.
  set id(String? value);
  @override

  /// ID of the tank [Asset].
  String? get fromAssetId;

  /// ID of the tank [Asset].
  set fromAssetId(String? value);
  @override
  @JsonKey(ignore: true)
  _$$_AtsEntryUnloadInputCopyWith<_$_AtsEntryUnloadInput> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsExitStatus _$AtsExitStatusFromJson(Map<String, dynamic> json) {
  return _AtsExitStatus.fromJson(json);
}

/// @nodoc
mixin _$AtsExitStatus {
  /// Date of the [AtsExit]
  @TimestampOrNullConverter()
  DateTime? get date => throw _privateConstructorUsedError;

  /// Validation between total liters by fluxometers and to total liters by exits records..
  bool? get status => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsExitStatusCopyWith<AtsExitStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsExitStatusCopyWith<$Res> {
  factory $AtsExitStatusCopyWith(
          AtsExitStatus value, $Res Function(AtsExitStatus) then) =
      _$AtsExitStatusCopyWithImpl<$Res, AtsExitStatus>;
  @useResult
  $Res call({@TimestampOrNullConverter() DateTime? date, bool? status});
}

/// @nodoc
class _$AtsExitStatusCopyWithImpl<$Res, $Val extends AtsExitStatus>
    implements $AtsExitStatusCopyWith<$Res> {
  _$AtsExitStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = freezed,
    Object? status = freezed,
  }) {
    return _then(_value.copyWith(
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsExitStatusCopyWith<$Res>
    implements $AtsExitStatusCopyWith<$Res> {
  factory _$$_AtsExitStatusCopyWith(
          _$_AtsExitStatus value, $Res Function(_$_AtsExitStatus) then) =
      __$$_AtsExitStatusCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({@TimestampOrNullConverter() DateTime? date, bool? status});
}

/// @nodoc
class __$$_AtsExitStatusCopyWithImpl<$Res>
    extends _$AtsExitStatusCopyWithImpl<$Res, _$_AtsExitStatus>
    implements _$$_AtsExitStatusCopyWith<$Res> {
  __$$_AtsExitStatusCopyWithImpl(
      _$_AtsExitStatus _value, $Res Function(_$_AtsExitStatus) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? date = freezed,
    Object? status = freezed,
  }) {
    return _then(_$_AtsExitStatus(
      date: freezed == date
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsExitStatus implements _AtsExitStatus {
  const _$_AtsExitStatus({@TimestampOrNullConverter() this.date, this.status});

  factory _$_AtsExitStatus.fromJson(Map<String, dynamic> json) =>
      _$$_AtsExitStatusFromJson(json);

  /// Date of the [AtsExit]
  @override
  @TimestampOrNullConverter()
  final DateTime? date;

  /// Validation between total liters by fluxometers and to total liters by exits records..
  @override
  final bool? status;

  @override
  String toString() {
    return 'AtsExitStatus(date: $date, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsExitStatus &&
            (identical(other.date, date) || other.date == date) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, date, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsExitStatusCopyWith<_$_AtsExitStatus> get copyWith =>
      __$$_AtsExitStatusCopyWithImpl<_$_AtsExitStatus>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsExitStatusToJson(
      this,
    );
  }
}

abstract class _AtsExitStatus implements AtsExitStatus {
  const factory _AtsExitStatus(
      {@TimestampOrNullConverter() final DateTime? date,
      final bool? status}) = _$_AtsExitStatus;

  factory _AtsExitStatus.fromJson(Map<String, dynamic> json) =
      _$_AtsExitStatus.fromJson;

  @override

  /// Date of the [AtsExit]
  @TimestampOrNullConverter()
  DateTime? get date;
  @override

  /// Validation between total liters by fluxometers and to total liters by exits records..
  bool? get status;
  @override
  @JsonKey(ignore: true)
  _$$_AtsExitStatusCopyWith<_$_AtsExitStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsExit _$AtsExitFromJson(Map<String, dynamic> json) {
  return _AtsExit.fromJson(json);
}

/// @nodoc
mixin _$AtsExit {
  /// ID of the volume. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// [fromAssetId] and [fromAsset] means the asset that the asset that generate the exit.
  String get fromAssetId => throw _privateConstructorUsedError;

  /// [fromAsset] is an instance of [Asset] means the asset that the asset that generate the exit.
  Asset? get fromAsset => throw _privateConstructorUsedError;

  /// [toAssetId] and [toAsset] means the asset that the asset that receive the fuel (Receive the exit).
  String? get toAssetId => throw _privateConstructorUsedError;

  /// [toAsset] means the asset that the asset that receive the fuel (Receive the exit).
  Asset? get toAsset => throw _privateConstructorUsedError;

  /// [errorPercent] is the percentage of error of the exit.
  double? get errorPercent => throw _privateConstructorUsedError;

  /// [totalLiters] is the total liters dispatched to [toAssetId] and [toAsset].
  double? get totalLiters => throw _privateConstructorUsedError;

  /// [startAt] is the date and time of the start of the exit.
  @TimestampOrNullConverter()
  DateTime? get startAt => throw _privateConstructorUsedError;

  /// [endAt] is the date and time of the end of the exit.
  /// [endAt] is null if the exit is not finished.
  @TimestampOrNullConverter()
  DateTime? get endAt => throw _privateConstructorUsedError;

  /// [totalTime] is the total time of the exit
  /// [totalTime] is null if the exit is not finished.
  String? get totalTime => throw _privateConstructorUsedError;

  /// [totalTimeDuration] is null if the exit is not finished.
  @DurationOrNullConverter()
  Duration? get totalTimeDuration =>
      throw _privateConstructorUsedError; // Asset ATS Last exit fields
  /// ID of the Sensor
  String? get sensorId => throw _privateConstructorUsedError;

  /// [sensor] Sensor linked to exit.
  Sensor? get sensor => throw _privateConstructorUsedError;

  /// Initial fluxometer of the day
  double? get initialFluxometer => throw _privateConstructorUsedError;

  /// Final fluxometer of the day
  double? get finalFluxometer => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsExitCopyWith<AtsExit> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsExitCopyWith<$Res> {
  factory $AtsExitCopyWith(AtsExit value, $Res Function(AtsExit) then) =
      _$AtsExitCopyWithImpl<$Res, AtsExit>;
  @useResult
  $Res call(
      {String id,
      String fromAssetId,
      Asset? fromAsset,
      String? toAssetId,
      Asset? toAsset,
      double? errorPercent,
      double? totalLiters,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      String? totalTime,
      @DurationOrNullConverter() Duration? totalTimeDuration,
      String? sensorId,
      Sensor? sensor,
      double? initialFluxometer,
      double? finalFluxometer});

  $AssetCopyWith<$Res>? get fromAsset;
  $AssetCopyWith<$Res>? get toAsset;
  $SensorCopyWith<$Res>? get sensor;
}

/// @nodoc
class _$AtsExitCopyWithImpl<$Res, $Val extends AtsExit>
    implements $AtsExitCopyWith<$Res> {
  _$AtsExitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? fromAssetId = null,
    Object? fromAsset = freezed,
    Object? toAssetId = freezed,
    Object? toAsset = freezed,
    Object? errorPercent = freezed,
    Object? totalLiters = freezed,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? totalTime = freezed,
    Object? totalTimeDuration = freezed,
    Object? sensorId = freezed,
    Object? sensor = freezed,
    Object? initialFluxometer = freezed,
    Object? finalFluxometer = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      fromAssetId: null == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String,
      fromAsset: freezed == fromAsset
          ? _value.fromAsset
          : fromAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      toAssetId: freezed == toAssetId
          ? _value.toAssetId
          : toAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      toAsset: freezed == toAsset
          ? _value.toAsset
          : toAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      errorPercent: freezed == errorPercent
          ? _value.errorPercent
          : errorPercent // ignore: cast_nullable_to_non_nullable
              as double?,
      totalLiters: freezed == totalLiters
          ? _value.totalLiters
          : totalLiters // ignore: cast_nullable_to_non_nullable
              as double?,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      totalTime: freezed == totalTime
          ? _value.totalTime
          : totalTime // ignore: cast_nullable_to_non_nullable
              as String?,
      totalTimeDuration: freezed == totalTimeDuration
          ? _value.totalTimeDuration
          : totalTimeDuration // ignore: cast_nullable_to_non_nullable
              as Duration?,
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      sensor: freezed == sensor
          ? _value.sensor
          : sensor // ignore: cast_nullable_to_non_nullable
              as Sensor?,
      initialFluxometer: freezed == initialFluxometer
          ? _value.initialFluxometer
          : initialFluxometer // ignore: cast_nullable_to_non_nullable
              as double?,
      finalFluxometer: freezed == finalFluxometer
          ? _value.finalFluxometer
          : finalFluxometer // ignore: cast_nullable_to_non_nullable
              as double?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get fromAsset {
    if (_value.fromAsset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.fromAsset!, (value) {
      return _then(_value.copyWith(fromAsset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get toAsset {
    if (_value.toAsset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.toAsset!, (value) {
      return _then(_value.copyWith(toAsset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SensorCopyWith<$Res>? get sensor {
    if (_value.sensor == null) {
      return null;
    }

    return $SensorCopyWith<$Res>(_value.sensor!, (value) {
      return _then(_value.copyWith(sensor: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsExitCopyWith<$Res> implements $AtsExitCopyWith<$Res> {
  factory _$$_AtsExitCopyWith(
          _$_AtsExit value, $Res Function(_$_AtsExit) then) =
      __$$_AtsExitCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String fromAssetId,
      Asset? fromAsset,
      String? toAssetId,
      Asset? toAsset,
      double? errorPercent,
      double? totalLiters,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      String? totalTime,
      @DurationOrNullConverter() Duration? totalTimeDuration,
      String? sensorId,
      Sensor? sensor,
      double? initialFluxometer,
      double? finalFluxometer});

  @override
  $AssetCopyWith<$Res>? get fromAsset;
  @override
  $AssetCopyWith<$Res>? get toAsset;
  @override
  $SensorCopyWith<$Res>? get sensor;
}

/// @nodoc
class __$$_AtsExitCopyWithImpl<$Res>
    extends _$AtsExitCopyWithImpl<$Res, _$_AtsExit>
    implements _$$_AtsExitCopyWith<$Res> {
  __$$_AtsExitCopyWithImpl(_$_AtsExit _value, $Res Function(_$_AtsExit) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? fromAssetId = null,
    Object? fromAsset = freezed,
    Object? toAssetId = freezed,
    Object? toAsset = freezed,
    Object? errorPercent = freezed,
    Object? totalLiters = freezed,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? totalTime = freezed,
    Object? totalTimeDuration = freezed,
    Object? sensorId = freezed,
    Object? sensor = freezed,
    Object? initialFluxometer = freezed,
    Object? finalFluxometer = freezed,
  }) {
    return _then(_$_AtsExit(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      fromAssetId: null == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String,
      fromAsset: freezed == fromAsset
          ? _value.fromAsset
          : fromAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      toAssetId: freezed == toAssetId
          ? _value.toAssetId
          : toAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      toAsset: freezed == toAsset
          ? _value.toAsset
          : toAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      errorPercent: freezed == errorPercent
          ? _value.errorPercent
          : errorPercent // ignore: cast_nullable_to_non_nullable
              as double?,
      totalLiters: freezed == totalLiters
          ? _value.totalLiters
          : totalLiters // ignore: cast_nullable_to_non_nullable
              as double?,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      totalTime: freezed == totalTime
          ? _value.totalTime
          : totalTime // ignore: cast_nullable_to_non_nullable
              as String?,
      totalTimeDuration: freezed == totalTimeDuration
          ? _value.totalTimeDuration
          : totalTimeDuration // ignore: cast_nullable_to_non_nullable
              as Duration?,
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      sensor: freezed == sensor
          ? _value.sensor
          : sensor // ignore: cast_nullable_to_non_nullable
              as Sensor?,
      initialFluxometer: freezed == initialFluxometer
          ? _value.initialFluxometer
          : initialFluxometer // ignore: cast_nullable_to_non_nullable
              as double?,
      finalFluxometer: freezed == finalFluxometer
          ? _value.finalFluxometer
          : finalFluxometer // ignore: cast_nullable_to_non_nullable
              as double?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsExit implements _AtsExit {
  const _$_AtsExit(
      {required this.id,
      required this.fromAssetId,
      this.fromAsset,
      this.toAssetId,
      this.toAsset,
      this.errorPercent,
      this.totalLiters,
      @TimestampOrNullConverter() this.startAt,
      @TimestampOrNullConverter() this.endAt,
      this.totalTime,
      @DurationOrNullConverter() this.totalTimeDuration,
      this.sensorId,
      this.sensor,
      this.initialFluxometer,
      this.finalFluxometer});

  factory _$_AtsExit.fromJson(Map<String, dynamic> json) =>
      _$$_AtsExitFromJson(json);

  /// ID of the volume. This ID is unique.
  @override
  final String id;

  /// [fromAssetId] and [fromAsset] means the asset that the asset that generate the exit.
  @override
  final String fromAssetId;

  /// [fromAsset] is an instance of [Asset] means the asset that the asset that generate the exit.
  @override
  final Asset? fromAsset;

  /// [toAssetId] and [toAsset] means the asset that the asset that receive the fuel (Receive the exit).
  @override
  final String? toAssetId;

  /// [toAsset] means the asset that the asset that receive the fuel (Receive the exit).
  @override
  final Asset? toAsset;

  /// [errorPercent] is the percentage of error of the exit.
  @override
  final double? errorPercent;

  /// [totalLiters] is the total liters dispatched to [toAssetId] and [toAsset].
  @override
  final double? totalLiters;

  /// [startAt] is the date and time of the start of the exit.
  @override
  @TimestampOrNullConverter()
  final DateTime? startAt;

  /// [endAt] is the date and time of the end of the exit.
  /// [endAt] is null if the exit is not finished.
  @override
  @TimestampOrNullConverter()
  final DateTime? endAt;

  /// [totalTime] is the total time of the exit
  /// [totalTime] is null if the exit is not finished.
  @override
  final String? totalTime;

  /// [totalTimeDuration] is null if the exit is not finished.
  @override
  @DurationOrNullConverter()
  final Duration? totalTimeDuration;
// Asset ATS Last exit fields
  /// ID of the Sensor
  @override
  final String? sensorId;

  /// [sensor] Sensor linked to exit.
  @override
  final Sensor? sensor;

  /// Initial fluxometer of the day
  @override
  final double? initialFluxometer;

  /// Final fluxometer of the day
  @override
  final double? finalFluxometer;

  @override
  String toString() {
    return 'AtsExit(id: $id, fromAssetId: $fromAssetId, fromAsset: $fromAsset, toAssetId: $toAssetId, toAsset: $toAsset, errorPercent: $errorPercent, totalLiters: $totalLiters, startAt: $startAt, endAt: $endAt, totalTime: $totalTime, totalTimeDuration: $totalTimeDuration, sensorId: $sensorId, sensor: $sensor, initialFluxometer: $initialFluxometer, finalFluxometer: $finalFluxometer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsExit &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.fromAssetId, fromAssetId) ||
                other.fromAssetId == fromAssetId) &&
            (identical(other.fromAsset, fromAsset) ||
                other.fromAsset == fromAsset) &&
            (identical(other.toAssetId, toAssetId) ||
                other.toAssetId == toAssetId) &&
            (identical(other.toAsset, toAsset) || other.toAsset == toAsset) &&
            (identical(other.errorPercent, errorPercent) ||
                other.errorPercent == errorPercent) &&
            (identical(other.totalLiters, totalLiters) ||
                other.totalLiters == totalLiters) &&
            (identical(other.startAt, startAt) || other.startAt == startAt) &&
            (identical(other.endAt, endAt) || other.endAt == endAt) &&
            (identical(other.totalTime, totalTime) ||
                other.totalTime == totalTime) &&
            (identical(other.totalTimeDuration, totalTimeDuration) ||
                other.totalTimeDuration == totalTimeDuration) &&
            (identical(other.sensorId, sensorId) ||
                other.sensorId == sensorId) &&
            (identical(other.sensor, sensor) || other.sensor == sensor) &&
            (identical(other.initialFluxometer, initialFluxometer) ||
                other.initialFluxometer == initialFluxometer) &&
            (identical(other.finalFluxometer, finalFluxometer) ||
                other.finalFluxometer == finalFluxometer));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      fromAssetId,
      fromAsset,
      toAssetId,
      toAsset,
      errorPercent,
      totalLiters,
      startAt,
      endAt,
      totalTime,
      totalTimeDuration,
      sensorId,
      sensor,
      initialFluxometer,
      finalFluxometer);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsExitCopyWith<_$_AtsExit> get copyWith =>
      __$$_AtsExitCopyWithImpl<_$_AtsExit>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsExitToJson(
      this,
    );
  }
}

abstract class _AtsExit implements AtsExit {
  const factory _AtsExit(
      {required final String id,
      required final String fromAssetId,
      final Asset? fromAsset,
      final String? toAssetId,
      final Asset? toAsset,
      final double? errorPercent,
      final double? totalLiters,
      @TimestampOrNullConverter() final DateTime? startAt,
      @TimestampOrNullConverter() final DateTime? endAt,
      final String? totalTime,
      @DurationOrNullConverter() final Duration? totalTimeDuration,
      final String? sensorId,
      final Sensor? sensor,
      final double? initialFluxometer,
      final double? finalFluxometer}) = _$_AtsExit;

  factory _AtsExit.fromJson(Map<String, dynamic> json) = _$_AtsExit.fromJson;

  @override

  /// ID of the volume. This ID is unique.
  String get id;
  @override

  /// [fromAssetId] and [fromAsset] means the asset that the asset that generate the exit.
  String get fromAssetId;
  @override

  /// [fromAsset] is an instance of [Asset] means the asset that the asset that generate the exit.
  Asset? get fromAsset;
  @override

  /// [toAssetId] and [toAsset] means the asset that the asset that receive the fuel (Receive the exit).
  String? get toAssetId;
  @override

  /// [toAsset] means the asset that the asset that receive the fuel (Receive the exit).
  Asset? get toAsset;
  @override

  /// [errorPercent] is the percentage of error of the exit.
  double? get errorPercent;
  @override

  /// [totalLiters] is the total liters dispatched to [toAssetId] and [toAsset].
  double? get totalLiters;
  @override

  /// [startAt] is the date and time of the start of the exit.
  @TimestampOrNullConverter()
  DateTime? get startAt;
  @override

  /// [endAt] is the date and time of the end of the exit.
  /// [endAt] is null if the exit is not finished.
  @TimestampOrNullConverter()
  DateTime? get endAt;
  @override

  /// [totalTime] is the total time of the exit
  /// [totalTime] is null if the exit is not finished.
  String? get totalTime;
  @override

  /// [totalTimeDuration] is null if the exit is not finished.
  @DurationOrNullConverter()
  Duration? get totalTimeDuration;
  @override // Asset ATS Last exit fields
  /// ID of the Sensor
  String? get sensorId;
  @override

  /// [sensor] Sensor linked to exit.
  Sensor? get sensor;
  @override

  /// Initial fluxometer of the day
  double? get initialFluxometer;
  @override

  /// Final fluxometer of the day
  double? get finalFluxometer;
  @override
  @JsonKey(ignore: true)
  _$$_AtsExitCopyWith<_$_AtsExit> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsPossibleExit _$AtsPossibleExitFromJson(Map<String, dynamic> json) {
  return _AtsPossibleExit.fromJson(json);
}

/// @nodoc
mixin _$AtsPossibleExit {
  /// ID of the possible exit. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// ID of the Asset
  String? get fromAssetId => throw _privateConstructorUsedError;

  /// Asset linked to exit.
  Asset? get fromAsset => throw _privateConstructorUsedError;

  /// ID of the Sensor
  String? get sensorId => throw _privateConstructorUsedError;

  /// Sensor linked to exit.
  Sensor? get sensor => throw _privateConstructorUsedError;

  /// ID of the Asset
  String? get toAssetId => throw _privateConstructorUsedError;

  /// Asset linked to exit.
  Asset? get toAsset => throw _privateConstructorUsedError;

  /// Total liters of the exit.
  double? get totalLiters => throw _privateConstructorUsedError;

  /// Date of the start of the exit.
  @TimestampOrNullConverter()
  DateTime? get startAt => throw _privateConstructorUsedError;

  /// Date of the end of the exit.
  @TimestampOrNullConverter()
  DateTime? get endAt => throw _privateConstructorUsedError;

  /// This flag defines if the possible exit was finished.
  bool? get isReady => throw _privateConstructorUsedError;

  /// This flag defines if the possible exit was started but not finished.
  bool? get inProgress => throw _privateConstructorUsedError;

  /// This flag defines if the possible exit is authenticated.
  bool? get isValidated => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsPossibleExitCopyWith<AtsPossibleExit> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsPossibleExitCopyWith<$Res> {
  factory $AtsPossibleExitCopyWith(
          AtsPossibleExit value, $Res Function(AtsPossibleExit) then) =
      _$AtsPossibleExitCopyWithImpl<$Res, AtsPossibleExit>;
  @useResult
  $Res call(
      {String? id,
      String? fromAssetId,
      Asset? fromAsset,
      String? sensorId,
      Sensor? sensor,
      String? toAssetId,
      Asset? toAsset,
      double? totalLiters,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      bool? isReady,
      bool? inProgress,
      bool? isValidated});

  $AssetCopyWith<$Res>? get fromAsset;
  $SensorCopyWith<$Res>? get sensor;
  $AssetCopyWith<$Res>? get toAsset;
}

/// @nodoc
class _$AtsPossibleExitCopyWithImpl<$Res, $Val extends AtsPossibleExit>
    implements $AtsPossibleExitCopyWith<$Res> {
  _$AtsPossibleExitCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? fromAssetId = freezed,
    Object? fromAsset = freezed,
    Object? sensorId = freezed,
    Object? sensor = freezed,
    Object? toAssetId = freezed,
    Object? toAsset = freezed,
    Object? totalLiters = freezed,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? isReady = freezed,
    Object? inProgress = freezed,
    Object? isValidated = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAssetId: freezed == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAsset: freezed == fromAsset
          ? _value.fromAsset
          : fromAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      sensor: freezed == sensor
          ? _value.sensor
          : sensor // ignore: cast_nullable_to_non_nullable
              as Sensor?,
      toAssetId: freezed == toAssetId
          ? _value.toAssetId
          : toAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      toAsset: freezed == toAsset
          ? _value.toAsset
          : toAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      totalLiters: freezed == totalLiters
          ? _value.totalLiters
          : totalLiters // ignore: cast_nullable_to_non_nullable
              as double?,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isReady: freezed == isReady
          ? _value.isReady
          : isReady // ignore: cast_nullable_to_non_nullable
              as bool?,
      inProgress: freezed == inProgress
          ? _value.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as bool?,
      isValidated: freezed == isValidated
          ? _value.isValidated
          : isValidated // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get fromAsset {
    if (_value.fromAsset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.fromAsset!, (value) {
      return _then(_value.copyWith(fromAsset: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SensorCopyWith<$Res>? get sensor {
    if (_value.sensor == null) {
      return null;
    }

    return $SensorCopyWith<$Res>(_value.sensor!, (value) {
      return _then(_value.copyWith(sensor: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get toAsset {
    if (_value.toAsset == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.toAsset!, (value) {
      return _then(_value.copyWith(toAsset: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_AtsPossibleExitCopyWith<$Res>
    implements $AtsPossibleExitCopyWith<$Res> {
  factory _$$_AtsPossibleExitCopyWith(
          _$_AtsPossibleExit value, $Res Function(_$_AtsPossibleExit) then) =
      __$$_AtsPossibleExitCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? fromAssetId,
      Asset? fromAsset,
      String? sensorId,
      Sensor? sensor,
      String? toAssetId,
      Asset? toAsset,
      double? totalLiters,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      bool? isReady,
      bool? inProgress,
      bool? isValidated});

  @override
  $AssetCopyWith<$Res>? get fromAsset;
  @override
  $SensorCopyWith<$Res>? get sensor;
  @override
  $AssetCopyWith<$Res>? get toAsset;
}

/// @nodoc
class __$$_AtsPossibleExitCopyWithImpl<$Res>
    extends _$AtsPossibleExitCopyWithImpl<$Res, _$_AtsPossibleExit>
    implements _$$_AtsPossibleExitCopyWith<$Res> {
  __$$_AtsPossibleExitCopyWithImpl(
      _$_AtsPossibleExit _value, $Res Function(_$_AtsPossibleExit) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? fromAssetId = freezed,
    Object? fromAsset = freezed,
    Object? sensorId = freezed,
    Object? sensor = freezed,
    Object? toAssetId = freezed,
    Object? toAsset = freezed,
    Object? totalLiters = freezed,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? isReady = freezed,
    Object? inProgress = freezed,
    Object? isValidated = freezed,
  }) {
    return _then(_$_AtsPossibleExit(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAssetId: freezed == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAsset: freezed == fromAsset
          ? _value.fromAsset
          : fromAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      sensor: freezed == sensor
          ? _value.sensor
          : sensor // ignore: cast_nullable_to_non_nullable
              as Sensor?,
      toAssetId: freezed == toAssetId
          ? _value.toAssetId
          : toAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      toAsset: freezed == toAsset
          ? _value.toAsset
          : toAsset // ignore: cast_nullable_to_non_nullable
              as Asset?,
      totalLiters: freezed == totalLiters
          ? _value.totalLiters
          : totalLiters // ignore: cast_nullable_to_non_nullable
              as double?,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      isReady: freezed == isReady
          ? _value.isReady
          : isReady // ignore: cast_nullable_to_non_nullable
              as bool?,
      inProgress: freezed == inProgress
          ? _value.inProgress
          : inProgress // ignore: cast_nullable_to_non_nullable
              as bool?,
      isValidated: freezed == isValidated
          ? _value.isValidated
          : isValidated // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsPossibleExit implements _AtsPossibleExit {
  _$_AtsPossibleExit(
      {this.id,
      this.fromAssetId,
      this.fromAsset,
      this.sensorId,
      this.sensor,
      this.toAssetId,
      this.toAsset,
      this.totalLiters,
      @TimestampOrNullConverter() this.startAt,
      @TimestampOrNullConverter() this.endAt,
      this.isReady,
      this.inProgress,
      this.isValidated});

  factory _$_AtsPossibleExit.fromJson(Map<String, dynamic> json) =>
      _$$_AtsPossibleExitFromJson(json);

  /// ID of the possible exit. This ID is unique.
  @override
  final String? id;

  /// ID of the Asset
  @override
  final String? fromAssetId;

  /// Asset linked to exit.
  @override
  final Asset? fromAsset;

  /// ID of the Sensor
  @override
  final String? sensorId;

  /// Sensor linked to exit.
  @override
  final Sensor? sensor;

  /// ID of the Asset
  @override
  final String? toAssetId;

  /// Asset linked to exit.
  @override
  final Asset? toAsset;

  /// Total liters of the exit.
  @override
  final double? totalLiters;

  /// Date of the start of the exit.
  @override
  @TimestampOrNullConverter()
  final DateTime? startAt;

  /// Date of the end of the exit.
  @override
  @TimestampOrNullConverter()
  final DateTime? endAt;

  /// This flag defines if the possible exit was finished.
  @override
  final bool? isReady;

  /// This flag defines if the possible exit was started but not finished.
  @override
  final bool? inProgress;

  /// This flag defines if the possible exit is authenticated.
  @override
  final bool? isValidated;

  @override
  String toString() {
    return 'AtsPossibleExit(id: $id, fromAssetId: $fromAssetId, fromAsset: $fromAsset, sensorId: $sensorId, sensor: $sensor, toAssetId: $toAssetId, toAsset: $toAsset, totalLiters: $totalLiters, startAt: $startAt, endAt: $endAt, isReady: $isReady, inProgress: $inProgress, isValidated: $isValidated)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsPossibleExit &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.fromAssetId, fromAssetId) ||
                other.fromAssetId == fromAssetId) &&
            (identical(other.fromAsset, fromAsset) ||
                other.fromAsset == fromAsset) &&
            (identical(other.sensorId, sensorId) ||
                other.sensorId == sensorId) &&
            (identical(other.sensor, sensor) || other.sensor == sensor) &&
            (identical(other.toAssetId, toAssetId) ||
                other.toAssetId == toAssetId) &&
            (identical(other.toAsset, toAsset) || other.toAsset == toAsset) &&
            (identical(other.totalLiters, totalLiters) ||
                other.totalLiters == totalLiters) &&
            (identical(other.startAt, startAt) || other.startAt == startAt) &&
            (identical(other.endAt, endAt) || other.endAt == endAt) &&
            (identical(other.isReady, isReady) || other.isReady == isReady) &&
            (identical(other.inProgress, inProgress) ||
                other.inProgress == inProgress) &&
            (identical(other.isValidated, isValidated) ||
                other.isValidated == isValidated));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      fromAssetId,
      fromAsset,
      sensorId,
      sensor,
      toAssetId,
      toAsset,
      totalLiters,
      startAt,
      endAt,
      isReady,
      inProgress,
      isValidated);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsPossibleExitCopyWith<_$_AtsPossibleExit> get copyWith =>
      __$$_AtsPossibleExitCopyWithImpl<_$_AtsPossibleExit>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsPossibleExitToJson(
      this,
    );
  }
}

abstract class _AtsPossibleExit implements AtsPossibleExit {
  factory _AtsPossibleExit(
      {final String? id,
      final String? fromAssetId,
      final Asset? fromAsset,
      final String? sensorId,
      final Sensor? sensor,
      final String? toAssetId,
      final Asset? toAsset,
      final double? totalLiters,
      @TimestampOrNullConverter() final DateTime? startAt,
      @TimestampOrNullConverter() final DateTime? endAt,
      final bool? isReady,
      final bool? inProgress,
      final bool? isValidated}) = _$_AtsPossibleExit;

  factory _AtsPossibleExit.fromJson(Map<String, dynamic> json) =
      _$_AtsPossibleExit.fromJson;

  @override

  /// ID of the possible exit. This ID is unique.
  String? get id;
  @override

  /// ID of the Asset
  String? get fromAssetId;
  @override

  /// Asset linked to exit.
  Asset? get fromAsset;
  @override

  /// ID of the Sensor
  String? get sensorId;
  @override

  /// Sensor linked to exit.
  Sensor? get sensor;
  @override

  /// ID of the Asset
  String? get toAssetId;
  @override

  /// Asset linked to exit.
  Asset? get toAsset;
  @override

  /// Total liters of the exit.
  double? get totalLiters;
  @override

  /// Date of the start of the exit.
  @TimestampOrNullConverter()
  DateTime? get startAt;
  @override

  /// Date of the end of the exit.
  @TimestampOrNullConverter()
  DateTime? get endAt;
  @override

  /// This flag defines if the possible exit was finished.
  bool? get isReady;
  @override

  /// This flag defines if the possible exit was started but not finished.
  bool? get inProgress;
  @override

  /// This flag defines if the possible exit is authenticated.
  bool? get isValidated;
  @override
  @JsonKey(ignore: true)
  _$$_AtsPossibleExitCopyWith<_$_AtsPossibleExit> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsExecuteExitInput _$AtsExecuteExitInputFromJson(Map<String, dynamic> json) {
  return _AtsExecuteExitInput.fromJson(json);
}

/// @nodoc
mixin _$AtsExecuteExitInput {
  /// [fromAssetId] ID of the bomb [Asset].
  String? get fromAssetId => throw _privateConstructorUsedError;

  /// [fromAssetId] ID of the bomb [Asset].
  set fromAssetId(String? value) => throw _privateConstructorUsedError;

  /// [sensorId] ID of [Sensor] bomb.
  String? get sensorId => throw _privateConstructorUsedError;

  /// [sensorId] ID of [Sensor] bomb.
  set sensorId(String? value) => throw _privateConstructorUsedError;

  /// [presetValue] Total liters limit allowed for exit execution
  int? get presetValue => throw _privateConstructorUsedError;

  /// [presetValue] Total liters limit allowed for exit execution
  set presetValue(int? value) => throw _privateConstructorUsedError;

  /// [toAssetID] ID of the [Asset] validated.
  String? get toAssetId => throw _privateConstructorUsedError;

  /// [toAssetID] ID of the [Asset] validated.
  set toAssetId(String? value) => throw _privateConstructorUsedError;

  /// [fromApp] Exit execution enum definition
  @AtsFromAppOrNullConverter()
  AtsFromApp? get fromApp => throw _privateConstructorUsedError;

  /// [fromApp] Exit execution enum definition
  @AtsFromAppOrNullConverter()
  set fromApp(AtsFromApp? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsExecuteExitInputCopyWith<AtsExecuteExitInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsExecuteExitInputCopyWith<$Res> {
  factory $AtsExecuteExitInputCopyWith(
          AtsExecuteExitInput value, $Res Function(AtsExecuteExitInput) then) =
      _$AtsExecuteExitInputCopyWithImpl<$Res, AtsExecuteExitInput>;
  @useResult
  $Res call(
      {String? fromAssetId,
      String? sensorId,
      int? presetValue,
      String? toAssetId,
      @AtsFromAppOrNullConverter() AtsFromApp? fromApp});
}

/// @nodoc
class _$AtsExecuteExitInputCopyWithImpl<$Res, $Val extends AtsExecuteExitInput>
    implements $AtsExecuteExitInputCopyWith<$Res> {
  _$AtsExecuteExitInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fromAssetId = freezed,
    Object? sensorId = freezed,
    Object? presetValue = freezed,
    Object? toAssetId = freezed,
    Object? fromApp = freezed,
  }) {
    return _then(_value.copyWith(
      fromAssetId: freezed == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      presetValue: freezed == presetValue
          ? _value.presetValue
          : presetValue // ignore: cast_nullable_to_non_nullable
              as int?,
      toAssetId: freezed == toAssetId
          ? _value.toAssetId
          : toAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      fromApp: freezed == fromApp
          ? _value.fromApp
          : fromApp // ignore: cast_nullable_to_non_nullable
              as AtsFromApp?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsExecuteExitInputCopyWith<$Res>
    implements $AtsExecuteExitInputCopyWith<$Res> {
  factory _$$_AtsExecuteExitInputCopyWith(_$_AtsExecuteExitInput value,
          $Res Function(_$_AtsExecuteExitInput) then) =
      __$$_AtsExecuteExitInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? fromAssetId,
      String? sensorId,
      int? presetValue,
      String? toAssetId,
      @AtsFromAppOrNullConverter() AtsFromApp? fromApp});
}

/// @nodoc
class __$$_AtsExecuteExitInputCopyWithImpl<$Res>
    extends _$AtsExecuteExitInputCopyWithImpl<$Res, _$_AtsExecuteExitInput>
    implements _$$_AtsExecuteExitInputCopyWith<$Res> {
  __$$_AtsExecuteExitInputCopyWithImpl(_$_AtsExecuteExitInput _value,
      $Res Function(_$_AtsExecuteExitInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? fromAssetId = freezed,
    Object? sensorId = freezed,
    Object? presetValue = freezed,
    Object? toAssetId = freezed,
    Object? fromApp = freezed,
  }) {
    return _then(_$_AtsExecuteExitInput(
      fromAssetId: freezed == fromAssetId
          ? _value.fromAssetId
          : fromAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      sensorId: freezed == sensorId
          ? _value.sensorId
          : sensorId // ignore: cast_nullable_to_non_nullable
              as String?,
      presetValue: freezed == presetValue
          ? _value.presetValue
          : presetValue // ignore: cast_nullable_to_non_nullable
              as int?,
      toAssetId: freezed == toAssetId
          ? _value.toAssetId
          : toAssetId // ignore: cast_nullable_to_non_nullable
              as String?,
      fromApp: freezed == fromApp
          ? _value.fromApp
          : fromApp // ignore: cast_nullable_to_non_nullable
              as AtsFromApp?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsExecuteExitInput implements _AtsExecuteExitInput {
  _$_AtsExecuteExitInput(
      {this.fromAssetId,
      this.sensorId,
      this.presetValue,
      this.toAssetId,
      @AtsFromAppOrNullConverter() this.fromApp});

  factory _$_AtsExecuteExitInput.fromJson(Map<String, dynamic> json) =>
      _$$_AtsExecuteExitInputFromJson(json);

  /// [fromAssetId] ID of the bomb [Asset].
  @override
  String? fromAssetId;

  /// [sensorId] ID of [Sensor] bomb.
  @override
  String? sensorId;

  /// [presetValue] Total liters limit allowed for exit execution
  @override
  int? presetValue;

  /// [toAssetID] ID of the [Asset] validated.
  @override
  String? toAssetId;

  /// [fromApp] Exit execution enum definition
  @override
  @AtsFromAppOrNullConverter()
  AtsFromApp? fromApp;

  @override
  String toString() {
    return 'AtsExecuteExitInput(fromAssetId: $fromAssetId, sensorId: $sensorId, presetValue: $presetValue, toAssetId: $toAssetId, fromApp: $fromApp)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsExecuteExitInputCopyWith<_$_AtsExecuteExitInput> get copyWith =>
      __$$_AtsExecuteExitInputCopyWithImpl<_$_AtsExecuteExitInput>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsExecuteExitInputToJson(
      this,
    );
  }
}

abstract class _AtsExecuteExitInput implements AtsExecuteExitInput {
  factory _AtsExecuteExitInput(
          {String? fromAssetId,
          String? sensorId,
          int? presetValue,
          String? toAssetId,
          @AtsFromAppOrNullConverter() AtsFromApp? fromApp}) =
      _$_AtsExecuteExitInput;

  factory _AtsExecuteExitInput.fromJson(Map<String, dynamic> json) =
      _$_AtsExecuteExitInput.fromJson;

  @override

  /// [fromAssetId] ID of the bomb [Asset].
  String? get fromAssetId;

  /// [fromAssetId] ID of the bomb [Asset].
  set fromAssetId(String? value);
  @override

  /// [sensorId] ID of [Sensor] bomb.
  String? get sensorId;

  /// [sensorId] ID of [Sensor] bomb.
  set sensorId(String? value);
  @override

  /// [presetValue] Total liters limit allowed for exit execution
  int? get presetValue;

  /// [presetValue] Total liters limit allowed for exit execution
  set presetValue(int? value);
  @override

  /// [toAssetID] ID of the [Asset] validated.
  String? get toAssetId;

  /// [toAssetID] ID of the [Asset] validated.
  set toAssetId(String? value);
  @override

  /// [fromApp] Exit execution enum definition
  @AtsFromAppOrNullConverter()
  AtsFromApp? get fromApp;

  /// [fromApp] Exit execution enum definition
  @AtsFromAppOrNullConverter()
  set fromApp(AtsFromApp? value);
  @override
  @JsonKey(ignore: true)
  _$$_AtsExecuteExitInputCopyWith<_$_AtsExecuteExitInput> get copyWith =>
      throw _privateConstructorUsedError;
}

AtsExecuteExitHistory _$AtsExecuteExitHistoryFromJson(
    Map<String, dynamic> json) {
  return _AtsExecuteExitHistory.fromJson(json);
}

/// @nodoc
mixin _$AtsExecuteExitHistory {
  /// ID of the recalculation entity. This ID is unique.
  String? get id => throw _privateConstructorUsedError;

  /// User NAME who execute the exit
  String? get generateBy => throw _privateConstructorUsedError;

  /// Pump asset name
  String? get fromAsset => throw _privateConstructorUsedError;

  /// Vehicle asset name
  String? get toAsset => throw _privateConstructorUsedError;

  /// Date of execution
  @TimestampOrNullConverter()
  DateTime? get createdAt => throw _privateConstructorUsedError;

  /// Reason of any error in execution
  String? get errorResponse => throw _privateConstructorUsedError;

  /// Execution status to know the process
  @AtsExitExecuteStatusOrNullConverter()
  AtsExitExecuteStatus? get status => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AtsExecuteExitHistoryCopyWith<AtsExecuteExitHistory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AtsExecuteExitHistoryCopyWith<$Res> {
  factory $AtsExecuteExitHistoryCopyWith(AtsExecuteExitHistory value,
          $Res Function(AtsExecuteExitHistory) then) =
      _$AtsExecuteExitHistoryCopyWithImpl<$Res, AtsExecuteExitHistory>;
  @useResult
  $Res call(
      {String? id,
      String? generateBy,
      String? fromAsset,
      String? toAsset,
      @TimestampOrNullConverter() DateTime? createdAt,
      String? errorResponse,
      @AtsExitExecuteStatusOrNullConverter() AtsExitExecuteStatus? status});
}

/// @nodoc
class _$AtsExecuteExitHistoryCopyWithImpl<$Res,
        $Val extends AtsExecuteExitHistory>
    implements $AtsExecuteExitHistoryCopyWith<$Res> {
  _$AtsExecuteExitHistoryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? generateBy = freezed,
    Object? fromAsset = freezed,
    Object? toAsset = freezed,
    Object? createdAt = freezed,
    Object? errorResponse = freezed,
    Object? status = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      generateBy: freezed == generateBy
          ? _value.generateBy
          : generateBy // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAsset: freezed == fromAsset
          ? _value.fromAsset
          : fromAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      toAsset: freezed == toAsset
          ? _value.toAsset
          : toAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      errorResponse: freezed == errorResponse
          ? _value.errorResponse
          : errorResponse // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as AtsExitExecuteStatus?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AtsExecuteExitHistoryCopyWith<$Res>
    implements $AtsExecuteExitHistoryCopyWith<$Res> {
  factory _$$_AtsExecuteExitHistoryCopyWith(_$_AtsExecuteExitHistory value,
          $Res Function(_$_AtsExecuteExitHistory) then) =
      __$$_AtsExecuteExitHistoryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String? generateBy,
      String? fromAsset,
      String? toAsset,
      @TimestampOrNullConverter() DateTime? createdAt,
      String? errorResponse,
      @AtsExitExecuteStatusOrNullConverter() AtsExitExecuteStatus? status});
}

/// @nodoc
class __$$_AtsExecuteExitHistoryCopyWithImpl<$Res>
    extends _$AtsExecuteExitHistoryCopyWithImpl<$Res, _$_AtsExecuteExitHistory>
    implements _$$_AtsExecuteExitHistoryCopyWith<$Res> {
  __$$_AtsExecuteExitHistoryCopyWithImpl(_$_AtsExecuteExitHistory _value,
      $Res Function(_$_AtsExecuteExitHistory) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? generateBy = freezed,
    Object? fromAsset = freezed,
    Object? toAsset = freezed,
    Object? createdAt = freezed,
    Object? errorResponse = freezed,
    Object? status = freezed,
  }) {
    return _then(_$_AtsExecuteExitHistory(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      generateBy: freezed == generateBy
          ? _value.generateBy
          : generateBy // ignore: cast_nullable_to_non_nullable
              as String?,
      fromAsset: freezed == fromAsset
          ? _value.fromAsset
          : fromAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      toAsset: freezed == toAsset
          ? _value.toAsset
          : toAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: freezed == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      errorResponse: freezed == errorResponse
          ? _value.errorResponse
          : errorResponse // ignore: cast_nullable_to_non_nullable
              as String?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as AtsExitExecuteStatus?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AtsExecuteExitHistory implements _AtsExecuteExitHistory {
  _$_AtsExecuteExitHistory(
      {this.id,
      this.generateBy,
      this.fromAsset,
      this.toAsset,
      @TimestampOrNullConverter() this.createdAt,
      this.errorResponse,
      @AtsExitExecuteStatusOrNullConverter() this.status});

  factory _$_AtsExecuteExitHistory.fromJson(Map<String, dynamic> json) =>
      _$$_AtsExecuteExitHistoryFromJson(json);

  /// ID of the recalculation entity. This ID is unique.
  @override
  final String? id;

  /// User NAME who execute the exit
  @override
  final String? generateBy;

  /// Pump asset name
  @override
  final String? fromAsset;

  /// Vehicle asset name
  @override
  final String? toAsset;

  /// Date of execution
  @override
  @TimestampOrNullConverter()
  final DateTime? createdAt;

  /// Reason of any error in execution
  @override
  final String? errorResponse;

  /// Execution status to know the process
  @override
  @AtsExitExecuteStatusOrNullConverter()
  final AtsExitExecuteStatus? status;

  @override
  String toString() {
    return 'AtsExecuteExitHistory(id: $id, generateBy: $generateBy, fromAsset: $fromAsset, toAsset: $toAsset, createdAt: $createdAt, errorResponse: $errorResponse, status: $status)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AtsExecuteExitHistory &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.generateBy, generateBy) ||
                other.generateBy == generateBy) &&
            (identical(other.fromAsset, fromAsset) ||
                other.fromAsset == fromAsset) &&
            (identical(other.toAsset, toAsset) || other.toAsset == toAsset) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.errorResponse, errorResponse) ||
                other.errorResponse == errorResponse) &&
            (identical(other.status, status) || other.status == status));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, generateBy, fromAsset,
      toAsset, createdAt, errorResponse, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AtsExecuteExitHistoryCopyWith<_$_AtsExecuteExitHistory> get copyWith =>
      __$$_AtsExecuteExitHistoryCopyWithImpl<_$_AtsExecuteExitHistory>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AtsExecuteExitHistoryToJson(
      this,
    );
  }
}

abstract class _AtsExecuteExitHistory implements AtsExecuteExitHistory {
  factory _AtsExecuteExitHistory(
      {final String? id,
      final String? generateBy,
      final String? fromAsset,
      final String? toAsset,
      @TimestampOrNullConverter() final DateTime? createdAt,
      final String? errorResponse,
      @AtsExitExecuteStatusOrNullConverter()
      final AtsExitExecuteStatus? status}) = _$_AtsExecuteExitHistory;

  factory _AtsExecuteExitHistory.fromJson(Map<String, dynamic> json) =
      _$_AtsExecuteExitHistory.fromJson;

  @override

  /// ID of the recalculation entity. This ID is unique.
  String? get id;
  @override

  /// User NAME who execute the exit
  String? get generateBy;
  @override

  /// Pump asset name
  String? get fromAsset;
  @override

  /// Vehicle asset name
  String? get toAsset;
  @override

  /// Date of execution
  @TimestampOrNullConverter()
  DateTime? get createdAt;
  @override

  /// Reason of any error in execution
  String? get errorResponse;
  @override

  /// Execution status to know the process
  @AtsExitExecuteStatusOrNullConverter()
  AtsExitExecuteStatus? get status;
  @override
  @JsonKey(ignore: true)
  _$$_AtsExecuteExitHistoryCopyWith<_$_AtsExecuteExitHistory> get copyWith =>
      throw _privateConstructorUsedError;
}

BrickhouseAlert _$BrickhouseAlertFromJson(Map<String, dynamic> json) {
  return _BrickhouseAlert.fromJson(json);
}

/// @nodoc
mixin _$BrickhouseAlert {
  /// ID of the alert entity. This ID is unique.
  String get id => throw _privateConstructorUsedError;

  /// Name of the alert.
  String get name => throw _privateConstructorUsedError;

  /// Type of the alert.
  @BrickhouseAlertTypeConverter()
  BrickhouseAlertType get type => throw _privateConstructorUsedError;

  /// List of assets
  List<Asset>? get assets => throw _privateConstructorUsedError;

  /// List of assets IDs.
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  /// Email to send the alert to.
  List<String>? get email => throw _privateConstructorUsedError;

  /// Phone number to send the alert to.
  List<NullablePhoneNumber?>? get phone => throw _privateConstructorUsedError;

  /// If the alert should be shown in the mobile app.
  bool? get hasMobilePopup => throw _privateConstructorUsedError;

  /// If the alert should be shown in the web app.
  bool? get hasWebPopup => throw _privateConstructorUsedError;

  /// Email to send the alert to.
  bool? get hasEmail => throw _privateConstructorUsedError;

  /// Phone number to send the alert to.
  bool? get hasPhone => throw _privateConstructorUsedError;

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  int? get batteryMinLevel => throw _privateConstructorUsedError;

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewStartHour => throw _privateConstructorUsedError;

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewEndHour => throw _privateConstructorUsedError;

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  String? get curfewTimezone => throw _privateConstructorUsedError;

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @WeekdayConverter()
  List<Weekday>? get curfewWeekdays => throw _privateConstructorUsedError;

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @ColorOrNullConverter()
  Color? get geofenceColor => throw _privateConstructorUsedError;

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @GeofenceModeOrNullConverter()
  GeofenceMode? get geofenceMode => throw _privateConstructorUsedError;

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  double? get geofenceRadius => throw _privateConstructorUsedError;

  /// geofenceShape [GeofencePoint]
  List<GeofencePoint>? get geofenceShape => throw _privateConstructorUsedError;

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @BrickhouseGeofenceTriggerOrNullConverter()
  BrickhouseGeofenceTrigger? get geofenceTrigger =>
      throw _privateConstructorUsedError;

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  double? get maxSpeedMaxValue => throw _privateConstructorUsedError;

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  Duration? get cooldownTime => throw _privateConstructorUsedError;

  /// [isMuted] represents if the alert is muted or not.
  bool? get isMuted => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BrickhouseAlertCopyWith<BrickhouseAlert> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BrickhouseAlertCopyWith<$Res> {
  factory $BrickhouseAlertCopyWith(
          BrickhouseAlert value, $Res Function(BrickhouseAlert) then) =
      _$BrickhouseAlertCopyWithImpl<$Res, BrickhouseAlert>;
  @useResult
  $Res call(
      {String id,
      String name,
      @BrickhouseAlertTypeConverter() BrickhouseAlertType type,
      List<Asset>? assets,
      List<String>? assetsIds,
      List<String>? email,
      List<NullablePhoneNumber?>? phone,
      bool? hasMobilePopup,
      bool? hasWebPopup,
      bool? hasEmail,
      bool? hasPhone,
      int? batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewEndHour,
      String? curfewTimezone,
      @WeekdayConverter() List<Weekday>? curfewWeekdays,
      @ColorOrNullConverter() Color? geofenceColor,
      @GeofenceModeOrNullConverter() GeofenceMode? geofenceMode,
      double? geofenceRadius,
      List<GeofencePoint>? geofenceShape,
      @BrickhouseGeofenceTriggerOrNullConverter()
      BrickhouseGeofenceTrigger? geofenceTrigger,
      double? maxSpeedMaxValue,
      @DurationOrNullConverter() Duration? cooldownTime,
      bool? isMuted});
}

/// @nodoc
class _$BrickhouseAlertCopyWithImpl<$Res, $Val extends BrickhouseAlert>
    implements $BrickhouseAlertCopyWith<$Res> {
  _$BrickhouseAlertCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? type = null,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? email = freezed,
    Object? phone = freezed,
    Object? hasMobilePopup = freezed,
    Object? hasWebPopup = freezed,
    Object? hasEmail = freezed,
    Object? hasPhone = freezed,
    Object? batteryMinLevel = freezed,
    Object? curfewStartHour = freezed,
    Object? curfewEndHour = freezed,
    Object? curfewTimezone = freezed,
    Object? curfewWeekdays = freezed,
    Object? geofenceColor = freezed,
    Object? geofenceMode = freezed,
    Object? geofenceRadius = freezed,
    Object? geofenceShape = freezed,
    Object? geofenceTrigger = freezed,
    Object? maxSpeedMaxValue = freezed,
    Object? cooldownTime = freezed,
    Object? isMuted = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as BrickhouseAlertType,
      assets: freezed == assets
          ? _value.assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      phone: freezed == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as List<NullablePhoneNumber?>?,
      hasMobilePopup: freezed == hasMobilePopup
          ? _value.hasMobilePopup
          : hasMobilePopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasWebPopup: freezed == hasWebPopup
          ? _value.hasWebPopup
          : hasWebPopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasEmail: freezed == hasEmail
          ? _value.hasEmail
          : hasEmail // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPhone: freezed == hasPhone
          ? _value.hasPhone
          : hasPhone // ignore: cast_nullable_to_non_nullable
              as bool?,
      batteryMinLevel: freezed == batteryMinLevel
          ? _value.batteryMinLevel
          : batteryMinLevel // ignore: cast_nullable_to_non_nullable
              as int?,
      curfewStartHour: freezed == curfewStartHour
          ? _value.curfewStartHour
          : curfewStartHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewEndHour: freezed == curfewEndHour
          ? _value.curfewEndHour
          : curfewEndHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewTimezone: freezed == curfewTimezone
          ? _value.curfewTimezone
          : curfewTimezone // ignore: cast_nullable_to_non_nullable
              as String?,
      curfewWeekdays: freezed == curfewWeekdays
          ? _value.curfewWeekdays
          : curfewWeekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      geofenceColor: freezed == geofenceColor
          ? _value.geofenceColor
          : geofenceColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      geofenceMode: freezed == geofenceMode
          ? _value.geofenceMode
          : geofenceMode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode?,
      geofenceRadius: freezed == geofenceRadius
          ? _value.geofenceRadius
          : geofenceRadius // ignore: cast_nullable_to_non_nullable
              as double?,
      geofenceShape: freezed == geofenceShape
          ? _value.geofenceShape
          : geofenceShape // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      geofenceTrigger: freezed == geofenceTrigger
          ? _value.geofenceTrigger
          : geofenceTrigger // ignore: cast_nullable_to_non_nullable
              as BrickhouseGeofenceTrigger?,
      maxSpeedMaxValue: freezed == maxSpeedMaxValue
          ? _value.maxSpeedMaxValue
          : maxSpeedMaxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      cooldownTime: freezed == cooldownTime
          ? _value.cooldownTime
          : cooldownTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      isMuted: freezed == isMuted
          ? _value.isMuted
          : isMuted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BrickhouseAlertCopyWith<$Res>
    implements $BrickhouseAlertCopyWith<$Res> {
  factory _$$_BrickhouseAlertCopyWith(
          _$_BrickhouseAlert value, $Res Function(_$_BrickhouseAlert) then) =
      __$$_BrickhouseAlertCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      @BrickhouseAlertTypeConverter() BrickhouseAlertType type,
      List<Asset>? assets,
      List<String>? assetsIds,
      List<String>? email,
      List<NullablePhoneNumber?>? phone,
      bool? hasMobilePopup,
      bool? hasWebPopup,
      bool? hasEmail,
      bool? hasPhone,
      int? batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewEndHour,
      String? curfewTimezone,
      @WeekdayConverter() List<Weekday>? curfewWeekdays,
      @ColorOrNullConverter() Color? geofenceColor,
      @GeofenceModeOrNullConverter() GeofenceMode? geofenceMode,
      double? geofenceRadius,
      List<GeofencePoint>? geofenceShape,
      @BrickhouseGeofenceTriggerOrNullConverter()
      BrickhouseGeofenceTrigger? geofenceTrigger,
      double? maxSpeedMaxValue,
      @DurationOrNullConverter() Duration? cooldownTime,
      bool? isMuted});
}

/// @nodoc
class __$$_BrickhouseAlertCopyWithImpl<$Res>
    extends _$BrickhouseAlertCopyWithImpl<$Res, _$_BrickhouseAlert>
    implements _$$_BrickhouseAlertCopyWith<$Res> {
  __$$_BrickhouseAlertCopyWithImpl(
      _$_BrickhouseAlert _value, $Res Function(_$_BrickhouseAlert) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? type = null,
    Object? assets = freezed,
    Object? assetsIds = freezed,
    Object? email = freezed,
    Object? phone = freezed,
    Object? hasMobilePopup = freezed,
    Object? hasWebPopup = freezed,
    Object? hasEmail = freezed,
    Object? hasPhone = freezed,
    Object? batteryMinLevel = freezed,
    Object? curfewStartHour = freezed,
    Object? curfewEndHour = freezed,
    Object? curfewTimezone = freezed,
    Object? curfewWeekdays = freezed,
    Object? geofenceColor = freezed,
    Object? geofenceMode = freezed,
    Object? geofenceRadius = freezed,
    Object? geofenceShape = freezed,
    Object? geofenceTrigger = freezed,
    Object? maxSpeedMaxValue = freezed,
    Object? cooldownTime = freezed,
    Object? isMuted = freezed,
  }) {
    return _then(_$_BrickhouseAlert(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as BrickhouseAlertType,
      assets: freezed == assets
          ? _value._assets
          : assets // ignore: cast_nullable_to_non_nullable
              as List<Asset>?,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      email: freezed == email
          ? _value._email
          : email // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      phone: freezed == phone
          ? _value._phone
          : phone // ignore: cast_nullable_to_non_nullable
              as List<NullablePhoneNumber?>?,
      hasMobilePopup: freezed == hasMobilePopup
          ? _value.hasMobilePopup
          : hasMobilePopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasWebPopup: freezed == hasWebPopup
          ? _value.hasWebPopup
          : hasWebPopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasEmail: freezed == hasEmail
          ? _value.hasEmail
          : hasEmail // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPhone: freezed == hasPhone
          ? _value.hasPhone
          : hasPhone // ignore: cast_nullable_to_non_nullable
              as bool?,
      batteryMinLevel: freezed == batteryMinLevel
          ? _value.batteryMinLevel
          : batteryMinLevel // ignore: cast_nullable_to_non_nullable
              as int?,
      curfewStartHour: freezed == curfewStartHour
          ? _value.curfewStartHour
          : curfewStartHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewEndHour: freezed == curfewEndHour
          ? _value.curfewEndHour
          : curfewEndHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewTimezone: freezed == curfewTimezone
          ? _value.curfewTimezone
          : curfewTimezone // ignore: cast_nullable_to_non_nullable
              as String?,
      curfewWeekdays: freezed == curfewWeekdays
          ? _value._curfewWeekdays
          : curfewWeekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      geofenceColor: freezed == geofenceColor
          ? _value.geofenceColor
          : geofenceColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      geofenceMode: freezed == geofenceMode
          ? _value.geofenceMode
          : geofenceMode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode?,
      geofenceRadius: freezed == geofenceRadius
          ? _value.geofenceRadius
          : geofenceRadius // ignore: cast_nullable_to_non_nullable
              as double?,
      geofenceShape: freezed == geofenceShape
          ? _value._geofenceShape
          : geofenceShape // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      geofenceTrigger: freezed == geofenceTrigger
          ? _value.geofenceTrigger
          : geofenceTrigger // ignore: cast_nullable_to_non_nullable
              as BrickhouseGeofenceTrigger?,
      maxSpeedMaxValue: freezed == maxSpeedMaxValue
          ? _value.maxSpeedMaxValue
          : maxSpeedMaxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      cooldownTime: freezed == cooldownTime
          ? _value.cooldownTime
          : cooldownTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      isMuted: freezed == isMuted
          ? _value.isMuted
          : isMuted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BrickhouseAlert implements _BrickhouseAlert {
  const _$_BrickhouseAlert(
      {required this.id,
      required this.name,
      @BrickhouseAlertTypeConverter() required this.type,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      final List<String>? email,
      final List<NullablePhoneNumber?>? phone,
      this.hasMobilePopup,
      this.hasWebPopup,
      this.hasEmail,
      this.hasPhone,
      this.batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter() this.curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter() this.curfewEndHour,
      this.curfewTimezone,
      @WeekdayConverter() final List<Weekday>? curfewWeekdays,
      @ColorOrNullConverter() this.geofenceColor,
      @GeofenceModeOrNullConverter() this.geofenceMode,
      this.geofenceRadius,
      final List<GeofencePoint>? geofenceShape,
      @BrickhouseGeofenceTriggerOrNullConverter() this.geofenceTrigger,
      this.maxSpeedMaxValue,
      @DurationOrNullConverter() this.cooldownTime,
      this.isMuted = false})
      : _assets = assets,
        _assetsIds = assetsIds,
        _email = email,
        _phone = phone,
        _curfewWeekdays = curfewWeekdays,
        _geofenceShape = geofenceShape;

  factory _$_BrickhouseAlert.fromJson(Map<String, dynamic> json) =>
      _$$_BrickhouseAlertFromJson(json);

  /// ID of the alert entity. This ID is unique.
  @override
  final String id;

  /// Name of the alert.
  @override
  final String name;

  /// Type of the alert.
  @override
  @BrickhouseAlertTypeConverter()
  final BrickhouseAlertType type;

  /// List of assets
  final List<Asset>? _assets;

  /// List of assets
  @override
  List<Asset>? get assets {
    final value = _assets;
    if (value == null) return null;
    if (_assets is EqualUnmodifiableListView) return _assets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// List of assets IDs.
  final List<String>? _assetsIds;

  /// List of assets IDs.
  @override
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Email to send the alert to.
  final List<String>? _email;

  /// Email to send the alert to.
  @override
  List<String>? get email {
    final value = _email;
    if (value == null) return null;
    if (_email is EqualUnmodifiableListView) return _email;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Phone number to send the alert to.
  final List<NullablePhoneNumber?>? _phone;

  /// Phone number to send the alert to.
  @override
  List<NullablePhoneNumber?>? get phone {
    final value = _phone;
    if (value == null) return null;
    if (_phone is EqualUnmodifiableListView) return _phone;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// If the alert should be shown in the mobile app.
  @override
  final bool? hasMobilePopup;

  /// If the alert should be shown in the web app.
  @override
  final bool? hasWebPopup;

  /// Email to send the alert to.
  @override
  final bool? hasEmail;

  /// Phone number to send the alert to.
  @override
  final bool? hasPhone;

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  @override
  final int? batteryMinLevel;

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @override
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  final TimeOfDay? curfewStartHour;

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @override
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  final TimeOfDay? curfewEndHour;

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  @override
  final String? curfewTimezone;

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  final List<Weekday>? _curfewWeekdays;

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @override
  @WeekdayConverter()
  List<Weekday>? get curfewWeekdays {
    final value = _curfewWeekdays;
    if (value == null) return null;
    if (_curfewWeekdays is EqualUnmodifiableListView) return _curfewWeekdays;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  @ColorOrNullConverter()
  final Color? geofenceColor;

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  @GeofenceModeOrNullConverter()
  final GeofenceMode? geofenceMode;

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  final double? geofenceRadius;

  /// geofenceShape [GeofencePoint]
  final List<GeofencePoint>? _geofenceShape;

  /// geofenceShape [GeofencePoint]
  @override
  List<GeofencePoint>? get geofenceShape {
    final value = _geofenceShape;
    if (value == null) return null;
    if (_geofenceShape is EqualUnmodifiableListView) return _geofenceShape;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  @BrickhouseGeofenceTriggerOrNullConverter()
  final BrickhouseGeofenceTrigger? geofenceTrigger;

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  @override
  final double? maxSpeedMaxValue;

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @override
  @DurationOrNullConverter()
  final Duration? cooldownTime;

  /// [isMuted] represents if the alert is muted or not.
  @override
  @JsonKey()
  final bool? isMuted;

  @override
  String toString() {
    return 'BrickhouseAlert(id: $id, name: $name, type: $type, assets: $assets, assetsIds: $assetsIds, email: $email, phone: $phone, hasMobilePopup: $hasMobilePopup, hasWebPopup: $hasWebPopup, hasEmail: $hasEmail, hasPhone: $hasPhone, batteryMinLevel: $batteryMinLevel, curfewStartHour: $curfewStartHour, curfewEndHour: $curfewEndHour, curfewTimezone: $curfewTimezone, curfewWeekdays: $curfewWeekdays, geofenceColor: $geofenceColor, geofenceMode: $geofenceMode, geofenceRadius: $geofenceRadius, geofenceShape: $geofenceShape, geofenceTrigger: $geofenceTrigger, maxSpeedMaxValue: $maxSpeedMaxValue, cooldownTime: $cooldownTime, isMuted: $isMuted)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BrickhouseAlert &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality().equals(other._assets, _assets) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds) &&
            const DeepCollectionEquality().equals(other._email, _email) &&
            const DeepCollectionEquality().equals(other._phone, _phone) &&
            (identical(other.hasMobilePopup, hasMobilePopup) ||
                other.hasMobilePopup == hasMobilePopup) &&
            (identical(other.hasWebPopup, hasWebPopup) ||
                other.hasWebPopup == hasWebPopup) &&
            (identical(other.hasEmail, hasEmail) ||
                other.hasEmail == hasEmail) &&
            (identical(other.hasPhone, hasPhone) ||
                other.hasPhone == hasPhone) &&
            (identical(other.batteryMinLevel, batteryMinLevel) ||
                other.batteryMinLevel == batteryMinLevel) &&
            (identical(other.curfewStartHour, curfewStartHour) ||
                other.curfewStartHour == curfewStartHour) &&
            (identical(other.curfewEndHour, curfewEndHour) ||
                other.curfewEndHour == curfewEndHour) &&
            (identical(other.curfewTimezone, curfewTimezone) ||
                other.curfewTimezone == curfewTimezone) &&
            const DeepCollectionEquality()
                .equals(other._curfewWeekdays, _curfewWeekdays) &&
            (identical(other.geofenceColor, geofenceColor) ||
                other.geofenceColor == geofenceColor) &&
            (identical(other.geofenceMode, geofenceMode) ||
                other.geofenceMode == geofenceMode) &&
            (identical(other.geofenceRadius, geofenceRadius) ||
                other.geofenceRadius == geofenceRadius) &&
            const DeepCollectionEquality()
                .equals(other._geofenceShape, _geofenceShape) &&
            (identical(other.geofenceTrigger, geofenceTrigger) ||
                other.geofenceTrigger == geofenceTrigger) &&
            (identical(other.maxSpeedMaxValue, maxSpeedMaxValue) ||
                other.maxSpeedMaxValue == maxSpeedMaxValue) &&
            (identical(other.cooldownTime, cooldownTime) ||
                other.cooldownTime == cooldownTime) &&
            (identical(other.isMuted, isMuted) || other.isMuted == isMuted));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        name,
        type,
        const DeepCollectionEquality().hash(_assets),
        const DeepCollectionEquality().hash(_assetsIds),
        const DeepCollectionEquality().hash(_email),
        const DeepCollectionEquality().hash(_phone),
        hasMobilePopup,
        hasWebPopup,
        hasEmail,
        hasPhone,
        batteryMinLevel,
        curfewStartHour,
        curfewEndHour,
        curfewTimezone,
        const DeepCollectionEquality().hash(_curfewWeekdays),
        geofenceColor,
        geofenceMode,
        geofenceRadius,
        const DeepCollectionEquality().hash(_geofenceShape),
        geofenceTrigger,
        maxSpeedMaxValue,
        cooldownTime,
        isMuted
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BrickhouseAlertCopyWith<_$_BrickhouseAlert> get copyWith =>
      __$$_BrickhouseAlertCopyWithImpl<_$_BrickhouseAlert>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BrickhouseAlertToJson(
      this,
    );
  }
}

abstract class _BrickhouseAlert implements BrickhouseAlert {
  const factory _BrickhouseAlert(
      {required final String id,
      required final String name,
      @BrickhouseAlertTypeConverter() required final BrickhouseAlertType type,
      final List<Asset>? assets,
      final List<String>? assetsIds,
      final List<String>? email,
      final List<NullablePhoneNumber?>? phone,
      final bool? hasMobilePopup,
      final bool? hasWebPopup,
      final bool? hasEmail,
      final bool? hasPhone,
      final int? batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter()
      final TimeOfDay? curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter()
      final TimeOfDay? curfewEndHour,
      final String? curfewTimezone,
      @WeekdayConverter() final List<Weekday>? curfewWeekdays,
      @ColorOrNullConverter() final Color? geofenceColor,
      @GeofenceModeOrNullConverter() final GeofenceMode? geofenceMode,
      final double? geofenceRadius,
      final List<GeofencePoint>? geofenceShape,
      @BrickhouseGeofenceTriggerOrNullConverter()
      final BrickhouseGeofenceTrigger? geofenceTrigger,
      final double? maxSpeedMaxValue,
      @DurationOrNullConverter() final Duration? cooldownTime,
      final bool? isMuted}) = _$_BrickhouseAlert;

  factory _BrickhouseAlert.fromJson(Map<String, dynamic> json) =
      _$_BrickhouseAlert.fromJson;

  @override

  /// ID of the alert entity. This ID is unique.
  String get id;
  @override

  /// Name of the alert.
  String get name;
  @override

  /// Type of the alert.
  @BrickhouseAlertTypeConverter()
  BrickhouseAlertType get type;
  @override

  /// List of assets
  List<Asset>? get assets;
  @override

  /// List of assets IDs.
  List<String>? get assetsIds;
  @override

  /// Email to send the alert to.
  List<String>? get email;
  @override

  /// Phone number to send the alert to.
  List<NullablePhoneNumber?>? get phone;
  @override

  /// If the alert should be shown in the mobile app.
  bool? get hasMobilePopup;
  @override

  /// If the alert should be shown in the web app.
  bool? get hasWebPopup;
  @override

  /// Email to send the alert to.
  bool? get hasEmail;
  @override

  /// Phone number to send the alert to.
  bool? get hasPhone;
  @override

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  int? get batteryMinLevel;
  @override

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewStartHour;
  @override

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewEndHour;
  @override

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  String? get curfewTimezone;
  @override

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @WeekdayConverter()
  List<Weekday>? get curfewWeekdays;
  @override

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @ColorOrNullConverter()
  Color? get geofenceColor;
  @override

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @GeofenceModeOrNullConverter()
  GeofenceMode? get geofenceMode;
  @override

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  double? get geofenceRadius;
  @override

  /// geofenceShape [GeofencePoint]
  List<GeofencePoint>? get geofenceShape;
  @override

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @BrickhouseGeofenceTriggerOrNullConverter()
  BrickhouseGeofenceTrigger? get geofenceTrigger;
  @override

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  double? get maxSpeedMaxValue;
  @override

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  Duration? get cooldownTime;
  @override

  /// [isMuted] represents if the alert is muted or not.
  bool? get isMuted;
  @override
  @JsonKey(ignore: true)
  _$$_BrickhouseAlertCopyWith<_$_BrickhouseAlert> get copyWith =>
      throw _privateConstructorUsedError;
}

BrickhouseAlertInput _$BrickhouseAlertInputFromJson(Map<String, dynamic> json) {
  return _BrickhouseAlertInput.fromJson(json);
}

/// @nodoc
mixin _$BrickhouseAlertInput {
  /// ID of the alert entity. Send only when you want to edit it
  String? get id => throw _privateConstructorUsedError;

  /// ID of the alert entity. Send only when you want to edit it
  set id(String? value) => throw _privateConstructorUsedError;

  /// Name of the alert.
  String get name => throw _privateConstructorUsedError;

  /// Name of the alert.
  set name(String value) => throw _privateConstructorUsedError;

  /// Type of the alert.
  @BrickhouseAlertTypeConverter()
  BrickhouseAlertType get type => throw _privateConstructorUsedError;

  /// Type of the alert.
  @BrickhouseAlertTypeConverter()
  set type(BrickhouseAlertType value) => throw _privateConstructorUsedError;

  /// List of assets IDs.
  List<String> get assetsIds => throw _privateConstructorUsedError;

  /// List of assets IDs.
  set assetsIds(List<String> value) => throw _privateConstructorUsedError;

  /// Email to send the alert to.
  List<String>? get email => throw _privateConstructorUsedError;

  /// Email to send the alert to.
  set email(List<String>? value) => throw _privateConstructorUsedError;

  /// Phone number to send the alert to.
  List<NullablePhoneNumber?>? get phone => throw _privateConstructorUsedError;

  /// Phone number to send the alert to.
  set phone(List<NullablePhoneNumber?>? value) =>
      throw _privateConstructorUsedError;

  /// If the alert should be shown in the mobile app.
  bool? get hasMobilePopup => throw _privateConstructorUsedError;

  /// If the alert should be shown in the mobile app.
  set hasMobilePopup(bool? value) => throw _privateConstructorUsedError;

  /// If the alert should be shown in the web app.
  bool? get hasWebPopup => throw _privateConstructorUsedError;

  /// If the alert should be shown in the web app.
  set hasWebPopup(bool? value) => throw _privateConstructorUsedError;

  /// Email to send the alert to.
  bool? get hasEmail => throw _privateConstructorUsedError;

  /// Email to send the alert to.
  set hasEmail(bool? value) => throw _privateConstructorUsedError;

  /// Phone number to send the alert to.
  bool? get hasPhone => throw _privateConstructorUsedError;

  /// Phone number to send the alert to.
  set hasPhone(bool? value) => throw _privateConstructorUsedError;

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  int? get batteryMinLevel => throw _privateConstructorUsedError;

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  set batteryMinLevel(int? value) => throw _privateConstructorUsedError;

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewStartHour => throw _privateConstructorUsedError;

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  set curfewStartHour(TimeOfDay? value) => throw _privateConstructorUsedError;

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewEndHour => throw _privateConstructorUsedError;

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  set curfewEndHour(TimeOfDay? value) => throw _privateConstructorUsedError;

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  String? get curfewTimezone => throw _privateConstructorUsedError;

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  set curfewTimezone(String? value) => throw _privateConstructorUsedError;

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @WeekdayConverter()
  List<Weekday>? get curfewWeekdays => throw _privateConstructorUsedError;

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @WeekdayConverter()
  set curfewWeekdays(List<Weekday>? value) =>
      throw _privateConstructorUsedError;

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @ColorOrNullConverter()
  Color? get geofenceColor => throw _privateConstructorUsedError;

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @ColorOrNullConverter()
  set geofenceColor(Color? value) => throw _privateConstructorUsedError;

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @GeofenceModeOrNullConverter()
  GeofenceMode? get geofenceMode => throw _privateConstructorUsedError;

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @GeofenceModeOrNullConverter()
  set geofenceMode(GeofenceMode? value) => throw _privateConstructorUsedError;

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  double? get geofenceRadius => throw _privateConstructorUsedError;

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  set geofenceRadius(double? value) => throw _privateConstructorUsedError;

  /// geofenceShape [GeofencePointInput]
  List<GeofencePoint>? get geofenceShape => throw _privateConstructorUsedError;

  /// geofenceShape [GeofencePointInput]
  set geofenceShape(List<GeofencePoint>? value) =>
      throw _privateConstructorUsedError;

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @BrickhouseGeofenceTriggerOrNullConverter()
  BrickhouseGeofenceTrigger? get geofenceTrigger =>
      throw _privateConstructorUsedError;

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @BrickhouseGeofenceTriggerOrNullConverter()
  set geofenceTrigger(BrickhouseGeofenceTrigger? value) =>
      throw _privateConstructorUsedError;

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  double? get maxSpeedMaxValue => throw _privateConstructorUsedError;

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  set maxSpeedMaxValue(double? value) => throw _privateConstructorUsedError;

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  Duration? get cooldownTime => throw _privateConstructorUsedError;

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  set cooldownTime(Duration? value) => throw _privateConstructorUsedError;

  /// [isMuted] represents if the alert is muted or not.
  bool? get isMuted => throw _privateConstructorUsedError;

  /// [isMuted] represents if the alert is muted or not.
  set isMuted(bool? value) => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BrickhouseAlertInputCopyWith<BrickhouseAlertInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BrickhouseAlertInputCopyWith<$Res> {
  factory $BrickhouseAlertInputCopyWith(BrickhouseAlertInput value,
          $Res Function(BrickhouseAlertInput) then) =
      _$BrickhouseAlertInputCopyWithImpl<$Res, BrickhouseAlertInput>;
  @useResult
  $Res call(
      {String? id,
      String name,
      @BrickhouseAlertTypeConverter() BrickhouseAlertType type,
      List<String> assetsIds,
      List<String>? email,
      List<NullablePhoneNumber?>? phone,
      bool? hasMobilePopup,
      bool? hasWebPopup,
      bool? hasEmail,
      bool? hasPhone,
      int? batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewEndHour,
      String? curfewTimezone,
      @WeekdayConverter() List<Weekday>? curfewWeekdays,
      @ColorOrNullConverter() Color? geofenceColor,
      @GeofenceModeOrNullConverter() GeofenceMode? geofenceMode,
      double? geofenceRadius,
      List<GeofencePoint>? geofenceShape,
      @BrickhouseGeofenceTriggerOrNullConverter()
      BrickhouseGeofenceTrigger? geofenceTrigger,
      double? maxSpeedMaxValue,
      @DurationOrNullConverter() Duration? cooldownTime,
      bool? isMuted});
}

/// @nodoc
class _$BrickhouseAlertInputCopyWithImpl<$Res,
        $Val extends BrickhouseAlertInput>
    implements $BrickhouseAlertInputCopyWith<$Res> {
  _$BrickhouseAlertInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? type = null,
    Object? assetsIds = null,
    Object? email = freezed,
    Object? phone = freezed,
    Object? hasMobilePopup = freezed,
    Object? hasWebPopup = freezed,
    Object? hasEmail = freezed,
    Object? hasPhone = freezed,
    Object? batteryMinLevel = freezed,
    Object? curfewStartHour = freezed,
    Object? curfewEndHour = freezed,
    Object? curfewTimezone = freezed,
    Object? curfewWeekdays = freezed,
    Object? geofenceColor = freezed,
    Object? geofenceMode = freezed,
    Object? geofenceRadius = freezed,
    Object? geofenceShape = freezed,
    Object? geofenceTrigger = freezed,
    Object? maxSpeedMaxValue = freezed,
    Object? cooldownTime = freezed,
    Object? isMuted = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as BrickhouseAlertType,
      assetsIds: null == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      phone: freezed == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as List<NullablePhoneNumber?>?,
      hasMobilePopup: freezed == hasMobilePopup
          ? _value.hasMobilePopup
          : hasMobilePopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasWebPopup: freezed == hasWebPopup
          ? _value.hasWebPopup
          : hasWebPopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasEmail: freezed == hasEmail
          ? _value.hasEmail
          : hasEmail // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPhone: freezed == hasPhone
          ? _value.hasPhone
          : hasPhone // ignore: cast_nullable_to_non_nullable
              as bool?,
      batteryMinLevel: freezed == batteryMinLevel
          ? _value.batteryMinLevel
          : batteryMinLevel // ignore: cast_nullable_to_non_nullable
              as int?,
      curfewStartHour: freezed == curfewStartHour
          ? _value.curfewStartHour
          : curfewStartHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewEndHour: freezed == curfewEndHour
          ? _value.curfewEndHour
          : curfewEndHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewTimezone: freezed == curfewTimezone
          ? _value.curfewTimezone
          : curfewTimezone // ignore: cast_nullable_to_non_nullable
              as String?,
      curfewWeekdays: freezed == curfewWeekdays
          ? _value.curfewWeekdays
          : curfewWeekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      geofenceColor: freezed == geofenceColor
          ? _value.geofenceColor
          : geofenceColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      geofenceMode: freezed == geofenceMode
          ? _value.geofenceMode
          : geofenceMode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode?,
      geofenceRadius: freezed == geofenceRadius
          ? _value.geofenceRadius
          : geofenceRadius // ignore: cast_nullable_to_non_nullable
              as double?,
      geofenceShape: freezed == geofenceShape
          ? _value.geofenceShape
          : geofenceShape // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      geofenceTrigger: freezed == geofenceTrigger
          ? _value.geofenceTrigger
          : geofenceTrigger // ignore: cast_nullable_to_non_nullable
              as BrickhouseGeofenceTrigger?,
      maxSpeedMaxValue: freezed == maxSpeedMaxValue
          ? _value.maxSpeedMaxValue
          : maxSpeedMaxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      cooldownTime: freezed == cooldownTime
          ? _value.cooldownTime
          : cooldownTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      isMuted: freezed == isMuted
          ? _value.isMuted
          : isMuted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BrickhouseAlertInputCopyWith<$Res>
    implements $BrickhouseAlertInputCopyWith<$Res> {
  factory _$$_BrickhouseAlertInputCopyWith(_$_BrickhouseAlertInput value,
          $Res Function(_$_BrickhouseAlertInput) then) =
      __$$_BrickhouseAlertInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String name,
      @BrickhouseAlertTypeConverter() BrickhouseAlertType type,
      List<String> assetsIds,
      List<String>? email,
      List<NullablePhoneNumber?>? phone,
      bool? hasMobilePopup,
      bool? hasWebPopup,
      bool? hasEmail,
      bool? hasPhone,
      int? batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewEndHour,
      String? curfewTimezone,
      @WeekdayConverter() List<Weekday>? curfewWeekdays,
      @ColorOrNullConverter() Color? geofenceColor,
      @GeofenceModeOrNullConverter() GeofenceMode? geofenceMode,
      double? geofenceRadius,
      List<GeofencePoint>? geofenceShape,
      @BrickhouseGeofenceTriggerOrNullConverter()
      BrickhouseGeofenceTrigger? geofenceTrigger,
      double? maxSpeedMaxValue,
      @DurationOrNullConverter() Duration? cooldownTime,
      bool? isMuted});
}

/// @nodoc
class __$$_BrickhouseAlertInputCopyWithImpl<$Res>
    extends _$BrickhouseAlertInputCopyWithImpl<$Res, _$_BrickhouseAlertInput>
    implements _$$_BrickhouseAlertInputCopyWith<$Res> {
  __$$_BrickhouseAlertInputCopyWithImpl(_$_BrickhouseAlertInput _value,
      $Res Function(_$_BrickhouseAlertInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? name = null,
    Object? type = null,
    Object? assetsIds = null,
    Object? email = freezed,
    Object? phone = freezed,
    Object? hasMobilePopup = freezed,
    Object? hasWebPopup = freezed,
    Object? hasEmail = freezed,
    Object? hasPhone = freezed,
    Object? batteryMinLevel = freezed,
    Object? curfewStartHour = freezed,
    Object? curfewEndHour = freezed,
    Object? curfewTimezone = freezed,
    Object? curfewWeekdays = freezed,
    Object? geofenceColor = freezed,
    Object? geofenceMode = freezed,
    Object? geofenceRadius = freezed,
    Object? geofenceShape = freezed,
    Object? geofenceTrigger = freezed,
    Object? maxSpeedMaxValue = freezed,
    Object? cooldownTime = freezed,
    Object? isMuted = freezed,
  }) {
    return _then(_$_BrickhouseAlertInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as BrickhouseAlertType,
      assetsIds: null == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
      email: freezed == email
          ? _value.email
          : email // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      phone: freezed == phone
          ? _value.phone
          : phone // ignore: cast_nullable_to_non_nullable
              as List<NullablePhoneNumber?>?,
      hasMobilePopup: freezed == hasMobilePopup
          ? _value.hasMobilePopup
          : hasMobilePopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasWebPopup: freezed == hasWebPopup
          ? _value.hasWebPopup
          : hasWebPopup // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasEmail: freezed == hasEmail
          ? _value.hasEmail
          : hasEmail // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasPhone: freezed == hasPhone
          ? _value.hasPhone
          : hasPhone // ignore: cast_nullable_to_non_nullable
              as bool?,
      batteryMinLevel: freezed == batteryMinLevel
          ? _value.batteryMinLevel
          : batteryMinLevel // ignore: cast_nullable_to_non_nullable
              as int?,
      curfewStartHour: freezed == curfewStartHour
          ? _value.curfewStartHour
          : curfewStartHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewEndHour: freezed == curfewEndHour
          ? _value.curfewEndHour
          : curfewEndHour // ignore: cast_nullable_to_non_nullable
              as TimeOfDay?,
      curfewTimezone: freezed == curfewTimezone
          ? _value.curfewTimezone
          : curfewTimezone // ignore: cast_nullable_to_non_nullable
              as String?,
      curfewWeekdays: freezed == curfewWeekdays
          ? _value.curfewWeekdays
          : curfewWeekdays // ignore: cast_nullable_to_non_nullable
              as List<Weekday>?,
      geofenceColor: freezed == geofenceColor
          ? _value.geofenceColor
          : geofenceColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      geofenceMode: freezed == geofenceMode
          ? _value.geofenceMode
          : geofenceMode // ignore: cast_nullable_to_non_nullable
              as GeofenceMode?,
      geofenceRadius: freezed == geofenceRadius
          ? _value.geofenceRadius
          : geofenceRadius // ignore: cast_nullable_to_non_nullable
              as double?,
      geofenceShape: freezed == geofenceShape
          ? _value.geofenceShape
          : geofenceShape // ignore: cast_nullable_to_non_nullable
              as List<GeofencePoint>?,
      geofenceTrigger: freezed == geofenceTrigger
          ? _value.geofenceTrigger
          : geofenceTrigger // ignore: cast_nullable_to_non_nullable
              as BrickhouseGeofenceTrigger?,
      maxSpeedMaxValue: freezed == maxSpeedMaxValue
          ? _value.maxSpeedMaxValue
          : maxSpeedMaxValue // ignore: cast_nullable_to_non_nullable
              as double?,
      cooldownTime: freezed == cooldownTime
          ? _value.cooldownTime
          : cooldownTime // ignore: cast_nullable_to_non_nullable
              as Duration?,
      isMuted: freezed == isMuted
          ? _value.isMuted
          : isMuted // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BrickhouseAlertInput implements _BrickhouseAlertInput {
  _$_BrickhouseAlertInput(
      {this.id,
      required this.name,
      @BrickhouseAlertTypeConverter() required this.type,
      required this.assetsIds,
      this.email = const [],
      this.phone = const [],
      this.hasMobilePopup = false,
      this.hasWebPopup = false,
      this.hasEmail = false,
      this.hasPhone = false,
      this.batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter() this.curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter() this.curfewEndHour,
      this.curfewTimezone,
      @WeekdayConverter() this.curfewWeekdays = const [
        Weekday.monday,
        Weekday.tuesday,
        Weekday.wednesday,
        Weekday.thursday,
        Weekday.friday,
        Weekday.saturday,
        Weekday.sunday
      ],
      @ColorOrNullConverter() this.geofenceColor,
      @GeofenceModeOrNullConverter() this.geofenceMode,
      this.geofenceRadius,
      this.geofenceShape = const [],
      @BrickhouseGeofenceTriggerOrNullConverter()
      this.geofenceTrigger = BrickhouseGeofenceTrigger.both,
      this.maxSpeedMaxValue,
      @DurationOrNullConverter() this.cooldownTime,
      this.isMuted = false});

  factory _$_BrickhouseAlertInput.fromJson(Map<String, dynamic> json) =>
      _$$_BrickhouseAlertInputFromJson(json);

  /// ID of the alert entity. Send only when you want to edit it
  @override
  String? id;

  /// Name of the alert.
  @override
  String name;

  /// Type of the alert.
  @override
  @BrickhouseAlertTypeConverter()
  BrickhouseAlertType type;

  /// List of assets IDs.
  @override
  List<String> assetsIds;

  /// Email to send the alert to.
  @override
  @JsonKey()
  List<String>? email;

  /// Phone number to send the alert to.
  @override
  @JsonKey()
  List<NullablePhoneNumber?>? phone;

  /// If the alert should be shown in the mobile app.
  @override
  @JsonKey()
  bool? hasMobilePopup;

  /// If the alert should be shown in the web app.
  @override
  @JsonKey()
  bool? hasWebPopup;

  /// Email to send the alert to.
  @override
  @JsonKey()
  bool? hasEmail;

  /// Phone number to send the alert to.
  @override
  @JsonKey()
  bool? hasPhone;

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  @override
  int? batteryMinLevel;

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @override
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? curfewStartHour;

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @override
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? curfewEndHour;

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  @override
  String? curfewTimezone;

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @override
  @JsonKey()
  @WeekdayConverter()
  List<Weekday>? curfewWeekdays;

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  @ColorOrNullConverter()
  Color? geofenceColor;

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  @GeofenceModeOrNullConverter()
  GeofenceMode? geofenceMode;

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  double? geofenceRadius;

  /// geofenceShape [GeofencePointInput]
  @override
  @JsonKey()
  List<GeofencePoint>? geofenceShape;

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @override
  @JsonKey()
  @BrickhouseGeofenceTriggerOrNullConverter()
  BrickhouseGeofenceTrigger? geofenceTrigger;

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  @override
  double? maxSpeedMaxValue;

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @override
  @DurationOrNullConverter()
  Duration? cooldownTime;

  /// [isMuted] represents if the alert is muted or not.
  @override
  @JsonKey()
  bool? isMuted;

  @override
  String toString() {
    return 'BrickhouseAlertInput(id: $id, name: $name, type: $type, assetsIds: $assetsIds, email: $email, phone: $phone, hasMobilePopup: $hasMobilePopup, hasWebPopup: $hasWebPopup, hasEmail: $hasEmail, hasPhone: $hasPhone, batteryMinLevel: $batteryMinLevel, curfewStartHour: $curfewStartHour, curfewEndHour: $curfewEndHour, curfewTimezone: $curfewTimezone, curfewWeekdays: $curfewWeekdays, geofenceColor: $geofenceColor, geofenceMode: $geofenceMode, geofenceRadius: $geofenceRadius, geofenceShape: $geofenceShape, geofenceTrigger: $geofenceTrigger, maxSpeedMaxValue: $maxSpeedMaxValue, cooldownTime: $cooldownTime, isMuted: $isMuted)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BrickhouseAlertInputCopyWith<_$_BrickhouseAlertInput> get copyWith =>
      __$$_BrickhouseAlertInputCopyWithImpl<_$_BrickhouseAlertInput>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BrickhouseAlertInputToJson(
      this,
    );
  }
}

abstract class _BrickhouseAlertInput implements BrickhouseAlertInput {
  factory _BrickhouseAlertInput(
      {String? id,
      required String name,
      @BrickhouseAlertTypeConverter() required BrickhouseAlertType type,
      required List<String> assetsIds,
      List<String>? email,
      List<NullablePhoneNumber?>? phone,
      bool? hasMobilePopup,
      bool? hasWebPopup,
      bool? hasEmail,
      bool? hasPhone,
      int? batteryMinLevel,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewStartHour,
      @BrickhouseTimeOfDayMinuteOrNullConverter() TimeOfDay? curfewEndHour,
      String? curfewTimezone,
      @WeekdayConverter() List<Weekday>? curfewWeekdays,
      @ColorOrNullConverter() Color? geofenceColor,
      @GeofenceModeOrNullConverter() GeofenceMode? geofenceMode,
      double? geofenceRadius,
      List<GeofencePoint>? geofenceShape,
      @BrickhouseGeofenceTriggerOrNullConverter()
      BrickhouseGeofenceTrigger? geofenceTrigger,
      double? maxSpeedMaxValue,
      @DurationOrNullConverter() Duration? cooldownTime,
      bool? isMuted}) = _$_BrickhouseAlertInput;

  factory _BrickhouseAlertInput.fromJson(Map<String, dynamic> json) =
      _$_BrickhouseAlertInput.fromJson;

  @override

  /// ID of the alert entity. Send only when you want to edit it
  String? get id;

  /// ID of the alert entity. Send only when you want to edit it
  set id(String? value);
  @override

  /// Name of the alert.
  String get name;

  /// Name of the alert.
  set name(String value);
  @override

  /// Type of the alert.
  @BrickhouseAlertTypeConverter()
  BrickhouseAlertType get type;

  /// Type of the alert.
  @BrickhouseAlertTypeConverter()
  set type(BrickhouseAlertType value);
  @override

  /// List of assets IDs.
  List<String> get assetsIds;

  /// List of assets IDs.
  set assetsIds(List<String> value);
  @override

  /// Email to send the alert to.
  List<String>? get email;

  /// Email to send the alert to.
  set email(List<String>? value);
  @override

  /// Phone number to send the alert to.
  List<NullablePhoneNumber?>? get phone;

  /// Phone number to send the alert to.
  set phone(List<NullablePhoneNumber?>? value);
  @override

  /// If the alert should be shown in the mobile app.
  bool? get hasMobilePopup;

  /// If the alert should be shown in the mobile app.
  set hasMobilePopup(bool? value);
  @override

  /// If the alert should be shown in the web app.
  bool? get hasWebPopup;

  /// If the alert should be shown in the web app.
  set hasWebPopup(bool? value);
  @override

  /// Email to send the alert to.
  bool? get hasEmail;

  /// Email to send the alert to.
  set hasEmail(bool? value);
  @override

  /// Phone number to send the alert to.
  bool? get hasPhone;

  /// Phone number to send the alert to.
  set hasPhone(bool? value);
  @override

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  int? get batteryMinLevel;

  /// Minimum battery level to trigger the alert, in percentage (%). Only for BrickhouseAlertType.BATTERY
  set batteryMinLevel(int? value);
  @override

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewStartHour;

  /// Start hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  set curfewStartHour(TimeOfDay? value);
  @override

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  TimeOfDay? get curfewEndHour;

  /// End hour of the curfew, in minutes from midnight in the local timezone. Only for BrickhouseAlertType.CURFEW
  @BrickhouseTimeOfDayMinuteOrNullConverter()
  set curfewEndHour(TimeOfDay? value);
  @override

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  String? get curfewTimezone;

  /// Timezone of the curfew. Only for BrickhouseAlertType.CURFEW
  set curfewTimezone(String? value);
  @override

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @WeekdayConverter()
  List<Weekday>? get curfewWeekdays;

  /// Weekdays to apply the curfew. Only for BrickhouseAlertType.CURFEW
  @WeekdayConverter()
  set curfewWeekdays(List<Weekday>? value);
  @override

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @ColorOrNullConverter()
  Color? get geofenceColor;

  /// Geofence color, in hex mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @ColorOrNullConverter()
  set geofenceColor(Color? value);
  @override

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @GeofenceModeOrNullConverter()
  GeofenceMode? get geofenceMode;

  /// Geofence mode. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @GeofenceModeOrNullConverter()
  set geofenceMode(GeofenceMode? value);
  @override

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  double? get geofenceRadius;

  /// Geofence radius in meters. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  set geofenceRadius(double? value);
  @override

  /// geofenceShape [GeofencePointInput]
  List<GeofencePoint>? get geofenceShape;

  /// geofenceShape [GeofencePointInput]
  set geofenceShape(List<GeofencePoint>? value);
  @override

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @BrickhouseGeofenceTriggerOrNullConverter()
  BrickhouseGeofenceTrigger? get geofenceTrigger;

  /// Geofence trigger. Only for BrickhouseAlertType.PRESENCE_GEOFENCE
  @BrickhouseGeofenceTriggerOrNullConverter()
  set geofenceTrigger(BrickhouseGeofenceTrigger? value);
  @override

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  double? get maxSpeedMaxValue;

  /// Maximum speed to trigger the alert, in kilometers per hour (km/h). Only for BrickhouseAlertType
  set maxSpeedMaxValue(double? value);
  @override

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  Duration? get cooldownTime;

  /// Deprecated Message to send when the SOS alert is triggered. Only for BrickhouseAlertType.SOS
// String? sosMessage,
  /// [cooldownTime] represents the cooldown time of the trigger.
  @DurationOrNullConverter()
  set cooldownTime(Duration? value);
  @override

  /// [isMuted] represents if the alert is muted or not.
  bool? get isMuted;

  /// [isMuted] represents if the alert is muted or not.
  set isMuted(bool? value);
  @override
  @JsonKey(ignore: true)
  _$$_BrickhouseAlertInputCopyWith<_$_BrickhouseAlertInput> get copyWith =>
      throw _privateConstructorUsedError;
}

BrickHouseWorkspaceInput _$BrickHouseWorkspaceInputFromJson(
    Map<String, dynamic> json) {
  return _BrickHouseWorkspaceInput.fromJson(json);
}

/// @nodoc
mixin _$BrickHouseWorkspaceInput {
  String? get id => throw _privateConstructorUsedError;
  String get appId => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  @MetricSystemConverter()
  MetricSystem get metricSystem => throw _privateConstructorUsedError;

  /// Is the type of the App
  @AppInternalIdentifierOrNullConverter()
  AppInternalIdentifier? get typeApp => throw _privateConstructorUsedError;
  String get timezoneId => throw _privateConstructorUsedError;
  List<String>? get assetsIds => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BrickHouseWorkspaceInputCopyWith<BrickHouseWorkspaceInput> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BrickHouseWorkspaceInputCopyWith<$Res> {
  factory $BrickHouseWorkspaceInputCopyWith(BrickHouseWorkspaceInput value,
          $Res Function(BrickHouseWorkspaceInput) then) =
      _$BrickHouseWorkspaceInputCopyWithImpl<$Res, BrickHouseWorkspaceInput>;
  @useResult
  $Res call(
      {String? id,
      String appId,
      String name,
      @MetricSystemConverter() MetricSystem metricSystem,
      @AppInternalIdentifierOrNullConverter() AppInternalIdentifier? typeApp,
      String timezoneId,
      List<String>? assetsIds});
}

/// @nodoc
class _$BrickHouseWorkspaceInputCopyWithImpl<$Res,
        $Val extends BrickHouseWorkspaceInput>
    implements $BrickHouseWorkspaceInputCopyWith<$Res> {
  _$BrickHouseWorkspaceInputCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? appId = null,
    Object? name = null,
    Object? metricSystem = null,
    Object? typeApp = freezed,
    Object? timezoneId = null,
    Object? assetsIds = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      appId: null == appId
          ? _value.appId
          : appId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      metricSystem: null == metricSystem
          ? _value.metricSystem
          : metricSystem // ignore: cast_nullable_to_non_nullable
              as MetricSystem,
      typeApp: freezed == typeApp
          ? _value.typeApp
          : typeApp // ignore: cast_nullable_to_non_nullable
              as AppInternalIdentifier?,
      timezoneId: null == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String,
      assetsIds: freezed == assetsIds
          ? _value.assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BrickHouseWorkspaceInputCopyWith<$Res>
    implements $BrickHouseWorkspaceInputCopyWith<$Res> {
  factory _$$_BrickHouseWorkspaceInputCopyWith(
          _$_BrickHouseWorkspaceInput value,
          $Res Function(_$_BrickHouseWorkspaceInput) then) =
      __$$_BrickHouseWorkspaceInputCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? id,
      String appId,
      String name,
      @MetricSystemConverter() MetricSystem metricSystem,
      @AppInternalIdentifierOrNullConverter() AppInternalIdentifier? typeApp,
      String timezoneId,
      List<String>? assetsIds});
}

/// @nodoc
class __$$_BrickHouseWorkspaceInputCopyWithImpl<$Res>
    extends _$BrickHouseWorkspaceInputCopyWithImpl<$Res,
        _$_BrickHouseWorkspaceInput>
    implements _$$_BrickHouseWorkspaceInputCopyWith<$Res> {
  __$$_BrickHouseWorkspaceInputCopyWithImpl(_$_BrickHouseWorkspaceInput _value,
      $Res Function(_$_BrickHouseWorkspaceInput) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? appId = null,
    Object? name = null,
    Object? metricSystem = null,
    Object? typeApp = freezed,
    Object? timezoneId = null,
    Object? assetsIds = freezed,
  }) {
    return _then(_$_BrickHouseWorkspaceInput(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      appId: null == appId
          ? _value.appId
          : appId // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      metricSystem: null == metricSystem
          ? _value.metricSystem
          : metricSystem // ignore: cast_nullable_to_non_nullable
              as MetricSystem,
      typeApp: freezed == typeApp
          ? _value.typeApp
          : typeApp // ignore: cast_nullable_to_non_nullable
              as AppInternalIdentifier?,
      timezoneId: null == timezoneId
          ? _value.timezoneId
          : timezoneId // ignore: cast_nullable_to_non_nullable
              as String,
      assetsIds: freezed == assetsIds
          ? _value._assetsIds
          : assetsIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BrickHouseWorkspaceInput extends _BrickHouseWorkspaceInput {
  const _$_BrickHouseWorkspaceInput(
      {this.id,
      required this.appId,
      required this.name,
      @MetricSystemConverter() required this.metricSystem,
      @AppInternalIdentifierOrNullConverter()
      this.typeApp = AppInternalIdentifier.brickhouseTracking,
      required this.timezoneId,
      final List<String>? assetsIds = const []})
      : _assetsIds = assetsIds,
        super._();

  factory _$_BrickHouseWorkspaceInput.fromJson(Map<String, dynamic> json) =>
      _$$_BrickHouseWorkspaceInputFromJson(json);

  @override
  final String? id;
  @override
  final String appId;
  @override
  final String name;
  @override
  @MetricSystemConverter()
  final MetricSystem metricSystem;

  /// Is the type of the App
  @override
  @JsonKey()
  @AppInternalIdentifierOrNullConverter()
  final AppInternalIdentifier? typeApp;
  @override
  final String timezoneId;
  final List<String>? _assetsIds;
  @override
  @JsonKey()
  List<String>? get assetsIds {
    final value = _assetsIds;
    if (value == null) return null;
    if (_assetsIds is EqualUnmodifiableListView) return _assetsIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'BrickHouseWorkspaceInput(id: $id, appId: $appId, name: $name, metricSystem: $metricSystem, typeApp: $typeApp, timezoneId: $timezoneId, assetsIds: $assetsIds)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BrickHouseWorkspaceInput &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.appId, appId) || other.appId == appId) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.metricSystem, metricSystem) ||
                other.metricSystem == metricSystem) &&
            (identical(other.typeApp, typeApp) || other.typeApp == typeApp) &&
            (identical(other.timezoneId, timezoneId) ||
                other.timezoneId == timezoneId) &&
            const DeepCollectionEquality()
                .equals(other._assetsIds, _assetsIds));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, id, appId, name, metricSystem,
      typeApp, timezoneId, const DeepCollectionEquality().hash(_assetsIds));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BrickHouseWorkspaceInputCopyWith<_$_BrickHouseWorkspaceInput>
      get copyWith => __$$_BrickHouseWorkspaceInputCopyWithImpl<
          _$_BrickHouseWorkspaceInput>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BrickHouseWorkspaceInputToJson(
      this,
    );
  }
}

abstract class _BrickHouseWorkspaceInput extends BrickHouseWorkspaceInput {
  const factory _BrickHouseWorkspaceInput(
      {final String? id,
      required final String appId,
      required final String name,
      @MetricSystemConverter() required final MetricSystem metricSystem,
      @AppInternalIdentifierOrNullConverter()
      final AppInternalIdentifier? typeApp,
      required final String timezoneId,
      final List<String>? assetsIds}) = _$_BrickHouseWorkspaceInput;
  const _BrickHouseWorkspaceInput._() : super._();

  factory _BrickHouseWorkspaceInput.fromJson(Map<String, dynamic> json) =
      _$_BrickHouseWorkspaceInput.fromJson;

  @override
  String? get id;
  @override
  String get appId;
  @override
  String get name;
  @override
  @MetricSystemConverter()
  MetricSystem get metricSystem;
  @override

  /// Is the type of the App
  @AppInternalIdentifierOrNullConverter()
  AppInternalIdentifier? get typeApp;
  @override
  String get timezoneId;
  @override
  List<String>? get assetsIds;
  @override
  @JsonKey(ignore: true)
  _$$_BrickHouseWorkspaceInputCopyWith<_$_BrickHouseWorkspaceInput>
      get copyWith => throw _privateConstructorUsedError;
}

ConciergeFormPage _$ConciergeFormPageFromJson(Map<String, dynamic> json) {
  return _ConciergeFormPage.fromJson(json);
}

/// @nodoc
mixin _$ConciergeFormPage {
  /// Is the title of the page
  String get title => throw _privateConstructorUsedError;

  /// Is the blocks (May be fields, headers or paragraph) of the page
  List<ConciergeFormBlock> get blocks => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConciergeFormPageCopyWith<ConciergeFormPage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConciergeFormPageCopyWith<$Res> {
  factory $ConciergeFormPageCopyWith(
          ConciergeFormPage value, $Res Function(ConciergeFormPage) then) =
      _$ConciergeFormPageCopyWithImpl<$Res, ConciergeFormPage>;
  @useResult
  $Res call({String title, List<ConciergeFormBlock> blocks});
}

/// @nodoc
class _$ConciergeFormPageCopyWithImpl<$Res, $Val extends ConciergeFormPage>
    implements $ConciergeFormPageCopyWith<$Res> {
  _$ConciergeFormPageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? blocks = null,
  }) {
    return _then(_value.copyWith(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      blocks: null == blocks
          ? _value.blocks
          : blocks // ignore: cast_nullable_to_non_nullable
              as List<ConciergeFormBlock>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ConciergeFormPageCopyWith<$Res>
    implements $ConciergeFormPageCopyWith<$Res> {
  factory _$$_ConciergeFormPageCopyWith(_$_ConciergeFormPage value,
          $Res Function(_$_ConciergeFormPage) then) =
      __$$_ConciergeFormPageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String title, List<ConciergeFormBlock> blocks});
}

/// @nodoc
class __$$_ConciergeFormPageCopyWithImpl<$Res>
    extends _$ConciergeFormPageCopyWithImpl<$Res, _$_ConciergeFormPage>
    implements _$$_ConciergeFormPageCopyWith<$Res> {
  __$$_ConciergeFormPageCopyWithImpl(
      _$_ConciergeFormPage _value, $Res Function(_$_ConciergeFormPage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? title = null,
    Object? blocks = null,
  }) {
    return _then(_$_ConciergeFormPage(
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      blocks: null == blocks
          ? _value._blocks
          : blocks // ignore: cast_nullable_to_non_nullable
              as List<ConciergeFormBlock>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ConciergeFormPage implements _ConciergeFormPage {
  const _$_ConciergeFormPage(
      {required this.title,
      final List<ConciergeFormBlock> blocks = const <ConciergeFormBlock>[]})
      : _blocks = blocks;

  factory _$_ConciergeFormPage.fromJson(Map<String, dynamic> json) =>
      _$$_ConciergeFormPageFromJson(json);

  /// Is the title of the page
  @override
  final String title;

  /// Is the blocks (May be fields, headers or paragraph) of the page
  final List<ConciergeFormBlock> _blocks;

  /// Is the blocks (May be fields, headers or paragraph) of the page
  @override
  @JsonKey()
  List<ConciergeFormBlock> get blocks {
    if (_blocks is EqualUnmodifiableListView) return _blocks;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_blocks);
  }

  @override
  String toString() {
    return 'ConciergeFormPage(title: $title, blocks: $blocks)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConciergeFormPage &&
            (identical(other.title, title) || other.title == title) &&
            const DeepCollectionEquality().equals(other._blocks, _blocks));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, title, const DeepCollectionEquality().hash(_blocks));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ConciergeFormPageCopyWith<_$_ConciergeFormPage> get copyWith =>
      __$$_ConciergeFormPageCopyWithImpl<_$_ConciergeFormPage>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ConciergeFormPageToJson(
      this,
    );
  }
}

abstract class _ConciergeFormPage implements ConciergeFormPage {
  const factory _ConciergeFormPage(
      {required final String title,
      final List<ConciergeFormBlock> blocks}) = _$_ConciergeFormPage;

  factory _ConciergeFormPage.fromJson(Map<String, dynamic> json) =
      _$_ConciergeFormPage.fromJson;

  @override

  /// Is the title of the page
  String get title;
  @override

  /// Is the blocks (May be fields, headers or paragraph) of the page
  List<ConciergeFormBlock> get blocks;
  @override
  @JsonKey(ignore: true)
  _$$_ConciergeFormPageCopyWith<_$_ConciergeFormPage> get copyWith =>
      throw _privateConstructorUsedError;
}

ConciergeFormBlock _$ConciergeFormBlockFromJson(Map<String, dynamic> json) {
  return _ConciergeFormBlock.fromJson(json);
}

/// @nodoc
mixin _$ConciergeFormBlock {
  /// Is the type of the block
  @ConciergeFormBlockTypeConverter()
  ConciergeFormBlockType get blockType => throw _privateConstructorUsedError;

  /// Is the title of the block
  String get name => throw _privateConstructorUsedError;

  /// Is the configuration of the block
  ConciergeFormBlockConfiguration? get configuration =>
      throw _privateConstructorUsedError;

  /// Is the validator of the block
  ConciergeFormBlockValidator? get showWhen =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConciergeFormBlockCopyWith<ConciergeFormBlock> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConciergeFormBlockCopyWith<$Res> {
  factory $ConciergeFormBlockCopyWith(
          ConciergeFormBlock value, $Res Function(ConciergeFormBlock) then) =
      _$ConciergeFormBlockCopyWithImpl<$Res, ConciergeFormBlock>;
  @useResult
  $Res call(
      {@ConciergeFormBlockTypeConverter() ConciergeFormBlockType blockType,
      String name,
      ConciergeFormBlockConfiguration? configuration,
      ConciergeFormBlockValidator? showWhen});

  $ConciergeFormBlockConfigurationCopyWith<$Res>? get configuration;
  $ConciergeFormBlockValidatorCopyWith<$Res>? get showWhen;
}

/// @nodoc
class _$ConciergeFormBlockCopyWithImpl<$Res, $Val extends ConciergeFormBlock>
    implements $ConciergeFormBlockCopyWith<$Res> {
  _$ConciergeFormBlockCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? blockType = null,
    Object? name = null,
    Object? configuration = freezed,
    Object? showWhen = freezed,
  }) {
    return _then(_value.copyWith(
      blockType: null == blockType
          ? _value.blockType
          : blockType // ignore: cast_nullable_to_non_nullable
              as ConciergeFormBlockType,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      configuration: freezed == configuration
          ? _value.configuration
          : configuration // ignore: cast_nullable_to_non_nullable
              as ConciergeFormBlockConfiguration?,
      showWhen: freezed == showWhen
          ? _value.showWhen
          : showWhen // ignore: cast_nullable_to_non_nullable
              as ConciergeFormBlockValidator?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ConciergeFormBlockConfigurationCopyWith<$Res>? get configuration {
    if (_value.configuration == null) {
      return null;
    }

    return $ConciergeFormBlockConfigurationCopyWith<$Res>(_value.configuration!,
        (value) {
      return _then(_value.copyWith(configuration: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ConciergeFormBlockValidatorCopyWith<$Res>? get showWhen {
    if (_value.showWhen == null) {
      return null;
    }

    return $ConciergeFormBlockValidatorCopyWith<$Res>(_value.showWhen!,
        (value) {
      return _then(_value.copyWith(showWhen: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ConciergeFormBlockCopyWith<$Res>
    implements $ConciergeFormBlockCopyWith<$Res> {
  factory _$$_ConciergeFormBlockCopyWith(_$_ConciergeFormBlock value,
          $Res Function(_$_ConciergeFormBlock) then) =
      __$$_ConciergeFormBlockCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@ConciergeFormBlockTypeConverter() ConciergeFormBlockType blockType,
      String name,
      ConciergeFormBlockConfiguration? configuration,
      ConciergeFormBlockValidator? showWhen});

  @override
  $ConciergeFormBlockConfigurationCopyWith<$Res>? get configuration;
  @override
  $ConciergeFormBlockValidatorCopyWith<$Res>? get showWhen;
}

/// @nodoc
class __$$_ConciergeFormBlockCopyWithImpl<$Res>
    extends _$ConciergeFormBlockCopyWithImpl<$Res, _$_ConciergeFormBlock>
    implements _$$_ConciergeFormBlockCopyWith<$Res> {
  __$$_ConciergeFormBlockCopyWithImpl(
      _$_ConciergeFormBlock _value, $Res Function(_$_ConciergeFormBlock) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? blockType = null,
    Object? name = null,
    Object? configuration = freezed,
    Object? showWhen = freezed,
  }) {
    return _then(_$_ConciergeFormBlock(
      blockType: null == blockType
          ? _value.blockType
          : blockType // ignore: cast_nullable_to_non_nullable
              as ConciergeFormBlockType,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      configuration: freezed == configuration
          ? _value.configuration
          : configuration // ignore: cast_nullable_to_non_nullable
              as ConciergeFormBlockConfiguration?,
      showWhen: freezed == showWhen
          ? _value.showWhen
          : showWhen // ignore: cast_nullable_to_non_nullable
              as ConciergeFormBlockValidator?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ConciergeFormBlock implements _ConciergeFormBlock {
  const _$_ConciergeFormBlock(
      {@ConciergeFormBlockTypeConverter() required this.blockType,
      required this.name,
      this.configuration,
      this.showWhen});

  factory _$_ConciergeFormBlock.fromJson(Map<String, dynamic> json) =>
      _$$_ConciergeFormBlockFromJson(json);

  /// Is the type of the block
  @override
  @ConciergeFormBlockTypeConverter()
  final ConciergeFormBlockType blockType;

  /// Is the title of the block
  @override
  final String name;

  /// Is the configuration of the block
  @override
  final ConciergeFormBlockConfiguration? configuration;

  /// Is the validator of the block
  @override
  final ConciergeFormBlockValidator? showWhen;

  @override
  String toString() {
    return 'ConciergeFormBlock(blockType: $blockType, name: $name, configuration: $configuration, showWhen: $showWhen)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConciergeFormBlock &&
            (identical(other.blockType, blockType) ||
                other.blockType == blockType) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.configuration, configuration) ||
                other.configuration == configuration) &&
            (identical(other.showWhen, showWhen) ||
                other.showWhen == showWhen));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, blockType, name, configuration, showWhen);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ConciergeFormBlockCopyWith<_$_ConciergeFormBlock> get copyWith =>
      __$$_ConciergeFormBlockCopyWithImpl<_$_ConciergeFormBlock>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ConciergeFormBlockToJson(
      this,
    );
  }
}

abstract class _ConciergeFormBlock implements ConciergeFormBlock {
  const factory _ConciergeFormBlock(
      {@ConciergeFormBlockTypeConverter()
      required final ConciergeFormBlockType blockType,
      required final String name,
      final ConciergeFormBlockConfiguration? configuration,
      final ConciergeFormBlockValidator? showWhen}) = _$_ConciergeFormBlock;

  factory _ConciergeFormBlock.fromJson(Map<String, dynamic> json) =
      _$_ConciergeFormBlock.fromJson;

  @override

  /// Is the type of the block
  @ConciergeFormBlockTypeConverter()
  ConciergeFormBlockType get blockType;
  @override

  /// Is the title of the block
  String get name;
  @override

  /// Is the configuration of the block
  ConciergeFormBlockConfiguration? get configuration;
  @override

  /// Is the validator of the block
  ConciergeFormBlockValidator? get showWhen;
  @override
  @JsonKey(ignore: true)
  _$$_ConciergeFormBlockCopyWith<_$_ConciergeFormBlock> get copyWith =>
      throw _privateConstructorUsedError;
}

ConciergeFormBlockConfiguration _$ConciergeFormBlockConfigurationFromJson(
    Map<String, dynamic> json) {
  return _ConciergeFormBlockConfiguration.fromJson(json);
}

/// @nodoc
mixin _$ConciergeFormBlockConfiguration {
  /// Indicates if the field can be submitted without value
  bool get allowEmpty => throw _privateConstructorUsedError;

  /// Indicates if the field is an integer value or a float value
  bool? get isInt => throw _privateConstructorUsedError;

  /// Indicates if the field is a multiple choice
  bool? get isMultiple => throw _privateConstructorUsedError;

  /// [max] and [min] represents the range of the field when is a number
  double? get max => throw _privateConstructorUsedError;
  double? get min => throw _privateConstructorUsedError;

  /// Represents the list of choices when the field is a select
  List<String> get choices => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConciergeFormBlockConfigurationCopyWith<ConciergeFormBlockConfiguration>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConciergeFormBlockConfigurationCopyWith<$Res> {
  factory $ConciergeFormBlockConfigurationCopyWith(
          ConciergeFormBlockConfiguration value,
          $Res Function(ConciergeFormBlockConfiguration) then) =
      _$ConciergeFormBlockConfigurationCopyWithImpl<$Res,
          ConciergeFormBlockConfiguration>;
  @useResult
  $Res call(
      {bool allowEmpty,
      bool? isInt,
      bool? isMultiple,
      double? max,
      double? min,
      List<String> choices});
}

/// @nodoc
class _$ConciergeFormBlockConfigurationCopyWithImpl<$Res,
        $Val extends ConciergeFormBlockConfiguration>
    implements $ConciergeFormBlockConfigurationCopyWith<$Res> {
  _$ConciergeFormBlockConfigurationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allowEmpty = null,
    Object? isInt = freezed,
    Object? isMultiple = freezed,
    Object? max = freezed,
    Object? min = freezed,
    Object? choices = null,
  }) {
    return _then(_value.copyWith(
      allowEmpty: null == allowEmpty
          ? _value.allowEmpty
          : allowEmpty // ignore: cast_nullable_to_non_nullable
              as bool,
      isInt: freezed == isInt
          ? _value.isInt
          : isInt // ignore: cast_nullable_to_non_nullable
              as bool?,
      isMultiple: freezed == isMultiple
          ? _value.isMultiple
          : isMultiple // ignore: cast_nullable_to_non_nullable
              as bool?,
      max: freezed == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double?,
      min: freezed == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double?,
      choices: null == choices
          ? _value.choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ConciergeFormBlockConfigurationCopyWith<$Res>
    implements $ConciergeFormBlockConfigurationCopyWith<$Res> {
  factory _$$_ConciergeFormBlockConfigurationCopyWith(
          _$_ConciergeFormBlockConfiguration value,
          $Res Function(_$_ConciergeFormBlockConfiguration) then) =
      __$$_ConciergeFormBlockConfigurationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool allowEmpty,
      bool? isInt,
      bool? isMultiple,
      double? max,
      double? min,
      List<String> choices});
}

/// @nodoc
class __$$_ConciergeFormBlockConfigurationCopyWithImpl<$Res>
    extends _$ConciergeFormBlockConfigurationCopyWithImpl<$Res,
        _$_ConciergeFormBlockConfiguration>
    implements _$$_ConciergeFormBlockConfigurationCopyWith<$Res> {
  __$$_ConciergeFormBlockConfigurationCopyWithImpl(
      _$_ConciergeFormBlockConfiguration _value,
      $Res Function(_$_ConciergeFormBlockConfiguration) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allowEmpty = null,
    Object? isInt = freezed,
    Object? isMultiple = freezed,
    Object? max = freezed,
    Object? min = freezed,
    Object? choices = null,
  }) {
    return _then(_$_ConciergeFormBlockConfiguration(
      allowEmpty: null == allowEmpty
          ? _value.allowEmpty
          : allowEmpty // ignore: cast_nullable_to_non_nullable
              as bool,
      isInt: freezed == isInt
          ? _value.isInt
          : isInt // ignore: cast_nullable_to_non_nullable
              as bool?,
      isMultiple: freezed == isMultiple
          ? _value.isMultiple
          : isMultiple // ignore: cast_nullable_to_non_nullable
              as bool?,
      max: freezed == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double?,
      min: freezed == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double?,
      choices: null == choices
          ? _value._choices
          : choices // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ConciergeFormBlockConfiguration
    implements _ConciergeFormBlockConfiguration {
  const _$_ConciergeFormBlockConfiguration(
      {required this.allowEmpty,
      this.isInt,
      this.isMultiple,
      this.max,
      this.min,
      final List<String> choices = const <String>[]})
      : _choices = choices;

  factory _$_ConciergeFormBlockConfiguration.fromJson(
          Map<String, dynamic> json) =>
      _$$_ConciergeFormBlockConfigurationFromJson(json);

  /// Indicates if the field can be submitted without value
  @override
  final bool allowEmpty;

  /// Indicates if the field is an integer value or a float value
  @override
  final bool? isInt;

  /// Indicates if the field is a multiple choice
  @override
  final bool? isMultiple;

  /// [max] and [min] represents the range of the field when is a number
  @override
  final double? max;
  @override
  final double? min;

  /// Represents the list of choices when the field is a select
  final List<String> _choices;

  /// Represents the list of choices when the field is a select
  @override
  @JsonKey()
  List<String> get choices {
    if (_choices is EqualUnmodifiableListView) return _choices;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_choices);
  }

  @override
  String toString() {
    return 'ConciergeFormBlockConfiguration(allowEmpty: $allowEmpty, isInt: $isInt, isMultiple: $isMultiple, max: $max, min: $min, choices: $choices)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConciergeFormBlockConfiguration &&
            (identical(other.allowEmpty, allowEmpty) ||
                other.allowEmpty == allowEmpty) &&
            (identical(other.isInt, isInt) || other.isInt == isInt) &&
            (identical(other.isMultiple, isMultiple) ||
                other.isMultiple == isMultiple) &&
            (identical(other.max, max) || other.max == max) &&
            (identical(other.min, min) || other.min == min) &&
            const DeepCollectionEquality().equals(other._choices, _choices));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, allowEmpty, isInt, isMultiple,
      max, min, const DeepCollectionEquality().hash(_choices));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ConciergeFormBlockConfigurationCopyWith<
          _$_ConciergeFormBlockConfiguration>
      get copyWith => __$$_ConciergeFormBlockConfigurationCopyWithImpl<
          _$_ConciergeFormBlockConfiguration>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ConciergeFormBlockConfigurationToJson(
      this,
    );
  }
}

abstract class _ConciergeFormBlockConfiguration
    implements ConciergeFormBlockConfiguration {
  const factory _ConciergeFormBlockConfiguration(
      {required final bool allowEmpty,
      final bool? isInt,
      final bool? isMultiple,
      final double? max,
      final double? min,
      final List<String> choices}) = _$_ConciergeFormBlockConfiguration;

  factory _ConciergeFormBlockConfiguration.fromJson(Map<String, dynamic> json) =
      _$_ConciergeFormBlockConfiguration.fromJson;

  @override

  /// Indicates if the field can be submitted without value
  bool get allowEmpty;
  @override

  /// Indicates if the field is an integer value or a float value
  bool? get isInt;
  @override

  /// Indicates if the field is a multiple choice
  bool? get isMultiple;
  @override

  /// [max] and [min] represents the range of the field when is a number
  double? get max;
  @override
  double? get min;
  @override

  /// Represents the list of choices when the field is a select
  List<String> get choices;
  @override
  @JsonKey(ignore: true)
  _$$_ConciergeFormBlockConfigurationCopyWith<
          _$_ConciergeFormBlockConfiguration>
      get copyWith => throw _privateConstructorUsedError;
}

ConciergeFormBlockValidator _$ConciergeFormBlockValidatorFromJson(
    Map<String, dynamic> json) {
  return _ConciergeFormBlockValidator.fromJson(json);
}

/// @nodoc
mixin _$ConciergeFormBlockValidator {
  /// Is the reference number of the block inside the same page, in programming terms, is the position of the array
  int? get blockId => throw _privateConstructorUsedError;

  /// [max] and [min] represents the range of the field when is a number, or the length range of the string value
  double? get max => throw _privateConstructorUsedError;
  double? get min => throw _privateConstructorUsedError;

  /// Represents the exact value of the field
  String? get value => throw _privateConstructorUsedError;

  /// Represents the validator of the block
  @ConciergeFormDisplayConditionValidatorConverter()
  ConciergeFormDisplayConditionValidator get validator =>
      throw _privateConstructorUsedError;

  /// Represents the operator to validate the value
  @ConciergeFormDisplayConditionOperatorOrNullConverter()
  ConciergeFormDisplayConditionOperator? get validatorOperator =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConciergeFormBlockValidatorCopyWith<ConciergeFormBlockValidator>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConciergeFormBlockValidatorCopyWith<$Res> {
  factory $ConciergeFormBlockValidatorCopyWith(
          ConciergeFormBlockValidator value,
          $Res Function(ConciergeFormBlockValidator) then) =
      _$ConciergeFormBlockValidatorCopyWithImpl<$Res,
          ConciergeFormBlockValidator>;
  @useResult
  $Res call(
      {int? blockId,
      double? max,
      double? min,
      String? value,
      @ConciergeFormDisplayConditionValidatorConverter()
      ConciergeFormDisplayConditionValidator validator,
      @ConciergeFormDisplayConditionOperatorOrNullConverter()
      ConciergeFormDisplayConditionOperator? validatorOperator});
}

/// @nodoc
class _$ConciergeFormBlockValidatorCopyWithImpl<$Res,
        $Val extends ConciergeFormBlockValidator>
    implements $ConciergeFormBlockValidatorCopyWith<$Res> {
  _$ConciergeFormBlockValidatorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? blockId = freezed,
    Object? max = freezed,
    Object? min = freezed,
    Object? value = freezed,
    Object? validator = null,
    Object? validatorOperator = freezed,
  }) {
    return _then(_value.copyWith(
      blockId: freezed == blockId
          ? _value.blockId
          : blockId // ignore: cast_nullable_to_non_nullable
              as int?,
      max: freezed == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double?,
      min: freezed == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      validator: null == validator
          ? _value.validator
          : validator // ignore: cast_nullable_to_non_nullable
              as ConciergeFormDisplayConditionValidator,
      validatorOperator: freezed == validatorOperator
          ? _value.validatorOperator
          : validatorOperator // ignore: cast_nullable_to_non_nullable
              as ConciergeFormDisplayConditionOperator?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ConciergeFormBlockValidatorCopyWith<$Res>
    implements $ConciergeFormBlockValidatorCopyWith<$Res> {
  factory _$$_ConciergeFormBlockValidatorCopyWith(
          _$_ConciergeFormBlockValidator value,
          $Res Function(_$_ConciergeFormBlockValidator) then) =
      __$$_ConciergeFormBlockValidatorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? blockId,
      double? max,
      double? min,
      String? value,
      @ConciergeFormDisplayConditionValidatorConverter()
      ConciergeFormDisplayConditionValidator validator,
      @ConciergeFormDisplayConditionOperatorOrNullConverter()
      ConciergeFormDisplayConditionOperator? validatorOperator});
}

/// @nodoc
class __$$_ConciergeFormBlockValidatorCopyWithImpl<$Res>
    extends _$ConciergeFormBlockValidatorCopyWithImpl<$Res,
        _$_ConciergeFormBlockValidator>
    implements _$$_ConciergeFormBlockValidatorCopyWith<$Res> {
  __$$_ConciergeFormBlockValidatorCopyWithImpl(
      _$_ConciergeFormBlockValidator _value,
      $Res Function(_$_ConciergeFormBlockValidator) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? blockId = freezed,
    Object? max = freezed,
    Object? min = freezed,
    Object? value = freezed,
    Object? validator = null,
    Object? validatorOperator = freezed,
  }) {
    return _then(_$_ConciergeFormBlockValidator(
      blockId: freezed == blockId
          ? _value.blockId
          : blockId // ignore: cast_nullable_to_non_nullable
              as int?,
      max: freezed == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double?,
      min: freezed == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double?,
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String?,
      validator: null == validator
          ? _value.validator
          : validator // ignore: cast_nullable_to_non_nullable
              as ConciergeFormDisplayConditionValidator,
      validatorOperator: freezed == validatorOperator
          ? _value.validatorOperator
          : validatorOperator // ignore: cast_nullable_to_non_nullable
              as ConciergeFormDisplayConditionOperator?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ConciergeFormBlockValidator implements _ConciergeFormBlockValidator {
  const _$_ConciergeFormBlockValidator(
      {this.blockId,
      this.max,
      this.min,
      this.value,
      @ConciergeFormDisplayConditionValidatorConverter()
      required this.validator,
      @ConciergeFormDisplayConditionOperatorOrNullConverter()
      this.validatorOperator});

  factory _$_ConciergeFormBlockValidator.fromJson(Map<String, dynamic> json) =>
      _$$_ConciergeFormBlockValidatorFromJson(json);

  /// Is the reference number of the block inside the same page, in programming terms, is the position of the array
  @override
  final int? blockId;

  /// [max] and [min] represents the range of the field when is a number, or the length range of the string value
  @override
  final double? max;
  @override
  final double? min;

  /// Represents the exact value of the field
  @override
  final String? value;

  /// Represents the validator of the block
  @override
  @ConciergeFormDisplayConditionValidatorConverter()
  final ConciergeFormDisplayConditionValidator validator;

  /// Represents the operator to validate the value
  @override
  @ConciergeFormDisplayConditionOperatorOrNullConverter()
  final ConciergeFormDisplayConditionOperator? validatorOperator;

  @override
  String toString() {
    return 'ConciergeFormBlockValidator(blockId: $blockId, max: $max, min: $min, value: $value, validator: $validator, validatorOperator: $validatorOperator)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ConciergeFormBlockValidator &&
            (identical(other.blockId, blockId) || other.blockId == blockId) &&
            (identical(other.max, max) || other.max == max) &&
            (identical(other.min, min) || other.min == min) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.validator, validator) ||
                other.validator == validator) &&
            (identical(other.validatorOperator, validatorOperator) ||
                other.validatorOperator == validatorOperator));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, blockId, max, min, value, validator, validatorOperator);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ConciergeFormBlockValidatorCopyWith<_$_ConciergeFormBlockValidator>
      get copyWith => __$$_ConciergeFormBlockValidatorCopyWithImpl<
          _$_ConciergeFormBlockValidator>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ConciergeFormBlockValidatorToJson(
      this,
    );
  }
}

abstract class _ConciergeFormBlockValidator
    implements ConciergeFormBlockValidator {
  const factory _ConciergeFormBlockValidator(
          {final int? blockId,
          final double? max,
          final double? min,
          final String? value,
          @ConciergeFormDisplayConditionValidatorConverter()
          required final ConciergeFormDisplayConditionValidator validator,
          @ConciergeFormDisplayConditionOperatorOrNullConverter()
          final ConciergeFormDisplayConditionOperator? validatorOperator}) =
      _$_ConciergeFormBlockValidator;

  factory _ConciergeFormBlockValidator.fromJson(Map<String, dynamic> json) =
      _$_ConciergeFormBlockValidator.fromJson;

  @override

  /// Is the reference number of the block inside the same page, in programming terms, is the position of the array
  int? get blockId;
  @override

  /// [max] and [min] represents the range of the field when is a number, or the length range of the string value
  double? get max;
  @override
  double? get min;
  @override

  /// Represents the exact value of the field
  String? get value;
  @override

  /// Represents the validator of the block
  @ConciergeFormDisplayConditionValidatorConverter()
  ConciergeFormDisplayConditionValidator get validator;
  @override

  /// Represents the operator to validate the value
  @ConciergeFormDisplayConditionOperatorOrNullConverter()
  ConciergeFormDisplayConditionOperator? get validatorOperator;
  @override
  @JsonKey(ignore: true)
  _$$_ConciergeFormBlockValidatorCopyWith<_$_ConciergeFormBlockValidator>
      get copyWith => throw _privateConstructorUsedError;
}

MonitorRealWaypoint _$MonitorRealWaypointFromJson(Map<String, dynamic> json) {
  return _MonitorRealWaypoint.fromJson(json);
}

/// @nodoc
mixin _$MonitorRealWaypoint {
  String get activationId => throw _privateConstructorUsedError;
  String get geofenceId => throw _privateConstructorUsedError;
  int? get sequenceReal => throw _privateConstructorUsedError;
  int get sequenceIdeal => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get startAt => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get endAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MonitorRealWaypointCopyWith<MonitorRealWaypoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MonitorRealWaypointCopyWith<$Res> {
  factory $MonitorRealWaypointCopyWith(
          MonitorRealWaypoint value, $Res Function(MonitorRealWaypoint) then) =
      _$MonitorRealWaypointCopyWithImpl<$Res, MonitorRealWaypoint>;
  @useResult
  $Res call(
      {String activationId,
      String geofenceId,
      int? sequenceReal,
      int sequenceIdeal,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt});
}

/// @nodoc
class _$MonitorRealWaypointCopyWithImpl<$Res, $Val extends MonitorRealWaypoint>
    implements $MonitorRealWaypointCopyWith<$Res> {
  _$MonitorRealWaypointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? activationId = null,
    Object? geofenceId = null,
    Object? sequenceReal = freezed,
    Object? sequenceIdeal = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
  }) {
    return _then(_value.copyWith(
      activationId: null == activationId
          ? _value.activationId
          : activationId // ignore: cast_nullable_to_non_nullable
              as String,
      geofenceId: null == geofenceId
          ? _value.geofenceId
          : geofenceId // ignore: cast_nullable_to_non_nullable
              as String,
      sequenceReal: freezed == sequenceReal
          ? _value.sequenceReal
          : sequenceReal // ignore: cast_nullable_to_non_nullable
              as int?,
      sequenceIdeal: null == sequenceIdeal
          ? _value.sequenceIdeal
          : sequenceIdeal // ignore: cast_nullable_to_non_nullable
              as int,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MonitorRealWaypointCopyWith<$Res>
    implements $MonitorRealWaypointCopyWith<$Res> {
  factory _$$_MonitorRealWaypointCopyWith(_$_MonitorRealWaypoint value,
          $Res Function(_$_MonitorRealWaypoint) then) =
      __$$_MonitorRealWaypointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String activationId,
      String geofenceId,
      int? sequenceReal,
      int sequenceIdeal,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt});
}

/// @nodoc
class __$$_MonitorRealWaypointCopyWithImpl<$Res>
    extends _$MonitorRealWaypointCopyWithImpl<$Res, _$_MonitorRealWaypoint>
    implements _$$_MonitorRealWaypointCopyWith<$Res> {
  __$$_MonitorRealWaypointCopyWithImpl(_$_MonitorRealWaypoint _value,
      $Res Function(_$_MonitorRealWaypoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? activationId = null,
    Object? geofenceId = null,
    Object? sequenceReal = freezed,
    Object? sequenceIdeal = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
  }) {
    return _then(_$_MonitorRealWaypoint(
      activationId: null == activationId
          ? _value.activationId
          : activationId // ignore: cast_nullable_to_non_nullable
              as String,
      geofenceId: null == geofenceId
          ? _value.geofenceId
          : geofenceId // ignore: cast_nullable_to_non_nullable
              as String,
      sequenceReal: freezed == sequenceReal
          ? _value.sequenceReal
          : sequenceReal // ignore: cast_nullable_to_non_nullable
              as int?,
      sequenceIdeal: null == sequenceIdeal
          ? _value.sequenceIdeal
          : sequenceIdeal // ignore: cast_nullable_to_non_nullable
              as int,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MonitorRealWaypoint implements _MonitorRealWaypoint {
  const _$_MonitorRealWaypoint(
      {required this.activationId,
      required this.geofenceId,
      this.sequenceReal,
      required this.sequenceIdeal,
      @TimestampOrNullConverter() this.startAt,
      @TimestampOrNullConverter() this.endAt});

  factory _$_MonitorRealWaypoint.fromJson(Map<String, dynamic> json) =>
      _$$_MonitorRealWaypointFromJson(json);

  @override
  final String activationId;
  @override
  final String geofenceId;
  @override
  final int? sequenceReal;
  @override
  final int sequenceIdeal;
  @override
  @TimestampOrNullConverter()
  final DateTime? startAt;
  @override
  @TimestampOrNullConverter()
  final DateTime? endAt;

  @override
  String toString() {
    return 'MonitorRealWaypoint(activationId: $activationId, geofenceId: $geofenceId, sequenceReal: $sequenceReal, sequenceIdeal: $sequenceIdeal, startAt: $startAt, endAt: $endAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MonitorRealWaypoint &&
            (identical(other.activationId, activationId) ||
                other.activationId == activationId) &&
            (identical(other.geofenceId, geofenceId) ||
                other.geofenceId == geofenceId) &&
            (identical(other.sequenceReal, sequenceReal) ||
                other.sequenceReal == sequenceReal) &&
            (identical(other.sequenceIdeal, sequenceIdeal) ||
                other.sequenceIdeal == sequenceIdeal) &&
            (identical(other.startAt, startAt) || other.startAt == startAt) &&
            (identical(other.endAt, endAt) || other.endAt == endAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, activationId, geofenceId,
      sequenceReal, sequenceIdeal, startAt, endAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MonitorRealWaypointCopyWith<_$_MonitorRealWaypoint> get copyWith =>
      __$$_MonitorRealWaypointCopyWithImpl<_$_MonitorRealWaypoint>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MonitorRealWaypointToJson(
      this,
    );
  }
}

abstract class _MonitorRealWaypoint implements MonitorRealWaypoint {
  const factory _MonitorRealWaypoint(
          {required final String activationId,
          required final String geofenceId,
          final int? sequenceReal,
          required final int sequenceIdeal,
          @TimestampOrNullConverter() final DateTime? startAt,
          @TimestampOrNullConverter() final DateTime? endAt}) =
      _$_MonitorRealWaypoint;

  factory _MonitorRealWaypoint.fromJson(Map<String, dynamic> json) =
      _$_MonitorRealWaypoint.fromJson;

  @override
  String get activationId;
  @override
  String get geofenceId;
  @override
  int? get sequenceReal;
  @override
  int get sequenceIdeal;
  @override
  @TimestampOrNullConverter()
  DateTime? get startAt;
  @override
  @TimestampOrNullConverter()
  DateTime? get endAt;
  @override
  @JsonKey(ignore: true)
  _$$_MonitorRealWaypointCopyWith<_$_MonitorRealWaypoint> get copyWith =>
      throw _privateConstructorUsedError;
}

MonitorActiveCheckpoint _$MonitorActiveCheckpointFromJson(
    Map<String, dynamic> json) {
  return _MonitorActiveCheckpoint.fromJson(json);
}

/// @nodoc
mixin _$MonitorActiveCheckpoint {
  String get id => throw _privateConstructorUsedError;
  @MonitorActiveCheckpointStateConverter()
  MonitorActiveCheckpointState get state => throw _privateConstructorUsedError;
  Checkpoint get checkpoint => throw _privateConstructorUsedError;
  Asset get asset => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get startAt => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get endAt => throw _privateConstructorUsedError;
  @TimestampOrNullConverter()
  DateTime? get updatedAt => throw _privateConstructorUsedError;
  @CheckpointStateConverter()
  CheckpointState get checkpointState => throw _privateConstructorUsedError;
  List<MonitorRealWaypoint> get waypoints => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MonitorActiveCheckpointCopyWith<MonitorActiveCheckpoint> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MonitorActiveCheckpointCopyWith<$Res> {
  factory $MonitorActiveCheckpointCopyWith(MonitorActiveCheckpoint value,
          $Res Function(MonitorActiveCheckpoint) then) =
      _$MonitorActiveCheckpointCopyWithImpl<$Res, MonitorActiveCheckpoint>;
  @useResult
  $Res call(
      {String id,
      @MonitorActiveCheckpointStateConverter()
      MonitorActiveCheckpointState state,
      Checkpoint checkpoint,
      Asset asset,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      @TimestampOrNullConverter() DateTime? updatedAt,
      @CheckpointStateConverter() CheckpointState checkpointState,
      List<MonitorRealWaypoint> waypoints});

  $CheckpointCopyWith<$Res> get checkpoint;
  $AssetCopyWith<$Res> get asset;
}

/// @nodoc
class _$MonitorActiveCheckpointCopyWithImpl<$Res,
        $Val extends MonitorActiveCheckpoint>
    implements $MonitorActiveCheckpointCopyWith<$Res> {
  _$MonitorActiveCheckpointCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? state = null,
    Object? checkpoint = null,
    Object? asset = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? updatedAt = freezed,
    Object? checkpointState = null,
    Object? waypoints = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as MonitorActiveCheckpointState,
      checkpoint: null == checkpoint
          ? _value.checkpoint
          : checkpoint // ignore: cast_nullable_to_non_nullable
              as Checkpoint,
      asset: null == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      checkpointState: null == checkpointState
          ? _value.checkpointState
          : checkpointState // ignore: cast_nullable_to_non_nullable
              as CheckpointState,
      waypoints: null == waypoints
          ? _value.waypoints
          : waypoints // ignore: cast_nullable_to_non_nullable
              as List<MonitorRealWaypoint>,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $CheckpointCopyWith<$Res> get checkpoint {
    return $CheckpointCopyWith<$Res>(_value.checkpoint, (value) {
      return _then(_value.copyWith(checkpoint: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res> get asset {
    return $AssetCopyWith<$Res>(_value.asset, (value) {
      return _then(_value.copyWith(asset: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MonitorActiveCheckpointCopyWith<$Res>
    implements $MonitorActiveCheckpointCopyWith<$Res> {
  factory _$$_MonitorActiveCheckpointCopyWith(_$_MonitorActiveCheckpoint value,
          $Res Function(_$_MonitorActiveCheckpoint) then) =
      __$$_MonitorActiveCheckpointCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @MonitorActiveCheckpointStateConverter()
      MonitorActiveCheckpointState state,
      Checkpoint checkpoint,
      Asset asset,
      @TimestampOrNullConverter() DateTime? startAt,
      @TimestampOrNullConverter() DateTime? endAt,
      @TimestampOrNullConverter() DateTime? updatedAt,
      @CheckpointStateConverter() CheckpointState checkpointState,
      List<MonitorRealWaypoint> waypoints});

  @override
  $CheckpointCopyWith<$Res> get checkpoint;
  @override
  $AssetCopyWith<$Res> get asset;
}

/// @nodoc
class __$$_MonitorActiveCheckpointCopyWithImpl<$Res>
    extends _$MonitorActiveCheckpointCopyWithImpl<$Res,
        _$_MonitorActiveCheckpoint>
    implements _$$_MonitorActiveCheckpointCopyWith<$Res> {
  __$$_MonitorActiveCheckpointCopyWithImpl(_$_MonitorActiveCheckpoint _value,
      $Res Function(_$_MonitorActiveCheckpoint) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? state = null,
    Object? checkpoint = null,
    Object? asset = null,
    Object? startAt = freezed,
    Object? endAt = freezed,
    Object? updatedAt = freezed,
    Object? checkpointState = null,
    Object? waypoints = null,
  }) {
    return _then(_$_MonitorActiveCheckpoint(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      state: null == state
          ? _value.state
          : state // ignore: cast_nullable_to_non_nullable
              as MonitorActiveCheckpointState,
      checkpoint: null == checkpoint
          ? _value.checkpoint
          : checkpoint // ignore: cast_nullable_to_non_nullable
              as Checkpoint,
      asset: null == asset
          ? _value.asset
          : asset // ignore: cast_nullable_to_non_nullable
              as Asset,
      startAt: freezed == startAt
          ? _value.startAt
          : startAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endAt: freezed == endAt
          ? _value.endAt
          : endAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      updatedAt: freezed == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      checkpointState: null == checkpointState
          ? _value.checkpointState
          : checkpointState // ignore: cast_nullable_to_non_nullable
              as CheckpointState,
      waypoints: null == waypoints
          ? _value._waypoints
          : waypoints // ignore: cast_nullable_to_non_nullable
              as List<MonitorRealWaypoint>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MonitorActiveCheckpoint implements _MonitorActiveCheckpoint {
  const _$_MonitorActiveCheckpoint(
      {required this.id,
      @MonitorActiveCheckpointStateConverter() required this.state,
      required this.checkpoint,
      required this.asset,
      @TimestampOrNullConverter() this.startAt,
      @TimestampOrNullConverter() this.endAt,
      @TimestampOrNullConverter() this.updatedAt,
      @CheckpointStateConverter() required this.checkpointState,
      final List<MonitorRealWaypoint> waypoints = const []})
      : _waypoints = waypoints;

  factory _$_MonitorActiveCheckpoint.fromJson(Map<String, dynamic> json) =>
      _$$_MonitorActiveCheckpointFromJson(json);

  @override
  final String id;
  @override
  @MonitorActiveCheckpointStateConverter()
  final MonitorActiveCheckpointState state;
  @override
  final Checkpoint checkpoint;
  @override
  final Asset asset;
  @override
  @TimestampOrNullConverter()
  final DateTime? startAt;
  @override
  @TimestampOrNullConverter()
  final DateTime? endAt;
  @override
  @TimestampOrNullConverter()
  final DateTime? updatedAt;
  @override
  @CheckpointStateConverter()
  final CheckpointState checkpointState;
  final List<MonitorRealWaypoint> _waypoints;
  @override
  @JsonKey()
  List<MonitorRealWaypoint> get waypoints {
    if (_waypoints is EqualUnmodifiableListView) return _waypoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_waypoints);
  }

  @override
  String toString() {
    return 'MonitorActiveCheckpoint(id: $id, state: $state, checkpoint: $checkpoint, asset: $asset, startAt: $startAt, endAt: $endAt, updatedAt: $updatedAt, checkpointState: $checkpointState, waypoints: $waypoints)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MonitorActiveCheckpoint &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.state, state) || other.state == state) &&
            (identical(other.checkpoint, checkpoint) ||
                other.checkpoint == checkpoint) &&
            (identical(other.asset, asset) || other.asset == asset) &&
            (identical(other.startAt, startAt) || other.startAt == startAt) &&
            (identical(other.endAt, endAt) || other.endAt == endAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.checkpointState, checkpointState) ||
                other.checkpointState == checkpointState) &&
            const DeepCollectionEquality()
                .equals(other._waypoints, _waypoints));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      state,
      checkpoint,
      asset,
      startAt,
      endAt,
      updatedAt,
      checkpointState,
      const DeepCollectionEquality().hash(_waypoints));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MonitorActiveCheckpointCopyWith<_$_MonitorActiveCheckpoint>
      get copyWith =>
          __$$_MonitorActiveCheckpointCopyWithImpl<_$_MonitorActiveCheckpoint>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MonitorActiveCheckpointToJson(
      this,
    );
  }
}

abstract class _MonitorActiveCheckpoint implements MonitorActiveCheckpoint {
  const factory _MonitorActiveCheckpoint(
      {required final String id,
      @MonitorActiveCheckpointStateConverter()
      required final MonitorActiveCheckpointState state,
      required final Checkpoint checkpoint,
      required final Asset asset,
      @TimestampOrNullConverter() final DateTime? startAt,
      @TimestampOrNullConverter() final DateTime? endAt,
      @TimestampOrNullConverter() final DateTime? updatedAt,
      @CheckpointStateConverter()
      required final CheckpointState checkpointState,
      final List<MonitorRealWaypoint> waypoints}) = _$_MonitorActiveCheckpoint;

  factory _MonitorActiveCheckpoint.fromJson(Map<String, dynamic> json) =
      _$_MonitorActiveCheckpoint.fromJson;

  @override
  String get id;
  @override
  @MonitorActiveCheckpointStateConverter()
  MonitorActiveCheckpointState get state;
  @override
  Checkpoint get checkpoint;
  @override
  Asset get asset;
  @override
  @TimestampOrNullConverter()
  DateTime? get startAt;
  @override
  @TimestampOrNullConverter()
  DateTime? get endAt;
  @override
  @TimestampOrNullConverter()
  DateTime? get updatedAt;
  @override
  @CheckpointStateConverter()
  CheckpointState get checkpointState;
  @override
  List<MonitorRealWaypoint> get waypoints;
  @override
  @JsonKey(ignore: true)
  _$$_MonitorActiveCheckpointCopyWith<_$_MonitorActiveCheckpoint>
      get copyWith => throw _privateConstructorUsedError;
}

MappitRouteLinkingHistory _$MappitRouteLinkingHistoryFromJson(
    Map<String, dynamic> json) {
  return _MappitRouteLinkingHistory.fromJson(json);
}

/// @nodoc
mixin _$MappitRouteLinkingHistory {
  /// [currentSeller] represents the current seller of the route. If this field comes null, means is a unlink
  Asset? get currentSeller => throw _privateConstructorUsedError;

  /// [currentSellerId] represents the current seller ID of the route. If this field comes null, means is a unlink
  String? get currentSellerId => throw _privateConstructorUsedError;

  /// [performedBy] represents the user that performed the operation of link or unlink
  User get performedBy => throw _privateConstructorUsedError;

  /// [performedById] represents the user ID that performed the operation of link or unlink
  String get performedById => throw _privateConstructorUsedError;

  /// [performedAt] is the timestamp of the operation
  @TimestampConverter()
  DateTime get performedAt => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitRouteLinkingHistoryCopyWith<MappitRouteLinkingHistory> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitRouteLinkingHistoryCopyWith<$Res> {
  factory $MappitRouteLinkingHistoryCopyWith(MappitRouteLinkingHistory value,
          $Res Function(MappitRouteLinkingHistory) then) =
      _$MappitRouteLinkingHistoryCopyWithImpl<$Res, MappitRouteLinkingHistory>;
  @useResult
  $Res call(
      {Asset? currentSeller,
      String? currentSellerId,
      User performedBy,
      String performedById,
      @TimestampConverter() DateTime performedAt});

  $AssetCopyWith<$Res>? get currentSeller;
  $UserCopyWith<$Res> get performedBy;
}

/// @nodoc
class _$MappitRouteLinkingHistoryCopyWithImpl<$Res,
        $Val extends MappitRouteLinkingHistory>
    implements $MappitRouteLinkingHistoryCopyWith<$Res> {
  _$MappitRouteLinkingHistoryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentSeller = freezed,
    Object? currentSellerId = freezed,
    Object? performedBy = null,
    Object? performedById = null,
    Object? performedAt = null,
  }) {
    return _then(_value.copyWith(
      currentSeller: freezed == currentSeller
          ? _value.currentSeller
          : currentSeller // ignore: cast_nullable_to_non_nullable
              as Asset?,
      currentSellerId: freezed == currentSellerId
          ? _value.currentSellerId
          : currentSellerId // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: null == performedBy
          ? _value.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as User,
      performedById: null == performedById
          ? _value.performedById
          : performedById // ignore: cast_nullable_to_non_nullable
              as String,
      performedAt: null == performedAt
          ? _value.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get currentSeller {
    if (_value.currentSeller == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.currentSeller!, (value) {
      return _then(_value.copyWith(currentSeller: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $UserCopyWith<$Res> get performedBy {
    return $UserCopyWith<$Res>(_value.performedBy, (value) {
      return _then(_value.copyWith(performedBy: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MappitRouteLinkingHistoryCopyWith<$Res>
    implements $MappitRouteLinkingHistoryCopyWith<$Res> {
  factory _$$_MappitRouteLinkingHistoryCopyWith(
          _$_MappitRouteLinkingHistory value,
          $Res Function(_$_MappitRouteLinkingHistory) then) =
      __$$_MappitRouteLinkingHistoryCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Asset? currentSeller,
      String? currentSellerId,
      User performedBy,
      String performedById,
      @TimestampConverter() DateTime performedAt});

  @override
  $AssetCopyWith<$Res>? get currentSeller;
  @override
  $UserCopyWith<$Res> get performedBy;
}

/// @nodoc
class __$$_MappitRouteLinkingHistoryCopyWithImpl<$Res>
    extends _$MappitRouteLinkingHistoryCopyWithImpl<$Res,
        _$_MappitRouteLinkingHistory>
    implements _$$_MappitRouteLinkingHistoryCopyWith<$Res> {
  __$$_MappitRouteLinkingHistoryCopyWithImpl(
      _$_MappitRouteLinkingHistory _value,
      $Res Function(_$_MappitRouteLinkingHistory) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentSeller = freezed,
    Object? currentSellerId = freezed,
    Object? performedBy = null,
    Object? performedById = null,
    Object? performedAt = null,
  }) {
    return _then(_$_MappitRouteLinkingHistory(
      currentSeller: freezed == currentSeller
          ? _value.currentSeller
          : currentSeller // ignore: cast_nullable_to_non_nullable
              as Asset?,
      currentSellerId: freezed == currentSellerId
          ? _value.currentSellerId
          : currentSellerId // ignore: cast_nullable_to_non_nullable
              as String?,
      performedBy: null == performedBy
          ? _value.performedBy
          : performedBy // ignore: cast_nullable_to_non_nullable
              as User,
      performedById: null == performedById
          ? _value.performedById
          : performedById // ignore: cast_nullable_to_non_nullable
              as String,
      performedAt: null == performedAt
          ? _value.performedAt
          : performedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitRouteLinkingHistory implements _MappitRouteLinkingHistory {
  const _$_MappitRouteLinkingHistory(
      {this.currentSeller,
      this.currentSellerId,
      required this.performedBy,
      required this.performedById,
      @TimestampConverter() required this.performedAt});

  factory _$_MappitRouteLinkingHistory.fromJson(Map<String, dynamic> json) =>
      _$$_MappitRouteLinkingHistoryFromJson(json);

  /// [currentSeller] represents the current seller of the route. If this field comes null, means is a unlink
  @override
  final Asset? currentSeller;

  /// [currentSellerId] represents the current seller ID of the route. If this field comes null, means is a unlink
  @override
  final String? currentSellerId;

  /// [performedBy] represents the user that performed the operation of link or unlink
  @override
  final User performedBy;

  /// [performedById] represents the user ID that performed the operation of link or unlink
  @override
  final String performedById;

  /// [performedAt] is the timestamp of the operation
  @override
  @TimestampConverter()
  final DateTime performedAt;

  @override
  String toString() {
    return 'MappitRouteLinkingHistory(currentSeller: $currentSeller, currentSellerId: $currentSellerId, performedBy: $performedBy, performedById: $performedById, performedAt: $performedAt)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitRouteLinkingHistory &&
            (identical(other.currentSeller, currentSeller) ||
                other.currentSeller == currentSeller) &&
            (identical(other.currentSellerId, currentSellerId) ||
                other.currentSellerId == currentSellerId) &&
            (identical(other.performedBy, performedBy) ||
                other.performedBy == performedBy) &&
            (identical(other.performedById, performedById) ||
                other.performedById == performedById) &&
            (identical(other.performedAt, performedAt) ||
                other.performedAt == performedAt));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, currentSeller, currentSellerId,
      performedBy, performedById, performedAt);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitRouteLinkingHistoryCopyWith<_$_MappitRouteLinkingHistory>
      get copyWith => __$$_MappitRouteLinkingHistoryCopyWithImpl<
          _$_MappitRouteLinkingHistory>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitRouteLinkingHistoryToJson(
      this,
    );
  }
}

abstract class _MappitRouteLinkingHistory implements MappitRouteLinkingHistory {
  const factory _MappitRouteLinkingHistory(
          {final Asset? currentSeller,
          final String? currentSellerId,
          required final User performedBy,
          required final String performedById,
          @TimestampConverter() required final DateTime performedAt}) =
      _$_MappitRouteLinkingHistory;

  factory _MappitRouteLinkingHistory.fromJson(Map<String, dynamic> json) =
      _$_MappitRouteLinkingHistory.fromJson;

  @override

  /// [currentSeller] represents the current seller of the route. If this field comes null, means is a unlink
  Asset? get currentSeller;
  @override

  /// [currentSellerId] represents the current seller ID of the route. If this field comes null, means is a unlink
  String? get currentSellerId;
  @override

  /// [performedBy] represents the user that performed the operation of link or unlink
  User get performedBy;
  @override

  /// [performedById] represents the user ID that performed the operation of link or unlink
  String get performedById;
  @override

  /// [performedAt] is the timestamp of the operation
  @TimestampConverter()
  DateTime get performedAt;
  @override
  @JsonKey(ignore: true)
  _$$_MappitRouteLinkingHistoryCopyWith<_$_MappitRouteLinkingHistory>
      get copyWith => throw _privateConstructorUsedError;
}

MappitRoute _$MappitRouteFromJson(Map<String, dynamic> json) {
  return _MappitRoute.fromJson(json);
}

/// @nodoc
mixin _$MappitRoute {
  /// [id] represents the route ID
  String get id => throw _privateConstructorUsedError;

  /// [name] represents the route name
  String get name => throw _privateConstructorUsedError;

  /// [currentSeller] represents the current seller of the route
  Asset? get currentSeller => throw _privateConstructorUsedError;

  /// [currentSellerId] represents the current seller ID of the route
  String? get currentSellerId => throw _privateConstructorUsedError;

  /// [geofences] represents the geofences linked to the route
  List<Geofence>? get geofences => throw _privateConstructorUsedError;

  /// [geofencesIds] represents the geofences IDs linked to the route
  List<String>? get geofencesIds => throw _privateConstructorUsedError;

  /// [assignmentsHistory] is the history of the link and unlink operations of this route
  List<MappitRouteLinkingHistory>? get assignmentsHistory =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitRouteCopyWith<MappitRoute> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitRouteCopyWith<$Res> {
  factory $MappitRouteCopyWith(
          MappitRoute value, $Res Function(MappitRoute) then) =
      _$MappitRouteCopyWithImpl<$Res, MappitRoute>;
  @useResult
  $Res call(
      {String id,
      String name,
      Asset? currentSeller,
      String? currentSellerId,
      List<Geofence>? geofences,
      List<String>? geofencesIds,
      List<MappitRouteLinkingHistory>? assignmentsHistory});

  $AssetCopyWith<$Res>? get currentSeller;
}

/// @nodoc
class _$MappitRouteCopyWithImpl<$Res, $Val extends MappitRoute>
    implements $MappitRouteCopyWith<$Res> {
  _$MappitRouteCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? currentSeller = freezed,
    Object? currentSellerId = freezed,
    Object? geofences = freezed,
    Object? geofencesIds = freezed,
    Object? assignmentsHistory = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      currentSeller: freezed == currentSeller
          ? _value.currentSeller
          : currentSeller // ignore: cast_nullable_to_non_nullable
              as Asset?,
      currentSellerId: freezed == currentSellerId
          ? _value.currentSellerId
          : currentSellerId // ignore: cast_nullable_to_non_nullable
              as String?,
      geofences: freezed == geofences
          ? _value.geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      geofencesIds: freezed == geofencesIds
          ? _value.geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assignmentsHistory: freezed == assignmentsHistory
          ? _value.assignmentsHistory
          : assignmentsHistory // ignore: cast_nullable_to_non_nullable
              as List<MappitRouteLinkingHistory>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $AssetCopyWith<$Res>? get currentSeller {
    if (_value.currentSeller == null) {
      return null;
    }

    return $AssetCopyWith<$Res>(_value.currentSeller!, (value) {
      return _then(_value.copyWith(currentSeller: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MappitRouteCopyWith<$Res>
    implements $MappitRouteCopyWith<$Res> {
  factory _$$_MappitRouteCopyWith(
          _$_MappitRoute value, $Res Function(_$_MappitRoute) then) =
      __$$_MappitRouteCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      Asset? currentSeller,
      String? currentSellerId,
      List<Geofence>? geofences,
      List<String>? geofencesIds,
      List<MappitRouteLinkingHistory>? assignmentsHistory});

  @override
  $AssetCopyWith<$Res>? get currentSeller;
}

/// @nodoc
class __$$_MappitRouteCopyWithImpl<$Res>
    extends _$MappitRouteCopyWithImpl<$Res, _$_MappitRoute>
    implements _$$_MappitRouteCopyWith<$Res> {
  __$$_MappitRouteCopyWithImpl(
      _$_MappitRoute _value, $Res Function(_$_MappitRoute) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? currentSeller = freezed,
    Object? currentSellerId = freezed,
    Object? geofences = freezed,
    Object? geofencesIds = freezed,
    Object? assignmentsHistory = freezed,
  }) {
    return _then(_$_MappitRoute(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      currentSeller: freezed == currentSeller
          ? _value.currentSeller
          : currentSeller // ignore: cast_nullable_to_non_nullable
              as Asset?,
      currentSellerId: freezed == currentSellerId
          ? _value.currentSellerId
          : currentSellerId // ignore: cast_nullable_to_non_nullable
              as String?,
      geofences: freezed == geofences
          ? _value._geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<Geofence>?,
      geofencesIds: freezed == geofencesIds
          ? _value._geofencesIds
          : geofencesIds // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      assignmentsHistory: freezed == assignmentsHistory
          ? _value._assignmentsHistory
          : assignmentsHistory // ignore: cast_nullable_to_non_nullable
              as List<MappitRouteLinkingHistory>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitRoute implements _MappitRoute {
  const _$_MappitRoute(
      {required this.id,
      required this.name,
      this.currentSeller,
      this.currentSellerId,
      final List<Geofence>? geofences,
      final List<String>? geofencesIds,
      final List<MappitRouteLinkingHistory>? assignmentsHistory})
      : _geofences = geofences,
        _geofencesIds = geofencesIds,
        _assignmentsHistory = assignmentsHistory;

  factory _$_MappitRoute.fromJson(Map<String, dynamic> json) =>
      _$$_MappitRouteFromJson(json);

  /// [id] represents the route ID
  @override
  final String id;

  /// [name] represents the route name
  @override
  final String name;

  /// [currentSeller] represents the current seller of the route
  @override
  final Asset? currentSeller;

  /// [currentSellerId] represents the current seller ID of the route
  @override
  final String? currentSellerId;

  /// [geofences] represents the geofences linked to the route
  final List<Geofence>? _geofences;

  /// [geofences] represents the geofences linked to the route
  @override
  List<Geofence>? get geofences {
    final value = _geofences;
    if (value == null) return null;
    if (_geofences is EqualUnmodifiableListView) return _geofences;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [geofencesIds] represents the geofences IDs linked to the route
  final List<String>? _geofencesIds;

  /// [geofencesIds] represents the geofences IDs linked to the route
  @override
  List<String>? get geofencesIds {
    final value = _geofencesIds;
    if (value == null) return null;
    if (_geofencesIds is EqualUnmodifiableListView) return _geofencesIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  /// [assignmentsHistory] is the history of the link and unlink operations of this route
  final List<MappitRouteLinkingHistory>? _assignmentsHistory;

  /// [assignmentsHistory] is the history of the link and unlink operations of this route
  @override
  List<MappitRouteLinkingHistory>? get assignmentsHistory {
    final value = _assignmentsHistory;
    if (value == null) return null;
    if (_assignmentsHistory is EqualUnmodifiableListView)
      return _assignmentsHistory;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'MappitRoute(id: $id, name: $name, currentSeller: $currentSeller, currentSellerId: $currentSellerId, geofences: $geofences, geofencesIds: $geofencesIds, assignmentsHistory: $assignmentsHistory)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitRoute &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.currentSeller, currentSeller) ||
                other.currentSeller == currentSeller) &&
            (identical(other.currentSellerId, currentSellerId) ||
                other.currentSellerId == currentSellerId) &&
            const DeepCollectionEquality()
                .equals(other._geofences, _geofences) &&
            const DeepCollectionEquality()
                .equals(other._geofencesIds, _geofencesIds) &&
            const DeepCollectionEquality()
                .equals(other._assignmentsHistory, _assignmentsHistory));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      name,
      currentSeller,
      currentSellerId,
      const DeepCollectionEquality().hash(_geofences),
      const DeepCollectionEquality().hash(_geofencesIds),
      const DeepCollectionEquality().hash(_assignmentsHistory));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitRouteCopyWith<_$_MappitRoute> get copyWith =>
      __$$_MappitRouteCopyWithImpl<_$_MappitRoute>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitRouteToJson(
      this,
    );
  }
}

abstract class _MappitRoute implements MappitRoute {
  const factory _MappitRoute(
          {required final String id,
          required final String name,
          final Asset? currentSeller,
          final String? currentSellerId,
          final List<Geofence>? geofences,
          final List<String>? geofencesIds,
          final List<MappitRouteLinkingHistory>? assignmentsHistory}) =
      _$_MappitRoute;

  factory _MappitRoute.fromJson(Map<String, dynamic> json) =
      _$_MappitRoute.fromJson;

  @override

  /// [id] represents the route ID
  String get id;
  @override

  /// [name] represents the route name
  String get name;
  @override

  /// [currentSeller] represents the current seller of the route
  Asset? get currentSeller;
  @override

  /// [currentSellerId] represents the current seller ID of the route
  String? get currentSellerId;
  @override

  /// [geofences] represents the geofences linked to the route
  List<Geofence>? get geofences;
  @override

  /// [geofencesIds] represents the geofences IDs linked to the route
  List<String>? get geofencesIds;
  @override

  /// [assignmentsHistory] is the history of the link and unlink operations of this route
  List<MappitRouteLinkingHistory>? get assignmentsHistory;
  @override
  @JsonKey(ignore: true)
  _$$_MappitRouteCopyWith<_$_MappitRoute> get copyWith =>
      throw _privateConstructorUsedError;
}

MappitLaborHour _$MappitLaborHourFromJson(Map<String, dynamic> json) {
  return _MappitLaborHour.fromJson(json);
}

/// @nodoc
mixin _$MappitLaborHour {
  /// [id] represents the labor hour ID.
  String get id => throw _privateConstructorUsedError;

  /// [weekday] represents the labor hour weekday.
  @WeekdayConverter()
  Weekday get weekday => throw _privateConstructorUsedError;

  /// [administrative] represents the labor hour administrative time.
  @DurationConverter()
  Duration get administrative => throw _privateConstructorUsedError;

  /// [f2f] represents the labor hour face-to-face time.
  @DurationConverter()
  Duration get f2f => throw _privateConstructorUsedError;

  /// [other] represents the labor hour other time.
  @DurationConverter()
  Duration get other => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitLaborHourCopyWith<MappitLaborHour> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitLaborHourCopyWith<$Res> {
  factory $MappitLaborHourCopyWith(
          MappitLaborHour value, $Res Function(MappitLaborHour) then) =
      _$MappitLaborHourCopyWithImpl<$Res, MappitLaborHour>;
  @useResult
  $Res call(
      {String id,
      @WeekdayConverter() Weekday weekday,
      @DurationConverter() Duration administrative,
      @DurationConverter() Duration f2f,
      @DurationConverter() Duration other});
}

/// @nodoc
class _$MappitLaborHourCopyWithImpl<$Res, $Val extends MappitLaborHour>
    implements $MappitLaborHourCopyWith<$Res> {
  _$MappitLaborHourCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? weekday = null,
    Object? administrative = null,
    Object? f2f = null,
    Object? other = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      weekday: null == weekday
          ? _value.weekday
          : weekday // ignore: cast_nullable_to_non_nullable
              as Weekday,
      administrative: null == administrative
          ? _value.administrative
          : administrative // ignore: cast_nullable_to_non_nullable
              as Duration,
      f2f: null == f2f
          ? _value.f2f
          : f2f // ignore: cast_nullable_to_non_nullable
              as Duration,
      other: null == other
          ? _value.other
          : other // ignore: cast_nullable_to_non_nullable
              as Duration,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MappitLaborHourCopyWith<$Res>
    implements $MappitLaborHourCopyWith<$Res> {
  factory _$$_MappitLaborHourCopyWith(
          _$_MappitLaborHour value, $Res Function(_$_MappitLaborHour) then) =
      __$$_MappitLaborHourCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @WeekdayConverter() Weekday weekday,
      @DurationConverter() Duration administrative,
      @DurationConverter() Duration f2f,
      @DurationConverter() Duration other});
}

/// @nodoc
class __$$_MappitLaborHourCopyWithImpl<$Res>
    extends _$MappitLaborHourCopyWithImpl<$Res, _$_MappitLaborHour>
    implements _$$_MappitLaborHourCopyWith<$Res> {
  __$$_MappitLaborHourCopyWithImpl(
      _$_MappitLaborHour _value, $Res Function(_$_MappitLaborHour) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? weekday = null,
    Object? administrative = null,
    Object? f2f = null,
    Object? other = null,
  }) {
    return _then(_$_MappitLaborHour(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      weekday: null == weekday
          ? _value.weekday
          : weekday // ignore: cast_nullable_to_non_nullable
              as Weekday,
      administrative: null == administrative
          ? _value.administrative
          : administrative // ignore: cast_nullable_to_non_nullable
              as Duration,
      f2f: null == f2f
          ? _value.f2f
          : f2f // ignore: cast_nullable_to_non_nullable
              as Duration,
      other: null == other
          ? _value.other
          : other // ignore: cast_nullable_to_non_nullable
              as Duration,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitLaborHour implements _MappitLaborHour {
  const _$_MappitLaborHour(
      {required this.id,
      @WeekdayConverter() required this.weekday,
      @DurationConverter() required this.administrative,
      @DurationConverter() required this.f2f,
      @DurationConverter() required this.other});

  factory _$_MappitLaborHour.fromJson(Map<String, dynamic> json) =>
      _$$_MappitLaborHourFromJson(json);

  /// [id] represents the labor hour ID.
  @override
  final String id;

  /// [weekday] represents the labor hour weekday.
  @override
  @WeekdayConverter()
  final Weekday weekday;

  /// [administrative] represents the labor hour administrative time.
  @override
  @DurationConverter()
  final Duration administrative;

  /// [f2f] represents the labor hour face-to-face time.
  @override
  @DurationConverter()
  final Duration f2f;

  /// [other] represents the labor hour other time.
  @override
  @DurationConverter()
  final Duration other;

  @override
  String toString() {
    return 'MappitLaborHour(id: $id, weekday: $weekday, administrative: $administrative, f2f: $f2f, other: $other)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitLaborHour &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.weekday, weekday) || other.weekday == weekday) &&
            (identical(other.administrative, administrative) ||
                other.administrative == administrative) &&
            (identical(other.f2f, f2f) || other.f2f == f2f) &&
            (identical(other.other, this.other) || other.other == this.other));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, weekday, administrative, f2f, other);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitLaborHourCopyWith<_$_MappitLaborHour> get copyWith =>
      __$$_MappitLaborHourCopyWithImpl<_$_MappitLaborHour>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitLaborHourToJson(
      this,
    );
  }
}

abstract class _MappitLaborHour implements MappitLaborHour {
  const factory _MappitLaborHour(
      {required final String id,
      @WeekdayConverter() required final Weekday weekday,
      @DurationConverter() required final Duration administrative,
      @DurationConverter() required final Duration f2f,
      @DurationConverter() required final Duration other}) = _$_MappitLaborHour;

  factory _MappitLaborHour.fromJson(Map<String, dynamic> json) =
      _$_MappitLaborHour.fromJson;

  @override

  /// [id] represents the labor hour ID.
  String get id;
  @override

  /// [weekday] represents the labor hour weekday.
  @WeekdayConverter()
  Weekday get weekday;
  @override

  /// [administrative] represents the labor hour administrative time.
  @DurationConverter()
  Duration get administrative;
  @override

  /// [f2f] represents the labor hour face-to-face time.
  @DurationConverter()
  Duration get f2f;
  @override

  /// [other] represents the labor hour other time.
  @DurationConverter()
  Duration get other;
  @override
  @JsonKey(ignore: true)
  _$$_MappitLaborHourCopyWith<_$_MappitLaborHour> get copyWith =>
      throw _privateConstructorUsedError;
}

MappitProfileGeofence _$MappitProfileGeofenceFromJson(
    Map<String, dynamic> json) {
  return _MappitProfileGeofence.fromJson(json);
}

/// @nodoc
mixin _$MappitProfileGeofence {
  /// [geofenceId] represents the ID of the geofence.
  String get geofenceId => throw _privateConstructorUsedError;

  /// [geofence] represents the geofence entity.
  Geofence? get geofence => throw _privateConstructorUsedError;

  /// [color] represents the color override of the geofence.
  /// If null, will be show the original color of the geofence
  @ColorOrNullConverter()
  Color? get color => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitProfileGeofenceCopyWith<MappitProfileGeofence> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitProfileGeofenceCopyWith<$Res> {
  factory $MappitProfileGeofenceCopyWith(MappitProfileGeofence value,
          $Res Function(MappitProfileGeofence) then) =
      _$MappitProfileGeofenceCopyWithImpl<$Res, MappitProfileGeofence>;
  @useResult
  $Res call(
      {String geofenceId,
      Geofence? geofence,
      @ColorOrNullConverter() Color? color});

  $GeofenceCopyWith<$Res>? get geofence;
}

/// @nodoc
class _$MappitProfileGeofenceCopyWithImpl<$Res,
        $Val extends MappitProfileGeofence>
    implements $MappitProfileGeofenceCopyWith<$Res> {
  _$MappitProfileGeofenceCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? geofenceId = null,
    Object? geofence = freezed,
    Object? color = freezed,
  }) {
    return _then(_value.copyWith(
      geofenceId: null == geofenceId
          ? _value.geofenceId
          : geofenceId // ignore: cast_nullable_to_non_nullable
              as String,
      geofence: freezed == geofence
          ? _value.geofence
          : geofence // ignore: cast_nullable_to_non_nullable
              as Geofence?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $GeofenceCopyWith<$Res>? get geofence {
    if (_value.geofence == null) {
      return null;
    }

    return $GeofenceCopyWith<$Res>(_value.geofence!, (value) {
      return _then(_value.copyWith(geofence: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_MappitProfileGeofenceCopyWith<$Res>
    implements $MappitProfileGeofenceCopyWith<$Res> {
  factory _$$_MappitProfileGeofenceCopyWith(_$_MappitProfileGeofence value,
          $Res Function(_$_MappitProfileGeofence) then) =
      __$$_MappitProfileGeofenceCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String geofenceId,
      Geofence? geofence,
      @ColorOrNullConverter() Color? color});

  @override
  $GeofenceCopyWith<$Res>? get geofence;
}

/// @nodoc
class __$$_MappitProfileGeofenceCopyWithImpl<$Res>
    extends _$MappitProfileGeofenceCopyWithImpl<$Res, _$_MappitProfileGeofence>
    implements _$$_MappitProfileGeofenceCopyWith<$Res> {
  __$$_MappitProfileGeofenceCopyWithImpl(_$_MappitProfileGeofence _value,
      $Res Function(_$_MappitProfileGeofence) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? geofenceId = null,
    Object? geofence = freezed,
    Object? color = freezed,
  }) {
    return _then(_$_MappitProfileGeofence(
      geofenceId: null == geofenceId
          ? _value.geofenceId
          : geofenceId // ignore: cast_nullable_to_non_nullable
              as String,
      geofence: freezed == geofence
          ? _value.geofence
          : geofence // ignore: cast_nullable_to_non_nullable
              as Geofence?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitProfileGeofence implements _MappitProfileGeofence {
  const _$_MappitProfileGeofence(
      {required this.geofenceId,
      this.geofence,
      @ColorOrNullConverter() this.color});

  factory _$_MappitProfileGeofence.fromJson(Map<String, dynamic> json) =>
      _$$_MappitProfileGeofenceFromJson(json);

  /// [geofenceId] represents the ID of the geofence.
  @override
  final String geofenceId;

  /// [geofence] represents the geofence entity.
  @override
  final Geofence? geofence;

  /// [color] represents the color override of the geofence.
  /// If null, will be show the original color of the geofence
  @override
  @ColorOrNullConverter()
  final Color? color;

  @override
  String toString() {
    return 'MappitProfileGeofence(geofenceId: $geofenceId, geofence: $geofence, color: $color)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitProfileGeofence &&
            (identical(other.geofenceId, geofenceId) ||
                other.geofenceId == geofenceId) &&
            (identical(other.geofence, geofence) ||
                other.geofence == geofence) &&
            (identical(other.color, color) || other.color == color));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, geofenceId, geofence, color);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitProfileGeofenceCopyWith<_$_MappitProfileGeofence> get copyWith =>
      __$$_MappitProfileGeofenceCopyWithImpl<_$_MappitProfileGeofence>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitProfileGeofenceToJson(
      this,
    );
  }
}

abstract class _MappitProfileGeofence implements MappitProfileGeofence {
  const factory _MappitProfileGeofence(
      {required final String geofenceId,
      final Geofence? geofence,
      @ColorOrNullConverter() final Color? color}) = _$_MappitProfileGeofence;

  factory _MappitProfileGeofence.fromJson(Map<String, dynamic> json) =
      _$_MappitProfileGeofence.fromJson;

  @override

  /// [geofenceId] represents the ID of the geofence.
  String get geofenceId;
  @override

  /// [geofence] represents the geofence entity.
  Geofence? get geofence;
  @override

  /// [color] represents the color override of the geofence.
  /// If null, will be show the original color of the geofence
  @ColorOrNullConverter()
  Color? get color;
  @override
  @JsonKey(ignore: true)
  _$$_MappitProfileGeofenceCopyWith<_$_MappitProfileGeofence> get copyWith =>
      throw _privateConstructorUsedError;
}

MappitProfile _$MappitProfileFromJson(Map<String, dynamic> json) {
  return _MappitProfile.fromJson(json);
}

/// @nodoc
mixin _$MappitProfile {
  /// [id] represents the ID of the profile.
  String get id => throw _privateConstructorUsedError;

  /// [name] represents the name of the profile.
  String get name => throw _privateConstructorUsedError;

  /// [geofences] represents the list of linked geofences with some customization
  List<MappitProfileGeofence> get geofences =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitProfileCopyWith<MappitProfile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitProfileCopyWith<$Res> {
  factory $MappitProfileCopyWith(
          MappitProfile value, $Res Function(MappitProfile) then) =
      _$MappitProfileCopyWithImpl<$Res, MappitProfile>;
  @useResult
  $Res call({String id, String name, List<MappitProfileGeofence> geofences});
}

/// @nodoc
class _$MappitProfileCopyWithImpl<$Res, $Val extends MappitProfile>
    implements $MappitProfileCopyWith<$Res> {
  _$MappitProfileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? geofences = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      geofences: null == geofences
          ? _value.geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<MappitProfileGeofence>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MappitProfileCopyWith<$Res>
    implements $MappitProfileCopyWith<$Res> {
  factory _$$_MappitProfileCopyWith(
          _$_MappitProfile value, $Res Function(_$_MappitProfile) then) =
      __$$_MappitProfileCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, String name, List<MappitProfileGeofence> geofences});
}

/// @nodoc
class __$$_MappitProfileCopyWithImpl<$Res>
    extends _$MappitProfileCopyWithImpl<$Res, _$_MappitProfile>
    implements _$$_MappitProfileCopyWith<$Res> {
  __$$_MappitProfileCopyWithImpl(
      _$_MappitProfile _value, $Res Function(_$_MappitProfile) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? geofences = null,
  }) {
    return _then(_$_MappitProfile(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      geofences: null == geofences
          ? _value._geofences
          : geofences // ignore: cast_nullable_to_non_nullable
              as List<MappitProfileGeofence>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitProfile implements _MappitProfile {
  const _$_MappitProfile(
      {required this.id,
      required this.name,
      required final List<MappitProfileGeofence> geofences})
      : _geofences = geofences;

  factory _$_MappitProfile.fromJson(Map<String, dynamic> json) =>
      _$$_MappitProfileFromJson(json);

  /// [id] represents the ID of the profile.
  @override
  final String id;

  /// [name] represents the name of the profile.
  @override
  final String name;

  /// [geofences] represents the list of linked geofences with some customization
  final List<MappitProfileGeofence> _geofences;

  /// [geofences] represents the list of linked geofences with some customization
  @override
  List<MappitProfileGeofence> get geofences {
    if (_geofences is EqualUnmodifiableListView) return _geofences;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_geofences);
  }

  @override
  String toString() {
    return 'MappitProfile(id: $id, name: $name, geofences: $geofences)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitProfile &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            const DeepCollectionEquality()
                .equals(other._geofences, _geofences));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, id, name, const DeepCollectionEquality().hash(_geofences));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitProfileCopyWith<_$_MappitProfile> get copyWith =>
      __$$_MappitProfileCopyWithImpl<_$_MappitProfile>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitProfileToJson(
      this,
    );
  }
}

abstract class _MappitProfile implements MappitProfile {
  const factory _MappitProfile(
      {required final String id,
      required final String name,
      required final List<MappitProfileGeofence> geofences}) = _$_MappitProfile;

  factory _MappitProfile.fromJson(Map<String, dynamic> json) =
      _$_MappitProfile.fromJson;

  @override

  /// [id] represents the ID of the profile.
  String get id;
  @override

  /// [name] represents the name of the profile.
  String get name;
  @override

  /// [geofences] represents the list of linked geofences with some customization
  List<MappitProfileGeofence> get geofences;
  @override
  @JsonKey(ignore: true)
  _$$_MappitProfileCopyWith<_$_MappitProfile> get copyWith =>
      throw _privateConstructorUsedError;
}

MappitDurationRange _$MappitDurationRangeFromJson(Map<String, dynamic> json) {
  return _MappitDurationRange.fromJson(json);
}

/// @nodoc
mixin _$MappitDurationRange {
  /// [min] is the minimum value of the range
  @DurationConverter()
  Duration get min => throw _privateConstructorUsedError;

  /// [max] is the maximum value of the range
  @DurationConverter()
  Duration get max => throw _privateConstructorUsedError;

  /// [color] is the color of the range
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitDurationRangeCopyWith<MappitDurationRange> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitDurationRangeCopyWith<$Res> {
  factory $MappitDurationRangeCopyWith(
          MappitDurationRange value, $Res Function(MappitDurationRange) then) =
      _$MappitDurationRangeCopyWithImpl<$Res, MappitDurationRange>;
  @useResult
  $Res call(
      {@DurationConverter() Duration min,
      @DurationConverter() Duration max,
      @ColorConverter() Color color});
}

/// @nodoc
class _$MappitDurationRangeCopyWithImpl<$Res, $Val extends MappitDurationRange>
    implements $MappitDurationRangeCopyWith<$Res> {
  _$MappitDurationRangeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? min = null,
    Object? max = null,
    Object? color = null,
  }) {
    return _then(_value.copyWith(
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as Duration,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as Duration,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MappitDurationRangeCopyWith<$Res>
    implements $MappitDurationRangeCopyWith<$Res> {
  factory _$$_MappitDurationRangeCopyWith(_$_MappitDurationRange value,
          $Res Function(_$_MappitDurationRange) then) =
      __$$_MappitDurationRangeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@DurationConverter() Duration min,
      @DurationConverter() Duration max,
      @ColorConverter() Color color});
}

/// @nodoc
class __$$_MappitDurationRangeCopyWithImpl<$Res>
    extends _$MappitDurationRangeCopyWithImpl<$Res, _$_MappitDurationRange>
    implements _$$_MappitDurationRangeCopyWith<$Res> {
  __$$_MappitDurationRangeCopyWithImpl(_$_MappitDurationRange _value,
      $Res Function(_$_MappitDurationRange) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? min = null,
    Object? max = null,
    Object? color = null,
  }) {
    return _then(_$_MappitDurationRange(
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as Duration,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as Duration,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitDurationRange implements _MappitDurationRange {
  const _$_MappitDurationRange(
      {@DurationConverter() this.min = Duration.zero,
      @DurationConverter() this.max = Duration.zero,
      @ColorConverter() this.color = Colors.blue});

  factory _$_MappitDurationRange.fromJson(Map<String, dynamic> json) =>
      _$$_MappitDurationRangeFromJson(json);

  /// [min] is the minimum value of the range
  @override
  @JsonKey()
  @DurationConverter()
  final Duration min;

  /// [max] is the maximum value of the range
  @override
  @JsonKey()
  @DurationConverter()
  final Duration max;

  /// [color] is the color of the range
  @override
  @JsonKey()
  @ColorConverter()
  final Color color;

  @override
  String toString() {
    return 'MappitDurationRange(min: $min, max: $max, color: $color)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitDurationRange &&
            (identical(other.min, min) || other.min == min) &&
            (identical(other.max, max) || other.max == max) &&
            (identical(other.color, color) || other.color == color));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, min, max, color);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitDurationRangeCopyWith<_$_MappitDurationRange> get copyWith =>
      __$$_MappitDurationRangeCopyWithImpl<_$_MappitDurationRange>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitDurationRangeToJson(
      this,
    );
  }
}

abstract class _MappitDurationRange implements MappitDurationRange {
  const factory _MappitDurationRange(
      {@DurationConverter() final Duration min,
      @DurationConverter() final Duration max,
      @ColorConverter() final Color color}) = _$_MappitDurationRange;

  factory _MappitDurationRange.fromJson(Map<String, dynamic> json) =
      _$_MappitDurationRange.fromJson;

  @override

  /// [min] is the minimum value of the range
  @DurationConverter()
  Duration get min;
  @override

  /// [max] is the maximum value of the range
  @DurationConverter()
  Duration get max;
  @override

  /// [color] is the color of the range
  @ColorConverter()
  Color get color;
  @override
  @JsonKey(ignore: true)
  _$$_MappitDurationRangeCopyWith<_$_MappitDurationRange> get copyWith =>
      throw _privateConstructorUsedError;
}

MappitIntRange _$MappitIntRangeFromJson(Map<String, dynamic> json) {
  return _MappitIntRange.fromJson(json);
}

/// @nodoc
mixin _$MappitIntRange {
  /// [min] is the minimum value of the range
  int get min => throw _privateConstructorUsedError;

  /// [max] is the maximum value of the range
  int get max => throw _privateConstructorUsedError;

  /// [color] is the color of the range
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitIntRangeCopyWith<MappitIntRange> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitIntRangeCopyWith<$Res> {
  factory $MappitIntRangeCopyWith(
          MappitIntRange value, $Res Function(MappitIntRange) then) =
      _$MappitIntRangeCopyWithImpl<$Res, MappitIntRange>;
  @useResult
  $Res call({int min, int max, @ColorConverter() Color color});
}

/// @nodoc
class _$MappitIntRangeCopyWithImpl<$Res, $Val extends MappitIntRange>
    implements $MappitIntRangeCopyWith<$Res> {
  _$MappitIntRangeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? min = null,
    Object? max = null,
    Object? color = null,
  }) {
    return _then(_value.copyWith(
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MappitIntRangeCopyWith<$Res>
    implements $MappitIntRangeCopyWith<$Res> {
  factory _$$_MappitIntRangeCopyWith(
          _$_MappitIntRange value, $Res Function(_$_MappitIntRange) then) =
      __$$_MappitIntRangeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int min, int max, @ColorConverter() Color color});
}

/// @nodoc
class __$$_MappitIntRangeCopyWithImpl<$Res>
    extends _$MappitIntRangeCopyWithImpl<$Res, _$_MappitIntRange>
    implements _$$_MappitIntRangeCopyWith<$Res> {
  __$$_MappitIntRangeCopyWithImpl(
      _$_MappitIntRange _value, $Res Function(_$_MappitIntRange) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? min = null,
    Object? max = null,
    Object? color = null,
  }) {
    return _then(_$_MappitIntRange(
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitIntRange implements _MappitIntRange {
  const _$_MappitIntRange(
      {this.min = 0, this.max = 0, @ColorConverter() this.color = Colors.blue});

  factory _$_MappitIntRange.fromJson(Map<String, dynamic> json) =>
      _$$_MappitIntRangeFromJson(json);

  /// [min] is the minimum value of the range
  @override
  @JsonKey()
  final int min;

  /// [max] is the maximum value of the range
  @override
  @JsonKey()
  final int max;

  /// [color] is the color of the range
  @override
  @JsonKey()
  @ColorConverter()
  final Color color;

  @override
  String toString() {
    return 'MappitIntRange(min: $min, max: $max, color: $color)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitIntRange &&
            (identical(other.min, min) || other.min == min) &&
            (identical(other.max, max) || other.max == max) &&
            (identical(other.color, color) || other.color == color));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, min, max, color);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitIntRangeCopyWith<_$_MappitIntRange> get copyWith =>
      __$$_MappitIntRangeCopyWithImpl<_$_MappitIntRange>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitIntRangeToJson(
      this,
    );
  }
}

abstract class _MappitIntRange implements MappitIntRange {
  const factory _MappitIntRange(
      {final int min,
      final int max,
      @ColorConverter() final Color color}) = _$_MappitIntRange;

  factory _MappitIntRange.fromJson(Map<String, dynamic> json) =
      _$_MappitIntRange.fromJson;

  @override

  /// [min] is the minimum value of the range
  int get min;
  @override

  /// [max] is the maximum value of the range
  int get max;
  @override

  /// [color] is the color of the range
  @ColorConverter()
  Color get color;
  @override
  @JsonKey(ignore: true)
  _$$_MappitIntRangeCopyWith<_$_MappitIntRange> get copyWith =>
      throw _privateConstructorUsedError;
}

MappitDoubleRange _$MappitDoubleRangeFromJson(Map<String, dynamic> json) {
  return _MappitDoubleRange.fromJson(json);
}

/// @nodoc
mixin _$MappitDoubleRange {
  /// [min] is the minimum value of the range
  double get min => throw _privateConstructorUsedError;

  /// [max] is the maximum value of the range
  double get max => throw _privateConstructorUsedError;

  /// [color] is the color of the range
  @ColorConverter()
  Color get color => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitDoubleRangeCopyWith<MappitDoubleRange> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitDoubleRangeCopyWith<$Res> {
  factory $MappitDoubleRangeCopyWith(
          MappitDoubleRange value, $Res Function(MappitDoubleRange) then) =
      _$MappitDoubleRangeCopyWithImpl<$Res, MappitDoubleRange>;
  @useResult
  $Res call({double min, double max, @ColorConverter() Color color});
}

/// @nodoc
class _$MappitDoubleRangeCopyWithImpl<$Res, $Val extends MappitDoubleRange>
    implements $MappitDoubleRangeCopyWith<$Res> {
  _$MappitDoubleRangeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? min = null,
    Object? max = null,
    Object? color = null,
  }) {
    return _then(_value.copyWith(
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MappitDoubleRangeCopyWith<$Res>
    implements $MappitDoubleRangeCopyWith<$Res> {
  factory _$$_MappitDoubleRangeCopyWith(_$_MappitDoubleRange value,
          $Res Function(_$_MappitDoubleRange) then) =
      __$$_MappitDoubleRangeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double min, double max, @ColorConverter() Color color});
}

/// @nodoc
class __$$_MappitDoubleRangeCopyWithImpl<$Res>
    extends _$MappitDoubleRangeCopyWithImpl<$Res, _$_MappitDoubleRange>
    implements _$$_MappitDoubleRangeCopyWith<$Res> {
  __$$_MappitDoubleRangeCopyWithImpl(
      _$_MappitDoubleRange _value, $Res Function(_$_MappitDoubleRange) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? min = null,
    Object? max = null,
    Object? color = null,
  }) {
    return _then(_$_MappitDoubleRange(
      min: null == min
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as double,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitDoubleRange implements _MappitDoubleRange {
  const _$_MappitDoubleRange(
      {this.min = 0, this.max = 0, @ColorConverter() this.color = Colors.blue});

  factory _$_MappitDoubleRange.fromJson(Map<String, dynamic> json) =>
      _$$_MappitDoubleRangeFromJson(json);

  /// [min] is the minimum value of the range
  @override
  @JsonKey()
  final double min;

  /// [max] is the maximum value of the range
  @override
  @JsonKey()
  final double max;

  /// [color] is the color of the range
  @override
  @JsonKey()
  @ColorConverter()
  final Color color;

  @override
  String toString() {
    return 'MappitDoubleRange(min: $min, max: $max, color: $color)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitDoubleRange &&
            (identical(other.min, min) || other.min == min) &&
            (identical(other.max, max) || other.max == max) &&
            (identical(other.color, color) || other.color == color));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, min, max, color);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitDoubleRangeCopyWith<_$_MappitDoubleRange> get copyWith =>
      __$$_MappitDoubleRangeCopyWithImpl<_$_MappitDoubleRange>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitDoubleRangeToJson(
      this,
    );
  }
}

abstract class _MappitDoubleRange implements MappitDoubleRange {
  const factory _MappitDoubleRange(
      {final double min,
      final double max,
      @ColorConverter() final Color color}) = _$_MappitDoubleRange;

  factory _MappitDoubleRange.fromJson(Map<String, dynamic> json) =
      _$_MappitDoubleRange.fromJson;

  @override

  /// [min] is the minimum value of the range
  double get min;
  @override

  /// [max] is the maximum value of the range
  double get max;
  @override

  /// [color] is the color of the range
  @ColorConverter()
  Color get color;
  @override
  @JsonKey(ignore: true)
  _$$_MappitDoubleRangeCopyWith<_$_MappitDoubleRange> get copyWith =>
      throw _privateConstructorUsedError;
}

MappitHomeConfig _$MappitHomeConfigFromJson(Map<String, dynamic> json) {
  return _MappitHomeConfig.fromJson(json);
}

/// @nodoc
mixin _$MappitHomeConfig {
  /// [firstVisit] is the conditions of the first visit
  List<MappitDurationRange> get firstVisit =>
      throw _privateConstructorUsedError;

  /// [avgTimePerVisit] is the conditions of the average time per visit
  List<MappitDurationRange> get avgTimePerVisit =>
      throw _privateConstructorUsedError;

  /// [customersVisited] is the conditions of the customers visited
  List<MappitIntRange> get customersVisited =>
      throw _privateConstructorUsedError;

  /// [dailyDistance] is the conditions of the daily distance
  List<MappitDoubleRange> get dailyDistance =>
      throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MappitHomeConfigCopyWith<MappitHomeConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MappitHomeConfigCopyWith<$Res> {
  factory $MappitHomeConfigCopyWith(
          MappitHomeConfig value, $Res Function(MappitHomeConfig) then) =
      _$MappitHomeConfigCopyWithImpl<$Res, MappitHomeConfig>;
  @useResult
  $Res call(
      {List<MappitDurationRange> firstVisit,
      List<MappitDurationRange> avgTimePerVisit,
      List<MappitIntRange> customersVisited,
      List<MappitDoubleRange> dailyDistance});
}

/// @nodoc
class _$MappitHomeConfigCopyWithImpl<$Res, $Val extends MappitHomeConfig>
    implements $MappitHomeConfigCopyWith<$Res> {
  _$MappitHomeConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? firstVisit = null,
    Object? avgTimePerVisit = null,
    Object? customersVisited = null,
    Object? dailyDistance = null,
  }) {
    return _then(_value.copyWith(
      firstVisit: null == firstVisit
          ? _value.firstVisit
          : firstVisit // ignore: cast_nullable_to_non_nullable
              as List<MappitDurationRange>,
      avgTimePerVisit: null == avgTimePerVisit
          ? _value.avgTimePerVisit
          : avgTimePerVisit // ignore: cast_nullable_to_non_nullable
              as List<MappitDurationRange>,
      customersVisited: null == customersVisited
          ? _value.customersVisited
          : customersVisited // ignore: cast_nullable_to_non_nullable
              as List<MappitIntRange>,
      dailyDistance: null == dailyDistance
          ? _value.dailyDistance
          : dailyDistance // ignore: cast_nullable_to_non_nullable
              as List<MappitDoubleRange>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MappitHomeConfigCopyWith<$Res>
    implements $MappitHomeConfigCopyWith<$Res> {
  factory _$$_MappitHomeConfigCopyWith(
          _$_MappitHomeConfig value, $Res Function(_$_MappitHomeConfig) then) =
      __$$_MappitHomeConfigCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<MappitDurationRange> firstVisit,
      List<MappitDurationRange> avgTimePerVisit,
      List<MappitIntRange> customersVisited,
      List<MappitDoubleRange> dailyDistance});
}

/// @nodoc
class __$$_MappitHomeConfigCopyWithImpl<$Res>
    extends _$MappitHomeConfigCopyWithImpl<$Res, _$_MappitHomeConfig>
    implements _$$_MappitHomeConfigCopyWith<$Res> {
  __$$_MappitHomeConfigCopyWithImpl(
      _$_MappitHomeConfig _value, $Res Function(_$_MappitHomeConfig) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? firstVisit = null,
    Object? avgTimePerVisit = null,
    Object? customersVisited = null,
    Object? dailyDistance = null,
  }) {
    return _then(_$_MappitHomeConfig(
      firstVisit: null == firstVisit
          ? _value._firstVisit
          : firstVisit // ignore: cast_nullable_to_non_nullable
              as List<MappitDurationRange>,
      avgTimePerVisit: null == avgTimePerVisit
          ? _value._avgTimePerVisit
          : avgTimePerVisit // ignore: cast_nullable_to_non_nullable
              as List<MappitDurationRange>,
      customersVisited: null == customersVisited
          ? _value._customersVisited
          : customersVisited // ignore: cast_nullable_to_non_nullable
              as List<MappitIntRange>,
      dailyDistance: null == dailyDistance
          ? _value._dailyDistance
          : dailyDistance // ignore: cast_nullable_to_non_nullable
              as List<MappitDoubleRange>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_MappitHomeConfig implements _MappitHomeConfig {
  const _$_MappitHomeConfig(
      {final List<MappitDurationRange> firstVisit = const [],
      final List<MappitDurationRange> avgTimePerVisit = const [],
      final List<MappitIntRange> customersVisited = const [],
      final List<MappitDoubleRange> dailyDistance = const []})
      : _firstVisit = firstVisit,
        _avgTimePerVisit = avgTimePerVisit,
        _customersVisited = customersVisited,
        _dailyDistance = dailyDistance;

  factory _$_MappitHomeConfig.fromJson(Map<String, dynamic> json) =>
      _$$_MappitHomeConfigFromJson(json);

  /// [firstVisit] is the conditions of the first visit
  final List<MappitDurationRange> _firstVisit;

  /// [firstVisit] is the conditions of the first visit
  @override
  @JsonKey()
  List<MappitDurationRange> get firstVisit {
    if (_firstVisit is EqualUnmodifiableListView) return _firstVisit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_firstVisit);
  }

  /// [avgTimePerVisit] is the conditions of the average time per visit
  final List<MappitDurationRange> _avgTimePerVisit;

  /// [avgTimePerVisit] is the conditions of the average time per visit
  @override
  @JsonKey()
  List<MappitDurationRange> get avgTimePerVisit {
    if (_avgTimePerVisit is EqualUnmodifiableListView) return _avgTimePerVisit;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_avgTimePerVisit);
  }

  /// [customersVisited] is the conditions of the customers visited
  final List<MappitIntRange> _customersVisited;

  /// [customersVisited] is the conditions of the customers visited
  @override
  @JsonKey()
  List<MappitIntRange> get customersVisited {
    if (_customersVisited is EqualUnmodifiableListView)
      return _customersVisited;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_customersVisited);
  }

  /// [dailyDistance] is the conditions of the daily distance
  final List<MappitDoubleRange> _dailyDistance;

  /// [dailyDistance] is the conditions of the daily distance
  @override
  @JsonKey()
  List<MappitDoubleRange> get dailyDistance {
    if (_dailyDistance is EqualUnmodifiableListView) return _dailyDistance;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_dailyDistance);
  }

  @override
  String toString() {
    return 'MappitHomeConfig(firstVisit: $firstVisit, avgTimePerVisit: $avgTimePerVisit, customersVisited: $customersVisited, dailyDistance: $dailyDistance)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MappitHomeConfig &&
            const DeepCollectionEquality()
                .equals(other._firstVisit, _firstVisit) &&
            const DeepCollectionEquality()
                .equals(other._avgTimePerVisit, _avgTimePerVisit) &&
            const DeepCollectionEquality()
                .equals(other._customersVisited, _customersVisited) &&
            const DeepCollectionEquality()
                .equals(other._dailyDistance, _dailyDistance));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_firstVisit),
      const DeepCollectionEquality().hash(_avgTimePerVisit),
      const DeepCollectionEquality().hash(_customersVisited),
      const DeepCollectionEquality().hash(_dailyDistance));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MappitHomeConfigCopyWith<_$_MappitHomeConfig> get copyWith =>
      __$$_MappitHomeConfigCopyWithImpl<_$_MappitHomeConfig>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MappitHomeConfigToJson(
      this,
    );
  }
}

abstract class _MappitHomeConfig implements MappitHomeConfig {
  const factory _MappitHomeConfig(
      {final List<MappitDurationRange> firstVisit,
      final List<MappitDurationRange> avgTimePerVisit,
      final List<MappitIntRange> customersVisited,
      final List<MappitDoubleRange> dailyDistance}) = _$_MappitHomeConfig;

  factory _MappitHomeConfig.fromJson(Map<String, dynamic> json) =
      _$_MappitHomeConfig.fromJson;

  @override

  /// [firstVisit] is the conditions of the first visit
  List<MappitDurationRange> get firstVisit;
  @override

  /// [avgTimePerVisit] is the conditions of the average time per visit
  List<MappitDurationRange> get avgTimePerVisit;
  @override

  /// [customersVisited] is the conditions of the customers visited
  List<MappitIntRange> get customersVisited;
  @override

  /// [dailyDistance] is the conditions of the daily distance
  List<MappitDoubleRange> get dailyDistance;
  @override
  @JsonKey(ignore: true)
  _$$_MappitHomeConfigCopyWith<_$_MappitHomeConfig> get copyWith =>
      throw _privateConstructorUsedError;
}
